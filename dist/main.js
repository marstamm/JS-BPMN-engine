/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/bpmn-js/index.js":
/*!***************************************!*\
  !*** ./node_modules/bpmn-js/index.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_Viewer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/Viewer */ "./node_modules/bpmn-js/lib/Viewer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _lib_Viewer__WEBPACK_IMPORTED_MODULE_0__["default"]; });



/***/ }),

/***/ "./node_modules/bpmn-js/lib/BaseViewer.js":
/*!************************************************!*\
  !*** ./node_modules/bpmn-js/lib/BaseViewer.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BaseViewer; });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var diagram_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! diagram-js */ "./node_modules/diagram-js/index.js");
/* harmony import */ var bpmn_moddle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! bpmn-moddle */ "./node_modules/bpmn-js/node_modules/bpmn-moddle/dist/index.esm.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _import_Importer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./import/Importer */ "./node_modules/bpmn-js/lib/import/Importer.js");
/* harmony import */ var _util_PoweredByUtil__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./util/PoweredByUtil */ "./node_modules/bpmn-js/lib/util/PoweredByUtil.js");
/**
 * The code in the <project-logo></project-logo> area
 * must not be changed.
 *
 * @see http://bpmn.io/license for more information.
 */














/**
 * A base viewer for BPMN 2.0 diagrams.
 *
 * Have a look at {@link Viewer}, {@link NavigatedViewer} or {@link Modeler} for
 * bundles that include actual features.
 *
 * @param {Object} [options] configuration options to pass to the viewer
 * @param {DOMElement} [options.container] the container to render the viewer in, defaults to body.
 * @param {String|Number} [options.width] the width of the viewer
 * @param {String|Number} [options.height] the height of the viewer
 * @param {Object} [options.moddleExtensions] extension packages to provide
 * @param {Array<didi.Module>} [options.modules] a list of modules to override the default modules
 * @param {Array<didi.Module>} [options.additionalModules] a list of modules to use with the default modules
 */
function BaseViewer(options) {

  options = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({}, DEFAULT_OPTIONS, options);

  this._moddle = this._createModdle(options);

  this._container = this._createContainer(options);

  /* <project-logo> */

  addProjectLogo(this._container);

  /* </project-logo> */

  this._init(this._container, this._moddle, options);
}

inherits__WEBPACK_IMPORTED_MODULE_5___default()(BaseViewer, diagram_js__WEBPACK_IMPORTED_MODULE_3__["default"]);


/**
 * Parse and render a BPMN 2.0 diagram.
 *
 * Once finished the viewer reports back the result to the
 * provided callback function with (err, warnings).
 *
 * ## Life-Cycle Events
 *
 * During import the viewer will fire life-cycle events:
 *
 *   * import.parse.start (about to read model from xml)
 *   * import.parse.complete (model read; may have worked or not)
 *   * import.render.start (graphical import start)
 *   * import.render.complete (graphical import finished)
 *   * import.done (everything done)
 *
 * You can use these events to hook into the life-cycle.
 *
 * @param {String} xml the BPMN 2.0 xml
 * @param {ModdleElement<BPMNDiagram>|String} [bpmnDiagram] BPMN diagram or id of diagram to render (if not provided, the first one will be rendered)
 * @param {Function} [done] invoked with (err, warnings=[])
 */
BaseViewer.prototype.importXML = function(xml, bpmnDiagram, done) {

  if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(bpmnDiagram)) {
    done = bpmnDiagram;
    bpmnDiagram = null;
  }

  // done is optional
  done = done || function() {};

  var self = this;

  // hook in pre-parse listeners +
  // allow xml manipulation
  xml = this._emit('import.parse.start', { xml: xml }) || xml;

  this._moddle.fromXML(xml, 'bpmn:Definitions', function(err, definitions, context) {

    // hook in post parse listeners +
    // allow definitions manipulation
    definitions = self._emit('import.parse.complete', {
      error: err,
      definitions: definitions,
      context: context
    }) || definitions;

    var parseWarnings = context.warnings;

    if (err) {
      err = checkValidationError(err);

      self._emit('import.done', { error: err, warnings: parseWarnings });

      return done(err, parseWarnings);
    }

    self.importDefinitions(definitions, bpmnDiagram, function(err, importWarnings) {
      var allWarnings = [].concat(parseWarnings, importWarnings || []);

      self._emit('import.done', { error: err, warnings: allWarnings });

      done(err, allWarnings);
    });
  });
};

/**
 * Import parsed definitions and render a BPMN 2.0 diagram.
 *
 * Once finished the viewer reports back the result to the
 * provided callback function with (err, warnings).
 *
 * ## Life-Cycle Events
 *
 * During import the viewer will fire life-cycle events:
 *
 *   * import.render.start (graphical import start)
 *   * import.render.complete (graphical import finished)
 *
 * You can use these events to hook into the life-cycle.
 *
 * @param {ModdleElement<Definitions>} definitions parsed BPMN 2.0 definitions
 * @param {ModdleElement<BPMNDiagram>|String} [bpmnDiagram] BPMN diagram or id of diagram to render (if not provided, the first one will be rendered)
 * @param {Function} [done] invoked with (err, warnings=[])
 */
BaseViewer.prototype.importDefinitions = function(definitions, bpmnDiagram, done) {

  if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(bpmnDiagram)) {
    done = bpmnDiagram;
    bpmnDiagram = null;
  }

  // done is optional
  done = done || function() {};

  this._setDefinitions(definitions);

  return this.open(bpmnDiagram, done);
};

/**
 * Open diagram of previously imported XML.
 *
 * Once finished the viewer reports back the result to the
 * provided callback function with (err, warnings).
 *
 * ## Life-Cycle Events
 *
 * During switch the viewer will fire life-cycle events:
 *
 *   * import.render.start (graphical import start)
 *   * import.render.complete (graphical import finished)
 *
 * You can use these events to hook into the life-cycle.
 *
 * @param {String|ModdleElement<BPMNDiagram>} [bpmnDiagramOrId] id or the diagram to open
 * @param {Function} [done] invoked with (err, warnings=[])
 */
BaseViewer.prototype.open = function(bpmnDiagramOrId, done) {

  if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(bpmnDiagramOrId)) {
    done = bpmnDiagramOrId;
    bpmnDiagramOrId = null;
  }

  var definitions = this._definitions;
  var bpmnDiagram = bpmnDiagramOrId;

  // done is optional
  done = done || function() {};

  if (!definitions) {
    return done(new Error('no XML imported'));
  }

  if (typeof bpmnDiagramOrId === 'string') {
    bpmnDiagram = findBPMNDiagram(definitions, bpmnDiagramOrId);

    if (!bpmnDiagram) {
      return done(new Error('BPMNDiagram <' + bpmnDiagramOrId + '> not found'));
    }
  }

  // clear existing rendered diagram
  // catch synchronous exceptions during #clear()
  try {
    this.clear();
  } catch (error) {
    return done(error);
  }

  // perform graphical import
  return Object(_import_Importer__WEBPACK_IMPORTED_MODULE_6__["importBpmnDiagram"])(this, definitions, bpmnDiagram, done);
};

/**
 * Export the currently displayed BPMN 2.0 diagram as
 * a BPMN 2.0 XML document.
 *
 * ## Life-Cycle Events
 *
 * During XML saving the viewer will fire life-cycle events:
 *
 *   * saveXML.start (before serialization)
 *   * saveXML.serialized (after xml generation)
 *   * saveXML.done (everything done)
 *
 * You can use these events to hook into the life-cycle.
 *
 * @param {Object} [options] export options
 * @param {Boolean} [options.format=false] output formatted XML
 * @param {Boolean} [options.preamble=true] output preamble
 *
 * @param {Function} done invoked with (err, xml)
 */
BaseViewer.prototype.saveXML = function(options, done) {

  if (!done) {
    done = options;
    options = {};
  }

  var self = this;

  var definitions = this._definitions;

  if (!definitions) {
    return done(new Error('no definitions loaded'));
  }

  // allow to fiddle around with definitions
  definitions = this._emit('saveXML.start', {
    definitions: definitions
  }) || definitions;

  this._moddle.toXML(definitions, options, function(err, xml) {

    try {
      xml = self._emit('saveXML.serialized', {
        error: err,
        xml: xml
      }) || xml;

      self._emit('saveXML.done', {
        error: err,
        xml: xml
      });
    } catch (e) {
      console.error('error in saveXML life-cycle listener', e);
    }

    done(err, xml);
  });
};

/**
 * Export the currently displayed BPMN 2.0 diagram as
 * an SVG image.
 *
 * ## Life-Cycle Events
 *
 * During SVG saving the viewer will fire life-cycle events:
 *
 *   * saveSVG.start (before serialization)
 *   * saveSVG.done (everything done)
 *
 * You can use these events to hook into the life-cycle.
 *
 * @param {Object} [options]
 * @param {Function} done invoked with (err, svgStr)
 */
BaseViewer.prototype.saveSVG = function(options, done) {

  if (!done) {
    done = options;
    options = {};
  }

  this._emit('saveSVG.start');

  var svg, err;

  try {
    var canvas = this.get('canvas');

    var contentNode = canvas.getDefaultLayer(),
        defsNode = Object(min_dom__WEBPACK_IMPORTED_MODULE_1__["query"])('defs', canvas._svg);

    var contents = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_2__["innerSVG"])(contentNode),
        defs = defsNode ? '<defs>' + Object(tiny_svg__WEBPACK_IMPORTED_MODULE_2__["innerSVG"])(defsNode) + '</defs>' : '';

    var bbox = contentNode.getBBox();

    svg =
      '<?xml version="1.0" encoding="utf-8"?>\n' +
      '<!-- created with bpmn-js / http://bpmn.io -->\n' +
      '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n' +
      '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" ' +
           'width="' + bbox.width + '" height="' + bbox.height + '" ' +
           'viewBox="' + bbox.x + ' ' + bbox.y + ' ' + bbox.width + ' ' + bbox.height + '" version="1.1">' +
        defs + contents +
      '</svg>';
  } catch (e) {
    err = e;
  }

  this._emit('saveSVG.done', {
    error: err,
    svg: svg
  });

  done(err, svg);
};

/**
 * Get a named diagram service.
 *
 * @example
 *
 * var elementRegistry = viewer.get('elementRegistry');
 * var startEventShape = elementRegistry.get('StartEvent_1');
 *
 * @param {String} name
 *
 * @return {Object} diagram service instance
 *
 * @method BaseViewer#get
 */

/**
 * Invoke a function in the context of this viewer.
 *
 * @example
 *
 * viewer.invoke(function(elementRegistry) {
 *   var startEventShape = elementRegistry.get('StartEvent_1');
 * });
 *
 * @param {Function} fn to be invoked
 *
 * @return {Object} the functions return value
 *
 * @method BaseViewer#invoke
 */


BaseViewer.prototype._setDefinitions = function(definitions) {
  this._definitions = definitions;
};

BaseViewer.prototype.getModules = function() {
  return this._modules;
};

/**
 * Remove all drawn elements from the viewer.
 *
 * After calling this method the viewer can still
 * be reused for opening another diagram.
 *
 * @method BaseViewer#clear
 */
BaseViewer.prototype.clear = function() {
  if (!this.getDefinitions()) {

    // no diagram to clear
    return;
  }

  // remove businessObject#di binding
  //
  // this is necessary, as we establish the bindings
  // in the BpmnTreeWalker (and assume none are given
  // on reimport)
  this.get('elementRegistry').forEach(function(element) {
    var bo = element.businessObject;

    if (bo && bo.di) {
      delete bo.di;
    }
  });

  // remove drawn elements
  diagram_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.clear.call(this);
};

/**
 * Destroy the viewer instance and remove all its
 * remainders from the document tree.
 */
BaseViewer.prototype.destroy = function() {

  // diagram destroy
  diagram_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.destroy.call(this);

  // dom detach
  Object(min_dom__WEBPACK_IMPORTED_MODULE_1__["remove"])(this._container);
};

/**
 * Register an event listener
 *
 * Remove a previously added listener via {@link #off(event, callback)}.
 *
 * @param {String} event
 * @param {Number} [priority]
 * @param {Function} callback
 * @param {Object} [that]
 */
BaseViewer.prototype.on = function(event, priority, callback, target) {
  return this.get('eventBus').on(event, priority, callback, target);
};

/**
 * De-register an event listener
 *
 * @param {String} event
 * @param {Function} callback
 */
BaseViewer.prototype.off = function(event, callback) {
  this.get('eventBus').off(event, callback);
};

BaseViewer.prototype.attachTo = function(parentNode) {

  if (!parentNode) {
    throw new Error('parentNode required');
  }

  // ensure we detach from the
  // previous, old parent
  this.detach();

  // unwrap jQuery if provided
  if (parentNode.get && parentNode.constructor.prototype.jquery) {
    parentNode = parentNode.get(0);
  }

  if (typeof parentNode === 'string') {
    parentNode = Object(min_dom__WEBPACK_IMPORTED_MODULE_1__["query"])(parentNode);
  }

  parentNode.appendChild(this._container);

  this._emit('attach', {});

  this.get('canvas').resized();
};

BaseViewer.prototype.getDefinitions = function() {
  return this._definitions;
};

BaseViewer.prototype.detach = function() {

  var container = this._container,
      parentNode = container.parentNode;

  if (!parentNode) {
    return;
  }

  this._emit('detach', {});

  parentNode.removeChild(container);
};

BaseViewer.prototype._init = function(container, moddle, options) {

  var baseModules = options.modules || this.getModules(),
      additionalModules = options.additionalModules || [],
      staticModules = [
        {
          bpmnjs: [ 'value', this ],
          moddle: [ 'value', moddle ]
        }
      ];

  var diagramModules = [].concat(staticModules, baseModules, additionalModules);

  var diagramOptions = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])(Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["omit"])(options, [ 'additionalModules' ]), {
    canvas: Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({}, options.canvas, { container: container }),
    modules: diagramModules
  });

  // invoke diagram constructor
  diagram_js__WEBPACK_IMPORTED_MODULE_3__["default"].call(this, diagramOptions);

  if (options && options.container) {
    this.attachTo(options.container);
  }
};

/**
 * Emit an event on the underlying {@link EventBus}
 *
 * @param  {String} type
 * @param  {Object} event
 *
 * @return {Object} event processing result (if any)
 */
BaseViewer.prototype._emit = function(type, event) {
  return this.get('eventBus').fire(type, event);
};

BaseViewer.prototype._createContainer = function(options) {

  var container = Object(min_dom__WEBPACK_IMPORTED_MODULE_1__["domify"])('<div class="bjs-container"></div>');

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])(container.style, {
    width: ensureUnit(options.width),
    height: ensureUnit(options.height),
    position: options.position
  });

  return container;
};

BaseViewer.prototype._createModdle = function(options) {
  var moddleOptions = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({}, this._moddleExtensions, options.moddleExtensions);

  return new bpmn_moddle__WEBPACK_IMPORTED_MODULE_4__["default"](moddleOptions);
};

BaseViewer.prototype._modules = [];


// helpers ///////////////

function checkValidationError(err) {

  // check if we can help the user by indicating wrong BPMN 2.0 xml
  // (in case he or the exporting tool did not get that right)

  var pattern = /unparsable content <([^>]+)> detected([\s\S]*)$/;
  var match = pattern.exec(err.message);

  if (match) {
    err.message =
      'unparsable content <' + match[1] + '> detected; ' +
      'this may indicate an invalid BPMN 2.0 diagram file' + match[2];
  }

  return err;
}

var DEFAULT_OPTIONS = {
  width: '100%',
  height: '100%',
  position: 'relative'
};


/**
 * Ensure the passed argument is a proper unit (defaulting to px)
 */
function ensureUnit(val) {
  return val + (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(val) ? 'px' : '');
}


/**
 * Find BPMNDiagram in definitions by ID
 *
 * @param {ModdleElement<Definitions>} definitions
 * @param {String} diagramId
 *
 * @return {ModdleElement<BPMNDiagram>|null}
 */
function findBPMNDiagram(definitions, diagramId) {
  if (!diagramId) {
    return null;
  }

  return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["find"])(definitions.diagrams, function(element) {
    return element.id === diagramId;
  }) || null;
}


/* <project-logo> */





/**
 * Adds the project logo to the diagram container as
 * required by the bpmn.io license.
 *
 * @see http://bpmn.io/license
 *
 * @param {Element} container
 */
function addProjectLogo(container) {
  var img = _util_PoweredByUtil__WEBPACK_IMPORTED_MODULE_7__["BPMNIO_IMG"];

  var linkMarkup =
    '<a href="http://bpmn.io" ' +
       'target="_blank" ' +
       'class="bjs-powered-by" ' +
       'title="Powered by bpmn.io" ' +
       'style="position: absolute; bottom: 15px; right: 15px; z-index: 100">' +
      img +
    '</a>';

  var linkElement = Object(min_dom__WEBPACK_IMPORTED_MODULE_1__["domify"])(linkMarkup);

  container.appendChild(linkElement);

  min_dom__WEBPACK_IMPORTED_MODULE_1__["event"].bind(linkElement, 'click', function(event) {
    Object(_util_PoweredByUtil__WEBPACK_IMPORTED_MODULE_7__["open"])();

    event.preventDefault();
  });
}

/* </project-logo> */

/***/ }),

/***/ "./node_modules/bpmn-js/lib/Viewer.js":
/*!********************************************!*\
  !*** ./node_modules/bpmn-js/lib/Viewer.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Viewer; });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core */ "./node_modules/bpmn-js/lib/core/index.js");
/* harmony import */ var diagram_js_lib_i18n_translate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! diagram-js/lib/i18n/translate */ "./node_modules/diagram-js/lib/i18n/translate/index.js");
/* harmony import */ var diagram_js_lib_features_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! diagram-js/lib/features/selection */ "./node_modules/diagram-js/lib/features/selection/index.js");
/* harmony import */ var diagram_js_lib_features_overlays__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! diagram-js/lib/features/overlays */ "./node_modules/diagram-js/lib/features/overlays/index.js");
/* harmony import */ var _BaseViewer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./BaseViewer */ "./node_modules/bpmn-js/lib/BaseViewer.js");










/**
 * A viewer for BPMN 2.0 diagrams.
 *
 * Have a look at {@link NavigatedViewer} or {@link Modeler} for bundles that include
 * additional features.
 *
 *
 * ## Extending the Viewer
 *
 * In order to extend the viewer pass extension modules to bootstrap via the
 * `additionalModules` option. An extension module is an object that exposes
 * named services.
 *
 * The following example depicts the integration of a simple
 * logging component that integrates with interaction events:
 *
 *
 * ```javascript
 *
 * // logging component
 * function InteractionLogger(eventBus) {
 *   eventBus.on('element.hover', function(event) {
 *     console.log()
 *   })
 * }
 *
 * InteractionLogger.$inject = [ 'eventBus' ]; // minification save
 *
 * // extension module
 * var extensionModule = {
 *   __init__: [ 'interactionLogger' ],
 *   interactionLogger: [ 'type', InteractionLogger ]
 * };
 *
 * // extend the viewer
 * var bpmnViewer = new Viewer({ additionalModules: [ extensionModule ] });
 * bpmnViewer.importXML(...);
 * ```
 *
 * @param {Object} [options] configuration options to pass to the viewer
 * @param {DOMElement} [options.container] the container to render the viewer in, defaults to body.
 * @param {String|Number} [options.width] the width of the viewer
 * @param {String|Number} [options.height] the height of the viewer
 * @param {Object} [options.moddleExtensions] extension packages to provide
 * @param {Array<didi.Module>} [options.modules] a list of modules to override the default modules
 * @param {Array<didi.Module>} [options.additionalModules] a list of modules to use with the default modules
 */
function Viewer(options) {
  _BaseViewer__WEBPACK_IMPORTED_MODULE_5__["default"].call(this, options);
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(Viewer, _BaseViewer__WEBPACK_IMPORTED_MODULE_5__["default"]);

// modules the viewer is composed of
Viewer.prototype._modules = [
  _core__WEBPACK_IMPORTED_MODULE_1__["default"],
  diagram_js_lib_i18n_translate__WEBPACK_IMPORTED_MODULE_2__["default"],
  diagram_js_lib_features_selection__WEBPACK_IMPORTED_MODULE_3__["default"],
  diagram_js_lib_features_overlays__WEBPACK_IMPORTED_MODULE_4__["default"]
];

// default moddle extensions the viewer is composed of
Viewer.prototype._moddleExtensions = {};

/***/ }),

/***/ "./node_modules/bpmn-js/lib/core/index.js":
/*!************************************************!*\
  !*** ./node_modules/bpmn-js/lib/core/index.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../draw */ "./node_modules/bpmn-js/lib/draw/index.js");
/* harmony import */ var _import__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../import */ "./node_modules/bpmn-js/lib/import/index.js");



/* harmony default export */ __webpack_exports__["default"] = ({
  __depends__: [
    _draw__WEBPACK_IMPORTED_MODULE_0__["default"],
    _import__WEBPACK_IMPORTED_MODULE_1__["default"]
  ]
});

/***/ }),

/***/ "./node_modules/bpmn-js/lib/draw/BpmnRenderUtil.js":
/*!*********************************************************!*\
  !*** ./node_modules/bpmn-js/lib/draw/BpmnRenderUtil.js ***!
  \*********************************************************/
/*! exports provided: isTypedEvent, isThrowEvent, isCollection, getDi, getSemantic, getFillColor, getStrokeColor, getCirclePath, getRoundRectPath, getDiamondPath, getRectPath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTypedEvent", function() { return isTypedEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isThrowEvent", function() { return isThrowEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isCollection", function() { return isCollection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDi", function() { return getDi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSemantic", function() { return getSemantic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFillColor", function() { return getFillColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStrokeColor", function() { return getStrokeColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCirclePath", function() { return getCirclePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRoundRectPath", function() { return getRoundRectPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDiamondPath", function() { return getDiamondPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRectPath", function() { return getRectPath; });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var diagram_js_lib_util_RenderUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/util/RenderUtil */ "./node_modules/diagram-js/lib/util/RenderUtil.js");





// element utils //////////////////////

/**
 * Checks if eventDefinition of the given element matches with semantic type.
 *
 * @return {boolean} true if element is of the given semantic type
 */
function isTypedEvent(event, eventDefinitionType, filter) {

  function matches(definition, filter) {
    return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["every"])(filter, function(val, key) {

      // we want a == conversion here, to be able to catch
      // undefined == false and friends
      /* jshint -W116 */
      return definition[key] == val;
    });
  }

  return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["some"])(event.eventDefinitions, function(definition) {
    return definition.$type === eventDefinitionType && matches(event, filter);
  });
}

function isThrowEvent(event) {
  return (event.$type === 'bpmn:IntermediateThrowEvent') || (event.$type === 'bpmn:EndEvent');
}

function isCollection(element) {
  var dataObject = element.dataObjectRef;

  return element.isCollection || (dataObject && dataObject.isCollection);
}

function getDi(element) {
  return element.businessObject.di;
}

function getSemantic(element) {
  return element.businessObject;
}


// color access //////////////////////

function getFillColor(element, defaultColor) {
  return getDi(element).get('bioc:fill') || defaultColor || 'white';
}

function getStrokeColor(element, defaultColor) {
  return getDi(element).get('bioc:stroke') || defaultColor || 'black';
}


// cropping path customizations //////////////////////

function getCirclePath(shape) {

  var cx = shape.x + shape.width / 2,
      cy = shape.y + shape.height / 2,
      radius = shape.width / 2;

  var circlePath = [
    ['M', cx, cy],
    ['m', 0, -radius],
    ['a', radius, radius, 0, 1, 1, 0, 2 * radius],
    ['a', radius, radius, 0, 1, 1, 0, -2 * radius],
    ['z']
  ];

  return Object(diagram_js_lib_util_RenderUtil__WEBPACK_IMPORTED_MODULE_1__["componentsToPath"])(circlePath);
}

function getRoundRectPath(shape, borderRadius) {

  var x = shape.x,
      y = shape.y,
      width = shape.width,
      height = shape.height;

  var roundRectPath = [
    ['M', x + borderRadius, y],
    ['l', width - borderRadius * 2, 0],
    ['a', borderRadius, borderRadius, 0, 0, 1, borderRadius, borderRadius],
    ['l', 0, height - borderRadius * 2],
    ['a', borderRadius, borderRadius, 0, 0, 1, -borderRadius, borderRadius],
    ['l', borderRadius * 2 - width, 0],
    ['a', borderRadius, borderRadius, 0, 0, 1, -borderRadius, -borderRadius],
    ['l', 0, borderRadius * 2 - height],
    ['a', borderRadius, borderRadius, 0, 0, 1, borderRadius, -borderRadius],
    ['z']
  ];

  return Object(diagram_js_lib_util_RenderUtil__WEBPACK_IMPORTED_MODULE_1__["componentsToPath"])(roundRectPath);
}

function getDiamondPath(shape) {

  var width = shape.width,
      height = shape.height,
      x = shape.x,
      y = shape.y,
      halfWidth = width / 2,
      halfHeight = height / 2;

  var diamondPath = [
    ['M', x + halfWidth, y],
    ['l', halfWidth, halfHeight],
    ['l', -halfWidth, halfHeight],
    ['l', -halfWidth, -halfHeight],
    ['z']
  ];

  return Object(diagram_js_lib_util_RenderUtil__WEBPACK_IMPORTED_MODULE_1__["componentsToPath"])(diamondPath);
}

function getRectPath(shape) {
  var x = shape.x,
      y = shape.y,
      width = shape.width,
      height = shape.height;

  var rectPath = [
    ['M', x, y],
    ['l', width, 0],
    ['l', 0, height],
    ['l', -width, 0],
    ['z']
  ];

  return Object(diagram_js_lib_util_RenderUtil__WEBPACK_IMPORTED_MODULE_1__["componentsToPath"])(rectPath);
}

/***/ }),

/***/ "./node_modules/bpmn-js/lib/draw/BpmnRenderer.js":
/*!*******************************************************!*\
  !*** ./node_modules/bpmn-js/lib/draw/BpmnRenderer.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BpmnRenderer; });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var diagram_js_lib_draw_BaseRenderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! diagram-js/lib/draw/BaseRenderer */ "./node_modules/diagram-js/lib/draw/BaseRenderer.js");
/* harmony import */ var _util_DiUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/DiUtil */ "./node_modules/bpmn-js/lib/util/DiUtil.js");
/* harmony import */ var _features_label_editing_LabelUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../features/label-editing/LabelUtil */ "./node_modules/bpmn-js/lib/features/label-editing/LabelUtil.js");
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/ModelUtil */ "./node_modules/bpmn-js/lib/util/ModelUtil.js");
/* harmony import */ var diagram_js_lib_util_RenderUtil__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! diagram-js/lib/util/RenderUtil */ "./node_modules/diagram-js/lib/util/RenderUtil.js");
/* harmony import */ var _BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./BpmnRenderUtil */ "./node_modules/bpmn-js/lib/draw/BpmnRenderUtil.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var diagram_js_lib_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! diagram-js/lib/util/SvgTransformUtil */ "./node_modules/diagram-js/lib/util/SvgTransformUtil.js");
/* harmony import */ var ids__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ids */ "./node_modules/ids/dist/index.esm.js");
























var RENDERER_IDS = new ids__WEBPACK_IMPORTED_MODULE_11__["default"]();

var TASK_BORDER_RADIUS = 10;
var INNER_OUTER_DIST = 3;

var DEFAULT_FILL_OPACITY = .95,
    HIGH_FILL_OPACITY = .35;


function BpmnRenderer(
    config, eventBus, styles, pathMap,
    canvas, textRenderer, priority) {

  diagram_js_lib_draw_BaseRenderer__WEBPACK_IMPORTED_MODULE_2__["default"].call(this, eventBus, priority);

  var defaultFillColor = config && config.defaultFillColor,
      defaultStrokeColor = config && config.defaultStrokeColor;

  var rendererId = RENDERER_IDS.next();

  var markers = {};

  var computeStyle = styles.computeStyle;

  function addMarker(id, options) {
    var attrs = Object(min_dash__WEBPACK_IMPORTED_MODULE_1__["assign"])({
      fill: 'black',
      strokeWidth: 1,
      strokeLinecap: 'round',
      strokeDasharray: 'none'
    }, options.attrs);

    var ref = options.ref || { x: 0, y: 0 };

    var scale = options.scale || 1;

    // fix for safari / chrome / firefox bug not correctly
    // resetting stroke dash array
    if (attrs.strokeDasharray === 'none') {
      attrs.strokeDasharray = [10000, 1];
    }

    var marker = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["create"])('marker');

    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["attr"])(options.element, attrs);

    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["append"])(marker, options.element);

    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["attr"])(marker, {
      id: id,
      viewBox: '0 0 20 20',
      refX: ref.x,
      refY: ref.y,
      markerWidth: 20 * scale,
      markerHeight: 20 * scale,
      orient: 'auto'
    });

    var defs = Object(min_dom__WEBPACK_IMPORTED_MODULE_8__["query"])('defs', canvas._svg);

    if (!defs) {
      defs = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["create"])('defs');

      Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["append"])(canvas._svg, defs);
    }

    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["append"])(defs, marker);

    markers[id] = marker;
  }

  function colorEscape(str) {

    // only allow characters and numbers
    return str.replace(/[^0-9a-zA-z]+/g, '_');
  }

  function marker(type, fill, stroke) {
    var id = type + '-' + colorEscape(fill) + '-' + colorEscape(stroke) + '-' + rendererId;

    if (!markers[id]) {
      createMarker(id, type, fill, stroke);
    }

    return 'url(#' + id + ')';
  }

  function createMarker(id, type, fill, stroke) {

    if (type === 'sequenceflow-end') {
      var sequenceflowEnd = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["create"])('path');
      Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["attr"])(sequenceflowEnd, { d: 'M 1 5 L 11 10 L 1 15 Z' });

      addMarker(id, {
        element: sequenceflowEnd,
        ref: { x: 11, y: 10 },
        scale: 0.5,
        attrs: {
          fill: stroke,
          stroke: stroke
        }
      });
    }

    if (type === 'messageflow-start') {
      var messageflowStart = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["create"])('circle');
      Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["attr"])(messageflowStart, { cx: 6, cy: 6, r: 3.5 });

      addMarker(id, {
        element: messageflowStart,
        attrs: {
          fill: fill,
          stroke: stroke
        },
        ref: { x: 6, y: 6 }
      });
    }

    if (type === 'messageflow-end') {
      var messageflowEnd = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["create"])('path');
      Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["attr"])(messageflowEnd, { d: 'm 1 5 l 0 -3 l 7 3 l -7 3 z' });

      addMarker(id, {
        element: messageflowEnd,
        attrs: {
          fill: fill,
          stroke: stroke,
          strokeLinecap: 'butt'
        },
        ref: { x: 8.5, y: 5 }
      });
    }

    if (type === 'association-start') {
      var associationStart = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["create"])('path');
      Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["attr"])(associationStart, { d: 'M 11 5 L 1 10 L 11 15' });

      addMarker(id, {
        element: associationStart,
        attrs: {
          fill: 'none',
          stroke: stroke,
          strokeWidth: 1.5
        },
        ref: { x: 1, y: 10 },
        scale: 0.5
      });
    }

    if (type === 'association-end') {
      var associationEnd = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["create"])('path');
      Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["attr"])(associationEnd, { d: 'M 1 5 L 11 10 L 1 15' });

      addMarker(id, {
        element: associationEnd,
        attrs: {
          fill: 'none',
          stroke: stroke,
          strokeWidth: 1.5
        },
        ref: { x: 12, y: 10 },
        scale: 0.5
      });
    }

    if (type === 'conditional-flow-marker') {
      var conditionalflowMarker = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["create"])('path');
      Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["attr"])(conditionalflowMarker, { d: 'M 0 10 L 8 6 L 16 10 L 8 14 Z' });

      addMarker(id, {
        element: conditionalflowMarker,
        attrs: {
          fill: fill,
          stroke: stroke
        },
        ref: { x: -1, y: 10 },
        scale: 0.5
      });
    }

    if (type === 'conditional-default-flow-marker') {
      var conditionaldefaultflowMarker = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["create"])('path');
      Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["attr"])(conditionaldefaultflowMarker, { d: 'M 6 4 L 10 16' });

      addMarker(id, {
        element: conditionaldefaultflowMarker,
        attrs: {
          stroke: stroke
        },
        ref: { x: 0, y: 10 },
        scale: 0.5
      });
    }
  }

  function drawCircle(parentGfx, width, height, offset, attrs) {

    if (Object(min_dash__WEBPACK_IMPORTED_MODULE_1__["isObject"])(offset)) {
      attrs = offset;
      offset = 0;
    }

    offset = offset || 0;

    attrs = computeStyle(attrs, {
      stroke: 'black',
      strokeWidth: 2,
      fill: 'white'
    });

    if (attrs.fill === 'none') {
      delete attrs.fillOpacity;
    }

    var cx = width / 2,
        cy = height / 2;

    var circle = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["create"])('circle');
    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["attr"])(circle, {
      cx: cx,
      cy: cy,
      r: Math.round((width + height) / 4 - offset)
    });
    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["attr"])(circle, attrs);

    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["append"])(parentGfx, circle);

    return circle;
  }

  function drawRect(parentGfx, width, height, r, offset, attrs) {

    if (Object(min_dash__WEBPACK_IMPORTED_MODULE_1__["isObject"])(offset)) {
      attrs = offset;
      offset = 0;
    }

    offset = offset || 0;

    attrs = computeStyle(attrs, {
      stroke: 'black',
      strokeWidth: 2,
      fill: 'white'
    });

    var rect = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["create"])('rect');
    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["attr"])(rect, {
      x: offset,
      y: offset,
      width: width - offset * 2,
      height: height - offset * 2,
      rx: r,
      ry: r
    });
    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["attr"])(rect, attrs);

    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["append"])(parentGfx, rect);

    return rect;
  }

  function drawDiamond(parentGfx, width, height, attrs) {

    var x_2 = width / 2;
    var y_2 = height / 2;

    var points = [{ x: x_2, y: 0 }, { x: width, y: y_2 }, { x: x_2, y: height }, { x: 0, y: y_2 }];

    var pointsString = points.map(function(point) {
      return point.x + ',' + point.y;
    }).join(' ');

    attrs = computeStyle(attrs, {
      stroke: 'black',
      strokeWidth: 2,
      fill: 'white'
    });

    var polygon = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["create"])('polygon');
    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["attr"])(polygon, {
      points: pointsString
    });
    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["attr"])(polygon, attrs);

    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["append"])(parentGfx, polygon);

    return polygon;
  }

  function drawLine(parentGfx, waypoints, attrs) {
    attrs = computeStyle(attrs, [ 'no-fill' ], {
      stroke: 'black',
      strokeWidth: 2,
      fill: 'none'
    });

    var line = Object(diagram_js_lib_util_RenderUtil__WEBPACK_IMPORTED_MODULE_6__["createLine"])(waypoints, attrs);

    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["append"])(parentGfx, line);

    return line;
  }

  function drawPath(parentGfx, d, attrs) {

    attrs = computeStyle(attrs, [ 'no-fill' ], {
      strokeWidth: 2,
      stroke: 'black'
    });

    var path = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["create"])('path');
    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["attr"])(path, { d: d });
    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["attr"])(path, attrs);

    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["append"])(parentGfx, path);

    return path;
  }

  function drawMarker(type, parentGfx, path, attrs) {
    return drawPath(parentGfx, path, Object(min_dash__WEBPACK_IMPORTED_MODULE_1__["assign"])({ 'data-marker': type }, attrs));
  }

  function as(type) {
    return function(parentGfx, element) {
      return handlers[type](parentGfx, element);
    };
  }

  function renderer(type) {
    return handlers[type];
  }

  function renderEventContent(element, parentGfx) {

    var event = Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getSemantic"])(element);
    var isThrowing = Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["isThrowEvent"])(event);

    if (event.eventDefinitions && event.eventDefinitions.length>1) {
      if (event.parallelMultiple) {
        return renderer('bpmn:ParallelMultipleEventDefinition')(parentGfx, element, isThrowing);
      }
      else {
        return renderer('bpmn:MultipleEventDefinition')(parentGfx, element, isThrowing);
      }
    }

    if (Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["isTypedEvent"])(event, 'bpmn:MessageEventDefinition')) {
      return renderer('bpmn:MessageEventDefinition')(parentGfx, element, isThrowing);
    }

    if (Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["isTypedEvent"])(event, 'bpmn:TimerEventDefinition')) {
      return renderer('bpmn:TimerEventDefinition')(parentGfx, element, isThrowing);
    }

    if (Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["isTypedEvent"])(event, 'bpmn:ConditionalEventDefinition')) {
      return renderer('bpmn:ConditionalEventDefinition')(parentGfx, element);
    }

    if (Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["isTypedEvent"])(event, 'bpmn:SignalEventDefinition')) {
      return renderer('bpmn:SignalEventDefinition')(parentGfx, element, isThrowing);
    }

    if (Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["isTypedEvent"])(event, 'bpmn:EscalationEventDefinition')) {
      return renderer('bpmn:EscalationEventDefinition')(parentGfx, element, isThrowing);
    }

    if (Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["isTypedEvent"])(event, 'bpmn:LinkEventDefinition')) {
      return renderer('bpmn:LinkEventDefinition')(parentGfx, element, isThrowing);
    }

    if (Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["isTypedEvent"])(event, 'bpmn:ErrorEventDefinition')) {
      return renderer('bpmn:ErrorEventDefinition')(parentGfx, element, isThrowing);
    }

    if (Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["isTypedEvent"])(event, 'bpmn:CancelEventDefinition')) {
      return renderer('bpmn:CancelEventDefinition')(parentGfx, element, isThrowing);
    }

    if (Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["isTypedEvent"])(event, 'bpmn:CompensateEventDefinition')) {
      return renderer('bpmn:CompensateEventDefinition')(parentGfx, element, isThrowing);
    }

    if (Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["isTypedEvent"])(event, 'bpmn:TerminateEventDefinition')) {
      return renderer('bpmn:TerminateEventDefinition')(parentGfx, element, isThrowing);
    }

    return null;
  }

  function renderLabel(parentGfx, label, options) {

    options = Object(min_dash__WEBPACK_IMPORTED_MODULE_1__["assign"])({
      size: {
        width: 100
      }
    }, options);

    var text = textRenderer.createText(label || '', options);

    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["classes"])(text).add('djs-label');

    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["append"])(parentGfx, text);

    return text;
  }

  function renderEmbeddedLabel(parentGfx, element, align) {
    var semantic = Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getSemantic"])(element);

    return renderLabel(parentGfx, semantic.name, {
      box: element,
      align: align,
      padding: 5,
      style: {
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      }
    });
  }

  function renderExternalLabel(parentGfx, element) {

    var box = {
      width: 90,
      height: 30,
      x: element.width / 2 + element.x,
      y: element.height / 2 + element.y
    };

    return renderLabel(parentGfx, Object(_features_label_editing_LabelUtil__WEBPACK_IMPORTED_MODULE_4__["getLabel"])(element), {
      box: box,
      fitBox: true,
      style: Object(min_dash__WEBPACK_IMPORTED_MODULE_1__["assign"])(
        {},
        textRenderer.getExternalStyle(),
        {
          fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
        }
      )
    });
  }

  function renderLaneLabel(parentGfx, text, element) {
    var textBox = renderLabel(parentGfx, text, {
      box: {
        height: 30,
        width: element.height
      },
      align: 'center-middle',
      style: {
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      }
    });

    var top = -1 * element.height;

    Object(diagram_js_lib_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_10__["transform"])(textBox, 0, -top, 270);
  }

  function createPathFromConnection(connection) {
    var waypoints = connection.waypoints;

    var pathData = 'm  ' + waypoints[0].x + ',' + waypoints[0].y;
    for (var i = 1; i < waypoints.length; i++) {
      pathData += 'L' + waypoints[i].x + ',' + waypoints[i].y + ' ';
    }
    return pathData;
  }

  var handlers = this.handlers = {
    'bpmn:Event': function(parentGfx, element, attrs) {

      if (!('fillOpacity' in attrs)) {
        attrs.fillOpacity = DEFAULT_FILL_OPACITY;
      }

      return drawCircle(parentGfx, element.width, element.height, attrs);
    },
    'bpmn:StartEvent': function(parentGfx, element) {
      var attrs = {
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      };

      var semantic = Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getSemantic"])(element);

      if (!semantic.isInterrupting) {
        attrs = {
          strokeDasharray: '6',
          strokeLinecap: 'round',
          fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
          stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
        };
      }

      var circle = renderer('bpmn:Event')(parentGfx, element, attrs);

      renderEventContent(element, parentGfx);

      return circle;
    },
    'bpmn:MessageEventDefinition': function(parentGfx, element, isThrowing) {
      var pathData = pathMap.getScaledPath('EVENT_MESSAGE', {
        xScaleFactor: 0.9,
        yScaleFactor: 0.9,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.235,
          my: 0.315
        }
      });

      var fill = isThrowing ? Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor) : Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor);
      var stroke = isThrowing ? Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor) : Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor);

      var messagePath = drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill: fill,
        stroke: stroke
      });

      return messagePath;
    },
    'bpmn:TimerEventDefinition': function(parentGfx, element) {
      var circle = drawCircle(parentGfx, element.width, element.height, 0.2 * element.height, {
        strokeWidth: 2,
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });

      var pathData = pathMap.getScaledPath('EVENT_TIMER_WH', {
        xScaleFactor: 0.75,
        yScaleFactor: 0.75,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.5,
          my: 0.5
        }
      });

      drawPath(parentGfx, pathData, {
        strokeWidth: 2,
        strokeLinecap: 'square',
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });

      for (var i = 0;i < 12; i++) {

        var linePathData = pathMap.getScaledPath('EVENT_TIMER_LINE', {
          xScaleFactor: 0.75,
          yScaleFactor: 0.75,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0.5,
            my: 0.5
          }
        });

        var width = element.width / 2;
        var height = element.height / 2;

        drawPath(parentGfx, linePathData, {
          strokeWidth: 1,
          strokeLinecap: 'square',
          transform: 'rotate(' + (i * 30) + ',' + height + ',' + width + ')',
          stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
        });
      }

      return circle;
    },
    'bpmn:EscalationEventDefinition': function(parentGfx, event, isThrowing) {
      var pathData = pathMap.getScaledPath('EVENT_ESCALATION', {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: event.width,
        containerHeight: event.height,
        position: {
          mx: 0.5,
          my: 0.2
        }
      });

      var fill = isThrowing ? Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(event, defaultStrokeColor) : 'none';

      return drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill: fill,
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(event, defaultStrokeColor)
      });
    },
    'bpmn:ConditionalEventDefinition': function(parentGfx, event) {
      var pathData = pathMap.getScaledPath('EVENT_CONDITIONAL', {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: event.width,
        containerHeight: event.height,
        position: {
          mx: 0.5,
          my: 0.222
        }
      });

      return drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(event, defaultStrokeColor)
      });
    },
    'bpmn:LinkEventDefinition': function(parentGfx, event, isThrowing) {
      var pathData = pathMap.getScaledPath('EVENT_LINK', {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: event.width,
        containerHeight: event.height,
        position: {
          mx: 0.57,
          my: 0.263
        }
      });

      var fill = isThrowing ? Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(event, defaultStrokeColor) : 'none';

      return drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill: fill,
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(event, defaultStrokeColor)
      });
    },
    'bpmn:ErrorEventDefinition': function(parentGfx, event, isThrowing) {
      var pathData = pathMap.getScaledPath('EVENT_ERROR', {
        xScaleFactor: 1.1,
        yScaleFactor: 1.1,
        containerWidth: event.width,
        containerHeight: event.height,
        position: {
          mx: 0.2,
          my: 0.722
        }
      });

      var fill = isThrowing ? Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(event, defaultStrokeColor) : 'none';

      return drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill: fill,
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(event, defaultStrokeColor)
      });
    },
    'bpmn:CancelEventDefinition': function(parentGfx, event, isThrowing) {
      var pathData = pathMap.getScaledPath('EVENT_CANCEL_45', {
        xScaleFactor: 1.0,
        yScaleFactor: 1.0,
        containerWidth: event.width,
        containerHeight: event.height,
        position: {
          mx: 0.638,
          my: -0.055
        }
      });

      var fill = isThrowing ? Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(event, defaultStrokeColor) : 'none';

      var path = drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill: fill,
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(event, defaultStrokeColor)
      });

      Object(diagram_js_lib_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_10__["rotate"])(path, 45);

      return path;
    },
    'bpmn:CompensateEventDefinition': function(parentGfx, event, isThrowing) {
      var pathData = pathMap.getScaledPath('EVENT_COMPENSATION', {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: event.width,
        containerHeight: event.height,
        position: {
          mx: 0.22,
          my: 0.5
        }
      });

      var fill = isThrowing ? Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(event, defaultStrokeColor) : 'none';

      return drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill: fill,
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(event, defaultStrokeColor)
      });
    },
    'bpmn:SignalEventDefinition': function(parentGfx, event, isThrowing) {
      var pathData = pathMap.getScaledPath('EVENT_SIGNAL', {
        xScaleFactor: 0.9,
        yScaleFactor: 0.9,
        containerWidth: event.width,
        containerHeight: event.height,
        position: {
          mx: 0.5,
          my: 0.2
        }
      });

      var fill = isThrowing ? Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(event, defaultStrokeColor) : 'none';

      return drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill: fill,
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(event, defaultStrokeColor)
      });
    },
    'bpmn:MultipleEventDefinition': function(parentGfx, event, isThrowing) {
      var pathData = pathMap.getScaledPath('EVENT_MULTIPLE', {
        xScaleFactor: 1.1,
        yScaleFactor: 1.1,
        containerWidth: event.width,
        containerHeight: event.height,
        position: {
          mx: 0.222,
          my: 0.36
        }
      });

      var fill = isThrowing ? Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(event, defaultStrokeColor) : 'none';

      return drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill: fill
      });
    },
    'bpmn:ParallelMultipleEventDefinition': function(parentGfx, event) {
      var pathData = pathMap.getScaledPath('EVENT_PARALLEL_MULTIPLE', {
        xScaleFactor: 1.2,
        yScaleFactor: 1.2,
        containerWidth: event.width,
        containerHeight: event.height,
        position: {
          mx: 0.458,
          my: 0.194
        }
      });

      return drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(event, defaultStrokeColor),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(event, defaultStrokeColor)
      });
    },
    'bpmn:EndEvent': function(parentGfx, element) {
      var circle = renderer('bpmn:Event')(parentGfx, element, {
        strokeWidth: 4,
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });

      renderEventContent(element, parentGfx, true);

      return circle;
    },
    'bpmn:TerminateEventDefinition': function(parentGfx, element) {
      var circle = drawCircle(parentGfx, element.width, element.height, 8, {
        strokeWidth: 4,
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });

      return circle;
    },
    'bpmn:IntermediateEvent': function(parentGfx, element) {
      var outer = renderer('bpmn:Event')(parentGfx, element, {
        strokeWidth: 1,
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });

      /* inner */
      drawCircle(parentGfx, element.width, element.height, INNER_OUTER_DIST, {
        strokeWidth: 1,
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, 'none'),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });

      renderEventContent(element, parentGfx);

      return outer;
    },
    'bpmn:IntermediateCatchEvent': as('bpmn:IntermediateEvent'),
    'bpmn:IntermediateThrowEvent': as('bpmn:IntermediateEvent'),

    'bpmn:Activity': function(parentGfx, element, attrs) {

      attrs = attrs || {};

      if (!('fillOpacity' in attrs)) {
        attrs.fillOpacity = DEFAULT_FILL_OPACITY;
      }

      return drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS, attrs);
    },

    'bpmn:Task': function(parentGfx, element) {
      var attrs = {
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      };

      var rect = renderer('bpmn:Activity')(parentGfx, element, attrs);

      renderEmbeddedLabel(parentGfx, element, 'center-middle');
      attachTaskMarkers(parentGfx, element);

      return rect;
    },
    'bpmn:ServiceTask': function(parentGfx, element) {
      var task = renderer('bpmn:Task')(parentGfx, element);

      var pathDataBG = pathMap.getScaledPath('TASK_TYPE_SERVICE', {
        abspos: {
          x: 12,
          y: 18
        }
      });

      /* service bg */ drawPath(parentGfx, pathDataBG, {
        strokeWidth: 1,
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });

      var fillPathData = pathMap.getScaledPath('TASK_TYPE_SERVICE_FILL', {
        abspos: {
          x: 17.2,
          y: 18
        }
      });

      /* service fill */ drawPath(parentGfx, fillPathData, {
        strokeWidth: 0,
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor)
      });

      var pathData = pathMap.getScaledPath('TASK_TYPE_SERVICE', {
        abspos: {
          x: 17,
          y: 22
        }
      });

      /* service */ drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });

      return task;
    },
    'bpmn:UserTask': function(parentGfx, element) {
      var task = renderer('bpmn:Task')(parentGfx, element);

      var x = 15;
      var y = 12;

      var pathData = pathMap.getScaledPath('TASK_TYPE_USER_1', {
        abspos: {
          x: x,
          y: y
        }
      });

      /* user path */ drawPath(parentGfx, pathData, {
        strokeWidth: 0.5,
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });

      var pathData2 = pathMap.getScaledPath('TASK_TYPE_USER_2', {
        abspos: {
          x: x,
          y: y
        }
      });

      /* user2 path */ drawPath(parentGfx, pathData2, {
        strokeWidth: 0.5,
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });

      var pathData3 = pathMap.getScaledPath('TASK_TYPE_USER_3', {
        abspos: {
          x: x,
          y: y
        }
      });

      /* user3 path */ drawPath(parentGfx, pathData3, {
        strokeWidth: 0.5,
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });

      return task;
    },
    'bpmn:ManualTask': function(parentGfx, element) {
      var task = renderer('bpmn:Task')(parentGfx, element);

      var pathData = pathMap.getScaledPath('TASK_TYPE_MANUAL', {
        abspos: {
          x: 17,
          y: 15
        }
      });

      /* manual path */ drawPath(parentGfx, pathData, {
        strokeWidth: 0.5, // 0.25,
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });

      return task;
    },
    'bpmn:SendTask': function(parentGfx, element) {
      var task = renderer('bpmn:Task')(parentGfx, element);

      var pathData = pathMap.getScaledPath('TASK_TYPE_SEND', {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: 21,
        containerHeight: 14,
        position: {
          mx: 0.285,
          my: 0.357
        }
      });

      /* send path */ drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor)
      });

      return task;
    },
    'bpmn:ReceiveTask' : function(parentGfx, element) {
      var semantic = Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getSemantic"])(element);

      var task = renderer('bpmn:Task')(parentGfx, element);
      var pathData;

      if (semantic.instantiate) {
        drawCircle(parentGfx, 28, 28, 20 * 0.22, { strokeWidth: 1 });

        pathData = pathMap.getScaledPath('TASK_TYPE_INSTANTIATING_SEND', {
          abspos: {
            x: 7.77,
            y: 9.52
          }
        });
      } else {

        pathData = pathMap.getScaledPath('TASK_TYPE_SEND', {
          xScaleFactor: 0.9,
          yScaleFactor: 0.9,
          containerWidth: 21,
          containerHeight: 14,
          position: {
            mx: 0.3,
            my: 0.4
          }
        });
      }

      /* receive path */ drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });

      return task;
    },
    'bpmn:ScriptTask': function(parentGfx, element) {
      var task = renderer('bpmn:Task')(parentGfx, element);

      var pathData = pathMap.getScaledPath('TASK_TYPE_SCRIPT', {
        abspos: {
          x: 15,
          y: 20
        }
      });

      /* script path */ drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });

      return task;
    },
    'bpmn:BusinessRuleTask': function(parentGfx, element) {
      var task = renderer('bpmn:Task')(parentGfx, element);

      var headerPathData = pathMap.getScaledPath('TASK_TYPE_BUSINESS_RULE_HEADER', {
        abspos: {
          x: 8,
          y: 8
        }
      });

      var businessHeaderPath = drawPath(parentGfx, headerPathData);
      Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["attr"])(businessHeaderPath, {
        strokeWidth: 1,
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, '#aaaaaa'),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });

      var headerData = pathMap.getScaledPath('TASK_TYPE_BUSINESS_RULE_MAIN', {
        abspos: {
          x: 8,
          y: 8
        }
      });

      var businessPath = drawPath(parentGfx, headerData);
      Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["attr"])(businessPath, {
        strokeWidth: 1,
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });

      return task;
    },
    'bpmn:SubProcess': function(parentGfx, element, attrs) {
      attrs = Object(min_dash__WEBPACK_IMPORTED_MODULE_1__["assign"])({
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      }, attrs);

      var rect = renderer('bpmn:Activity')(parentGfx, element, attrs);

      var expanded = Object(_util_DiUtil__WEBPACK_IMPORTED_MODULE_3__["isExpanded"])(element);

      if (Object(_util_DiUtil__WEBPACK_IMPORTED_MODULE_3__["isEventSubProcess"])(element)) {
        Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["attr"])(rect, {
          strokeDasharray: '1,2'
        });
      }

      renderEmbeddedLabel(parentGfx, element, expanded ? 'center-top' : 'center-middle');

      if (expanded) {
        attachTaskMarkers(parentGfx, element);
      } else {
        attachTaskMarkers(parentGfx, element, ['SubProcessMarker']);
      }

      return rect;
    },
    'bpmn:AdHocSubProcess': function(parentGfx, element) {
      return renderer('bpmn:SubProcess')(parentGfx, element);
    },
    'bpmn:Transaction': function(parentGfx, element) {
      var outer = renderer('bpmn:SubProcess')(parentGfx, element);

      var innerAttrs = styles.style([ 'no-fill', 'no-events' ], {
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });

      /* inner path */ drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS - 2, INNER_OUTER_DIST, innerAttrs);

      return outer;
    },
    'bpmn:CallActivity': function(parentGfx, element) {
      return renderer('bpmn:SubProcess')(parentGfx, element, {
        strokeWidth: 5
      });
    },
    'bpmn:Participant': function(parentGfx, element) {

      var attrs = {
        fillOpacity: DEFAULT_FILL_OPACITY,
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      };

      var lane = renderer('bpmn:Lane')(parentGfx, element, attrs);

      var expandedPool = Object(_util_DiUtil__WEBPACK_IMPORTED_MODULE_3__["isExpanded"])(element);

      if (expandedPool) {
        drawLine(parentGfx, [
          { x: 30, y: 0 },
          { x: 30, y: element.height }
        ], {
          stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
        });
        var text = Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getSemantic"])(element).name;
        renderLaneLabel(parentGfx, text, element);
      } else {

        // Collapsed pool draw text inline
        var text2 = Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getSemantic"])(element).name;
        renderLabel(parentGfx, text2, {
          box: element, align: 'center-middle',
          style: {
            fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
          }
        });
      }

      var participantMultiplicity = !!(Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getSemantic"])(element).participantMultiplicity);

      if (participantMultiplicity) {
        renderer('ParticipantMultiplicityMarker')(parentGfx, element);
      }

      return lane;
    },
    'bpmn:Lane': function(parentGfx, element, attrs) {
      var rect = drawRect(parentGfx, element.width, element.height, 0, Object(min_dash__WEBPACK_IMPORTED_MODULE_1__["assign"])({
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
        fillOpacity: HIGH_FILL_OPACITY,
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      }, attrs));

      var semantic = Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getSemantic"])(element);

      if (semantic.$type === 'bpmn:Lane') {
        var text = semantic.name;
        renderLaneLabel(parentGfx, text, element);
      }

      return rect;
    },
    'bpmn:InclusiveGateway': function(parentGfx, element) {
      var diamond = renderer('bpmn:Gateway')(parentGfx, element);

      /* circle path */
      drawCircle(parentGfx, element.width, element.height, element.height * 0.24, {
        strokeWidth: 2.5,
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });

      return diamond;
    },
    'bpmn:ExclusiveGateway': function(parentGfx, element) {
      var diamond = renderer('bpmn:Gateway')(parentGfx, element);

      var pathData = pathMap.getScaledPath('GATEWAY_EXCLUSIVE', {
        xScaleFactor: 0.4,
        yScaleFactor: 0.4,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.32,
          my: 0.3
        }
      });

      if ((Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getDi"])(element).isMarkerVisible)) {
        drawPath(parentGfx, pathData, {
          strokeWidth: 1,
          fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor),
          stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
        });
      }

      return diamond;
    },
    'bpmn:ComplexGateway': function(parentGfx, element) {
      var diamond = renderer('bpmn:Gateway')(parentGfx, element);

      var pathData = pathMap.getScaledPath('GATEWAY_COMPLEX', {
        xScaleFactor: 0.5,
        yScaleFactor:0.5,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.46,
          my: 0.26
        }
      });

      /* complex path */ drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });

      return diamond;
    },
    'bpmn:ParallelGateway': function(parentGfx, element) {
      var diamond = renderer('bpmn:Gateway')(parentGfx, element);

      var pathData = pathMap.getScaledPath('GATEWAY_PARALLEL', {
        xScaleFactor: 0.6,
        yScaleFactor:0.6,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.46,
          my: 0.2
        }
      });

      /* parallel path */ drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });

      return diamond;
    },
    'bpmn:EventBasedGateway': function(parentGfx, element) {

      var semantic = Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getSemantic"])(element);

      var diamond = renderer('bpmn:Gateway')(parentGfx, element);

      /* outer circle path */ drawCircle(parentGfx, element.width, element.height, element.height * 0.20, {
        strokeWidth: 1,
        fill: 'none',
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });

      var type = semantic.eventGatewayType;
      var instantiate = !!semantic.instantiate;

      function drawEvent() {

        var pathData = pathMap.getScaledPath('GATEWAY_EVENT_BASED', {
          xScaleFactor: 0.18,
          yScaleFactor: 0.18,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0.36,
            my: 0.44
          }
        });

        var attrs = {
          strokeWidth: 2,
          fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, 'none'),
          stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
        };

        /* event path */ drawPath(parentGfx, pathData, attrs);
      }

      if (type === 'Parallel') {

        var pathData = pathMap.getScaledPath('GATEWAY_PARALLEL', {
          xScaleFactor: 0.4,
          yScaleFactor:0.4,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0.474,
            my: 0.296
          }
        });

        var parallelPath = drawPath(parentGfx, pathData);
        Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["attr"])(parallelPath, {
          strokeWidth: 1,
          fill: 'none'
        });
      } else if (type === 'Exclusive') {

        if (!instantiate) {
          var innerCircle = drawCircle(parentGfx, element.width, element.height, element.height * 0.26);
          Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["attr"])(innerCircle, {
            strokeWidth: 1,
            fill: 'none',
            stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
          });
        }

        drawEvent();
      }


      return diamond;
    },
    'bpmn:Gateway': function(parentGfx, element) {
      var attrs = {
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
        fillOpacity: DEFAULT_FILL_OPACITY,
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      };

      return drawDiamond(parentGfx, element.width, element.height, attrs);
    },
    'bpmn:SequenceFlow': function(parentGfx, element) {
      var pathData = createPathFromConnection(element);

      var fill = Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
          stroke = Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor);

      var attrs = {
        strokeLinejoin: 'round',
        markerEnd: marker('sequenceflow-end', fill, stroke),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      };

      var path = drawPath(parentGfx, pathData, attrs);

      var sequenceFlow = Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getSemantic"])(element);

      var source;

      if (element.source) {
        source = element.source.businessObject;

        // conditional flow marker
        if (sequenceFlow.conditionExpression && source.$instanceOf('bpmn:Activity')) {
          Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["attr"])(path, {
            markerStart: marker('conditional-flow-marker', fill, stroke)
          });
        }

        // default marker
        if (source.default && (source.$instanceOf('bpmn:Gateway') || source.$instanceOf('bpmn:Activity')) &&
            source.default === sequenceFlow) {
          Object(tiny_svg__WEBPACK_IMPORTED_MODULE_9__["attr"])(path, {
            markerStart: marker('conditional-default-flow-marker', fill, stroke)
          });
        }
      }

      return path;
    },
    'bpmn:Association': function(parentGfx, element, attrs) {

      var semantic = Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getSemantic"])(element);

      var fill = Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
          stroke = Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor);

      attrs = Object(min_dash__WEBPACK_IMPORTED_MODULE_1__["assign"])({
        strokeDasharray: '0.5, 5',
        strokeLinecap: 'round',
        strokeLinejoin: 'round',
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      }, attrs || {});

      if (semantic.associationDirection === 'One' ||
          semantic.associationDirection === 'Both') {
        attrs.markerEnd = marker('association-end', fill, stroke);
      }

      if (semantic.associationDirection === 'Both') {
        attrs.markerStart = marker('association-start', fill, stroke);
      }

      return drawLine(parentGfx, element.waypoints, attrs);
    },
    'bpmn:DataInputAssociation': function(parentGfx, element) {
      var fill = Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
          stroke = Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor);

      return renderer('bpmn:Association')(parentGfx, element, {
        markerEnd: marker('association-end', fill, stroke)
      });
    },
    'bpmn:DataOutputAssociation': function(parentGfx, element) {
      var fill = Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
          stroke = Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor);

      return renderer('bpmn:Association')(parentGfx, element, {
        markerEnd: marker('association-end', fill, stroke)
      });
    },
    'bpmn:MessageFlow': function(parentGfx, element) {

      var semantic = Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getSemantic"])(element),
          di = Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getDi"])(element);

      var fill = Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
          stroke = Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor);

      var pathData = createPathFromConnection(element);

      var attrs = {
        markerEnd: marker('messageflow-end', fill, stroke),
        markerStart: marker('messageflow-start', fill, stroke),
        strokeDasharray: '10, 12',
        strokeLinecap: 'round',
        strokeLinejoin: 'round',
        strokeWidth: '1.5px',
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      };

      var path = drawPath(parentGfx, pathData, attrs);

      if (semantic.messageRef) {
        var midPoint = path.getPointAtLength(path.getTotalLength() / 2);

        var markerPathData = pathMap.getScaledPath('MESSAGE_FLOW_MARKER', {
          abspos: {
            x: midPoint.x,
            y: midPoint.y
          }
        });

        var messageAttrs = { strokeWidth: 1 };

        if (di.messageVisibleKind === 'initiating') {
          messageAttrs.fill = 'white';
          messageAttrs.stroke = 'black';
        } else {
          messageAttrs.fill = '#888';
          messageAttrs.stroke = 'white';
        }

        drawPath(parentGfx, markerPathData, messageAttrs);
      }

      return path;
    },
    'bpmn:DataObject': function(parentGfx, element) {
      var pathData = pathMap.getScaledPath('DATA_OBJECT_PATH', {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.474,
          my: 0.296
        }
      });

      var elementObject = drawPath(parentGfx, pathData, {
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
        fillOpacity: DEFAULT_FILL_OPACITY,
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });

      var semantic = Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getSemantic"])(element);

      if (Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["isCollection"])(semantic)) {
        renderDataItemCollection(parentGfx, element);
      }

      return elementObject;
    },
    'bpmn:DataObjectReference': as('bpmn:DataObject'),
    'bpmn:DataInput': function(parentGfx, element) {

      var arrowPathData = pathMap.getRawPath('DATA_ARROW');

      // page
      var elementObject = renderer('bpmn:DataObject')(parentGfx, element);

      /* input arrow path */ drawPath(parentGfx, arrowPathData, { strokeWidth: 1 });

      return elementObject;
    },
    'bpmn:DataOutput': function(parentGfx, element) {
      var arrowPathData = pathMap.getRawPath('DATA_ARROW');

      // page
      var elementObject = renderer('bpmn:DataObject')(parentGfx, element);

      /* output arrow path */ drawPath(parentGfx, arrowPathData, {
        strokeWidth: 1,
        fill: 'black'
      });

      return elementObject;
    },
    'bpmn:DataStoreReference': function(parentGfx, element) {
      var DATA_STORE_PATH = pathMap.getScaledPath('DATA_STORE', {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0,
          my: 0.133
        }
      });

      var elementStore = drawPath(parentGfx, DATA_STORE_PATH, {
        strokeWidth: 2,
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
        fillOpacity: DEFAULT_FILL_OPACITY,
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });

      return elementStore;
    },
    'bpmn:BoundaryEvent': function(parentGfx, element) {

      var semantic = Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getSemantic"])(element),
          cancel = semantic.cancelActivity;

      var attrs = {
        strokeWidth: 1,
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      };

      if (!cancel) {
        attrs.strokeDasharray = '6';
        attrs.strokeLinecap = 'round';
      }

      // apply fillOpacity
      var outerAttrs = Object(min_dash__WEBPACK_IMPORTED_MODULE_1__["assign"])({}, attrs, {
        fillOpacity: 1
      });

      // apply no-fill
      var innerAttrs = Object(min_dash__WEBPACK_IMPORTED_MODULE_1__["assign"])({}, attrs, {
        fill: 'none'
      });

      var outer = renderer('bpmn:Event')(parentGfx, element, outerAttrs);

      /* inner path */ drawCircle(parentGfx, element.width, element.height, INNER_OUTER_DIST, innerAttrs);

      renderEventContent(element, parentGfx);

      return outer;
    },
    'bpmn:Group': function(parentGfx, element) {

      var group = drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS, {
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor),
        strokeWidth: 1,
        strokeDasharray: '8,3,1,3',
        fill: 'none',
        pointerEvents: 'none'
      });

      return group;
    },
    'label': function(parentGfx, element) {
      return renderExternalLabel(parentGfx, element);
    },
    'bpmn:TextAnnotation': function(parentGfx, element) {
      var style = {
        'fill': 'none',
        'stroke': 'none'
      };

      var textElement = drawRect(parentGfx, element.width, element.height, 0, 0, style);

      var textPathData = pathMap.getScaledPath('TEXT_ANNOTATION', {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.0,
          my: 0.0
        }
      });

      drawPath(parentGfx, textPathData, {
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });

      var text = Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getSemantic"])(element).text || '';
      renderLabel(parentGfx, text, {
        box: element,
        align: 'left-top',
        padding: 5,
        style: {
          fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
        }
      });

      return textElement;
    },
    'ParticipantMultiplicityMarker': function(parentGfx, element) {
      var markerPath = pathMap.getScaledPath('MARKER_PARALLEL', {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: ((element.width / 2) / element.width),
          my: (element.height - 15) / element.height
        }
      });

      drawMarker('participant-multiplicity', parentGfx, markerPath, {
        strokeWidth: 1,
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });
    },
    'SubProcessMarker': function(parentGfx, element) {
      var markerRect = drawRect(parentGfx, 14, 14, 0, {
        strokeWidth: 1,
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });

      // Process marker is placed in the middle of the box
      // therefore fixed values can be used here
      Object(diagram_js_lib_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_10__["translate"])(markerRect, element.width / 2 - 7.5, element.height - 20);

      var markerPath = pathMap.getScaledPath('MARKER_SUB_PROCESS', {
        xScaleFactor: 1.5,
        yScaleFactor: 1.5,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: (element.width / 2 - 7.5) / element.width,
          my: (element.height - 20) / element.height
        }
      });

      drawMarker('sub-process', parentGfx, markerPath, {
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });
    },
    'ParallelMarker': function(parentGfx, element, position) {
      var markerPath = pathMap.getScaledPath('MARKER_PARALLEL', {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: ((element.width / 2 + position.parallel) / element.width),
          my: (element.height - 20) / element.height
        }
      });

      drawMarker('parallel', parentGfx, markerPath, {
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });
    },
    'SequentialMarker': function(parentGfx, element, position) {
      var markerPath = pathMap.getScaledPath('MARKER_SEQUENTIAL', {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: ((element.width / 2 + position.seq) / element.width),
          my: (element.height - 19) / element.height
        }
      });

      drawMarker('sequential', parentGfx, markerPath, {
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });
    },
    'CompensationMarker': function(parentGfx, element, position) {
      var markerMath = pathMap.getScaledPath('MARKER_COMPENSATION', {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: ((element.width / 2 + position.compensation) / element.width),
          my: (element.height - 13) / element.height
        }
      });

      drawMarker('compensation', parentGfx, markerMath, {
        strokeWidth: 1,
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });
    },
    'LoopMarker': function(parentGfx, element, position) {
      var markerPath = pathMap.getScaledPath('MARKER_LOOP', {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: ((element.width / 2 + position.loop) / element.width),
          my: (element.height - 7) / element.height
        }
      });

      drawMarker('loop', parentGfx, markerPath, {
        strokeWidth: 1,
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getFillColor"])(element, defaultFillColor),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor),
        strokeLinecap: 'round',
        strokeMiterlimit: 0.5
      });
    },
    'AdhocMarker': function(parentGfx, element, position) {
      var markerPath = pathMap.getScaledPath('MARKER_ADHOC', {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: ((element.width / 2 + position.adhoc) / element.width),
          my: (element.height - 15) / element.height
        }
      });

      drawMarker('adhoc', parentGfx, markerPath, {
        strokeWidth: 1,
        fill: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor),
        stroke: Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getStrokeColor"])(element, defaultStrokeColor)
      });
    }
  };

  function attachTaskMarkers(parentGfx, element, taskMarkers) {
    var obj = Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getSemantic"])(element);

    var subprocess = taskMarkers && taskMarkers.indexOf('SubProcessMarker') !== -1;
    var position;

    if (subprocess) {
      position = {
        seq: -21,
        parallel: -22,
        compensation: -42,
        loop: -18,
        adhoc: 10
      };
    } else {
      position = {
        seq: -3,
        parallel: -6,
        compensation: -27,
        loop: 0,
        adhoc: 10
      };
    }

    Object(min_dash__WEBPACK_IMPORTED_MODULE_1__["forEach"])(taskMarkers, function(marker) {
      renderer(marker)(parentGfx, element, position);
    });

    if (obj.isForCompensation) {
      renderer('CompensationMarker')(parentGfx, element, position);
    }

    if (obj.$type === 'bpmn:AdHocSubProcess') {
      renderer('AdhocMarker')(parentGfx, element, position);
    }

    var loopCharacteristics = obj.loopCharacteristics,
        isSequential = loopCharacteristics && loopCharacteristics.isSequential;

    if (loopCharacteristics) {

      if (isSequential === undefined) {
        renderer('LoopMarker')(parentGfx, element, position);
      }

      if (isSequential === false) {
        renderer('ParallelMarker')(parentGfx, element, position);
      }

      if (isSequential === true) {
        renderer('SequentialMarker')(parentGfx, element, position);
      }
    }
  }

  function renderDataItemCollection(parentGfx, element) {

    var yPosition = (element.height - 16) / element.height;

    var pathData = pathMap.getScaledPath('DATA_OBJECT_COLLECTION_PATH', {
      xScaleFactor: 1,
      yScaleFactor: 1,
      containerWidth: element.width,
      containerHeight: element.height,
      position: {
        mx: 0.451,
        my: yPosition
      }
    });

    /* collection path */ drawPath(parentGfx, pathData, {
      strokeWidth: 2
    });
  }


  // extension API, use at your own risk
  this._drawPath = drawPath;

}


inherits__WEBPACK_IMPORTED_MODULE_0___default()(BpmnRenderer, diagram_js_lib_draw_BaseRenderer__WEBPACK_IMPORTED_MODULE_2__["default"]);

BpmnRenderer.$inject = [
  'config.bpmnRenderer',
  'eventBus',
  'styles',
  'pathMap',
  'canvas',
  'textRenderer'
];


BpmnRenderer.prototype.canRender = function(element) {
  return Object(_util_ModelUtil__WEBPACK_IMPORTED_MODULE_5__["is"])(element, 'bpmn:BaseElement');
};

BpmnRenderer.prototype.drawShape = function(parentGfx, element) {
  var type = element.type;
  var h = this.handlers[type];

  /* jshint -W040 */
  return h(parentGfx, element);
};

BpmnRenderer.prototype.drawConnection = function(parentGfx, element) {
  var type = element.type;
  var h = this.handlers[type];

  /* jshint -W040 */
  return h(parentGfx, element);
};

BpmnRenderer.prototype.getShapePath = function(element) {

  if (Object(_util_ModelUtil__WEBPACK_IMPORTED_MODULE_5__["is"])(element, 'bpmn:Event')) {
    return Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getCirclePath"])(element);
  }

  if (Object(_util_ModelUtil__WEBPACK_IMPORTED_MODULE_5__["is"])(element, 'bpmn:Activity')) {
    return Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getRoundRectPath"])(element, TASK_BORDER_RADIUS);
  }

  if (Object(_util_ModelUtil__WEBPACK_IMPORTED_MODULE_5__["is"])(element, 'bpmn:Gateway')) {
    return Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getDiamondPath"])(element);
  }

  return Object(_BpmnRenderUtil__WEBPACK_IMPORTED_MODULE_7__["getRectPath"])(element);
};


/***/ }),

/***/ "./node_modules/bpmn-js/lib/draw/PathMap.js":
/*!**************************************************!*\
  !*** ./node_modules/bpmn-js/lib/draw/PathMap.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PathMap; });
/**
 * Map containing SVG paths needed by BpmnRenderer.
 */

function PathMap() {

  /**
   * Contains a map of path elements
   *
   * <h1>Path definition</h1>
   * A parameterized path is defined like this:
   * <pre>
   * 'GATEWAY_PARALLEL': {
   *   d: 'm {mx},{my} {e.x0},0 0,{e.x1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} ' +
          '-{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z',
   *   height: 17.5,
   *   width:  17.5,
   *   heightElements: [2.5, 7.5],
   *   widthElements: [2.5, 7.5]
   * }
   * </pre>
   * <p>It's important to specify a correct <b>height and width</b> for the path as the scaling
   * is based on the ratio between the specified height and width in this object and the
   * height and width that is set as scale target (Note x,y coordinates will be scaled with
   * individual ratios).</p>
   * <p>The '<b>heightElements</b>' and '<b>widthElements</b>' array must contain the values that will be scaled.
   * The scaling is based on the computed ratios.
   * Coordinates on the y axis should be in the <b>heightElement</b>'s array, they will be scaled using
   * the computed ratio coefficient.
   * In the parameterized path the scaled values can be accessed through the 'e' object in {} brackets.
   *   <ul>
   *    <li>The values for the y axis can be accessed in the path string using {e.y0}, {e.y1}, ....</li>
   *    <li>The values for the x axis can be accessed in the path string using {e.x0}, {e.x1}, ....</li>
   *   </ul>
   *   The numbers x0, x1 respectively y0, y1, ... map to the corresponding array index.
   * </p>
   */
  this.pathMap = {
    'EVENT_MESSAGE': {
      d: 'm {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}',
      height: 36,
      width:  36,
      heightElements: [6, 14],
      widthElements: [10.5, 21]
    },
    'EVENT_SIGNAL': {
      d: 'M {mx},{my} l {e.x0},{e.y0} l -{e.x1},0 Z',
      height: 36,
      width: 36,
      heightElements: [18],
      widthElements: [10, 20]
    },
    'EVENT_ESCALATION': {
      d: 'M {mx},{my} l {e.x0},{e.y0} l -{e.x0},-{e.y1} l -{e.x0},{e.y1} Z',
      height: 36,
      width: 36,
      heightElements: [20, 7],
      widthElements: [8]
    },
    'EVENT_CONDITIONAL': {
      d: 'M {e.x0},{e.y0} l {e.x1},0 l 0,{e.y2} l -{e.x1},0 Z ' +
         'M {e.x2},{e.y3} l {e.x0},0 ' +
         'M {e.x2},{e.y4} l {e.x0},0 ' +
         'M {e.x2},{e.y5} l {e.x0},0 ' +
         'M {e.x2},{e.y6} l {e.x0},0 ' +
         'M {e.x2},{e.y7} l {e.x0},0 ' +
         'M {e.x2},{e.y8} l {e.x0},0 ',
      height: 36,
      width:  36,
      heightElements: [8.5, 14.5, 18, 11.5, 14.5, 17.5, 20.5, 23.5, 26.5],
      widthElements:  [10.5, 14.5, 12.5]
    },
    'EVENT_LINK': {
      d: 'm {mx},{my} 0,{e.y0} -{e.x1},0 0,{e.y1} {e.x1},0 0,{e.y0} {e.x0},-{e.y2} -{e.x0},-{e.y2} z',
      height: 36,
      width: 36,
      heightElements: [4.4375, 6.75, 7.8125],
      widthElements: [9.84375, 13.5]
    },
    'EVENT_ERROR': {
      d: 'm {mx},{my} {e.x0},-{e.y0} {e.x1},-{e.y1} {e.x2},{e.y2} {e.x3},-{e.y3} -{e.x4},{e.y4} -{e.x5},-{e.y5} z',
      height: 36,
      width: 36,
      heightElements: [0.023, 8.737, 8.151, 16.564, 10.591, 8.714],
      widthElements: [0.085, 6.672, 6.97, 4.273, 5.337, 6.636]
    },
    'EVENT_CANCEL_45': {
      d: 'm {mx},{my} -{e.x1},0 0,{e.x0} {e.x1},0 0,{e.y1} {e.x0},0 ' +
        '0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z',
      height: 36,
      width: 36,
      heightElements: [4.75, 8.5],
      widthElements: [4.75, 8.5]
    },
    'EVENT_COMPENSATION': {
      d: 'm {mx},{my} {e.x0},-{e.y0} 0,{e.y1} z m {e.x1},-{e.y2} {e.x2},-{e.y3} 0,{e.y1} -{e.x2},-{e.y3} z',
      height: 36,
      width: 36,
      heightElements: [6.5, 13, 0.4, 6.1],
      widthElements: [9, 9.3, 8.7]
    },
    'EVENT_TIMER_WH': {
      d: 'M {mx},{my} l {e.x0},-{e.y0} m -{e.x0},{e.y0} l {e.x1},{e.y1} ',
      height: 36,
      width:  36,
      heightElements: [10, 2],
      widthElements: [3, 7]
    },
    'EVENT_TIMER_LINE': {
      d:  'M {mx},{my} ' +
          'm {e.x0},{e.y0} l -{e.x1},{e.y1} ',
      height: 36,
      width:  36,
      heightElements: [10, 3],
      widthElements: [0, 0]
    },
    'EVENT_MULTIPLE': {
      d:'m {mx},{my} {e.x1},-{e.y0} {e.x1},{e.y0} -{e.x0},{e.y1} -{e.x2},0 z',
      height: 36,
      width:  36,
      heightElements: [6.28099, 12.56199],
      widthElements: [3.1405, 9.42149, 12.56198]
    },
    'EVENT_PARALLEL_MULTIPLE': {
      d:'m {mx},{my} {e.x0},0 0,{e.y1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} ' +
        '-{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z',
      height: 36,
      width:  36,
      heightElements: [2.56228, 7.68683],
      widthElements: [2.56228, 7.68683]
    },
    'GATEWAY_EXCLUSIVE': {
      d:'m {mx},{my} {e.x0},{e.y0} {e.x1},{e.y0} {e.x2},0 {e.x4},{e.y2} ' +
                    '{e.x4},{e.y1} {e.x2},0 {e.x1},{e.y3} {e.x0},{e.y3} ' +
                    '{e.x3},0 {e.x5},{e.y1} {e.x5},{e.y2} {e.x3},0 z',
      height: 17.5,
      width:  17.5,
      heightElements: [8.5, 6.5312, -6.5312, -8.5],
      widthElements:  [6.5, -6.5, 3, -3, 5, -5]
    },
    'GATEWAY_PARALLEL': {
      d:'m {mx},{my} 0,{e.y1} -{e.x1},0 0,{e.y0} {e.x1},0 0,{e.y1} {e.x0},0 ' +
        '0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z',
      height: 30,
      width:  30,
      heightElements: [5, 12.5],
      widthElements: [5, 12.5]
    },
    'GATEWAY_EVENT_BASED': {
      d:'m {mx},{my} {e.x0},{e.y0} {e.x0},{e.y1} {e.x1},{e.y2} {e.x2},0 z',
      height: 11,
      width:  11,
      heightElements: [-6, 6, 12, -12],
      widthElements: [9, -3, -12]
    },
    'GATEWAY_COMPLEX': {
      d:'m {mx},{my} 0,{e.y0} -{e.x0},-{e.y1} -{e.x1},{e.y2} {e.x0},{e.y1} -{e.x2},0 0,{e.y3} ' +
        '{e.x2},0  -{e.x0},{e.y1} l {e.x1},{e.y2} {e.x0},-{e.y1} 0,{e.y0} {e.x3},0 0,-{e.y0} {e.x0},{e.y1} ' +
        '{e.x1},-{e.y2} -{e.x0},-{e.y1} {e.x2},0 0,-{e.y3} -{e.x2},0 {e.x0},-{e.y1} -{e.x1},-{e.y2} ' +
        '-{e.x0},{e.y1} 0,-{e.y0} -{e.x3},0 z',
      height: 17.125,
      width:  17.125,
      heightElements: [4.875, 3.4375, 2.125, 3],
      widthElements: [3.4375, 2.125, 4.875, 3]
    },
    'DATA_OBJECT_PATH': {
      d:'m 0,0 {e.x1},0 {e.x0},{e.y0} 0,{e.y1} -{e.x2},0 0,-{e.y2} {e.x1},0 0,{e.y0} {e.x0},0',
      height: 61,
      width:  51,
      heightElements: [10, 50, 60],
      widthElements: [10, 40, 50, 60]
    },
    'DATA_OBJECT_COLLECTION_PATH': {
      d:'m {mx}, {my} ' +
        'm  0 15  l 0 -15 ' +
        'm  4 15  l 0 -15 ' +
        'm  4 15  l 0 -15 ',
      height: 61,
      width:  51,
      heightElements: [12],
      widthElements: [1, 6, 12, 15]
    },
    'DATA_ARROW': {
      d:'m 5,9 9,0 0,-3 5,5 -5,5 0,-3 -9,0 z',
      height: 61,
      width:  51,
      heightElements: [],
      widthElements: []
    },
    'DATA_STORE': {
      d:'m  {mx},{my} ' +
        'l  0,{e.y2} ' +
        'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 ' +
        'l  0,-{e.y2} ' +
        'c -{e.x0},-{e.y1} -{e.x1},-{e.y1} -{e.x2},0' +
        'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 ' +
        'm  -{e.x2},{e.y0}' +
        'c  {e.x0},{e.y1} {e.x1},{e.y1} {e.x2},0' +
        'm  -{e.x2},{e.y0}' +
        'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0',
      height: 61,
      width:  61,
      heightElements: [7, 10, 45],
      widthElements:  [2, 58, 60]
    },
    'TEXT_ANNOTATION': {
      d: 'm {mx}, {my} m 10,0 l -10,0 l 0,{e.y0} l 10,0',
      height: 30,
      width: 10,
      heightElements: [30],
      widthElements: [10]
    },
    'MARKER_SUB_PROCESS': {
      d: 'm{mx},{my} m 7,2 l 0,10 m -5,-5 l 10,0',
      height: 10,
      width: 10,
      heightElements: [],
      widthElements: []
    },
    'MARKER_PARALLEL': {
      d: 'm{mx},{my} m 3,2 l 0,10 m 3,-10 l 0,10 m 3,-10 l 0,10',
      height: 10,
      width: 10,
      heightElements: [],
      widthElements: []
    },
    'MARKER_SEQUENTIAL': {
      d: 'm{mx},{my} m 0,3 l 10,0 m -10,3 l 10,0 m -10,3 l 10,0',
      height: 10,
      width: 10,
      heightElements: [],
      widthElements: []
    },
    'MARKER_COMPENSATION': {
      d: 'm {mx},{my} 7,-5 0,10 z m 7.1,-0.3 6.9,-4.7 0,10 -6.9,-4.7 z',
      height: 10,
      width: 21,
      heightElements: [],
      widthElements: []
    },
    'MARKER_LOOP': {
      d: 'm {mx},{my} c 3.526979,0 6.386161,-2.829858 6.386161,-6.320661 0,-3.490806 -2.859182,-6.320661 ' +
        '-6.386161,-6.320661 -3.526978,0 -6.38616,2.829855 -6.38616,6.320661 0,1.745402 ' +
        '0.714797,3.325567 1.870463,4.469381 0.577834,0.571908 1.265885,1.034728 2.029916,1.35457 ' +
        'l -0.718163,-3.909793 m 0.718163,3.909793 -3.885211,0.802902',
      height: 13.9,
      width: 13.7,
      heightElements: [],
      widthElements: []
    },
    'MARKER_ADHOC': {
      d: 'm {mx},{my} m 0.84461,2.64411 c 1.05533,-1.23780996 2.64337,-2.07882 4.29653,-1.97997996 2.05163,0.0805 ' +
        '3.85579,1.15803 5.76082,1.79107 1.06385,0.34139996 2.24454,0.1438 3.18759,-0.43767 0.61743,-0.33642 ' +
        '1.2775,-0.64078 1.7542,-1.17511 0,0.56023 0,1.12046 0,1.6807 -0.98706,0.96237996 -2.29792,1.62393996 ' +
        '-3.6918,1.66181996 -1.24459,0.0927 -2.46671,-0.2491 -3.59505,-0.74812 -1.35789,-0.55965 ' +
        '-2.75133,-1.33436996 -4.27027,-1.18121996 -1.37741,0.14601 -2.41842,1.13685996 -3.44288,1.96782996 z',
      height: 4,
      width: 15,
      heightElements: [],
      widthElements: []
    },
    'TASK_TYPE_SEND': {
      d: 'm {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}',
      height: 14,
      width:  21,
      heightElements: [6, 14],
      widthElements: [10.5, 21]
    },
    'TASK_TYPE_SCRIPT': {
      d: 'm {mx},{my} c 9.966553,-6.27276 -8.000926,-7.91932 2.968968,-14.938 l -8.802728,0 ' +
        'c -10.969894,7.01868 6.997585,8.66524 -2.968967,14.938 z ' +
        'm -7,-12 l 5,0 ' +
        'm -4.5,3 l 4.5,0 ' +
        'm -3,3 l 5,0' +
        'm -4,3 l 5,0',
      height: 15,
      width:  12.6,
      heightElements: [6, 14],
      widthElements: [10.5, 21]
    },
    'TASK_TYPE_USER_1': {
      d: 'm {mx},{my} c 0.909,-0.845 1.594,-2.049 1.594,-3.385 0,-2.554 -1.805,-4.62199999 ' +
        '-4.357,-4.62199999 -2.55199998,0 -4.28799998,2.06799999 -4.28799998,4.62199999 0,1.348 ' +
        '0.974,2.562 1.89599998,3.405 -0.52899998,0.187 -5.669,2.097 -5.794,4.7560005 v 6.718 ' +
        'h 17 v -6.718 c 0,-2.2980005 -5.5279996,-4.5950005 -6.0509996,-4.7760005 z' +
        'm -8,6 l 0,5.5 m 11,0 l 0,-5'
    },
    'TASK_TYPE_USER_2': {
      d: 'm {mx},{my} m 2.162,1.009 c 0,2.4470005 -2.158,4.4310005 -4.821,4.4310005 ' +
        '-2.66499998,0 -4.822,-1.981 -4.822,-4.4310005 '
    },
    'TASK_TYPE_USER_3': {
      d: 'm {mx},{my} m -6.9,-3.80 c 0,0 2.25099998,-2.358 4.27399998,-1.177 2.024,1.181 4.221,1.537 ' +
        '4.124,0.965 -0.098,-0.57 -0.117,-3.79099999 -4.191,-4.13599999 -3.57499998,0.001 ' +
        '-4.20799998,3.36699999 -4.20699998,4.34799999 z'
    },
    'TASK_TYPE_MANUAL': {
      d: 'm {mx},{my} c 0.234,-0.01 5.604,0.008 8.029,0.004 0.808,0 1.271,-0.172 1.417,-0.752 0.227,-0.898 ' +
        '-0.334,-1.314 -1.338,-1.316 -2.467,-0.01 -7.886,-0.004 -8.108,-0.004 -0.014,-0.079 0.016,-0.533 0,-0.61 ' +
        '0.195,-0.042 8.507,0.006 9.616,0.002 0.877,-0.007 1.35,-0.438 1.353,-1.208 0.003,-0.768 -0.479,-1.09 ' +
        '-1.35,-1.091 -2.968,-0.002 -9.619,-0.013 -9.619,-0.013 v -0.591 c 0,0 5.052,-0.016 7.225,-0.016 ' +
        '0.888,-0.002 1.354,-0.416 1.351,-1.193 -0.006,-0.761 -0.492,-1.196 -1.361,-1.196 -3.473,-0.005 ' +
        '-10.86,-0.003 -11.0829995,-0.003 -0.022,-0.047 -0.045,-0.094 -0.069,-0.139 0.3939995,-0.319 ' +
        '2.0409995,-1.626 2.4149995,-2.017 0.469,-0.4870005 0.519,-1.1650005 0.162,-1.6040005 -0.414,-0.511 ' +
        '-0.973,-0.5 -1.48,-0.236 -1.4609995,0.764 -6.5999995,3.6430005 -7.7329995,4.2710005 -0.9,0.499 ' +
        '-1.516,1.253 -1.882,2.19 -0.37000002,0.95 -0.17,2.01 -0.166,2.979 0.004,0.718 -0.27300002,1.345 ' +
        '-0.055,2.063 0.629,2.087 2.425,3.312 4.859,3.318 4.6179995,0.014 9.2379995,-0.139 13.8569995,-0.158 ' +
        '0.755,-0.004 1.171,-0.301 1.182,-1.033 0.012,-0.754 -0.423,-0.969 -1.183,-0.973 -1.778,-0.01 ' +
        '-5.824,-0.004 -6.04,-0.004 10e-4,-0.084 0.003,-0.586 10e-4,-0.67 z'
    },
    'TASK_TYPE_INSTANTIATING_SEND': {
      d: 'm {mx},{my} l 0,8.4 l 12.6,0 l 0,-8.4 z l 6.3,3.6 l 6.3,-3.6'
    },
    'TASK_TYPE_SERVICE': {
      d: 'm {mx},{my} v -1.71335 c 0.352326,-0.0705 0.703932,-0.17838 1.047628,-0.32133 ' +
        '0.344416,-0.14465 0.665822,-0.32133 0.966377,-0.52145 l 1.19431,1.18005 1.567487,-1.57688 ' +
        '-1.195028,-1.18014 c 0.403376,-0.61394 0.683079,-1.29908 0.825447,-2.01824 l 1.622133,-0.01 ' +
        'v -2.2196 l -1.636514,0.01 c -0.07333,-0.35153 -0.178319,-0.70024 -0.323564,-1.04372 ' +
        '-0.145244,-0.34406 -0.321407,-0.6644 -0.522735,-0.96217 l 1.131035,-1.13631 -1.583305,-1.56293 ' +
        '-1.129598,1.13589 c -0.614052,-0.40108 -1.302883,-0.68093 -2.022633,-0.82247 l 0.0093,-1.61852 ' +
        'h -2.241173 l 0.0042,1.63124 c -0.353763,0.0736 -0.705369,0.17977 -1.049785,0.32371 -0.344415,0.14437 ' +
        '-0.665102,0.32092 -0.9635006,0.52046 l -1.1698628,-1.15823 -1.5667691,1.5792 1.1684265,1.15669 ' +
        'c -0.4026573,0.61283 -0.68308,1.29797 -0.8247287,2.01713 l -1.6588041,0.003 v 2.22174 ' +
        'l 1.6724648,-0.006 c 0.073327,0.35077 0.1797598,0.70243 0.3242851,1.04472 0.1452428,0.34448 ' +
        '0.3214064,0.6644 0.5227339,0.96066 l -1.1993431,1.19723 1.5840256,1.56011 1.1964668,-1.19348 ' +
        'c 0.6140517,0.40346 1.3028827,0.68232 2.0233517,0.82331 l 7.19e-4,1.69892 h 2.226848 z ' +
        'm 0.221462,-3.9957 c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 ' +
        '0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 ' +
        '0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z'
    },
    'TASK_TYPE_SERVICE_FILL': {
      d: 'm {mx},{my} c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 ' +
        '0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 ' +
        '0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z'
    },
    'TASK_TYPE_BUSINESS_RULE_HEADER': {
      d: 'm {mx},{my} 0,4 20,0 0,-4 z'
    },
    'TASK_TYPE_BUSINESS_RULE_MAIN': {
      d: 'm {mx},{my} 0,12 20,0 0,-12 z' +
        'm 0,8 l 20,0 ' +
        'm -13,-4 l 0,8'
    },
    'MESSAGE_FLOW_MARKER': {
      d: 'm {mx},{my} m -10.5 ,-7 l 0,14 l 21,0 l 0,-14 z l 10.5,6 l 10.5,-6'
    }
  };

  this.getRawPath = function getRawPath(pathId) {
    return this.pathMap[pathId].d;
  };

  /**
   * Scales the path to the given height and width.
   * <h1>Use case</h1>
   * <p>Use case is to scale the content of elements (event, gateways) based
   * on the element bounding box's size.
   * </p>
   * <h1>Why not transform</h1>
   * <p>Scaling a path with transform() will also scale the stroke and IE does not support
   * the option 'non-scaling-stroke' to prevent this.
   * Also there are use cases where only some parts of a path should be
   * scaled.</p>
   *
   * @param {String} pathId The ID of the path.
   * @param {Object} param <p>
   *   Example param object scales the path to 60% size of the container (data.width, data.height).
   *   <pre>
   *   {
   *     xScaleFactor: 0.6,
   *     yScaleFactor:0.6,
   *     containerWidth: data.width,
   *     containerHeight: data.height,
   *     position: {
   *       mx: 0.46,
   *       my: 0.2,
   *     }
   *   }
   *   </pre>
   *   <ul>
   *    <li>targetpathwidth = xScaleFactor * containerWidth</li>
   *    <li>targetpathheight = yScaleFactor * containerHeight</li>
   *    <li>Position is used to set the starting coordinate of the path. M is computed:
    *    <ul>
    *      <li>position.x * containerWidth</li>
    *      <li>position.y * containerHeight</li>
    *    </ul>
    *    Center of the container <pre> position: {
   *       mx: 0.5,
   *       my: 0.5,
   *     }</pre>
   *     Upper left corner of the container
   *     <pre> position: {
   *       mx: 0.0,
   *       my: 0.0,
   *     }</pre>
   *    </li>
   *   </ul>
   * </p>
   *
   */
  this.getScaledPath = function getScaledPath(pathId, param) {
    var rawPath = this.pathMap[pathId];

    // positioning
    // compute the start point of the path
    var mx, my;

    if (param.abspos) {
      mx = param.abspos.x;
      my = param.abspos.y;
    } else {
      mx = param.containerWidth * param.position.mx;
      my = param.containerHeight * param.position.my;
    }

    var coordinates = {}; // map for the scaled coordinates
    if (param.position) {

      // path
      var heightRatio = (param.containerHeight / rawPath.height) * param.yScaleFactor;
      var widthRatio = (param.containerWidth / rawPath.width) * param.xScaleFactor;


      // Apply height ratio
      for (var heightIndex = 0; heightIndex < rawPath.heightElements.length; heightIndex++) {
        coordinates['y' + heightIndex] = rawPath.heightElements[heightIndex] * heightRatio;
      }

      // Apply width ratio
      for (var widthIndex = 0; widthIndex < rawPath.widthElements.length; widthIndex++) {
        coordinates['x' + widthIndex] = rawPath.widthElements[widthIndex] * widthRatio;
      }
    }

    // Apply value to raw path
    var path = format(
      rawPath.d, {
        mx: mx,
        my: my,
        e: coordinates
      }
    );
    return path;
  };
}

// helpers //////////////////////

// copied from https://github.com/adobe-webplatform/Snap.svg/blob/master/src/svg.js
var tokenRegex = /\{([^}]+)\}/g,
    objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g; // matches .xxxxx or ["xxxxx"] to run over object properties

function replacer(all, key, obj) {
  var res = obj;
  key.replace(objNotationRegex, function(all, name, quote, quotedName, isFunc) {
    name = name || quotedName;
    if (res) {
      if (name in res) {
        res = res[name];
      }
      typeof res == 'function' && isFunc && (res = res());
    }
  });
  res = (res == null || res == obj ? all : res) + '';

  return res;
}

function format(str, obj) {
  return String(str).replace(tokenRegex, function(all, key) {
    return replacer(all, key, obj);
  });
}


/***/ }),

/***/ "./node_modules/bpmn-js/lib/draw/TextRenderer.js":
/*!*******************************************************!*\
  !*** ./node_modules/bpmn-js/lib/draw/TextRenderer.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TextRenderer; });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var diagram_js_lib_util_Text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/util/Text */ "./node_modules/diagram-js/lib/util/Text.js");




var DEFAULT_FONT_SIZE = 12;
var LINE_HEIGHT_RATIO = 1.2;

var MIN_TEXT_ANNOTATION_HEIGHT = 30;


function TextRenderer(config) {

  var defaultStyle = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({
    fontFamily: 'Arial, sans-serif',
    fontSize: DEFAULT_FONT_SIZE,
    fontWeight: 'normal',
    lineHeight: LINE_HEIGHT_RATIO
  }, config && config.defaultStyle || {});

  var fontSize = parseInt(defaultStyle.fontSize, 10) - 1;

  var externalStyle = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({}, defaultStyle, {
    fontSize: fontSize
  }, config && config.externalStyle || {});

  var textUtil = new diagram_js_lib_util_Text__WEBPACK_IMPORTED_MODULE_1__["default"]({
    style: defaultStyle
  });

  /**
   * Get the new bounds of an externally rendered,
   * layouted label.
   *
   * @param  {Bounds} bounds
   * @param  {String} text
   *
   * @return {Bounds}
   */
  this.getExternalLabelBounds = function(bounds, text) {

    var layoutedDimensions = textUtil.getDimensions(text, {
      box: {
        width: 90,
        height: 30,
        x: bounds.width / 2 + bounds.x,
        y: bounds.height / 2 + bounds.y
      },
      style: externalStyle
    });

    // resize label shape to fit label text
    return {
      x: Math.round(bounds.x + bounds.width / 2 - layoutedDimensions.width / 2),
      y: Math.round(bounds.y),
      width: Math.ceil(layoutedDimensions.width),
      height: Math.ceil(layoutedDimensions.height)
    };

  };

  /**
   * Get the new bounds of text annotation.
   *
   * @param  {Bounds} bounds
   * @param  {String} text
   *
   * @return {Bounds}
   */
  this.getTextAnnotationBounds = function(bounds, text) {

    var layoutedDimensions = textUtil.getDimensions(text, {
      box: bounds,
      style: defaultStyle,
      align: 'left-top',
      padding: 5
    });

    return {
      x: bounds.x,
      y: bounds.y,
      width: bounds.width,
      height: Math.max(MIN_TEXT_ANNOTATION_HEIGHT, Math.round(layoutedDimensions.height))
    };
  };

  /**
   * Create a layouted text element.
   *
   * @param {String} text
   * @param {Object} [options]
   *
   * @return {SVGElement} rendered text
   */
  this.createText = function(text, options) {
    return textUtil.createText(text, options || {});
  };

  /**
   * Get default text style.
   */
  this.getDefaultStyle = function() {
    return defaultStyle;
  };

  /**
   * Get the external text style.
   */
  this.getExternalStyle = function() {
    return externalStyle;
  };

}

TextRenderer.$inject = [
  'config.textRenderer'
];

/***/ }),

/***/ "./node_modules/bpmn-js/lib/draw/index.js":
/*!************************************************!*\
  !*** ./node_modules/bpmn-js/lib/draw/index.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _BpmnRenderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BpmnRenderer */ "./node_modules/bpmn-js/lib/draw/BpmnRenderer.js");
/* harmony import */ var _TextRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TextRenderer */ "./node_modules/bpmn-js/lib/draw/TextRenderer.js");
/* harmony import */ var _PathMap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PathMap */ "./node_modules/bpmn-js/lib/draw/PathMap.js");





/* harmony default export */ __webpack_exports__["default"] = ({
  __init__: [ 'bpmnRenderer' ],
  bpmnRenderer: [ 'type', _BpmnRenderer__WEBPACK_IMPORTED_MODULE_0__["default"] ],
  textRenderer: [ 'type', _TextRenderer__WEBPACK_IMPORTED_MODULE_1__["default"] ],
  pathMap: [ 'type', _PathMap__WEBPACK_IMPORTED_MODULE_2__["default"] ]
});


/***/ }),

/***/ "./node_modules/bpmn-js/lib/features/label-editing/LabelUtil.js":
/*!**********************************************************************!*\
  !*** ./node_modules/bpmn-js/lib/features/label-editing/LabelUtil.js ***!
  \**********************************************************************/
/*! exports provided: getLabel, setLabel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLabel", function() { return getLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setLabel", function() { return setLabel; });
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/ModelUtil */ "./node_modules/bpmn-js/lib/util/ModelUtil.js");


function getLabelAttr(semantic) {
  if (
    Object(_util_ModelUtil__WEBPACK_IMPORTED_MODULE_0__["is"])(semantic, 'bpmn:FlowElement') ||
    Object(_util_ModelUtil__WEBPACK_IMPORTED_MODULE_0__["is"])(semantic, 'bpmn:Participant') ||
    Object(_util_ModelUtil__WEBPACK_IMPORTED_MODULE_0__["is"])(semantic, 'bpmn:Lane') ||
    Object(_util_ModelUtil__WEBPACK_IMPORTED_MODULE_0__["is"])(semantic, 'bpmn:SequenceFlow') ||
    Object(_util_ModelUtil__WEBPACK_IMPORTED_MODULE_0__["is"])(semantic, 'bpmn:MessageFlow') ||
    Object(_util_ModelUtil__WEBPACK_IMPORTED_MODULE_0__["is"])(semantic, 'bpmn:DataInput') ||
    Object(_util_ModelUtil__WEBPACK_IMPORTED_MODULE_0__["is"])(semantic, 'bpmn:DataOutput')
  ) {
    return 'name';
  }

  if (Object(_util_ModelUtil__WEBPACK_IMPORTED_MODULE_0__["is"])(semantic, 'bpmn:TextAnnotation')) {
    return 'text';
  }

  if (Object(_util_ModelUtil__WEBPACK_IMPORTED_MODULE_0__["is"])(semantic, 'bpmn:Group')) {
    return 'categoryValueRef';
  }
}

function getCategoryValue(semantic) {
  var categoryValueRef = semantic['categoryValueRef'];

  if (!categoryValueRef) {
    return '';
  }


  return categoryValueRef.value || '';
}

function getLabel(element) {
  var semantic = element.businessObject,
      attr = getLabelAttr(semantic);

  if (attr) {

    if (attr === 'categoryValueRef') {

      return getCategoryValue(semantic);
    }

    return semantic[attr] || '';
  }
}


function setLabel(element, text, isExternal) {
  var semantic = element.businessObject,
      attr = getLabelAttr(semantic);

  if (attr) {

    if (attr === 'categoryValueRef') {
      semantic['categoryValueRef'].value = text;
    } else {
      semantic[attr] = text;
    }

  }

  return element;
}

/***/ }),

/***/ "./node_modules/bpmn-js/lib/import/BpmnImporter.js":
/*!*********************************************************!*\
  !*** ./node_modules/bpmn-js/lib/import/BpmnImporter.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BpmnImporter; });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ModelUtil */ "./node_modules/bpmn-js/lib/util/ModelUtil.js");
/* harmony import */ var _util_LabelUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/LabelUtil */ "./node_modules/bpmn-js/lib/util/LabelUtil.js");
/* harmony import */ var diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! diagram-js/lib/layout/LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");
/* harmony import */ var _util_DiUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/DiUtil */ "./node_modules/bpmn-js/lib/util/DiUtil.js");
/* harmony import */ var _features_label_editing_LabelUtil__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../features/label-editing/LabelUtil */ "./node_modules/bpmn-js/lib/features/label-editing/LabelUtil.js");
/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Util */ "./node_modules/bpmn-js/lib/import/Util.js");















function elementData(semantic, attrs) {
  return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({
    id: semantic.id,
    type: semantic.$type,
    businessObject: semantic
  }, attrs);
}

function getWaypoints(bo, source, target) {

  var waypoints = bo.di.waypoint;

  if (!waypoints || waypoints.length < 2) {
    return [ Object(diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_3__["getMid"])(source), Object(diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_3__["getMid"])(target) ];
  }

  return waypoints.map(function(p) {
    return { x: p.x, y: p.y };
  });
}

function notYetDrawn(translate, semantic, refSemantic, property) {
  return new Error(translate('element {element} referenced by {referenced}#{property} not yet drawn', {
    element: Object(_Util__WEBPACK_IMPORTED_MODULE_6__["elementToString"])(refSemantic),
    referenced: Object(_Util__WEBPACK_IMPORTED_MODULE_6__["elementToString"])(semantic),
    property: property
  }));
}


/**
 * An importer that adds bpmn elements to the canvas
 *
 * @param {EventBus} eventBus
 * @param {Canvas} canvas
 * @param {ElementFactory} elementFactory
 * @param {ElementRegistry} elementRegistry
 * @param {Function} translate
 * @param {TextRenderer} textRenderer
 */
function BpmnImporter(
    eventBus, canvas, elementFactory,
    elementRegistry, translate, textRenderer) {

  this._eventBus = eventBus;
  this._canvas = canvas;
  this._elementFactory = elementFactory;
  this._elementRegistry = elementRegistry;
  this._translate = translate;
  this._textRenderer = textRenderer;
}

BpmnImporter.$inject = [
  'eventBus',
  'canvas',
  'elementFactory',
  'elementRegistry',
  'translate',
  'textRenderer'
];


/**
 * Add bpmn element (semantic) to the canvas onto the
 * specified parent shape.
 */
BpmnImporter.prototype.add = function(semantic, parentElement) {

  var di = semantic.di,
      element,
      translate = this._translate,
      hidden;

  var parentIndex;

  // ROOT ELEMENT
  // handle the special case that we deal with a
  // invisible root element (process or collaboration)
  if (Object(_util_ModelUtil__WEBPACK_IMPORTED_MODULE_1__["is"])(di, 'bpmndi:BPMNPlane')) {

    // add a virtual element (not being drawn)
    element = this._elementFactory.createRoot(elementData(semantic));

    this._canvas.setRootElement(element);
  }

  // SHAPE
  else if (Object(_util_ModelUtil__WEBPACK_IMPORTED_MODULE_1__["is"])(di, 'bpmndi:BPMNShape')) {

    var collapsed = !Object(_util_DiUtil__WEBPACK_IMPORTED_MODULE_4__["isExpanded"])(semantic),
        isFrame = isFrameElement(semantic);
    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);

    var bounds = semantic.di.bounds;

    element = this._elementFactory.createShape(elementData(semantic, {
      collapsed: collapsed,
      hidden: hidden,
      x: Math.round(bounds.x),
      y: Math.round(bounds.y),
      width: Math.round(bounds.width),
      height: Math.round(bounds.height),
      isFrame: isFrame
    }));

    if (Object(_util_ModelUtil__WEBPACK_IMPORTED_MODULE_1__["is"])(semantic, 'bpmn:BoundaryEvent')) {
      this._attachBoundary(semantic, element);
    }

    // insert lanes behind other flow nodes (cf. #727)
    if (Object(_util_ModelUtil__WEBPACK_IMPORTED_MODULE_1__["is"])(semantic, 'bpmn:Lane')) {
      parentIndex = 0;
    }

    if (Object(_util_ModelUtil__WEBPACK_IMPORTED_MODULE_1__["is"])(semantic, 'bpmn:DataStoreReference')) {

      // check whether data store is inside our outside of its semantic parent
      if (!isPointInsideBBox(parentElement, Object(diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_3__["getMid"])(bounds))) {
        parentElement = this._canvas.getRootElement();
      }
    }

    this._canvas.addShape(element, parentElement, parentIndex);
  }

  // CONNECTION
  else if (Object(_util_ModelUtil__WEBPACK_IMPORTED_MODULE_1__["is"])(di, 'bpmndi:BPMNEdge')) {

    var source = this._getSource(semantic),
        target = this._getTarget(semantic);

    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);

    element = this._elementFactory.createConnection(elementData(semantic, {
      hidden: hidden,
      source: source,
      target: target,
      waypoints: getWaypoints(semantic, source, target)
    }));

    if (Object(_util_ModelUtil__WEBPACK_IMPORTED_MODULE_1__["is"])(semantic, 'bpmn:DataAssociation')) {

      // render always on top; this ensures DataAssociations
      // are rendered correctly across different "hacks" people
      // love to model such as cross participant / sub process
      // associations
      parentElement = null;
    }

    // insert sequence flows behind other flow nodes (cf. #727)
    if (Object(_util_ModelUtil__WEBPACK_IMPORTED_MODULE_1__["is"])(semantic, 'bpmn:SequenceFlow')) {
      parentIndex = 0;
    }

    this._canvas.addConnection(element, parentElement, parentIndex);
  } else {
    throw new Error(translate('unknown di {di} for element {semantic}', {
      di: Object(_Util__WEBPACK_IMPORTED_MODULE_6__["elementToString"])(di),
      semantic: Object(_Util__WEBPACK_IMPORTED_MODULE_6__["elementToString"])(semantic)
    }));
  }

  // (optional) LABEL
  if (Object(_util_LabelUtil__WEBPACK_IMPORTED_MODULE_2__["isLabelExternal"])(semantic) && Object(_features_label_editing_LabelUtil__WEBPACK_IMPORTED_MODULE_5__["getLabel"])(element)) {
    this.addLabel(semantic, element);
  }


  this._eventBus.fire('bpmnElement.added', { element: element });

  return element;
};


/**
 * Attach the boundary element to the given host
 *
 * @param {ModdleElement} boundarySemantic
 * @param {djs.model.Base} boundaryElement
 */
BpmnImporter.prototype._attachBoundary = function(boundarySemantic, boundaryElement) {
  var translate = this._translate;
  var hostSemantic = boundarySemantic.attachedToRef;

  if (!hostSemantic) {
    throw new Error(translate('missing {semantic}#attachedToRef', {
      semantic: Object(_Util__WEBPACK_IMPORTED_MODULE_6__["elementToString"])(boundarySemantic)
    }));
  }

  var host = this._elementRegistry.get(hostSemantic.id),
      attachers = host && host.attachers;

  if (!host) {
    throw notYetDrawn(translate, boundarySemantic, hostSemantic, 'attachedToRef');
  }

  // wire element.host <> host.attachers
  boundaryElement.host = host;

  if (!attachers) {
    host.attachers = attachers = [];
  }

  if (attachers.indexOf(boundaryElement) === -1) {
    attachers.push(boundaryElement);
  }
};


/**
 * add label for an element
 */
BpmnImporter.prototype.addLabel = function(semantic, element) {
  var bounds,
      text,
      label;

  bounds = Object(_util_LabelUtil__WEBPACK_IMPORTED_MODULE_2__["getExternalLabelBounds"])(semantic, element);

  text = Object(_features_label_editing_LabelUtil__WEBPACK_IMPORTED_MODULE_5__["getLabel"])(element);

  if (text) {

    // get corrected bounds from actual layouted text
    bounds = this._textRenderer.getExternalLabelBounds(bounds, text);
  }

  label = this._elementFactory.createLabel(elementData(semantic, {
    id: semantic.id + '_label',
    labelTarget: element,
    type: 'label',
    hidden: element.hidden || !Object(_features_label_editing_LabelUtil__WEBPACK_IMPORTED_MODULE_5__["getLabel"])(element),
    x: Math.round(bounds.x),
    y: Math.round(bounds.y),
    width: Math.round(bounds.width),
    height: Math.round(bounds.height)
  }));

  return this._canvas.addShape(label, element.parent);
};

/**
 * Return the drawn connection end based on the given side.
 *
 * @throws {Error} if the end is not yet drawn
 */
BpmnImporter.prototype._getEnd = function(semantic, side) {

  var element,
      refSemantic,
      type = semantic.$type,
      translate = this._translate;

  refSemantic = semantic[side + 'Ref'];

  // handle mysterious isMany DataAssociation#sourceRef
  if (side === 'source' && type === 'bpmn:DataInputAssociation') {
    refSemantic = refSemantic && refSemantic[0];
  }

  // fix source / target for DataInputAssociation / DataOutputAssociation
  if (side === 'source' && type === 'bpmn:DataOutputAssociation' ||
      side === 'target' && type === 'bpmn:DataInputAssociation') {

    refSemantic = semantic.$parent;
  }

  element = refSemantic && this._getElement(refSemantic);

  if (element) {
    return element;
  }

  if (refSemantic) {
    throw notYetDrawn(translate, semantic, refSemantic, side + 'Ref');
  } else {
    throw new Error(translate('{semantic}#{side} Ref not specified', {
      semantic: Object(_Util__WEBPACK_IMPORTED_MODULE_6__["elementToString"])(semantic),
      side: side
    }));
  }
};

BpmnImporter.prototype._getSource = function(semantic) {
  return this._getEnd(semantic, 'source');
};

BpmnImporter.prototype._getTarget = function(semantic) {
  return this._getEnd(semantic, 'target');
};


BpmnImporter.prototype._getElement = function(semantic) {
  return this._elementRegistry.get(semantic.id);
};


// helpers ////////////////////

function isPointInsideBBox(bbox, point) {
  var x = point.x,
      y = point.y;

  return x >= bbox.x &&
    x <= bbox.x + bbox.width &&
    y >= bbox.y &&
    y <= bbox.y + bbox.height;
}

function isFrameElement(semantic) {
  return Object(_util_ModelUtil__WEBPACK_IMPORTED_MODULE_1__["is"])(semantic, 'bpmn:Group');
}

/***/ }),

/***/ "./node_modules/bpmn-js/lib/import/BpmnTreeWalker.js":
/*!***********************************************************!*\
  !*** ./node_modules/bpmn-js/lib/import/BpmnTreeWalker.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BpmnTreeWalker; });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var object_refs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! object-refs */ "./node_modules/object-refs/index.js");
/* harmony import */ var object_refs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(object_refs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Util */ "./node_modules/bpmn-js/lib/import/Util.js");






var diRefs = new object_refs__WEBPACK_IMPORTED_MODULE_1___default.a(
  { name: 'bpmnElement', enumerable: true },
  { name: 'di', configurable: true }
);

/**
 * Returns true if an element has the given meta-model type
 *
 * @param  {ModdleElement}  element
 * @param  {String}         type
 *
 * @return {Boolean}
 */
function is(element, type) {
  return element.$instanceOf(type);
}


/**
 * Find a suitable display candidate for definitions where the DI does not
 * correctly specify one.
 */
function findDisplayCandidate(definitions) {
  return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["find"])(definitions.rootElements, function(e) {
    return is(e, 'bpmn:Process') || is(e, 'bpmn:Collaboration');
  });
}


function BpmnTreeWalker(handler, translate) {

  // list of containers already walked
  var handledElements = {};

  // list of elements to handle deferred to ensure
  // prerequisites are drawn
  var deferred = [];

  // Helpers //////////////////////

  function contextual(fn, ctx) {
    return function(e) {
      fn(e, ctx);
    };
  }

  function handled(element) {
    handledElements[element.id] = element;
  }

  function isHandled(element) {
    return handledElements[element.id];
  }

  function visit(element, ctx) {

    var gfx = element.gfx;

    // avoid multiple rendering of elements
    if (gfx) {
      throw new Error(
        translate('already rendered {element}', { element: Object(_Util__WEBPACK_IMPORTED_MODULE_2__["elementToString"])(element) })
      );
    }

    // call handler
    return handler.element(element, ctx);
  }

  function visitRoot(element, diagram) {
    return handler.root(element, diagram);
  }

  function visitIfDi(element, ctx) {

    try {
      var gfx = element.di && visit(element, ctx);

      handled(element);

      return gfx;
    } catch (e) {
      logError(e.message, { element: element, error: e });

      console.error(translate('failed to import {element}', { element: Object(_Util__WEBPACK_IMPORTED_MODULE_2__["elementToString"])(element) }));
      console.error(e);
    }
  }

  function logError(message, context) {
    handler.error(message, context);
  }

  // DI handling //////////////////////

  function registerDi(di) {
    var bpmnElement = di.bpmnElement;

    if (bpmnElement) {
      if (bpmnElement.di) {
        logError(
          translate('multiple DI elements defined for {element}', {
            element: Object(_Util__WEBPACK_IMPORTED_MODULE_2__["elementToString"])(bpmnElement)
          }),
          { element: bpmnElement }
        );
      } else {
        diRefs.bind(bpmnElement, 'di');
        bpmnElement.di = di;
      }
    } else {
      logError(
        translate('no bpmnElement referenced in {element}', {
          element: Object(_Util__WEBPACK_IMPORTED_MODULE_2__["elementToString"])(di)
        }),
        { element: di }
      );
    }
  }

  function handleDiagram(diagram) {
    handlePlane(diagram.plane);
  }

  function handlePlane(plane) {
    registerDi(plane);

    Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(plane.planeElement, handlePlaneElement);
  }

  function handlePlaneElement(planeElement) {
    registerDi(planeElement);
  }


  // Semantic handling //////////////////////

  /**
   * Handle definitions and return the rendered diagram (if any)
   *
   * @param {ModdleElement} definitions to walk and import
   * @param {ModdleElement} [diagram] specific diagram to import and display
   *
   * @throws {Error} if no diagram to display could be found
   */
  function handleDefinitions(definitions, diagram) {

    // make sure we walk the correct bpmnElement

    var diagrams = definitions.diagrams;

    if (diagram && diagrams.indexOf(diagram) === -1) {
      throw new Error(translate('diagram not part of bpmn:Definitions'));
    }

    if (!diagram && diagrams && diagrams.length) {
      diagram = diagrams[0];
    }

    // no diagram -> nothing to import
    if (!diagram) {
      throw new Error(translate('no diagram to display'));
    }

    // load DI from selected diagram only
    handleDiagram(diagram);


    var plane = diagram.plane;

    if (!plane) {
      throw new Error(translate(
        'no plane for {element}',
        { element: Object(_Util__WEBPACK_IMPORTED_MODULE_2__["elementToString"])(diagram) }
      ));
    }

    var rootElement = plane.bpmnElement;

    // ensure we default to a suitable display candidate (process or collaboration),
    // even if non is specified in DI
    if (!rootElement) {
      rootElement = findDisplayCandidate(definitions);

      if (!rootElement) {
        throw new Error(translate('no process or collaboration to display'));
      } else {

        logError(
          translate('correcting missing bpmnElement on {plane} to {rootElement}', {
            plane: Object(_Util__WEBPACK_IMPORTED_MODULE_2__["elementToString"])(plane),
            rootElement: Object(_Util__WEBPACK_IMPORTED_MODULE_2__["elementToString"])(rootElement)
          })
        );

        // correct DI on the fly
        plane.bpmnElement = rootElement;
        registerDi(plane);
      }
    }


    var ctx = visitRoot(rootElement, plane);

    if (is(rootElement, 'bpmn:Process')) {
      handleProcess(rootElement, ctx);
    } else if (is(rootElement, 'bpmn:Collaboration')) {
      handleCollaboration(rootElement, ctx);

      // force drawing of everything not yet drawn that is part of the target DI
      handleUnhandledProcesses(definitions.rootElements, ctx);
    } else {
      throw new Error(
        translate('unsupported bpmnElement for {plane}: {rootElement}', {
          plane: Object(_Util__WEBPACK_IMPORTED_MODULE_2__["elementToString"])(plane),
          rootElement: Object(_Util__WEBPACK_IMPORTED_MODULE_2__["elementToString"])(rootElement)
        })
      );
    }

    // handle all deferred elements
    handleDeferred(deferred);
  }

  function handleDeferred() {

    var fn;

    // drain deferred until empty
    while (deferred.length) {
      fn = deferred.shift();

      fn();
    }
  }

  function handleProcess(process, context) {
    handleFlowElementsContainer(process, context);
    handleIoSpecification(process.ioSpecification, context);

    handleArtifacts(process.artifacts, context);

    // log process handled
    handled(process);
  }

  function handleUnhandledProcesses(rootElements, ctx) {

    // walk through all processes that have not yet been drawn and draw them
    // if they contain lanes with DI information.
    // we do this to pass the free-floating lane test cases in the MIWG test suite
    var processes = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["filter"])(rootElements, function(e) {
      return !isHandled(e) && is(e, 'bpmn:Process') && e.laneSets;
    });

    processes.forEach(contextual(handleProcess, ctx));
  }

  function handleMessageFlow(messageFlow, context) {
    visitIfDi(messageFlow, context);
  }

  function handleMessageFlows(messageFlows, context) {
    Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(messageFlows, contextual(handleMessageFlow, context));
  }

  function handleDataAssociation(association, context) {
    visitIfDi(association, context);
  }

  function handleDataInput(dataInput, context) {
    visitIfDi(dataInput, context);
  }

  function handleDataOutput(dataOutput, context) {
    visitIfDi(dataOutput, context);
  }

  function handleArtifact(artifact, context) {

    // bpmn:TextAnnotation
    // bpmn:Group
    // bpmn:Association

    visitIfDi(artifact, context);
  }

  function handleArtifacts(artifacts, context) {

    Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(artifacts, function(e) {
      if (is(e, 'bpmn:Association')) {
        deferred.push(function() {
          handleArtifact(e, context);
        });
      } else {
        handleArtifact(e, context);
      }
    });
  }

  function handleIoSpecification(ioSpecification, context) {

    if (!ioSpecification) {
      return;
    }

    Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(ioSpecification.dataInputs, contextual(handleDataInput, context));
    Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(ioSpecification.dataOutputs, contextual(handleDataOutput, context));
  }

  function handleSubProcess(subProcess, context) {
    handleFlowElementsContainer(subProcess, context);
    handleArtifacts(subProcess.artifacts, context);
  }

  function handleFlowNode(flowNode, context) {
    var childCtx = visitIfDi(flowNode, context);

    if (is(flowNode, 'bpmn:SubProcess')) {
      handleSubProcess(flowNode, childCtx || context);
    }

    if (is(flowNode, 'bpmn:Activity')) {
      handleIoSpecification(flowNode.ioSpecification, context);
    }

    // defer handling of associations
    // affected types:
    //
    //   * bpmn:Activity
    //   * bpmn:ThrowEvent
    //   * bpmn:CatchEvent
    //
    deferred.push(function() {
      Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(flowNode.dataInputAssociations, contextual(handleDataAssociation, context));
      Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(flowNode.dataOutputAssociations, contextual(handleDataAssociation, context));
    });
  }

  function handleSequenceFlow(sequenceFlow, context) {
    visitIfDi(sequenceFlow, context);
  }

  function handleDataElement(dataObject, context) {
    visitIfDi(dataObject, context);
  }

  function handleLane(lane, context) {

    deferred.push(function() {

      var newContext = visitIfDi(lane, context);

      if (lane.childLaneSet) {
        handleLaneSet(lane.childLaneSet, newContext || context);
      }

      wireFlowNodeRefs(lane);
    });
  }

  function handleLaneSet(laneSet, context) {
    Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(laneSet.lanes, contextual(handleLane, context));
  }

  function handleLaneSets(laneSets, context) {
    Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(laneSets, contextual(handleLaneSet, context));
  }

  function handleFlowElementsContainer(container, context) {
    handleFlowElements(container.flowElements, context);

    if (container.laneSets) {
      handleLaneSets(container.laneSets, context);
    }
  }

  function handleFlowElements(flowElements, context) {
    Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(flowElements, function(e) {
      if (is(e, 'bpmn:SequenceFlow')) {
        deferred.push(function() {
          handleSequenceFlow(e, context);
        });
      } else if (is(e, 'bpmn:BoundaryEvent')) {
        deferred.unshift(function() {
          handleFlowNode(e, context);
        });
      } else if (is(e, 'bpmn:FlowNode')) {
        handleFlowNode(e, context);
      } else if (is(e, 'bpmn:DataObject')) {

        // SKIP (assume correct referencing via DataObjectReference)
      } else if (is(e, 'bpmn:DataStoreReference')) {
        handleDataElement(e, context);
      } else if (is(e, 'bpmn:DataObjectReference')) {
        handleDataElement(e, context);
      } else {
        logError(
          translate('unrecognized flowElement {element} in context {context}', {
            element: Object(_Util__WEBPACK_IMPORTED_MODULE_2__["elementToString"])(e),
            context: (context ? Object(_Util__WEBPACK_IMPORTED_MODULE_2__["elementToString"])(context.businessObject) : 'null')
          }),
          { element: e, context: context }
        );
      }
    });
  }

  function handleParticipant(participant, context) {
    var newCtx = visitIfDi(participant, context);

    var process = participant.processRef;
    if (process) {
      handleProcess(process, newCtx || context);
    }
  }

  function handleCollaboration(collaboration) {

    Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(collaboration.participants, contextual(handleParticipant));

    handleArtifacts(collaboration.artifacts);

    // handle message flows latest in the process
    deferred.push(function() {
      handleMessageFlows(collaboration.messageFlows);
    });
  }


  function wireFlowNodeRefs(lane) {

    // wire the virtual flowNodeRefs <-> relationship
    Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(lane.flowNodeRef, function(flowNode) {
      var lanes = flowNode.get('lanes');

      if (lanes) {
        lanes.push(lane);
      }
    });
  }

  // API //////////////////////

  return {
    handleDeferred: handleDeferred,
    handleDefinitions: handleDefinitions,
    handleSubProcess: handleSubProcess,
    registerDi: registerDi
  };
}

/***/ }),

/***/ "./node_modules/bpmn-js/lib/import/Importer.js":
/*!*****************************************************!*\
  !*** ./node_modules/bpmn-js/lib/import/Importer.js ***!
  \*****************************************************/
/*! exports provided: importBpmnDiagram */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "importBpmnDiagram", function() { return importBpmnDiagram; });
/* harmony import */ var _BpmnTreeWalker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BpmnTreeWalker */ "./node_modules/bpmn-js/lib/import/BpmnTreeWalker.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");




/**
 * Import the definitions into a diagram.
 *
 * Errors and warnings are reported through the specified callback.
 *
 * @param  {djs.Diagram} diagram
 * @param  {ModdleElement<Definitions>} definitions
 * @param  {ModdleElement<BPMNDiagram>} [bpmnDiagram] the diagram to be rendered
 * (if not provided, the first one will be rendered)
 * @param  {Function} done the callback, invoked with (err, [ warning ]) once the import is done
 */
function importBpmnDiagram(diagram, definitions, bpmnDiagram, done) {

  if (Object(min_dash__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(bpmnDiagram)) {
    done = bpmnDiagram;
    bpmnDiagram = null;
  }

  var importer,
      eventBus,
      translate;

  var error,
      warnings = [];

  /**
   * Walk the diagram semantically, importing (=drawing)
   * all elements you encounter.
   *
   * @param {ModdleElement<Definitions>} definitions
   * @param {ModdleElement<BPMNDiagram>} bpmnDiagram
   */
  function render(definitions, bpmnDiagram) {

    var visitor = {

      root: function(element) {
        return importer.add(element);
      },

      element: function(element, parentShape) {
        return importer.add(element, parentShape);
      },

      error: function(message, context) {
        warnings.push({ message: message, context: context });
      }
    };

    var walker = new _BpmnTreeWalker__WEBPACK_IMPORTED_MODULE_0__["default"](visitor, translate);

    // traverse BPMN 2.0 document model,
    // starting at definitions
    walker.handleDefinitions(definitions, bpmnDiagram);
  }

  try {
    importer = diagram.get('bpmnImporter');
    eventBus = diagram.get('eventBus');
    translate = diagram.get('translate');

    eventBus.fire('import.render.start', { definitions: definitions });

    render(definitions, bpmnDiagram);

    eventBus.fire('import.render.complete', {
      error: error,
      warnings: warnings
    });
  } catch (e) {
    error = e;
  }

  done(error, warnings);
}

/***/ }),

/***/ "./node_modules/bpmn-js/lib/import/Util.js":
/*!*************************************************!*\
  !*** ./node_modules/bpmn-js/lib/import/Util.js ***!
  \*************************************************/
/*! exports provided: elementToString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elementToString", function() { return elementToString; });
function elementToString(e) {
  if (!e) {
    return '<null>';
  }

  return '<' + e.$type + (e.id ? ' id="' + e.id : '') + '" />';
}

/***/ }),

/***/ "./node_modules/bpmn-js/lib/import/index.js":
/*!**************************************************!*\
  !*** ./node_modules/bpmn-js/lib/import/index.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var diagram_js_lib_i18n_translate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js/lib/i18n/translate */ "./node_modules/diagram-js/lib/i18n/translate/index.js");
/* harmony import */ var _BpmnImporter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BpmnImporter */ "./node_modules/bpmn-js/lib/import/BpmnImporter.js");




/* harmony default export */ __webpack_exports__["default"] = ({
  __depends__: [
    diagram_js_lib_i18n_translate__WEBPACK_IMPORTED_MODULE_0__["default"]
  ],
  bpmnImporter: [ 'type', _BpmnImporter__WEBPACK_IMPORTED_MODULE_1__["default"] ]
});

/***/ }),

/***/ "./node_modules/bpmn-js/lib/util/DiUtil.js":
/*!*************************************************!*\
  !*** ./node_modules/bpmn-js/lib/util/DiUtil.js ***!
  \*************************************************/
/*! exports provided: isExpanded, isInterrupting, isEventSubProcess, hasEventDefinition, hasErrorEventDefinition, hasEscalationEventDefinition, hasCompensateEventDefinition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isExpanded", function() { return isExpanded; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isInterrupting", function() { return isInterrupting; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEventSubProcess", function() { return isEventSubProcess; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasEventDefinition", function() { return hasEventDefinition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasErrorEventDefinition", function() { return hasErrorEventDefinition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasEscalationEventDefinition", function() { return hasEscalationEventDefinition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasCompensateEventDefinition", function() { return hasCompensateEventDefinition; });
/* harmony import */ var _ModelUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ModelUtil */ "./node_modules/bpmn-js/lib/util/ModelUtil.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");





function isExpanded(element) {

  if (Object(_ModelUtil__WEBPACK_IMPORTED_MODULE_0__["is"])(element, 'bpmn:CallActivity')) {
    return false;
  }

  if (Object(_ModelUtil__WEBPACK_IMPORTED_MODULE_0__["is"])(element, 'bpmn:SubProcess')) {
    return !!Object(_ModelUtil__WEBPACK_IMPORTED_MODULE_0__["getBusinessObject"])(element).di.isExpanded;
  }

  if (Object(_ModelUtil__WEBPACK_IMPORTED_MODULE_0__["is"])(element, 'bpmn:Participant')) {
    return !!Object(_ModelUtil__WEBPACK_IMPORTED_MODULE_0__["getBusinessObject"])(element).processRef;
  }

  return true;
}

function isInterrupting(element) {
  return element && Object(_ModelUtil__WEBPACK_IMPORTED_MODULE_0__["getBusinessObject"])(element).isInterrupting !== false;
}

function isEventSubProcess(element) {
  return element && !!Object(_ModelUtil__WEBPACK_IMPORTED_MODULE_0__["getBusinessObject"])(element).triggeredByEvent;
}

function hasEventDefinition(element, eventType) {
  var bo = Object(_ModelUtil__WEBPACK_IMPORTED_MODULE_0__["getBusinessObject"])(element),
      hasEventDefinition = false;

  if (bo.eventDefinitions) {
    Object(min_dash__WEBPACK_IMPORTED_MODULE_1__["forEach"])(bo.eventDefinitions, function(event) {
      if (Object(_ModelUtil__WEBPACK_IMPORTED_MODULE_0__["is"])(event, eventType)) {
        hasEventDefinition = true;
      }
    });
  }

  return hasEventDefinition;
}

function hasErrorEventDefinition(element) {
  return hasEventDefinition(element, 'bpmn:ErrorEventDefinition');
}

function hasEscalationEventDefinition(element) {
  return hasEventDefinition(element, 'bpmn:EscalationEventDefinition');
}

function hasCompensateEventDefinition(element) {
  return hasEventDefinition(element, 'bpmn:CompensateEventDefinition');
}


/***/ }),

/***/ "./node_modules/bpmn-js/lib/util/LabelUtil.js":
/*!****************************************************!*\
  !*** ./node_modules/bpmn-js/lib/util/LabelUtil.js ***!
  \****************************************************/
/*! exports provided: DEFAULT_LABEL_SIZE, FLOW_LABEL_INDENT, isLabelExternal, hasExternalLabel, getFlowLabelPosition, getWaypointsMid, getExternalLabelMid, getExternalLabelBounds, isLabel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_LABEL_SIZE", function() { return DEFAULT_LABEL_SIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FLOW_LABEL_INDENT", function() { return FLOW_LABEL_INDENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isLabelExternal", function() { return isLabelExternal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasExternalLabel", function() { return hasExternalLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFlowLabelPosition", function() { return getFlowLabelPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getWaypointsMid", function() { return getWaypointsMid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getExternalLabelMid", function() { return getExternalLabelMid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getExternalLabelBounds", function() { return getExternalLabelBounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isLabel", function() { return isLabel; });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _ModelUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ModelUtil */ "./node_modules/bpmn-js/lib/util/ModelUtil.js");





var DEFAULT_LABEL_SIZE = {
  width: 90,
  height: 20
};

var FLOW_LABEL_INDENT = 15;


/**
 * Returns true if the given semantic has an external label
 *
 * @param {BpmnElement} semantic
 * @return {Boolean} true if has label
 */
function isLabelExternal(semantic) {
  return Object(_ModelUtil__WEBPACK_IMPORTED_MODULE_1__["is"])(semantic, 'bpmn:Event') ||
         Object(_ModelUtil__WEBPACK_IMPORTED_MODULE_1__["is"])(semantic, 'bpmn:Gateway') ||
         Object(_ModelUtil__WEBPACK_IMPORTED_MODULE_1__["is"])(semantic, 'bpmn:DataStoreReference') ||
         Object(_ModelUtil__WEBPACK_IMPORTED_MODULE_1__["is"])(semantic, 'bpmn:DataObjectReference') ||
         Object(_ModelUtil__WEBPACK_IMPORTED_MODULE_1__["is"])(semantic, 'bpmn:DataInput') ||
         Object(_ModelUtil__WEBPACK_IMPORTED_MODULE_1__["is"])(semantic, 'bpmn:DataOutput') ||
         Object(_ModelUtil__WEBPACK_IMPORTED_MODULE_1__["is"])(semantic, 'bpmn:SequenceFlow') ||
         Object(_ModelUtil__WEBPACK_IMPORTED_MODULE_1__["is"])(semantic, 'bpmn:MessageFlow') ||
         Object(_ModelUtil__WEBPACK_IMPORTED_MODULE_1__["is"])(semantic, 'bpmn:Group');
}

/**
 * Returns true if the given element has an external label
 *
 * @param {djs.model.shape} element
 * @return {Boolean} true if has label
 */
function hasExternalLabel(element) {
  return isLabel(element.label);
}

/**
 * Get the position for sequence flow labels
 *
 * @param  {Array<Point>} waypoints
 * @return {Point} the label position
 */
function getFlowLabelPosition(waypoints) {

  // get the waypoints mid
  var mid = waypoints.length / 2 - 1;

  var first = waypoints[Math.floor(mid)];
  var second = waypoints[Math.ceil(mid + 0.01)];

  // get position
  var position = getWaypointsMid(waypoints);

  // calculate angle
  var angle = Math.atan((second.y - first.y) / (second.x - first.x));

  var x = position.x,
      y = position.y;

  if (Math.abs(angle) < Math.PI / 2) {
    y -= FLOW_LABEL_INDENT;
  } else {
    x += FLOW_LABEL_INDENT;
  }

  return { x: x, y: y };
}


/**
 * Get the middle of a number of waypoints
 *
 * @param  {Array<Point>} waypoints
 * @return {Point} the mid point
 */
function getWaypointsMid(waypoints) {

  var mid = waypoints.length / 2 - 1;

  var first = waypoints[Math.floor(mid)];
  var second = waypoints[Math.ceil(mid + 0.01)];

  return {
    x: first.x + (second.x - first.x) / 2,
    y: first.y + (second.y - first.y) / 2
  };
}


function getExternalLabelMid(element) {

  if (element.waypoints) {
    return getFlowLabelPosition(element.waypoints);
  } else if (Object(_ModelUtil__WEBPACK_IMPORTED_MODULE_1__["is"])(element, 'bpmn:Group')) {
    return {
      x: element.x + element.width / 2,
      y: element.y + DEFAULT_LABEL_SIZE.height / 2
    };
  } else {
    return {
      x: element.x + element.width / 2,
      y: element.y + element.height + DEFAULT_LABEL_SIZE.height / 2
    };
  }
}


/**
 * Returns the bounds of an elements label, parsed from the elements DI or
 * generated from its bounds.
 *
 * @param {BpmnElement} semantic
 * @param {djs.model.Base} element
 */
function getExternalLabelBounds(semantic, element) {

  var mid,
      size,
      bounds,
      di = semantic.di,
      label = di.label;

  if (label && label.bounds) {
    bounds = label.bounds;

    size = {
      width: Math.max(DEFAULT_LABEL_SIZE.width, bounds.width),
      height: bounds.height
    };

    mid = {
      x: bounds.x + bounds.width / 2,
      y: bounds.y + bounds.height / 2
    };
  } else {

    mid = getExternalLabelMid(element);

    size = DEFAULT_LABEL_SIZE;
  }

  return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({
    x: mid.x - size.width / 2,
    y: mid.y - size.height / 2
  }, size);
}

function isLabel(element) {
  return element && !!element.labelTarget;
}


/***/ }),

/***/ "./node_modules/bpmn-js/lib/util/ModelUtil.js":
/*!****************************************************!*\
  !*** ./node_modules/bpmn-js/lib/util/ModelUtil.js ***!
  \****************************************************/
/*! exports provided: is, getBusinessObject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "is", function() { return is; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBusinessObject", function() { return getBusinessObject; });
/**
 * Is an element of the given BPMN type?
 *
 * @param  {djs.model.Base|ModdleElement} element
 * @param  {String} type
 *
 * @return {Boolean}
 */
function is(element, type) {
  var bo = getBusinessObject(element);

  return bo && (typeof bo.$instanceOf === 'function') && bo.$instanceOf(type);
}


/**
 * Return the business object for a given element.
 *
 * @param  {djs.model.Base|ModdleElement} element
 *
 * @return {ModdleElement}
 */
function getBusinessObject(element) {
  return (element && element.businessObject) || element;
}

/***/ }),

/***/ "./node_modules/bpmn-js/lib/util/PoweredByUtil.js":
/*!********************************************************!*\
  !*** ./node_modules/bpmn-js/lib/util/PoweredByUtil.js ***!
  \********************************************************/
/*! exports provided: BPMNIO_IMG, open */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BPMNIO_IMG", function() { return BPMNIO_IMG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "open", function() { return open; });
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/**
 * This file must not be changed or exchanged.
 *
 * @see http://bpmn.io/license for more information.
 */




// inlined ../../resources/logo.svg
var BPMNIO_LOGO_SVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 960 960"><path fill="#fff" d="M960 60v839c0 33-27 61-60 61H60c-33 0-60-27-60-60V60C0 27 27 0 60 0h839c34 0 61 27 61 60z"/><path fill="#52b415" d="M217 548a205 205 0 0 0-144 58 202 202 0 0 0-4 286 202 202 0 0 0 285 3 200 200 0 0 0 48-219 203 203 0 0 0-185-128zM752 6a206 206 0 0 0-192 285 206 206 0 0 0 269 111 207 207 0 0 0 111-260A204 204 0 0 0 752 6zM62 0A62 62 0 0 0 0 62v398l60 46a259 259 0 0 1 89-36c5-28 10-57 14-85l99 2 12 85a246 246 0 0 1 88 38l70-52 69 71-52 68c17 30 29 58 35 90l86 14-2 100-86 12a240 240 0 0 1-38 89l43 58h413c37 0 60-27 60-61V407a220 220 0 0 1-44 40l21 85-93 39-45-76a258 258 0 0 1-98 1l-45 76-94-39 22-85a298 298 0 0 1-70-69l-86 22-38-94 76-45a258 258 0 0 1-1-98l-76-45 40-94 85 22a271 271 0 0 1 41-47z"/></svg>';

var BPMNIO_LOGO_URL = 'data:image/svg+xml,' + encodeURIComponent(BPMNIO_LOGO_SVG);

var BPMNIO_IMG = '<img width="52" height="52" src="' + BPMNIO_LOGO_URL + '" />';

function css(attrs) {
  return attrs.join(';');
}

var LIGHTBOX_STYLES = css([
  'z-index: 1001',
  'position: fixed',
  'top: 0',
  'left: 0',
  'right: 0',
  'bottom: 0'
]);

var BACKDROP_STYLES = css([
  'width: 100%',
  'height: 100%',
  'background: rgba(0,0,0,0.2)'
]);

var NOTICE_STYLES = css([
  'position: absolute',
  'left: 50%',
  'top: 40%',
  'margin: 0 -130px',
  'width: 260px',
  'padding: 10px',
  'background: white',
  'border: solid 1px #AAA',
  'border-radius: 3px',
  'font-family: Helvetica, Arial, sans-serif',
  'font-size: 14px',
  'line-height: 1.2em'
]);

var LIGHTBOX_MARKUP =
  '<div class="bjs-powered-by-lightbox" style="' + LIGHTBOX_STYLES + '">' +
    '<div class="backdrop" style="' + BACKDROP_STYLES + '"></div>' +
    '<div class="notice" style="' + NOTICE_STYLES + '">' +
      '<a href="http://bpmn.io" target="_blank" style="float: left; margin-right: 10px">' +
        BPMNIO_IMG +
      '</a>' +
      'Web-based tooling for BPMN, DMN and CMMN diagrams ' +
      'powered by <a href="http://bpmn.io" target="_blank">bpmn.io</a>.' +
    '</div>' +
  '</div>';


var lightbox;

function open() {

  if (!lightbox) {
    lightbox = Object(min_dom__WEBPACK_IMPORTED_MODULE_0__["domify"])(LIGHTBOX_MARKUP);

    min_dom__WEBPACK_IMPORTED_MODULE_0__["delegate"].bind(lightbox, '.backdrop', 'click', function(event) {
      document.body.removeChild(lightbox);
    });
  }

  document.body.appendChild(lightbox);
}

/***/ }),

/***/ "./node_modules/bpmn-js/node_modules/bpmn-moddle/dist/index.esm.js":
/*!*************************************************************************!*\
  !*** ./node_modules/bpmn-js/node_modules/bpmn-moddle/dist/index.esm.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var moddle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! moddle */ "./node_modules/moddle/dist/index.esm.js");
/* harmony import */ var moddle_xml__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! moddle-xml */ "./node_modules/bpmn-js/node_modules/moddle-xml/dist/index.esm.js");




/**
 * A sub class of {@link Moddle} with support for import and export of BPMN 2.0 xml files.
 *
 * @class BpmnModdle
 * @extends Moddle
 *
 * @param {Object|Array} packages to use for instantiating the model
 * @param {Object} [options] additional options to pass over
 */
function BpmnModdle(packages, options) {
  moddle__WEBPACK_IMPORTED_MODULE_1__["Moddle"].call(this, packages, options);
}

BpmnModdle.prototype = Object.create(moddle__WEBPACK_IMPORTED_MODULE_1__["Moddle"].prototype);


/**
 * Instantiates a BPMN model tree from a given xml string.
 *
 * @param {String}   xmlStr
 * @param {String}   [typeName='bpmn:Definitions'] name of the root element
 * @param {Object}   [options]  options to pass to the underlying reader
 * @param {Function} done       callback that is invoked with (err, result, parseContext)
 *                              once the import completes
 */
BpmnModdle.prototype.fromXML = function(xmlStr, typeName, options, done) {

  if (!Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isString"])(typeName)) {
    done = options;
    options = typeName;
    typeName = 'bpmn:Definitions';
  }

  if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(options)) {
    done = options;
    options = {};
  }

  var reader = new moddle_xml__WEBPACK_IMPORTED_MODULE_2__["Reader"](Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({ model: this, lax: true }, options));
  var rootHandler = reader.handler(typeName);

  reader.fromXML(xmlStr, rootHandler, done);
};


/**
 * Serializes a BPMN 2.0 object tree to XML.
 *
 * @param {String}   element    the root element, typically an instance of `bpmn:Definitions`
 * @param {Object}   [options]  to pass to the underlying writer
 * @param {Function} done       callback invoked with (err, xmlStr) once the import completes
 */
BpmnModdle.prototype.toXML = function(element, options, done) {

  if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(options)) {
    done = options;
    options = {};
  }

  var writer = new moddle_xml__WEBPACK_IMPORTED_MODULE_2__["Writer"](options);

  var result;
  var err;

  try {
    result = writer.toXML(element);
  } catch (e) {
    err = e;
  }

  return done(err, result);
};

var name = "BPMN20";
var uri = "http://www.omg.org/spec/BPMN/20100524/MODEL";
var prefix = "bpmn";
var associations = [
];
var types = [
	{
		name: "Interface",
		superClass: [
			"RootElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "operations",
				type: "Operation",
				isMany: true
			},
			{
				name: "implementationRef",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "Operation",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "inMessageRef",
				type: "Message",
				isReference: true
			},
			{
				name: "outMessageRef",
				type: "Message",
				isReference: true
			},
			{
				name: "errorRef",
				type: "Error",
				isMany: true,
				isReference: true
			},
			{
				name: "implementationRef",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "EndPoint",
		superClass: [
			"RootElement"
		]
	},
	{
		name: "Auditing",
		superClass: [
			"BaseElement"
		]
	},
	{
		name: "GlobalTask",
		superClass: [
			"CallableElement"
		],
		properties: [
			{
				name: "resources",
				type: "ResourceRole",
				isMany: true
			}
		]
	},
	{
		name: "Monitoring",
		superClass: [
			"BaseElement"
		]
	},
	{
		name: "Performer",
		superClass: [
			"ResourceRole"
		]
	},
	{
		name: "Process",
		superClass: [
			"FlowElementsContainer",
			"CallableElement"
		],
		properties: [
			{
				name: "processType",
				type: "ProcessType",
				isAttr: true
			},
			{
				name: "isClosed",
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "auditing",
				type: "Auditing"
			},
			{
				name: "monitoring",
				type: "Monitoring"
			},
			{
				name: "properties",
				type: "Property",
				isMany: true
			},
			{
				name: "laneSets",
				isMany: true,
				replaces: "FlowElementsContainer#laneSets",
				type: "LaneSet"
			},
			{
				name: "flowElements",
				isMany: true,
				replaces: "FlowElementsContainer#flowElements",
				type: "FlowElement"
			},
			{
				name: "artifacts",
				type: "Artifact",
				isMany: true
			},
			{
				name: "resources",
				type: "ResourceRole",
				isMany: true
			},
			{
				name: "correlationSubscriptions",
				type: "CorrelationSubscription",
				isMany: true
			},
			{
				name: "supports",
				type: "Process",
				isMany: true,
				isReference: true
			},
			{
				name: "definitionalCollaborationRef",
				type: "Collaboration",
				isAttr: true,
				isReference: true
			},
			{
				name: "isExecutable",
				isAttr: true,
				type: "Boolean"
			}
		]
	},
	{
		name: "LaneSet",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "lanes",
				type: "Lane",
				isMany: true
			},
			{
				name: "name",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "Lane",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "partitionElementRef",
				type: "BaseElement",
				isAttr: true,
				isReference: true
			},
			{
				name: "partitionElement",
				type: "BaseElement"
			},
			{
				name: "flowNodeRef",
				type: "FlowNode",
				isMany: true,
				isReference: true
			},
			{
				name: "childLaneSet",
				type: "LaneSet",
				xml: {
					serialize: "xsi:type"
				}
			}
		]
	},
	{
		name: "GlobalManualTask",
		superClass: [
			"GlobalTask"
		]
	},
	{
		name: "ManualTask",
		superClass: [
			"Task"
		]
	},
	{
		name: "UserTask",
		superClass: [
			"Task"
		],
		properties: [
			{
				name: "renderings",
				type: "Rendering",
				isMany: true
			},
			{
				name: "implementation",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "Rendering",
		superClass: [
			"BaseElement"
		]
	},
	{
		name: "HumanPerformer",
		superClass: [
			"Performer"
		]
	},
	{
		name: "PotentialOwner",
		superClass: [
			"HumanPerformer"
		]
	},
	{
		name: "GlobalUserTask",
		superClass: [
			"GlobalTask"
		],
		properties: [
			{
				name: "implementation",
				isAttr: true,
				type: "String"
			},
			{
				name: "renderings",
				type: "Rendering",
				isMany: true
			}
		]
	},
	{
		name: "Gateway",
		isAbstract: true,
		superClass: [
			"FlowNode"
		],
		properties: [
			{
				name: "gatewayDirection",
				type: "GatewayDirection",
				"default": "Unspecified",
				isAttr: true
			}
		]
	},
	{
		name: "EventBasedGateway",
		superClass: [
			"Gateway"
		],
		properties: [
			{
				name: "instantiate",
				"default": false,
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "eventGatewayType",
				type: "EventBasedGatewayType",
				isAttr: true,
				"default": "Exclusive"
			}
		]
	},
	{
		name: "ComplexGateway",
		superClass: [
			"Gateway"
		],
		properties: [
			{
				name: "activationCondition",
				type: "Expression",
				xml: {
					serialize: "xsi:type"
				}
			},
			{
				name: "default",
				type: "SequenceFlow",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "ExclusiveGateway",
		superClass: [
			"Gateway"
		],
		properties: [
			{
				name: "default",
				type: "SequenceFlow",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "InclusiveGateway",
		superClass: [
			"Gateway"
		],
		properties: [
			{
				name: "default",
				type: "SequenceFlow",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "ParallelGateway",
		superClass: [
			"Gateway"
		]
	},
	{
		name: "RootElement",
		isAbstract: true,
		superClass: [
			"BaseElement"
		]
	},
	{
		name: "Relationship",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "type",
				isAttr: true,
				type: "String"
			},
			{
				name: "direction",
				type: "RelationshipDirection",
				isAttr: true
			},
			{
				name: "source",
				isMany: true,
				isReference: true,
				type: "Element"
			},
			{
				name: "target",
				isMany: true,
				isReference: true,
				type: "Element"
			}
		]
	},
	{
		name: "BaseElement",
		isAbstract: true,
		properties: [
			{
				name: "id",
				isAttr: true,
				type: "String",
				isId: true
			},
			{
				name: "documentation",
				type: "Documentation",
				isMany: true
			},
			{
				name: "extensionDefinitions",
				type: "ExtensionDefinition",
				isMany: true,
				isReference: true
			},
			{
				name: "extensionElements",
				type: "ExtensionElements"
			}
		]
	},
	{
		name: "Extension",
		properties: [
			{
				name: "mustUnderstand",
				"default": false,
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "definition",
				type: "ExtensionDefinition",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "ExtensionDefinition",
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "extensionAttributeDefinitions",
				type: "ExtensionAttributeDefinition",
				isMany: true
			}
		]
	},
	{
		name: "ExtensionAttributeDefinition",
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "type",
				isAttr: true,
				type: "String"
			},
			{
				name: "isReference",
				"default": false,
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "extensionDefinition",
				type: "ExtensionDefinition",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "ExtensionElements",
		properties: [
			{
				name: "valueRef",
				isAttr: true,
				isReference: true,
				type: "Element"
			},
			{
				name: "values",
				type: "Element",
				isMany: true
			},
			{
				name: "extensionAttributeDefinition",
				type: "ExtensionAttributeDefinition",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "Documentation",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "text",
				type: "String",
				isBody: true
			},
			{
				name: "textFormat",
				"default": "text/plain",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "Event",
		isAbstract: true,
		superClass: [
			"FlowNode",
			"InteractionNode"
		],
		properties: [
			{
				name: "properties",
				type: "Property",
				isMany: true
			}
		]
	},
	{
		name: "IntermediateCatchEvent",
		superClass: [
			"CatchEvent"
		]
	},
	{
		name: "IntermediateThrowEvent",
		superClass: [
			"ThrowEvent"
		]
	},
	{
		name: "EndEvent",
		superClass: [
			"ThrowEvent"
		]
	},
	{
		name: "StartEvent",
		superClass: [
			"CatchEvent"
		],
		properties: [
			{
				name: "isInterrupting",
				"default": true,
				isAttr: true,
				type: "Boolean"
			}
		]
	},
	{
		name: "ThrowEvent",
		isAbstract: true,
		superClass: [
			"Event"
		],
		properties: [
			{
				name: "dataInputs",
				type: "DataInput",
				isMany: true
			},
			{
				name: "dataInputAssociations",
				type: "DataInputAssociation",
				isMany: true
			},
			{
				name: "inputSet",
				type: "InputSet"
			},
			{
				name: "eventDefinitions",
				type: "EventDefinition",
				isMany: true
			},
			{
				name: "eventDefinitionRef",
				type: "EventDefinition",
				isMany: true,
				isReference: true
			}
		]
	},
	{
		name: "CatchEvent",
		isAbstract: true,
		superClass: [
			"Event"
		],
		properties: [
			{
				name: "parallelMultiple",
				isAttr: true,
				type: "Boolean",
				"default": false
			},
			{
				name: "dataOutputs",
				type: "DataOutput",
				isMany: true
			},
			{
				name: "dataOutputAssociations",
				type: "DataOutputAssociation",
				isMany: true
			},
			{
				name: "outputSet",
				type: "OutputSet"
			},
			{
				name: "eventDefinitions",
				type: "EventDefinition",
				isMany: true
			},
			{
				name: "eventDefinitionRef",
				type: "EventDefinition",
				isMany: true,
				isReference: true
			}
		]
	},
	{
		name: "BoundaryEvent",
		superClass: [
			"CatchEvent"
		],
		properties: [
			{
				name: "cancelActivity",
				"default": true,
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "attachedToRef",
				type: "Activity",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "EventDefinition",
		isAbstract: true,
		superClass: [
			"RootElement"
		]
	},
	{
		name: "CancelEventDefinition",
		superClass: [
			"EventDefinition"
		]
	},
	{
		name: "ErrorEventDefinition",
		superClass: [
			"EventDefinition"
		],
		properties: [
			{
				name: "errorRef",
				type: "Error",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "TerminateEventDefinition",
		superClass: [
			"EventDefinition"
		]
	},
	{
		name: "EscalationEventDefinition",
		superClass: [
			"EventDefinition"
		],
		properties: [
			{
				name: "escalationRef",
				type: "Escalation",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "Escalation",
		properties: [
			{
				name: "structureRef",
				type: "ItemDefinition",
				isAttr: true,
				isReference: true
			},
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "escalationCode",
				isAttr: true,
				type: "String"
			}
		],
		superClass: [
			"RootElement"
		]
	},
	{
		name: "CompensateEventDefinition",
		superClass: [
			"EventDefinition"
		],
		properties: [
			{
				name: "waitForCompletion",
				isAttr: true,
				type: "Boolean",
				"default": true
			},
			{
				name: "activityRef",
				type: "Activity",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "TimerEventDefinition",
		superClass: [
			"EventDefinition"
		],
		properties: [
			{
				name: "timeDate",
				type: "Expression",
				xml: {
					serialize: "xsi:type"
				}
			},
			{
				name: "timeCycle",
				type: "Expression",
				xml: {
					serialize: "xsi:type"
				}
			},
			{
				name: "timeDuration",
				type: "Expression",
				xml: {
					serialize: "xsi:type"
				}
			}
		]
	},
	{
		name: "LinkEventDefinition",
		superClass: [
			"EventDefinition"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "target",
				type: "LinkEventDefinition",
				isAttr: true,
				isReference: true
			},
			{
				name: "source",
				type: "LinkEventDefinition",
				isMany: true,
				isReference: true
			}
		]
	},
	{
		name: "MessageEventDefinition",
		superClass: [
			"EventDefinition"
		],
		properties: [
			{
				name: "messageRef",
				type: "Message",
				isAttr: true,
				isReference: true
			},
			{
				name: "operationRef",
				type: "Operation",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "ConditionalEventDefinition",
		superClass: [
			"EventDefinition"
		],
		properties: [
			{
				name: "condition",
				type: "Expression",
				xml: {
					serialize: "xsi:type"
				}
			}
		]
	},
	{
		name: "SignalEventDefinition",
		superClass: [
			"EventDefinition"
		],
		properties: [
			{
				name: "signalRef",
				type: "Signal",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "Signal",
		superClass: [
			"RootElement"
		],
		properties: [
			{
				name: "structureRef",
				type: "ItemDefinition",
				isAttr: true,
				isReference: true
			},
			{
				name: "name",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "ImplicitThrowEvent",
		superClass: [
			"ThrowEvent"
		]
	},
	{
		name: "DataState",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "ItemAwareElement",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "itemSubjectRef",
				type: "ItemDefinition",
				isAttr: true,
				isReference: true
			},
			{
				name: "dataState",
				type: "DataState"
			}
		]
	},
	{
		name: "DataAssociation",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "sourceRef",
				type: "ItemAwareElement",
				isMany: true,
				isReference: true
			},
			{
				name: "targetRef",
				type: "ItemAwareElement",
				isReference: true
			},
			{
				name: "transformation",
				type: "FormalExpression",
				xml: {
					serialize: "property"
				}
			},
			{
				name: "assignment",
				type: "Assignment",
				isMany: true
			}
		]
	},
	{
		name: "DataInput",
		superClass: [
			"ItemAwareElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "isCollection",
				"default": false,
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "inputSetRef",
				type: "InputSet",
				isMany: true,
				isVirtual: true,
				isReference: true
			},
			{
				name: "inputSetWithOptional",
				type: "InputSet",
				isMany: true,
				isVirtual: true,
				isReference: true
			},
			{
				name: "inputSetWithWhileExecuting",
				type: "InputSet",
				isMany: true,
				isVirtual: true,
				isReference: true
			}
		]
	},
	{
		name: "DataOutput",
		superClass: [
			"ItemAwareElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "isCollection",
				"default": false,
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "outputSetRef",
				type: "OutputSet",
				isMany: true,
				isVirtual: true,
				isReference: true
			},
			{
				name: "outputSetWithOptional",
				type: "OutputSet",
				isMany: true,
				isVirtual: true,
				isReference: true
			},
			{
				name: "outputSetWithWhileExecuting",
				type: "OutputSet",
				isMany: true,
				isVirtual: true,
				isReference: true
			}
		]
	},
	{
		name: "InputSet",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "dataInputRefs",
				type: "DataInput",
				isMany: true,
				isReference: true
			},
			{
				name: "optionalInputRefs",
				type: "DataInput",
				isMany: true,
				isReference: true
			},
			{
				name: "whileExecutingInputRefs",
				type: "DataInput",
				isMany: true,
				isReference: true
			},
			{
				name: "outputSetRefs",
				type: "OutputSet",
				isMany: true,
				isReference: true
			}
		]
	},
	{
		name: "OutputSet",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "dataOutputRefs",
				type: "DataOutput",
				isMany: true,
				isReference: true
			},
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "inputSetRefs",
				type: "InputSet",
				isMany: true,
				isReference: true
			},
			{
				name: "optionalOutputRefs",
				type: "DataOutput",
				isMany: true,
				isReference: true
			},
			{
				name: "whileExecutingOutputRefs",
				type: "DataOutput",
				isMany: true,
				isReference: true
			}
		]
	},
	{
		name: "Property",
		superClass: [
			"ItemAwareElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "DataInputAssociation",
		superClass: [
			"DataAssociation"
		]
	},
	{
		name: "DataOutputAssociation",
		superClass: [
			"DataAssociation"
		]
	},
	{
		name: "InputOutputSpecification",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "dataInputs",
				type: "DataInput",
				isMany: true
			},
			{
				name: "dataOutputs",
				type: "DataOutput",
				isMany: true
			},
			{
				name: "inputSets",
				type: "InputSet",
				isMany: true
			},
			{
				name: "outputSets",
				type: "OutputSet",
				isMany: true
			}
		]
	},
	{
		name: "DataObject",
		superClass: [
			"FlowElement",
			"ItemAwareElement"
		],
		properties: [
			{
				name: "isCollection",
				"default": false,
				isAttr: true,
				type: "Boolean"
			}
		]
	},
	{
		name: "InputOutputBinding",
		properties: [
			{
				name: "inputDataRef",
				type: "InputSet",
				isAttr: true,
				isReference: true
			},
			{
				name: "outputDataRef",
				type: "OutputSet",
				isAttr: true,
				isReference: true
			},
			{
				name: "operationRef",
				type: "Operation",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "Assignment",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "from",
				type: "Expression",
				xml: {
					serialize: "xsi:type"
				}
			},
			{
				name: "to",
				type: "Expression",
				xml: {
					serialize: "xsi:type"
				}
			}
		]
	},
	{
		name: "DataStore",
		superClass: [
			"RootElement",
			"ItemAwareElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "capacity",
				isAttr: true,
				type: "Integer"
			},
			{
				name: "isUnlimited",
				"default": true,
				isAttr: true,
				type: "Boolean"
			}
		]
	},
	{
		name: "DataStoreReference",
		superClass: [
			"ItemAwareElement",
			"FlowElement"
		],
		properties: [
			{
				name: "dataStoreRef",
				type: "DataStore",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "DataObjectReference",
		superClass: [
			"ItemAwareElement",
			"FlowElement"
		],
		properties: [
			{
				name: "dataObjectRef",
				type: "DataObject",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "ConversationLink",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "sourceRef",
				type: "InteractionNode",
				isAttr: true,
				isReference: true
			},
			{
				name: "targetRef",
				type: "InteractionNode",
				isAttr: true,
				isReference: true
			},
			{
				name: "name",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "ConversationAssociation",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "innerConversationNodeRef",
				type: "ConversationNode",
				isAttr: true,
				isReference: true
			},
			{
				name: "outerConversationNodeRef",
				type: "ConversationNode",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "CallConversation",
		superClass: [
			"ConversationNode"
		],
		properties: [
			{
				name: "calledCollaborationRef",
				type: "Collaboration",
				isAttr: true,
				isReference: true
			},
			{
				name: "participantAssociations",
				type: "ParticipantAssociation",
				isMany: true
			}
		]
	},
	{
		name: "Conversation",
		superClass: [
			"ConversationNode"
		]
	},
	{
		name: "SubConversation",
		superClass: [
			"ConversationNode"
		],
		properties: [
			{
				name: "conversationNodes",
				type: "ConversationNode",
				isMany: true
			}
		]
	},
	{
		name: "ConversationNode",
		isAbstract: true,
		superClass: [
			"InteractionNode",
			"BaseElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "participantRef",
				type: "Participant",
				isMany: true,
				isReference: true
			},
			{
				name: "messageFlowRefs",
				type: "MessageFlow",
				isMany: true,
				isReference: true
			},
			{
				name: "correlationKeys",
				type: "CorrelationKey",
				isMany: true
			}
		]
	},
	{
		name: "GlobalConversation",
		superClass: [
			"Collaboration"
		]
	},
	{
		name: "PartnerEntity",
		superClass: [
			"RootElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "participantRef",
				type: "Participant",
				isMany: true,
				isReference: true
			}
		]
	},
	{
		name: "PartnerRole",
		superClass: [
			"RootElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "participantRef",
				type: "Participant",
				isMany: true,
				isReference: true
			}
		]
	},
	{
		name: "CorrelationProperty",
		superClass: [
			"RootElement"
		],
		properties: [
			{
				name: "correlationPropertyRetrievalExpression",
				type: "CorrelationPropertyRetrievalExpression",
				isMany: true
			},
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "type",
				type: "ItemDefinition",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "Error",
		superClass: [
			"RootElement"
		],
		properties: [
			{
				name: "structureRef",
				type: "ItemDefinition",
				isAttr: true,
				isReference: true
			},
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "errorCode",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "CorrelationKey",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "correlationPropertyRef",
				type: "CorrelationProperty",
				isMany: true,
				isReference: true
			},
			{
				name: "name",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "Expression",
		superClass: [
			"BaseElement"
		],
		isAbstract: false,
		properties: [
			{
				name: "body",
				isBody: true,
				type: "String"
			}
		]
	},
	{
		name: "FormalExpression",
		superClass: [
			"Expression"
		],
		properties: [
			{
				name: "language",
				isAttr: true,
				type: "String"
			},
			{
				name: "evaluatesToTypeRef",
				type: "ItemDefinition",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "Message",
		superClass: [
			"RootElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "itemRef",
				type: "ItemDefinition",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "ItemDefinition",
		superClass: [
			"RootElement"
		],
		properties: [
			{
				name: "itemKind",
				type: "ItemKind",
				isAttr: true
			},
			{
				name: "structureRef",
				isAttr: true,
				type: "String"
			},
			{
				name: "isCollection",
				"default": false,
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "import",
				type: "Import",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "FlowElement",
		isAbstract: true,
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "auditing",
				type: "Auditing"
			},
			{
				name: "monitoring",
				type: "Monitoring"
			},
			{
				name: "categoryValueRef",
				type: "CategoryValue",
				isMany: true,
				isReference: true
			}
		]
	},
	{
		name: "SequenceFlow",
		superClass: [
			"FlowElement"
		],
		properties: [
			{
				name: "isImmediate",
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "conditionExpression",
				type: "Expression",
				xml: {
					serialize: "xsi:type"
				}
			},
			{
				name: "sourceRef",
				type: "FlowNode",
				isAttr: true,
				isReference: true
			},
			{
				name: "targetRef",
				type: "FlowNode",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "FlowElementsContainer",
		isAbstract: true,
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "laneSets",
				type: "LaneSet",
				isMany: true
			},
			{
				name: "flowElements",
				type: "FlowElement",
				isMany: true
			}
		]
	},
	{
		name: "CallableElement",
		isAbstract: true,
		superClass: [
			"RootElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "ioSpecification",
				type: "InputOutputSpecification",
				xml: {
					serialize: "property"
				}
			},
			{
				name: "supportedInterfaceRef",
				type: "Interface",
				isMany: true,
				isReference: true
			},
			{
				name: "ioBinding",
				type: "InputOutputBinding",
				isMany: true,
				xml: {
					serialize: "property"
				}
			}
		]
	},
	{
		name: "FlowNode",
		isAbstract: true,
		superClass: [
			"FlowElement"
		],
		properties: [
			{
				name: "incoming",
				type: "SequenceFlow",
				isMany: true,
				isReference: true
			},
			{
				name: "outgoing",
				type: "SequenceFlow",
				isMany: true,
				isReference: true
			},
			{
				name: "lanes",
				type: "Lane",
				isMany: true,
				isVirtual: true,
				isReference: true
			}
		]
	},
	{
		name: "CorrelationPropertyRetrievalExpression",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "messagePath",
				type: "FormalExpression"
			},
			{
				name: "messageRef",
				type: "Message",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "CorrelationPropertyBinding",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "dataPath",
				type: "FormalExpression"
			},
			{
				name: "correlationPropertyRef",
				type: "CorrelationProperty",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "Resource",
		superClass: [
			"RootElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "resourceParameters",
				type: "ResourceParameter",
				isMany: true
			}
		]
	},
	{
		name: "ResourceParameter",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "isRequired",
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "type",
				type: "ItemDefinition",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "CorrelationSubscription",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "correlationKeyRef",
				type: "CorrelationKey",
				isAttr: true,
				isReference: true
			},
			{
				name: "correlationPropertyBinding",
				type: "CorrelationPropertyBinding",
				isMany: true
			}
		]
	},
	{
		name: "MessageFlow",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "sourceRef",
				type: "InteractionNode",
				isAttr: true,
				isReference: true
			},
			{
				name: "targetRef",
				type: "InteractionNode",
				isAttr: true,
				isReference: true
			},
			{
				name: "messageRef",
				type: "Message",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "MessageFlowAssociation",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "innerMessageFlowRef",
				type: "MessageFlow",
				isAttr: true,
				isReference: true
			},
			{
				name: "outerMessageFlowRef",
				type: "MessageFlow",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "InteractionNode",
		isAbstract: true,
		properties: [
			{
				name: "incomingConversationLinks",
				type: "ConversationLink",
				isMany: true,
				isVirtual: true,
				isReference: true
			},
			{
				name: "outgoingConversationLinks",
				type: "ConversationLink",
				isMany: true,
				isVirtual: true,
				isReference: true
			}
		]
	},
	{
		name: "Participant",
		superClass: [
			"InteractionNode",
			"BaseElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "interfaceRef",
				type: "Interface",
				isMany: true,
				isReference: true
			},
			{
				name: "participantMultiplicity",
				type: "ParticipantMultiplicity"
			},
			{
				name: "endPointRefs",
				type: "EndPoint",
				isMany: true,
				isReference: true
			},
			{
				name: "processRef",
				type: "Process",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "ParticipantAssociation",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "innerParticipantRef",
				type: "Participant",
				isAttr: true,
				isReference: true
			},
			{
				name: "outerParticipantRef",
				type: "Participant",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "ParticipantMultiplicity",
		properties: [
			{
				name: "minimum",
				"default": 0,
				isAttr: true,
				type: "Integer"
			},
			{
				name: "maximum",
				"default": 1,
				isAttr: true,
				type: "Integer"
			}
		],
		superClass: [
			"BaseElement"
		]
	},
	{
		name: "Collaboration",
		superClass: [
			"RootElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "isClosed",
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "participants",
				type: "Participant",
				isMany: true
			},
			{
				name: "messageFlows",
				type: "MessageFlow",
				isMany: true
			},
			{
				name: "artifacts",
				type: "Artifact",
				isMany: true
			},
			{
				name: "conversations",
				type: "ConversationNode",
				isMany: true
			},
			{
				name: "conversationAssociations",
				type: "ConversationAssociation"
			},
			{
				name: "participantAssociations",
				type: "ParticipantAssociation",
				isMany: true
			},
			{
				name: "messageFlowAssociations",
				type: "MessageFlowAssociation",
				isMany: true
			},
			{
				name: "correlationKeys",
				type: "CorrelationKey",
				isMany: true
			},
			{
				name: "choreographyRef",
				type: "Choreography",
				isMany: true,
				isReference: true
			},
			{
				name: "conversationLinks",
				type: "ConversationLink",
				isMany: true
			}
		]
	},
	{
		name: "ChoreographyActivity",
		isAbstract: true,
		superClass: [
			"FlowNode"
		],
		properties: [
			{
				name: "participantRef",
				type: "Participant",
				isMany: true,
				isReference: true
			},
			{
				name: "initiatingParticipantRef",
				type: "Participant",
				isAttr: true,
				isReference: true
			},
			{
				name: "correlationKeys",
				type: "CorrelationKey",
				isMany: true
			},
			{
				name: "loopType",
				type: "ChoreographyLoopType",
				"default": "None",
				isAttr: true
			}
		]
	},
	{
		name: "CallChoreography",
		superClass: [
			"ChoreographyActivity"
		],
		properties: [
			{
				name: "calledChoreographyRef",
				type: "Choreography",
				isAttr: true,
				isReference: true
			},
			{
				name: "participantAssociations",
				type: "ParticipantAssociation",
				isMany: true
			}
		]
	},
	{
		name: "SubChoreography",
		superClass: [
			"ChoreographyActivity",
			"FlowElementsContainer"
		],
		properties: [
			{
				name: "artifacts",
				type: "Artifact",
				isMany: true
			}
		]
	},
	{
		name: "ChoreographyTask",
		superClass: [
			"ChoreographyActivity"
		],
		properties: [
			{
				name: "messageFlowRef",
				type: "MessageFlow",
				isMany: true,
				isReference: true
			}
		]
	},
	{
		name: "Choreography",
		superClass: [
			"Collaboration",
			"FlowElementsContainer"
		]
	},
	{
		name: "GlobalChoreographyTask",
		superClass: [
			"Choreography"
		],
		properties: [
			{
				name: "initiatingParticipantRef",
				type: "Participant",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "TextAnnotation",
		superClass: [
			"Artifact"
		],
		properties: [
			{
				name: "text",
				type: "String"
			},
			{
				name: "textFormat",
				"default": "text/plain",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "Group",
		superClass: [
			"Artifact"
		],
		properties: [
			{
				name: "categoryValueRef",
				type: "CategoryValue",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "Association",
		superClass: [
			"Artifact"
		],
		properties: [
			{
				name: "associationDirection",
				type: "AssociationDirection",
				isAttr: true
			},
			{
				name: "sourceRef",
				type: "BaseElement",
				isAttr: true,
				isReference: true
			},
			{
				name: "targetRef",
				type: "BaseElement",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "Category",
		superClass: [
			"RootElement"
		],
		properties: [
			{
				name: "categoryValue",
				type: "CategoryValue",
				isMany: true
			},
			{
				name: "name",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "Artifact",
		isAbstract: true,
		superClass: [
			"BaseElement"
		]
	},
	{
		name: "CategoryValue",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "categorizedFlowElements",
				type: "FlowElement",
				isMany: true,
				isVirtual: true,
				isReference: true
			},
			{
				name: "value",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "Activity",
		isAbstract: true,
		superClass: [
			"FlowNode"
		],
		properties: [
			{
				name: "isForCompensation",
				"default": false,
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "default",
				type: "SequenceFlow",
				isAttr: true,
				isReference: true
			},
			{
				name: "ioSpecification",
				type: "InputOutputSpecification",
				xml: {
					serialize: "property"
				}
			},
			{
				name: "boundaryEventRefs",
				type: "BoundaryEvent",
				isMany: true,
				isReference: true
			},
			{
				name: "properties",
				type: "Property",
				isMany: true
			},
			{
				name: "dataInputAssociations",
				type: "DataInputAssociation",
				isMany: true
			},
			{
				name: "dataOutputAssociations",
				type: "DataOutputAssociation",
				isMany: true
			},
			{
				name: "startQuantity",
				"default": 1,
				isAttr: true,
				type: "Integer"
			},
			{
				name: "resources",
				type: "ResourceRole",
				isMany: true
			},
			{
				name: "completionQuantity",
				"default": 1,
				isAttr: true,
				type: "Integer"
			},
			{
				name: "loopCharacteristics",
				type: "LoopCharacteristics"
			}
		]
	},
	{
		name: "ServiceTask",
		superClass: [
			"Task"
		],
		properties: [
			{
				name: "implementation",
				isAttr: true,
				type: "String"
			},
			{
				name: "operationRef",
				type: "Operation",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "SubProcess",
		superClass: [
			"Activity",
			"FlowElementsContainer",
			"InteractionNode"
		],
		properties: [
			{
				name: "triggeredByEvent",
				"default": false,
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "artifacts",
				type: "Artifact",
				isMany: true
			}
		]
	},
	{
		name: "LoopCharacteristics",
		isAbstract: true,
		superClass: [
			"BaseElement"
		]
	},
	{
		name: "MultiInstanceLoopCharacteristics",
		superClass: [
			"LoopCharacteristics"
		],
		properties: [
			{
				name: "isSequential",
				"default": false,
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "behavior",
				type: "MultiInstanceBehavior",
				"default": "All",
				isAttr: true
			},
			{
				name: "loopCardinality",
				type: "Expression",
				xml: {
					serialize: "xsi:type"
				}
			},
			{
				name: "loopDataInputRef",
				type: "ItemAwareElement",
				isReference: true
			},
			{
				name: "loopDataOutputRef",
				type: "ItemAwareElement",
				isReference: true
			},
			{
				name: "inputDataItem",
				type: "DataInput",
				xml: {
					serialize: "property"
				}
			},
			{
				name: "outputDataItem",
				type: "DataOutput",
				xml: {
					serialize: "property"
				}
			},
			{
				name: "complexBehaviorDefinition",
				type: "ComplexBehaviorDefinition",
				isMany: true
			},
			{
				name: "completionCondition",
				type: "Expression",
				xml: {
					serialize: "xsi:type"
				}
			},
			{
				name: "oneBehaviorEventRef",
				type: "EventDefinition",
				isAttr: true,
				isReference: true
			},
			{
				name: "noneBehaviorEventRef",
				type: "EventDefinition",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "StandardLoopCharacteristics",
		superClass: [
			"LoopCharacteristics"
		],
		properties: [
			{
				name: "testBefore",
				"default": false,
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "loopCondition",
				type: "Expression",
				xml: {
					serialize: "xsi:type"
				}
			},
			{
				name: "loopMaximum",
				type: "Integer",
				isAttr: true
			}
		]
	},
	{
		name: "CallActivity",
		superClass: [
			"Activity"
		],
		properties: [
			{
				name: "calledElement",
				type: "String",
				isAttr: true
			}
		]
	},
	{
		name: "Task",
		superClass: [
			"Activity",
			"InteractionNode"
		]
	},
	{
		name: "SendTask",
		superClass: [
			"Task"
		],
		properties: [
			{
				name: "implementation",
				isAttr: true,
				type: "String"
			},
			{
				name: "operationRef",
				type: "Operation",
				isAttr: true,
				isReference: true
			},
			{
				name: "messageRef",
				type: "Message",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "ReceiveTask",
		superClass: [
			"Task"
		],
		properties: [
			{
				name: "implementation",
				isAttr: true,
				type: "String"
			},
			{
				name: "instantiate",
				"default": false,
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "operationRef",
				type: "Operation",
				isAttr: true,
				isReference: true
			},
			{
				name: "messageRef",
				type: "Message",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "ScriptTask",
		superClass: [
			"Task"
		],
		properties: [
			{
				name: "scriptFormat",
				isAttr: true,
				type: "String"
			},
			{
				name: "script",
				type: "String"
			}
		]
	},
	{
		name: "BusinessRuleTask",
		superClass: [
			"Task"
		],
		properties: [
			{
				name: "implementation",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "AdHocSubProcess",
		superClass: [
			"SubProcess"
		],
		properties: [
			{
				name: "completionCondition",
				type: "Expression",
				xml: {
					serialize: "xsi:type"
				}
			},
			{
				name: "ordering",
				type: "AdHocOrdering",
				isAttr: true
			},
			{
				name: "cancelRemainingInstances",
				"default": true,
				isAttr: true,
				type: "Boolean"
			}
		]
	},
	{
		name: "Transaction",
		superClass: [
			"SubProcess"
		],
		properties: [
			{
				name: "protocol",
				isAttr: true,
				type: "String"
			},
			{
				name: "method",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "GlobalScriptTask",
		superClass: [
			"GlobalTask"
		],
		properties: [
			{
				name: "scriptLanguage",
				isAttr: true,
				type: "String"
			},
			{
				name: "script",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "GlobalBusinessRuleTask",
		superClass: [
			"GlobalTask"
		],
		properties: [
			{
				name: "implementation",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "ComplexBehaviorDefinition",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "condition",
				type: "FormalExpression"
			},
			{
				name: "event",
				type: "ImplicitThrowEvent"
			}
		]
	},
	{
		name: "ResourceRole",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "resourceRef",
				type: "Resource",
				isReference: true
			},
			{
				name: "resourceParameterBindings",
				type: "ResourceParameterBinding",
				isMany: true
			},
			{
				name: "resourceAssignmentExpression",
				type: "ResourceAssignmentExpression"
			},
			{
				name: "name",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "ResourceParameterBinding",
		properties: [
			{
				name: "expression",
				type: "Expression",
				xml: {
					serialize: "xsi:type"
				}
			},
			{
				name: "parameterRef",
				type: "ResourceParameter",
				isAttr: true,
				isReference: true
			}
		],
		superClass: [
			"BaseElement"
		]
	},
	{
		name: "ResourceAssignmentExpression",
		properties: [
			{
				name: "expression",
				type: "Expression",
				xml: {
					serialize: "xsi:type"
				}
			}
		],
		superClass: [
			"BaseElement"
		]
	},
	{
		name: "Import",
		properties: [
			{
				name: "importType",
				isAttr: true,
				type: "String"
			},
			{
				name: "location",
				isAttr: true,
				type: "String"
			},
			{
				name: "namespace",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "Definitions",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "targetNamespace",
				isAttr: true,
				type: "String"
			},
			{
				name: "expressionLanguage",
				"default": "http://www.w3.org/1999/XPath",
				isAttr: true,
				type: "String"
			},
			{
				name: "typeLanguage",
				"default": "http://www.w3.org/2001/XMLSchema",
				isAttr: true,
				type: "String"
			},
			{
				name: "imports",
				type: "Import",
				isMany: true
			},
			{
				name: "extensions",
				type: "Extension",
				isMany: true
			},
			{
				name: "rootElements",
				type: "RootElement",
				isMany: true
			},
			{
				name: "diagrams",
				isMany: true,
				type: "bpmndi:BPMNDiagram"
			},
			{
				name: "exporter",
				isAttr: true,
				type: "String"
			},
			{
				name: "relationships",
				type: "Relationship",
				isMany: true
			},
			{
				name: "exporterVersion",
				isAttr: true,
				type: "String"
			}
		]
	}
];
var enumerations = [
	{
		name: "ProcessType",
		literalValues: [
			{
				name: "None"
			},
			{
				name: "Public"
			},
			{
				name: "Private"
			}
		]
	},
	{
		name: "GatewayDirection",
		literalValues: [
			{
				name: "Unspecified"
			},
			{
				name: "Converging"
			},
			{
				name: "Diverging"
			},
			{
				name: "Mixed"
			}
		]
	},
	{
		name: "EventBasedGatewayType",
		literalValues: [
			{
				name: "Parallel"
			},
			{
				name: "Exclusive"
			}
		]
	},
	{
		name: "RelationshipDirection",
		literalValues: [
			{
				name: "None"
			},
			{
				name: "Forward"
			},
			{
				name: "Backward"
			},
			{
				name: "Both"
			}
		]
	},
	{
		name: "ItemKind",
		literalValues: [
			{
				name: "Physical"
			},
			{
				name: "Information"
			}
		]
	},
	{
		name: "ChoreographyLoopType",
		literalValues: [
			{
				name: "None"
			},
			{
				name: "Standard"
			},
			{
				name: "MultiInstanceSequential"
			},
			{
				name: "MultiInstanceParallel"
			}
		]
	},
	{
		name: "AssociationDirection",
		literalValues: [
			{
				name: "None"
			},
			{
				name: "One"
			},
			{
				name: "Both"
			}
		]
	},
	{
		name: "MultiInstanceBehavior",
		literalValues: [
			{
				name: "None"
			},
			{
				name: "One"
			},
			{
				name: "All"
			},
			{
				name: "Complex"
			}
		]
	},
	{
		name: "AdHocOrdering",
		literalValues: [
			{
				name: "Parallel"
			},
			{
				name: "Sequential"
			}
		]
	}
];
var xml = {
	tagAlias: "lowerCase",
	typePrefix: "t"
};
var BpmnPackage = {
	name: name,
	uri: uri,
	prefix: prefix,
	associations: associations,
	types: types,
	enumerations: enumerations,
	xml: xml
};

var name$1 = "BPMNDI";
var uri$1 = "http://www.omg.org/spec/BPMN/20100524/DI";
var prefix$1 = "bpmndi";
var types$1 = [
	{
		name: "BPMNDiagram",
		properties: [
			{
				name: "plane",
				type: "BPMNPlane",
				redefines: "di:Diagram#rootElement"
			},
			{
				name: "labelStyle",
				type: "BPMNLabelStyle",
				isMany: true
			}
		],
		superClass: [
			"di:Diagram"
		]
	},
	{
		name: "BPMNPlane",
		properties: [
			{
				name: "bpmnElement",
				isAttr: true,
				isReference: true,
				type: "bpmn:BaseElement",
				redefines: "di:DiagramElement#modelElement"
			}
		],
		superClass: [
			"di:Plane"
		]
	},
	{
		name: "BPMNShape",
		properties: [
			{
				name: "bpmnElement",
				isAttr: true,
				isReference: true,
				type: "bpmn:BaseElement",
				redefines: "di:DiagramElement#modelElement"
			},
			{
				name: "isHorizontal",
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "isExpanded",
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "isMarkerVisible",
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "label",
				type: "BPMNLabel"
			},
			{
				name: "isMessageVisible",
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "participantBandKind",
				type: "ParticipantBandKind",
				isAttr: true
			},
			{
				name: "choreographyActivityShape",
				type: "BPMNShape",
				isAttr: true,
				isReference: true
			}
		],
		superClass: [
			"di:LabeledShape"
		]
	},
	{
		name: "BPMNEdge",
		properties: [
			{
				name: "label",
				type: "BPMNLabel"
			},
			{
				name: "bpmnElement",
				isAttr: true,
				isReference: true,
				type: "bpmn:BaseElement",
				redefines: "di:DiagramElement#modelElement"
			},
			{
				name: "sourceElement",
				isAttr: true,
				isReference: true,
				type: "di:DiagramElement",
				redefines: "di:Edge#source"
			},
			{
				name: "targetElement",
				isAttr: true,
				isReference: true,
				type: "di:DiagramElement",
				redefines: "di:Edge#target"
			},
			{
				name: "messageVisibleKind",
				type: "MessageVisibleKind",
				isAttr: true,
				"default": "initiating"
			}
		],
		superClass: [
			"di:LabeledEdge"
		]
	},
	{
		name: "BPMNLabel",
		properties: [
			{
				name: "labelStyle",
				type: "BPMNLabelStyle",
				isAttr: true,
				isReference: true,
				redefines: "di:DiagramElement#style"
			}
		],
		superClass: [
			"di:Label"
		]
	},
	{
		name: "BPMNLabelStyle",
		properties: [
			{
				name: "font",
				type: "dc:Font"
			}
		],
		superClass: [
			"di:Style"
		]
	}
];
var enumerations$1 = [
	{
		name: "ParticipantBandKind",
		literalValues: [
			{
				name: "top_initiating"
			},
			{
				name: "middle_initiating"
			},
			{
				name: "bottom_initiating"
			},
			{
				name: "top_non_initiating"
			},
			{
				name: "middle_non_initiating"
			},
			{
				name: "bottom_non_initiating"
			}
		]
	},
	{
		name: "MessageVisibleKind",
		literalValues: [
			{
				name: "initiating"
			},
			{
				name: "non_initiating"
			}
		]
	}
];
var associations$1 = [
];
var BpmnDiPackage = {
	name: name$1,
	uri: uri$1,
	prefix: prefix$1,
	types: types$1,
	enumerations: enumerations$1,
	associations: associations$1
};

var name$2 = "DC";
var uri$2 = "http://www.omg.org/spec/DD/20100524/DC";
var prefix$2 = "dc";
var types$2 = [
	{
		name: "Boolean"
	},
	{
		name: "Integer"
	},
	{
		name: "Real"
	},
	{
		name: "String"
	},
	{
		name: "Font",
		properties: [
			{
				name: "name",
				type: "String",
				isAttr: true
			},
			{
				name: "size",
				type: "Real",
				isAttr: true
			},
			{
				name: "isBold",
				type: "Boolean",
				isAttr: true
			},
			{
				name: "isItalic",
				type: "Boolean",
				isAttr: true
			},
			{
				name: "isUnderline",
				type: "Boolean",
				isAttr: true
			},
			{
				name: "isStrikeThrough",
				type: "Boolean",
				isAttr: true
			}
		]
	},
	{
		name: "Point",
		properties: [
			{
				name: "x",
				type: "Real",
				"default": "0",
				isAttr: true
			},
			{
				name: "y",
				type: "Real",
				"default": "0",
				isAttr: true
			}
		]
	},
	{
		name: "Bounds",
		properties: [
			{
				name: "x",
				type: "Real",
				"default": "0",
				isAttr: true
			},
			{
				name: "y",
				type: "Real",
				"default": "0",
				isAttr: true
			},
			{
				name: "width",
				type: "Real",
				isAttr: true
			},
			{
				name: "height",
				type: "Real",
				isAttr: true
			}
		]
	}
];
var associations$2 = [
];
var DcPackage = {
	name: name$2,
	uri: uri$2,
	prefix: prefix$2,
	types: types$2,
	associations: associations$2
};

var name$3 = "DI";
var uri$3 = "http://www.omg.org/spec/DD/20100524/DI";
var prefix$3 = "di";
var types$3 = [
	{
		name: "DiagramElement",
		isAbstract: true,
		properties: [
			{
				name: "id",
				isAttr: true,
				isId: true,
				type: "String"
			},
			{
				name: "extension",
				type: "Extension"
			},
			{
				name: "owningDiagram",
				type: "Diagram",
				isReadOnly: true,
				isVirtual: true,
				isReference: true
			},
			{
				name: "owningElement",
				type: "DiagramElement",
				isReadOnly: true,
				isVirtual: true,
				isReference: true
			},
			{
				name: "modelElement",
				isReadOnly: true,
				isVirtual: true,
				isReference: true,
				type: "Element"
			},
			{
				name: "style",
				type: "Style",
				isReadOnly: true,
				isVirtual: true,
				isReference: true
			},
			{
				name: "ownedElement",
				type: "DiagramElement",
				isReadOnly: true,
				isMany: true,
				isVirtual: true
			}
		]
	},
	{
		name: "Node",
		isAbstract: true,
		superClass: [
			"DiagramElement"
		]
	},
	{
		name: "Edge",
		isAbstract: true,
		superClass: [
			"DiagramElement"
		],
		properties: [
			{
				name: "source",
				type: "DiagramElement",
				isReadOnly: true,
				isVirtual: true,
				isReference: true
			},
			{
				name: "target",
				type: "DiagramElement",
				isReadOnly: true,
				isVirtual: true,
				isReference: true
			},
			{
				name: "waypoint",
				isUnique: false,
				isMany: true,
				type: "dc:Point",
				xml: {
					serialize: "xsi:type"
				}
			}
		]
	},
	{
		name: "Diagram",
		isAbstract: true,
		properties: [
			{
				name: "id",
				isAttr: true,
				isId: true,
				type: "String"
			},
			{
				name: "rootElement",
				type: "DiagramElement",
				isReadOnly: true,
				isVirtual: true
			},
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "documentation",
				isAttr: true,
				type: "String"
			},
			{
				name: "resolution",
				isAttr: true,
				type: "Real"
			},
			{
				name: "ownedStyle",
				type: "Style",
				isReadOnly: true,
				isMany: true,
				isVirtual: true
			}
		]
	},
	{
		name: "Shape",
		isAbstract: true,
		superClass: [
			"Node"
		],
		properties: [
			{
				name: "bounds",
				type: "dc:Bounds"
			}
		]
	},
	{
		name: "Plane",
		isAbstract: true,
		superClass: [
			"Node"
		],
		properties: [
			{
				name: "planeElement",
				type: "DiagramElement",
				subsettedProperty: "DiagramElement-ownedElement",
				isMany: true
			}
		]
	},
	{
		name: "LabeledEdge",
		isAbstract: true,
		superClass: [
			"Edge"
		],
		properties: [
			{
				name: "ownedLabel",
				type: "Label",
				isReadOnly: true,
				subsettedProperty: "DiagramElement-ownedElement",
				isMany: true,
				isVirtual: true
			}
		]
	},
	{
		name: "LabeledShape",
		isAbstract: true,
		superClass: [
			"Shape"
		],
		properties: [
			{
				name: "ownedLabel",
				type: "Label",
				isReadOnly: true,
				subsettedProperty: "DiagramElement-ownedElement",
				isMany: true,
				isVirtual: true
			}
		]
	},
	{
		name: "Label",
		isAbstract: true,
		superClass: [
			"Node"
		],
		properties: [
			{
				name: "bounds",
				type: "dc:Bounds"
			}
		]
	},
	{
		name: "Style",
		isAbstract: true,
		properties: [
			{
				name: "id",
				isAttr: true,
				isId: true,
				type: "String"
			}
		]
	},
	{
		name: "Extension",
		properties: [
			{
				name: "values",
				isMany: true,
				type: "Element"
			}
		]
	}
];
var associations$3 = [
];
var xml$1 = {
	tagAlias: "lowerCase"
};
var DiPackage = {
	name: name$3,
	uri: uri$3,
	prefix: prefix$3,
	types: types$3,
	associations: associations$3,
	xml: xml$1
};

var name$4 = "bpmn.io colors for BPMN";
var uri$4 = "http://bpmn.io/schema/bpmn/biocolor/1.0";
var prefix$4 = "bioc";
var types$4 = [
	{
		name: "ColoredShape",
		"extends": [
			"bpmndi:BPMNShape"
		],
		properties: [
			{
				name: "stroke",
				isAttr: true,
				type: "String"
			},
			{
				name: "fill",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "ColoredEdge",
		"extends": [
			"bpmndi:BPMNEdge"
		],
		properties: [
			{
				name: "stroke",
				isAttr: true,
				type: "String"
			},
			{
				name: "fill",
				isAttr: true,
				type: "String"
			}
		]
	}
];
var enumerations$2 = [
];
var associations$4 = [
];
var BiocPackage = {
	name: name$4,
	uri: uri$4,
	prefix: prefix$4,
	types: types$4,
	enumerations: enumerations$2,
	associations: associations$4
};

var packages = {
  bpmn: BpmnPackage,
  bpmndi: BpmnDiPackage,
  dc: DcPackage,
  di: DiPackage,
  bioc: BiocPackage
};

function simple(additionalPackages, options) {
  var pks = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({}, packages, additionalPackages);

  return new BpmnModdle(pks, options);
}

/* harmony default export */ __webpack_exports__["default"] = (simple);


/***/ }),

/***/ "./node_modules/bpmn-js/node_modules/moddle-xml/dist/index.esm.js":
/*!************************************************************************!*\
  !*** ./node_modules/bpmn-js/node_modules/moddle-xml/dist/index.esm.js ***!
  \************************************************************************/
/*! exports provided: Reader, Writer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Reader", function() { return Reader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Writer", function() { return Writer; });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var saxen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! saxen */ "./node_modules/bpmn-js/node_modules/saxen/dist/index.esm.js");
/* harmony import */ var moddle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! moddle */ "./node_modules/moddle/dist/index.esm.js");




function hasLowerCaseAlias(pkg) {
  return pkg.xml && pkg.xml.tagAlias === 'lowerCase';
}

var DEFAULT_NS_MAP = {
  'xsi': 'http://www.w3.org/2001/XMLSchema-instance'
};

var XSI_TYPE = 'xsi:type';

function serializeFormat(element) {
  return element.xml && element.xml.serialize;
}

function serializeAsType(element) {
  return serializeFormat(element) === XSI_TYPE;
}

function serializeAsProperty(element) {
  return serializeFormat(element) === 'property';
}

function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function aliasToName(aliasNs, pkg) {

  if (!hasLowerCaseAlias(pkg)) {
    return aliasNs.name;
  }

  return aliasNs.prefix + ':' + capitalize(aliasNs.localName);
}

function prefixedToName(nameNs, pkg) {

  var name = nameNs.name,
      localName = nameNs.localName;

  var typePrefix = pkg.xml && pkg.xml.typePrefix;

  if (typePrefix && localName.indexOf(typePrefix) === 0) {
    return nameNs.prefix + ':' + localName.slice(typePrefix.length);
  } else {
    return name;
  }
}

function normalizeXsiTypeName(name, model) {

  var nameNs = Object(moddle__WEBPACK_IMPORTED_MODULE_2__["parseNameNS"])(name);
  var pkg = model.getPackage(nameNs.prefix);

  return prefixedToName(nameNs, pkg);
}

function error(message) {
  return new Error(message);
}

/**
 * Get the moddle descriptor for a given instance or type.
 *
 * @param  {ModdleElement|Function} element
 *
 * @return {Object} the moddle descriptor
 */
function getModdleDescriptor(element) {
  return element.$descriptor;
}

function defer(fn) {
  setTimeout(fn, 0);
}

/**
 * A parse context.
 *
 * @class
 *
 * @param {Object} options
 * @param {ElementHandler} options.rootHandler the root handler for parsing a document
 * @param {boolean} [options.lax=false] whether or not to ignore invalid elements
 */
function Context(options) {

  /**
   * @property {ElementHandler} rootHandler
   */

  /**
   * @property {Boolean} lax
   */

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])(this, options);

  this.elementsById = {};
  this.references = [];
  this.warnings = [];

  /**
   * Add an unresolved reference.
   *
   * @param {Object} reference
   */
  this.addReference = function(reference) {
    this.references.push(reference);
  };

  /**
   * Add a processed element.
   *
   * @param {ModdleElement} element
   */
  this.addElement = function(element) {

    if (!element) {
      throw error('expected element');
    }

    var elementsById = this.elementsById;

    var descriptor = getModdleDescriptor(element);

    var idProperty = descriptor.idProperty,
        id;

    if (idProperty) {
      id = element.get(idProperty.name);

      if (id) {
        // for QName validation as per http://www.w3.org/TR/REC-xml/#NT-NameChar
        if (!/^([a-z][\w-.]*:)?[a-z_][\w-.]*$/i.test(id)) {
          throw new Error('illegal ID <' + id + '>');
        }

        if (elementsById[id]) {
          throw error('duplicate ID <' + id + '>');
        }

        elementsById[id] = element;
      }
    }
  };

  /**
   * Add an import warning.
   *
   * @param {Object} warning
   * @param {String} warning.message
   * @param {Error} [warning.error]
   */
  this.addWarning = function(warning) {
    this.warnings.push(warning);
  };
}

function BaseHandler() {}

BaseHandler.prototype.handleEnd = function() {};
BaseHandler.prototype.handleText = function() {};
BaseHandler.prototype.handleNode = function() {};


/**
 * A simple pass through handler that does nothing except for
 * ignoring all input it receives.
 *
 * This is used to ignore unknown elements and
 * attributes.
 */
function NoopHandler() { }

NoopHandler.prototype = Object.create(BaseHandler.prototype);

NoopHandler.prototype.handleNode = function() {
  return this;
};

function BodyHandler() {}

BodyHandler.prototype = Object.create(BaseHandler.prototype);

BodyHandler.prototype.handleText = function(text) {
  this.body = (this.body || '') + text;
};

function ReferenceHandler(property, context) {
  this.property = property;
  this.context = context;
}

ReferenceHandler.prototype = Object.create(BodyHandler.prototype);

ReferenceHandler.prototype.handleNode = function(node) {

  if (this.element) {
    throw error('expected no sub nodes');
  } else {
    this.element = this.createReference(node);
  }

  return this;
};

ReferenceHandler.prototype.handleEnd = function() {
  this.element.id = this.body;
};

ReferenceHandler.prototype.createReference = function(node) {
  return {
    property: this.property.ns.name,
    id: ''
  };
};

function ValueHandler(propertyDesc, element) {
  this.element = element;
  this.propertyDesc = propertyDesc;
}

ValueHandler.prototype = Object.create(BodyHandler.prototype);

ValueHandler.prototype.handleEnd = function() {

  var value = this.body || '',
      element = this.element,
      propertyDesc = this.propertyDesc;

  value = Object(moddle__WEBPACK_IMPORTED_MODULE_2__["coerceType"])(propertyDesc.type, value);

  if (propertyDesc.isMany) {
    element.get(propertyDesc.name).push(value);
  } else {
    element.set(propertyDesc.name, value);
  }
};


function BaseElementHandler() {}

BaseElementHandler.prototype = Object.create(BodyHandler.prototype);

BaseElementHandler.prototype.handleNode = function(node) {
  var parser = this,
      element = this.element;

  if (!element) {
    element = this.element = this.createElement(node);

    this.context.addElement(element);
  } else {
    parser = this.handleChild(node);
  }

  return parser;
};

/**
 * @class Reader.ElementHandler
 *
 */
function ElementHandler(model, typeName, context) {
  this.model = model;
  this.type = model.getType(typeName);
  this.context = context;
}

ElementHandler.prototype = Object.create(BaseElementHandler.prototype);

ElementHandler.prototype.addReference = function(reference) {
  this.context.addReference(reference);
};

ElementHandler.prototype.handleText = function(text) {

  var element = this.element,
      descriptor = getModdleDescriptor(element),
      bodyProperty = descriptor.bodyProperty;

  if (!bodyProperty) {
    throw error('unexpected body text <' + text + '>');
  }

  BodyHandler.prototype.handleText.call(this, text);
};

ElementHandler.prototype.handleEnd = function() {

  var value = this.body,
      element = this.element,
      descriptor = getModdleDescriptor(element),
      bodyProperty = descriptor.bodyProperty;

  if (bodyProperty && value !== undefined) {
    value = Object(moddle__WEBPACK_IMPORTED_MODULE_2__["coerceType"])(bodyProperty.type, value);
    element.set(bodyProperty.name, value);
  }
};

/**
 * Create an instance of the model from the given node.
 *
 * @param  {Element} node the xml node
 */
ElementHandler.prototype.createElement = function(node) {
  var attributes = node.attributes,
      Type = this.type,
      descriptor = getModdleDescriptor(Type),
      context = this.context,
      instance = new Type({}),
      model = this.model,
      propNameNs;

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(attributes, function(value, name) {

    var prop = descriptor.propertiesByName[name],
        values;

    if (prop && prop.isReference) {

      if (!prop.isMany) {
        context.addReference({
          element: instance,
          property: prop.ns.name,
          id: value
        });
      } else {
        // IDREFS: parse references as whitespace-separated list
        values = value.split(' ');

        Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(values, function(v) {
          context.addReference({
            element: instance,
            property: prop.ns.name,
            id: v
          });
        });
      }

    } else {
      if (prop) {
        value = Object(moddle__WEBPACK_IMPORTED_MODULE_2__["coerceType"])(prop.type, value);
      } else
      if (name !== 'xmlns') {
        propNameNs = Object(moddle__WEBPACK_IMPORTED_MODULE_2__["parseNameNS"])(name, descriptor.ns.prefix);

        // check whether attribute is defined in a well-known namespace
        // if that is the case we emit a warning to indicate potential misuse
        if (model.getPackage(propNameNs.prefix)) {

          context.addWarning({
            message: 'unknown attribute <' + name + '>',
            element: instance,
            property: name,
            value: value
          });
        }
      }

      instance.set(name, value);
    }
  });

  return instance;
};

ElementHandler.prototype.getPropertyForNode = function(node) {

  var name = node.name;
  var nameNs = Object(moddle__WEBPACK_IMPORTED_MODULE_2__["parseNameNS"])(name);

  var type = this.type,
      model = this.model,
      descriptor = getModdleDescriptor(type);

  var propertyName = nameNs.name,
      property = descriptor.propertiesByName[propertyName],
      elementTypeName,
      elementType;

  // search for properties by name first

  if (property && !property.isAttr) {

    if (serializeAsType(property)) {
      elementTypeName = node.attributes[XSI_TYPE];

      // xsi type is optional, if it does not exists the
      // default type is assumed
      if (elementTypeName) {

        // take possible type prefixes from XML
        // into account, i.e.: xsi:type="t{ActualType}"
        elementTypeName = normalizeXsiTypeName(elementTypeName, model);

        elementType = model.getType(elementTypeName);

        return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({}, property, {
          effectiveType: getModdleDescriptor(elementType).name
        });
      }
    }

    // search for properties by name first
    return property;
  }

  var pkg = model.getPackage(nameNs.prefix);

  if (pkg) {
    elementTypeName = aliasToName(nameNs, pkg);
    elementType = model.getType(elementTypeName);

    // search for collection members later
    property = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["find"])(descriptor.properties, function(p) {
      return !p.isVirtual && !p.isReference && !p.isAttribute && elementType.hasType(p.type);
    });

    if (property) {
      return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({}, property, {
        effectiveType: getModdleDescriptor(elementType).name
      });
    }
  } else {
    // parse unknown element (maybe extension)
    property = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["find"])(descriptor.properties, function(p) {
      return !p.isReference && !p.isAttribute && p.type === 'Element';
    });

    if (property) {
      return property;
    }
  }

  throw error('unrecognized element <' + nameNs.name + '>');
};

ElementHandler.prototype.toString = function() {
  return 'ElementDescriptor[' + getModdleDescriptor(this.type).name + ']';
};

ElementHandler.prototype.valueHandler = function(propertyDesc, element) {
  return new ValueHandler(propertyDesc, element);
};

ElementHandler.prototype.referenceHandler = function(propertyDesc) {
  return new ReferenceHandler(propertyDesc, this.context);
};

ElementHandler.prototype.handler = function(type) {
  if (type === 'Element') {
    return new GenericElementHandler(this.model, type, this.context);
  } else {
    return new ElementHandler(this.model, type, this.context);
  }
};

/**
 * Handle the child element parsing
 *
 * @param  {Element} node the xml node
 */
ElementHandler.prototype.handleChild = function(node) {
  var propertyDesc, type, element, childHandler;

  propertyDesc = this.getPropertyForNode(node);
  element = this.element;

  type = propertyDesc.effectiveType || propertyDesc.type;

  if (Object(moddle__WEBPACK_IMPORTED_MODULE_2__["isSimpleType"])(type)) {
    return this.valueHandler(propertyDesc, element);
  }

  if (propertyDesc.isReference) {
    childHandler = this.referenceHandler(propertyDesc).handleNode(node);
  } else {
    childHandler = this.handler(type).handleNode(node);
  }

  var newElement = childHandler.element;

  // child handles may decide to skip elements
  // by not returning anything
  if (newElement !== undefined) {

    if (propertyDesc.isMany) {
      element.get(propertyDesc.name).push(newElement);
    } else {
      element.set(propertyDesc.name, newElement);
    }

    if (propertyDesc.isReference) {
      Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])(newElement, {
        element: element
      });

      this.context.addReference(newElement);
    } else {
      // establish child -> parent relationship
      newElement.$parent = element;
    }
  }

  return childHandler;
};

/**
 * An element handler that performs special validation
 * to ensure the node it gets initialized with matches
 * the handlers type (namespace wise).
 *
 * @param {Moddle} model
 * @param {String} typeName
 * @param {Context} context
 */
function RootElementHandler(model, typeName, context) {
  ElementHandler.call(this, model, typeName, context);
}

RootElementHandler.prototype = Object.create(ElementHandler.prototype);

RootElementHandler.prototype.createElement = function(node) {

  var name = node.name,
      nameNs = Object(moddle__WEBPACK_IMPORTED_MODULE_2__["parseNameNS"])(name),
      model = this.model,
      type = this.type,
      pkg = model.getPackage(nameNs.prefix),
      typeName = pkg && aliasToName(nameNs, pkg) || name;

  // verify the correct namespace if we parse
  // the first element in the handler tree
  //
  // this ensures we don't mistakenly import wrong namespace elements
  if (!type.hasType(typeName)) {
    throw error('unexpected element <' + node.originalName + '>');
  }

  return ElementHandler.prototype.createElement.call(this, node);
};


function GenericElementHandler(model, typeName, context) {
  this.model = model;
  this.context = context;
}

GenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);

GenericElementHandler.prototype.createElement = function(node) {

  var name = node.name,
      ns = Object(moddle__WEBPACK_IMPORTED_MODULE_2__["parseNameNS"])(name),
      prefix = ns.prefix,
      uri = node.ns[prefix + '$uri'],
      attributes = node.attributes;

  return this.model.createAny(name, uri, attributes);
};

GenericElementHandler.prototype.handleChild = function(node) {

  var handler = new GenericElementHandler(this.model, 'Element', this.context).handleNode(node),
      element = this.element;

  var newElement = handler.element,
      children;

  if (newElement !== undefined) {
    children = element.$children = element.$children || [];
    children.push(newElement);

    // establish child -> parent relationship
    newElement.$parent = element;
  }

  return handler;
};

GenericElementHandler.prototype.handleEnd = function() {
  if (this.body) {
    this.element.$body = this.body;
  }
};

/**
 * A reader for a meta-model
 *
 * @param {Object} options
 * @param {Model} options.model used to read xml files
 * @param {Boolean} options.lax whether to make parse errors warnings
 */
function Reader(options) {

  if (options instanceof moddle__WEBPACK_IMPORTED_MODULE_2__["Moddle"]) {
    options = {
      model: options
    };
  }

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])(this, { lax: false }, options);
}


/**
 * Parse the given XML into a moddle document tree.
 *
 * @param {String} xml
 * @param {ElementHandler|Object} options or rootHandler
 * @param  {Function} done
 */
Reader.prototype.fromXML = function(xml, options, done) {

  var rootHandler = options.rootHandler;

  if (options instanceof ElementHandler) {
    // root handler passed via (xml, { rootHandler: ElementHandler }, ...)
    rootHandler = options;
    options = {};
  } else {
    if (typeof options === 'string') {
      // rootHandler passed via (xml, 'someString', ...)
      rootHandler = this.handler(options);
      options = {};
    } else if (typeof rootHandler === 'string') {
      // rootHandler passed via (xml, { rootHandler: 'someString' }, ...)
      rootHandler = this.handler(rootHandler);
    }
  }

  var model = this.model,
      lax = this.lax;

  var context = new Context(Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({}, options, { rootHandler: rootHandler })),
      parser = new saxen__WEBPACK_IMPORTED_MODULE_1__["Parser"]({ proxy: true }),
      stack = createStack();

  rootHandler.context = context;

  // push root handler
  stack.push(rootHandler);


  /**
   * Handle error.
   *
   * @param  {Error} err
   * @param  {Function} getContext
   * @param  {boolean} lax
   *
   * @return {boolean} true if handled
   */
  function handleError(err, getContext, lax) {

    var ctx = getContext();

    var line = ctx.line,
        column = ctx.column,
        data = ctx.data;

    // we receive the full context data here,
    // for elements trim down the information
    // to the tag name, only
    if (data.charAt(0) === '<' && data.indexOf(' ') !== -1) {
      data = data.slice(0, data.indexOf(' ')) + '>';
    }

    var message =
      'unparsable content ' + (data ? data + ' ' : '') + 'detected\n\t' +
        'line: ' + line + '\n\t' +
        'column: ' + column + '\n\t' +
        'nested error: ' + err.message;

    if (lax) {
      context.addWarning({
        message: message,
        error: err
      });

      return true;
    } else {
      throw error(message);
    }
  }

  function handleWarning(err, getContext) {
    // just like handling errors in <lax=true> mode
    return handleError(err, getContext, true);
  }

  /**
   * Resolve collected references on parse end.
   */
  function resolveReferences() {

    var elementsById = context.elementsById;
    var references = context.references;

    var i, r;

    for (i = 0; (r = references[i]); i++) {
      var element = r.element;
      var reference = elementsById[r.id];
      var property = getModdleDescriptor(element).propertiesByName[r.property];

      if (!reference) {
        context.addWarning({
          message: 'unresolved reference <' + r.id + '>',
          element: r.element,
          property: r.property,
          value: r.id
        });
      }

      if (property.isMany) {
        var collection = element.get(property.name),
            idx = collection.indexOf(r);

        // we replace an existing place holder (idx != -1) or
        // append to the collection instead
        if (idx === -1) {
          idx = collection.length;
        }

        if (!reference) {
          // remove unresolvable reference
          collection.splice(idx, 1);
        } else {
          // add or update reference in collection
          collection[idx] = reference;
        }
      } else {
        element.set(property.name, reference);
      }
    }
  }

  function handleClose() {
    stack.pop().handleEnd();
  }

  var PREAMBLE_START_PATTERN = /^<\?xml /i;

  var ENCODING_PATTERN = / encoding="([^"]+)"/i;

  var UTF_8_PATTERN = /^utf-8$/i;

  function handleQuestion(question) {

    if (!PREAMBLE_START_PATTERN.test(question)) {
      return;
    }

    var match = ENCODING_PATTERN.exec(question);
    var encoding = match && match[1];

    if (!encoding || UTF_8_PATTERN.test(encoding)) {
      return;
    }

    context.addWarning({
      message:
        'unsupported document encoding <' + encoding + '>, ' +
        'falling back to UTF-8'
    });
  }

  function handleOpen(node, getContext) {
    var handler = stack.peek();

    try {
      stack.push(handler.handleNode(node));
    } catch (err) {

      if (handleError(err, getContext, lax)) {
        stack.push(new NoopHandler());
      }
    }
  }

  function handleCData(text, getContext) {

    try {
      stack.peek().handleText(text);
    } catch (err) {
      handleWarning(err, getContext);
    }
  }

  function handleText(text, getContext) {
    // strip whitespace only nodes, i.e. before
    // <!CDATA[ ... ]> sections and in between tags
    text = text.trim();

    if (!text) {
      return;
    }

    handleCData(text, getContext);
  }

  var uriMap = model.getPackages().reduce(function(uriMap, p) {
    uriMap[p.uri] = p.prefix;

    return uriMap;
  }, {});

  parser
    .ns(uriMap)
    .on('openTag', function(obj, decodeStr, selfClosing, getContext) {

      // gracefully handle unparsable attributes (attrs=false)
      var attrs = obj.attrs || {};

      var decodedAttrs = Object.keys(attrs).reduce(function(d, key) {
        var value = decodeStr(attrs[key]);

        d[key] = value;

        return d;
      }, {});

      var node = {
        name: obj.name,
        originalName: obj.originalName,
        attributes: decodedAttrs,
        ns: obj.ns
      };

      handleOpen(node, getContext);
    })
    .on('question', handleQuestion)
    .on('closeTag', handleClose)
    .on('cdata', handleCData)
    .on('text', function(text, decodeEntities, getContext) {
      handleText(decodeEntities(text), getContext);
    })
    .on('error', handleError)
    .on('warn', handleWarning);

  // deferred parse XML to make loading really ascnchronous
  // this ensures the execution environment (node or browser)
  // is kept responsive and that certain optimization strategies
  // can kick in
  defer(function() {
    var err;

    try {
      parser.parse(xml);

      resolveReferences();
    } catch (e) {
      err = e;
    }

    var element = rootHandler.element;

    // handle the situation that we could not extract
    // the desired root element from the document
    if (!err && !element) {
      err = error('failed to parse document as <' + rootHandler.type.$descriptor.name + '>');
    }

    done(err, err ? undefined : element, context);
  });
};

Reader.prototype.handler = function(name) {
  return new RootElementHandler(this.model, name);
};


// helpers //////////////////////////

function createStack() {
  var stack = [];

  Object.defineProperty(stack, 'peek', {
    value: function() {
      return this[this.length - 1];
    }
  });

  return stack;
}

var XML_PREAMBLE = '<?xml version="1.0" encoding="UTF-8"?>\n';

var ESCAPE_ATTR_CHARS = /<|>|'|"|&|\n\r|\n/g;
var ESCAPE_CHARS = /<|>|&/g;


function Namespaces(parent) {

  var prefixMap = {};
  var uriMap = {};
  var used = {};

  var wellknown = [];
  var custom = [];

  // API

  this.byUri = function(uri) {
    return uriMap[uri] || (
      parent && parent.byUri(uri)
    );
  };

  this.add = function(ns, isWellknown) {

    uriMap[ns.uri] = ns;

    if (isWellknown) {
      wellknown.push(ns);
    } else {
      custom.push(ns);
    }

    this.mapPrefix(ns.prefix, ns.uri);
  };

  this.uriByPrefix = function(prefix) {
    return prefixMap[prefix || 'xmlns'];
  };

  this.mapPrefix = function(prefix, uri) {
    prefixMap[prefix || 'xmlns'] = uri;
  };

  this.logUsed = function(ns) {
    var uri = ns.uri;

    used[uri] = this.byUri(uri);
  };

  this.getUsed = function(ns) {

    function isUsed(ns) {
      return used[ns.uri];
    }

    var allNs = [].concat(wellknown, custom);

    return allNs.filter(isUsed);
  };

}

function lower(string) {
  return string.charAt(0).toLowerCase() + string.slice(1);
}

function nameToAlias(name, pkg) {
  if (hasLowerCaseAlias(pkg)) {
    return lower(name);
  } else {
    return name;
  }
}

function inherits(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
}

function nsName(ns) {
  if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isString"])(ns)) {
    return ns;
  } else {
    return (ns.prefix ? ns.prefix + ':' : '') + ns.localName;
  }
}

function getNsAttrs(namespaces) {

  return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["map"])(namespaces.getUsed(), function(ns) {
    var name = 'xmlns' + (ns.prefix ? ':' + ns.prefix : '');
    return { name: name, value: ns.uri };
  });

}

function getElementNs(ns, descriptor) {
  if (descriptor.isGeneric) {
    return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({ localName: descriptor.ns.localName }, ns);
  } else {
    return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({ localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg) }, ns);
  }
}

function getPropertyNs(ns, descriptor) {
  return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({ localName: descriptor.ns.localName }, ns);
}

function getSerializableProperties(element) {
  var descriptor = element.$descriptor;

  return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["filter"])(descriptor.properties, function(p) {
    var name = p.name;

    if (p.isVirtual) {
      return false;
    }

    // do not serialize defaults
    if (!element.hasOwnProperty(name)) {
      return false;
    }

    var value = element[name];

    // do not serialize default equals
    if (value === p.default) {
      return false;
    }

    // do not serialize null properties
    if (value === null) {
      return false;
    }

    return p.isMany ? value.length : true;
  });
}

var ESCAPE_ATTR_MAP = {
  '\n': '#10',
  '\n\r': '#10',
  '"': '#34',
  '\'': '#39',
  '<': '#60',
  '>': '#62',
  '&': '#38'
};

var ESCAPE_MAP = {
  '<': 'lt',
  '>': 'gt',
  '&': 'amp'
};

function escape(str, charPattern, replaceMap) {

  // ensure we are handling strings here
  str = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isString"])(str) ? str : '' + str;

  return str.replace(charPattern, function(s) {
    return '&' + replaceMap[s] + ';';
  });
}

/**
 * Escape a string attribute to not contain any bad values (line breaks, '"', ...)
 *
 * @param {String} str the string to escape
 * @return {String} the escaped string
 */
function escapeAttr(str) {
  return escape(str, ESCAPE_ATTR_CHARS, ESCAPE_ATTR_MAP);
}

function escapeBody(str) {
  return escape(str, ESCAPE_CHARS, ESCAPE_MAP);
}

function filterAttributes(props) {
  return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["filter"])(props, function(p) { return p.isAttr; });
}

function filterContained(props) {
  return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["filter"])(props, function(p) { return !p.isAttr; });
}


function ReferenceSerializer(tagName) {
  this.tagName = tagName;
}

ReferenceSerializer.prototype.build = function(element) {
  this.element = element;
  return this;
};

ReferenceSerializer.prototype.serializeTo = function(writer) {
  writer
    .appendIndent()
    .append('<' + this.tagName + '>' + this.element.id + '</' + this.tagName + '>')
    .appendNewLine();
};

function BodySerializer() {}

BodySerializer.prototype.serializeValue =
BodySerializer.prototype.serializeTo = function(writer) {
  writer.append(
    this.escape
      ? escapeBody(this.value)
      : this.value
  );
};

BodySerializer.prototype.build = function(prop, value) {
  this.value = value;

  if (prop.type === 'String' && value.search(ESCAPE_CHARS) !== -1) {
    this.escape = true;
  }

  return this;
};

function ValueSerializer(tagName) {
  this.tagName = tagName;
}

inherits(ValueSerializer, BodySerializer);

ValueSerializer.prototype.serializeTo = function(writer) {

  writer
    .appendIndent()
    .append('<' + this.tagName + '>');

  this.serializeValue(writer);

  writer
    .append('</' + this.tagName + '>')
    .appendNewLine();
};

function ElementSerializer(parent, propertyDescriptor) {
  this.body = [];
  this.attrs = [];

  this.parent = parent;
  this.propertyDescriptor = propertyDescriptor;
}

ElementSerializer.prototype.build = function(element) {
  this.element = element;

  var elementDescriptor = element.$descriptor,
      propertyDescriptor = this.propertyDescriptor;

  var otherAttrs,
      properties;

  var isGeneric = elementDescriptor.isGeneric;

  if (isGeneric) {
    otherAttrs = this.parseGeneric(element);
  } else {
    otherAttrs = this.parseNsAttributes(element);
  }

  if (propertyDescriptor) {
    this.ns = this.nsPropertyTagName(propertyDescriptor);
  } else {
    this.ns = this.nsTagName(elementDescriptor);
  }

  // compute tag name
  this.tagName = this.addTagName(this.ns);

  if (!isGeneric) {
    properties = getSerializableProperties(element);

    this.parseAttributes(filterAttributes(properties));
    this.parseContainments(filterContained(properties));
  }

  this.parseGenericAttributes(element, otherAttrs);

  return this;
};

ElementSerializer.prototype.nsTagName = function(descriptor) {
  var effectiveNs = this.logNamespaceUsed(descriptor.ns);
  return getElementNs(effectiveNs, descriptor);
};

ElementSerializer.prototype.nsPropertyTagName = function(descriptor) {
  var effectiveNs = this.logNamespaceUsed(descriptor.ns);
  return getPropertyNs(effectiveNs, descriptor);
};

ElementSerializer.prototype.isLocalNs = function(ns) {
  return ns.uri === this.ns.uri;
};

/**
 * Get the actual ns attribute name for the given element.
 *
 * @param {Object} element
 * @param {Boolean} [element.inherited=false]
 *
 * @return {Object} nsName
 */
ElementSerializer.prototype.nsAttributeName = function(element) {

  var ns;

  if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isString"])(element)) {
    ns = Object(moddle__WEBPACK_IMPORTED_MODULE_2__["parseNameNS"])(element);
  } else {
    ns = element.ns;
  }

  // return just local name for inherited attributes
  if (element.inherited) {
    return { localName: ns.localName };
  }

  // parse + log effective ns
  var effectiveNs = this.logNamespaceUsed(ns);

  // LOG ACTUAL namespace use
  this.getNamespaces().logUsed(effectiveNs);

  // strip prefix if same namespace like parent
  if (this.isLocalNs(effectiveNs)) {
    return { localName: ns.localName };
  } else {
    return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({ localName: ns.localName }, effectiveNs);
  }
};

ElementSerializer.prototype.parseGeneric = function(element) {

  var self = this,
      body = this.body;

  var attributes = [];

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(element, function(val, key) {

    var nonNsAttr;

    if (key === '$body') {
      body.push(new BodySerializer().build({ type: 'String' }, val));
    } else
    if (key === '$children') {
      Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(val, function(child) {
        body.push(new ElementSerializer(self).build(child));
      });
    } else
    if (key.indexOf('$') !== 0) {
      nonNsAttr = self.parseNsAttribute(element, key, val);

      if (nonNsAttr) {
        attributes.push({ name: key, value: val });
      }
    }
  });

  return attributes;
};

ElementSerializer.prototype.parseNsAttribute = function(element, name, value) {
  var model = element.$model;

  var nameNs = Object(moddle__WEBPACK_IMPORTED_MODULE_2__["parseNameNS"])(name);

  var ns;

  // parse xmlns:foo="http://foo.bar"
  if (nameNs.prefix === 'xmlns') {
    ns = { prefix: nameNs.localName, uri: value };
  }

  // parse xmlns="http://foo.bar"
  if (!nameNs.prefix && nameNs.localName === 'xmlns') {
    ns = { uri: value };
  }

  if (!ns) {
    return {
      name: name,
      value: value
    };
  }

  if (model && model.getPackage(value)) {
    // register well known namespace
    this.logNamespace(ns, true, true);
  } else {
    // log custom namespace directly as used
    var actualNs = this.logNamespaceUsed(ns, true);

    this.getNamespaces().logUsed(actualNs);
  }
};


/**
 * Parse namespaces and return a list of left over generic attributes
 *
 * @param  {Object} element
 * @return {Array<Object>}
 */
ElementSerializer.prototype.parseNsAttributes = function(element, attrs) {
  var self = this;

  var genericAttrs = element.$attrs;

  var attributes = [];

  // parse namespace attributes first
  // and log them. push non namespace attributes to a list
  // and process them later
  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(genericAttrs, function(value, name) {

    var nonNsAttr = self.parseNsAttribute(element, name, value);

    if (nonNsAttr) {
      attributes.push(nonNsAttr);
    }
  });

  return attributes;
};

ElementSerializer.prototype.parseGenericAttributes = function(element, attributes) {

  var self = this;

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(attributes, function(attr) {

    // do not serialize xsi:type attribute
    // it is set manually based on the actual implementation type
    if (attr.name === XSI_TYPE) {
      return;
    }

    try {
      self.addAttribute(self.nsAttributeName(attr.name), attr.value);
    } catch (e) {
      console.warn(
        'missing namespace information for ',
        attr.name, '=', attr.value, 'on', element,
        e);
    }
  });
};

ElementSerializer.prototype.parseContainments = function(properties) {

  var self = this,
      body = this.body,
      element = this.element;

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(properties, function(p) {
    var value = element.get(p.name),
        isReference = p.isReference,
        isMany = p.isMany;

    if (!isMany) {
      value = [ value ];
    }

    if (p.isBody) {
      body.push(new BodySerializer().build(p, value[0]));
    } else
    if (Object(moddle__WEBPACK_IMPORTED_MODULE_2__["isSimpleType"])(p.type)) {
      Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(value, function(v) {
        body.push(new ValueSerializer(self.addTagName(self.nsPropertyTagName(p))).build(p, v));
      });
    } else
    if (isReference) {
      Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(value, function(v) {
        body.push(new ReferenceSerializer(self.addTagName(self.nsPropertyTagName(p))).build(v));
      });
    } else {
      // allow serialization via type
      // rather than element name
      var asType = serializeAsType(p),
          asProperty = serializeAsProperty(p);

      Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(value, function(v) {
        var serializer;

        if (asType) {
          serializer = new TypeSerializer(self, p);
        } else
        if (asProperty) {
          serializer = new ElementSerializer(self, p);
        } else {
          serializer = new ElementSerializer(self);
        }

        body.push(serializer.build(v));
      });
    }
  });
};

ElementSerializer.prototype.getNamespaces = function(local) {

  var namespaces = this.namespaces,
      parent = this.parent,
      parentNamespaces;

  if (!namespaces) {
    parentNamespaces = parent && parent.getNamespaces();

    if (local || !parentNamespaces) {
      this.namespaces = namespaces = new Namespaces(parentNamespaces);
    } else {
      namespaces = parentNamespaces;
    }
  }

  return namespaces;
};

ElementSerializer.prototype.logNamespace = function(ns, wellknown, local) {
  var namespaces = this.getNamespaces(local);

  var nsUri = ns.uri,
      nsPrefix = ns.prefix;

  var existing = namespaces.byUri(nsUri);

  if (!existing) {
    namespaces.add(ns, wellknown);
  }

  namespaces.mapPrefix(nsPrefix, nsUri);

  return ns;
};

ElementSerializer.prototype.logNamespaceUsed = function(ns, local) {
  var element = this.element,
      model = element.$model,
      namespaces = this.getNamespaces(local);

  // ns may be
  //
  //   * prefix only
  //   * prefix:uri
  //   * localName only

  var prefix = ns.prefix,
      uri = ns.uri,
      newPrefix, idx,
      wellknownUri;

  // handle anonymous namespaces (elementForm=unqualified), cf. #23
  if (!prefix && !uri) {
    return { localName: ns.localName };
  }

  wellknownUri = DEFAULT_NS_MAP[prefix] || model && (model.getPackage(prefix) || {}).uri;

  uri = uri || wellknownUri || namespaces.uriByPrefix(prefix);

  if (!uri) {
    throw new Error('no namespace uri given for prefix <' + prefix + '>');
  }

  ns = namespaces.byUri(uri);

  if (!ns) {
    newPrefix = prefix;
    idx = 1;

    // find a prefix that is not mapped yet
    while (namespaces.uriByPrefix(newPrefix)) {
      newPrefix = prefix + '_' + idx++;
    }

    ns = this.logNamespace({ prefix: newPrefix, uri: uri }, wellknownUri === uri);
  }

  if (prefix) {
    namespaces.mapPrefix(prefix, uri);
  }

  return ns;
};

ElementSerializer.prototype.parseAttributes = function(properties) {
  var self = this,
      element = this.element;

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(properties, function(p) {

    var value = element.get(p.name);

    if (p.isReference) {

      if (!p.isMany) {
        value = value.id;
      }
      else {
        var values = [];
        Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(value, function(v) {
          values.push(v.id);
        });
        // IDREFS is a whitespace-separated list of references.
        value = values.join(' ');
      }

    }

    self.addAttribute(self.nsAttributeName(p), value);
  });
};

ElementSerializer.prototype.addTagName = function(nsTagName) {
  var actualNs = this.logNamespaceUsed(nsTagName);

  this.getNamespaces().logUsed(actualNs);

  return nsName(nsTagName);
};

ElementSerializer.prototype.addAttribute = function(name, value) {
  var attrs = this.attrs;

  if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isString"])(value)) {
    value = escapeAttr(value);
  }

  attrs.push({ name: name, value: value });
};

ElementSerializer.prototype.serializeAttributes = function(writer) {
  var attrs = this.attrs,
      namespaces = this.namespaces;

  if (namespaces) {
    attrs = getNsAttrs(namespaces).concat(attrs);
  }

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(attrs, function(a) {
    writer
      .append(' ')
      .append(nsName(a.name)).append('="').append(a.value).append('"');
  });
};

ElementSerializer.prototype.serializeTo = function(writer) {
  var firstBody = this.body[0],
      indent = firstBody && firstBody.constructor !== BodySerializer;

  writer
    .appendIndent()
    .append('<' + this.tagName);

  this.serializeAttributes(writer);

  writer.append(firstBody ? '>' : ' />');

  if (firstBody) {

    if (indent) {
      writer
        .appendNewLine()
        .indent();
    }

    Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(this.body, function(b) {
      b.serializeTo(writer);
    });

    if (indent) {
      writer
        .unindent()
        .appendIndent();
    }

    writer.append('</' + this.tagName + '>');
  }

  writer.appendNewLine();
};

/**
 * A serializer for types that handles serialization of data types
 */
function TypeSerializer(parent, propertyDescriptor) {
  ElementSerializer.call(this, parent, propertyDescriptor);
}

inherits(TypeSerializer, ElementSerializer);

TypeSerializer.prototype.parseNsAttributes = function(element) {

  // extracted attributes
  var attributes = ElementSerializer.prototype.parseNsAttributes.call(this, element);

  var descriptor = element.$descriptor;

  // only serialize xsi:type if necessary
  if (descriptor.name === this.propertyDescriptor.type) {
    return attributes;
  }

  var typeNs = this.typeNs = this.nsTagName(descriptor);
  this.getNamespaces().logUsed(this.typeNs);

  // add xsi:type attribute to represent the elements
  // actual type

  var pkg = element.$model.getPackage(typeNs.uri),
      typePrefix = (pkg.xml && pkg.xml.typePrefix) || '';

  this.addAttribute(
    this.nsAttributeName(XSI_TYPE),
    (typeNs.prefix ? typeNs.prefix + ':' : '') + typePrefix + descriptor.ns.localName
  );

  return attributes;
};

TypeSerializer.prototype.isLocalNs = function(ns) {
  return ns.uri === (this.typeNs || this.ns).uri;
};

function SavingWriter() {
  this.value = '';

  this.write = function(str) {
    this.value += str;
  };
}

function FormatingWriter(out, format) {

  var indent = [''];

  this.append = function(str) {
    out.write(str);

    return this;
  };

  this.appendNewLine = function() {
    if (format) {
      out.write('\n');
    }

    return this;
  };

  this.appendIndent = function() {
    if (format) {
      out.write(indent.join('  '));
    }

    return this;
  };

  this.indent = function() {
    indent.push('');
    return this;
  };

  this.unindent = function() {
    indent.pop();
    return this;
  };
}

/**
 * A writer for meta-model backed document trees
 *
 * @param {Object} options output options to pass into the writer
 */
function Writer(options) {

  options = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({ format: false, preamble: true }, options || {});

  function toXML(tree, writer) {
    var internalWriter = writer || new SavingWriter();
    var formatingWriter = new FormatingWriter(internalWriter, options.format);

    if (options.preamble) {
      formatingWriter.append(XML_PREAMBLE);
    }

    new ElementSerializer().build(tree).serializeTo(formatingWriter);

    if (!writer) {
      return internalWriter.value;
    }
  }

  return {
    toXML: toXML
  };
}




/***/ }),

/***/ "./node_modules/bpmn-js/node_modules/saxen/dist/index.esm.js":
/*!*******************************************************************!*\
  !*** ./node_modules/bpmn-js/node_modules/saxen/dist/index.esm.js ***!
  \*******************************************************************/
/*! exports provided: Parser, decode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Parser", function() { return Parser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decode", function() { return decodeEntities; });
var fromCharCode = String.fromCharCode;

var hasOwnProperty = Object.prototype.hasOwnProperty;

var ENTITY_PATTERN = /&#(\d+);|&#x([0-9a-f]+);|&(\w+);/ig;

var ENTITY_MAPPING = {
  'amp': '&',
  'apos': '\'',
  'gt': '>',
  'lt': '<',
  'quot': '"'
};

// map UPPERCASE variants of supported special chars
Object.keys(ENTITY_MAPPING).forEach(function(k) {
  ENTITY_MAPPING[k.toUpperCase()] = ENTITY_MAPPING[k];
});


function replaceEntities(_, d, x, z) {

  // reserved names, i.e. &nbsp;
  if (z) {
    if (hasOwnProperty.call(ENTITY_MAPPING, z)) {
      return ENTITY_MAPPING[z];
    } else {

      // fall back to original value
      return '&' + z + ';';
    }
  }

  // decimal encoded char
  if (d) {
    return fromCharCode(d);
  }

  // hex encoded char
  return fromCharCode(parseInt(x, 16));
}


/**
 * A basic entity decoder that can decode a minimal
 * sub-set of reserved names (&amp;) as well as
 * hex (&#xaaf;) and decimal (&#1231;) encoded characters.
 *
 * @param {string} str
 *
 * @return {string} decoded string
 */
function decodeEntities(s) {
  if (s.length > 3 && s.indexOf('&') !== -1) {
    return s.replace(ENTITY_PATTERN, replaceEntities);
  }

  return s;
}

var XSI_URI = 'http://www.w3.org/2001/XMLSchema-instance';
var XSI_PREFIX = 'xsi';
var XSI_TYPE = 'xsi:type';

var NON_WHITESPACE_OUTSIDE_ROOT_NODE = 'non-whitespace outside of root node';

function error(msg) {
  return new Error(msg);
}

function missingNamespaceForPrefix(prefix) {
  return 'missing namespace for prefix <' + prefix + '>';
}

function getter(getFn) {
  return {
    'get': getFn,
    'enumerable': true
  };
}

function cloneNsMatrix(nsMatrix) {
  var clone = {}, key;
  for (key in nsMatrix) {
    clone[key] = nsMatrix[key];
  }
  return clone;
}

function uriPrefix(prefix) {
  return prefix + '$uri';
}

function buildNsMatrix(nsUriToPrefix) {
  var nsMatrix = {},
      uri,
      prefix;

  for (uri in nsUriToPrefix) {
    prefix = nsUriToPrefix[uri];
    nsMatrix[prefix] = prefix;
    nsMatrix[uriPrefix(prefix)] = uri;
  }

  return nsMatrix;
}

function noopGetContext() {
  return { 'line': 0, 'column': 0 };
}

function throwFunc(err) {
  throw err;
}

/**
 * Creates a new parser with the given options.
 *
 * @constructor
 *
 * @param  {!Object<string, ?>=} options
 */
function Parser(options) {

  if (!this) {
    return new Parser(options);
  }

  var proxy = options && options['proxy'];

  var onText,
      onOpenTag,
      onCloseTag,
      onCDATA,
      onError = throwFunc,
      onWarning,
      onComment,
      onQuestion,
      onAttention;

  var getContext = noopGetContext;

  /**
   * Do we need to parse the current elements attributes for namespaces?
   *
   * @type {boolean}
   */
  var maybeNS = false;

  /**
   * Do we process namespaces at all?
   *
   * @type {boolean}
   */
  var isNamespace = false;

  /**
   * The caught error returned on parse end
   *
   * @type {Error}
   */
  var returnError = null;

  /**
   * Should we stop parsing?
   *
   * @type {boolean}
   */
  var parseStop = false;

  /**
   * A map of { uri: prefix } used by the parser.
   *
   * This map will ensure we can normalize prefixes during processing;
   * for each uri, only one prefix will be exposed to the handlers.
   *
   * @type {!Object<string, string>}}
   */
  var nsUriToPrefix;

  /**
   * Handle parse error.
   *
   * @param  {string|Error} err
   */
  function handleError(err) {
    if (!(err instanceof Error)) {
      err = error(err);
    }

    returnError = err;

    onError(err, getContext);
  }

  /**
   * Handle parse error.
   *
   * @param  {string|Error} err
   */
  function handleWarning(err) {

    if (!onWarning) {
      return;
    }

    if (!(err instanceof Error)) {
      err = error(err);
    }

    onWarning(err, getContext);
  }

  /**
   * Register parse listener.
   *
   * @param  {string}   name
   * @param  {Function} cb
   *
   * @return {Parser}
   */
  this['on'] = function(name, cb) {

    if (typeof cb !== 'function') {
      throw error('required args <name, cb>');
    }

    switch (name) {
    case 'openTag': onOpenTag = cb; break;
    case 'text': onText = cb; break;
    case 'closeTag': onCloseTag = cb; break;
    case 'error': onError = cb; break;
    case 'warn': onWarning = cb; break;
    case 'cdata': onCDATA = cb; break;
    case 'attention': onAttention = cb; break; // <!XXXXX zzzz="eeee">
    case 'question': onQuestion = cb; break; // <? ....  ?>
    case 'comment': onComment = cb; break;
    default:
      throw error('unsupported event: ' + name);
    }

    return this;
  };

  /**
   * Set the namespace to prefix mapping.
   *
   * @example
   *
   * parser.ns({
   *   'http://foo': 'foo',
   *   'http://bar': 'bar'
   * });
   *
   * @param  {!Object<string, string>} nsMap
   *
   * @return {Parser}
   */
  this['ns'] = function(nsMap) {

    if (typeof nsMap === 'undefined') {
      nsMap = {};
    }

    if (typeof nsMap !== 'object') {
      throw error('required args <nsMap={}>');
    }

    var _nsUriToPrefix = {}, k;

    for (k in nsMap) {
      _nsUriToPrefix[k] = nsMap[k];
    }

    // FORCE default mapping for schema instance
    _nsUriToPrefix[XSI_URI] = XSI_PREFIX;

    isNamespace = true;
    nsUriToPrefix = _nsUriToPrefix;

    return this;
  };

  /**
   * Parse xml string.
   *
   * @param  {string} xml
   *
   * @return {Error} returnError, if not thrown
   */
  this['parse'] = function(xml) {
    if (typeof xml !== 'string') {
      throw error('required args <xml=string>');
    }

    returnError = null;

    parse(xml);

    getContext = noopGetContext;
    parseStop = false;

    return returnError;
  };

  /**
   * Stop parsing.
   */
  this['stop'] = function() {
    parseStop = true;
  };

  /**
   * Parse string, invoking configured listeners on element.
   *
   * @param  {string} xml
   */
  function parse(xml) {
    var nsMatrixStack = isNamespace ? [] : null,
        nsMatrix = isNamespace ? buildNsMatrix(nsUriToPrefix) : null,
        _nsMatrix,
        nodeStack = [],
        anonymousNsCount = 0,
        tagStart = false,
        tagEnd = false,
        i = 0, j = 0,
        x, y, q, w, v,
        xmlns,
        elementName,
        _elementName,
        elementProxy
        ;

    var attrsString = '',
        attrsStart = 0,
        cachedAttrs // false = parsed with errors, null = needs parsing
        ;

    /**
     * Parse attributes on demand and returns the parsed attributes.
     *
     * Return semantics: (1) `false` on attribute parse error,
     * (2) object hash on extracted attrs.
     *
     * @return {boolean|Object}
     */
    function getAttrs() {
      if (cachedAttrs !== null) {
        return cachedAttrs;
      }

      var nsUri,
          nsUriPrefix,
          nsName,
          defaultAlias = isNamespace && nsMatrix['xmlns'],
          attrList = isNamespace && maybeNS ? [] : null,
          i = attrsStart,
          s = attrsString,
          l = s.length,
          hasNewMatrix,
          newalias,
          value,
          alias,
          name,
          attrs = {},
          seenAttrs = {},
          skipAttr,
          w,
          j;

      parseAttr:
      for (; i < l; i++) {
        skipAttr = false;
        w = s.charCodeAt(i);

        if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE={ \f\n\r\t\v}
          continue;
        }

        // wait for non whitespace character
        if (w < 65 || w > 122 || (w > 90 && w < 97)) {
          if (w !== 95 && w !== 58) { // char 95"_" 58":"
            handleWarning('illegal first char attribute name');
            skipAttr = true;
          }
        }

        // parse attribute name
        for (j = i + 1; j < l; j++) {
          w = s.charCodeAt(j);

          if (
            w > 96 && w < 123 ||
            w > 64 && w < 91 ||
            w > 47 && w < 59 ||
            w === 46 || // '.'
            w === 45 || // '-'
            w === 95 // '_'
          ) {
            continue;
          }

          // unexpected whitespace
          if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE
            handleWarning('missing attribute value');
            i = j;

            continue parseAttr;
          }

          // expected "="
          if (w === 61) { // "=" == 61
            break;
          }

          handleWarning('illegal attribute name char');
          skipAttr = true;
        }

        name = s.substring(i, j);

        if (name === 'xmlns:xmlns') {
          handleWarning('illegal declaration of xmlns');
          skipAttr = true;
        }

        w = s.charCodeAt(j + 1);

        if (w === 34) { // '"'
          j = s.indexOf('"', i = j + 2);

          if (j === -1) {
            j = s.indexOf('\'', i);

            if (j !== -1) {
              handleWarning('attribute value quote missmatch');
              skipAttr = true;
            }
          }

        } else if (w === 39) { // "'"
          j = s.indexOf('\'', i = j + 2);

          if (j === -1) {
            j = s.indexOf('"', i);

            if (j !== -1) {
              handleWarning('attribute value quote missmatch');
              skipAttr = true;
            }
          }

        } else {
          handleWarning('missing attribute value quotes');
          skipAttr = true;

          // skip to next space
          for (j = j + 1; j < l; j++) {
            w = s.charCodeAt(j + 1);

            if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE
              break;
            }
          }

        }

        if (j === -1) {
          handleWarning('missing closing quotes');

          j = l;
          skipAttr = true;
        }

        if (!skipAttr) {
          value = s.substring(i, j);
        }

        i = j;

        // ensure SPACE follows attribute
        // skip illegal content otherwise
        // example a="b"c
        for (; j + 1 < l; j++) {
          w = s.charCodeAt(j + 1);

          if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE
            break;
          }

          // FIRST ILLEGAL CHAR
          if (i === j) {
            handleWarning('illegal character after attribute end');
            skipAttr = true;
          }
        }

        // advance cursor to next attribute
        i = j + 1;

        if (skipAttr) {
          continue parseAttr;
        }

        // check attribute re-declaration
        if (name in seenAttrs) {
          handleWarning('attribute <' + name + '> already defined');
          continue;
        }

        seenAttrs[name] = true;

        if (!isNamespace) {
          attrs[name] = value;
          continue;
        }

        // try to extract namespace information
        if (maybeNS) {
          newalias = (
            name === 'xmlns'
              ? 'xmlns'
              : (name.charCodeAt(0) === 120 && name.substr(0, 6) === 'xmlns:')
                ? name.substr(6)
                : null
          );

          // handle xmlns(:alias) assignment
          if (newalias !== null) {
            nsUri = decodeEntities(value);
            nsUriPrefix = uriPrefix(newalias);

            alias = nsUriToPrefix[nsUri];

            if (!alias) {

              // no prefix defined or prefix collision
              if (
                (newalias === 'xmlns') ||
                (nsUriPrefix in nsMatrix && nsMatrix[nsUriPrefix] !== nsUri)
              ) {

                // alocate free ns prefix
                do {
                  alias = 'ns' + (anonymousNsCount++);
                } while (typeof nsMatrix[alias] !== 'undefined');
              } else {
                alias = newalias;
              }

              nsUriToPrefix[nsUri] = alias;
            }

            if (nsMatrix[newalias] !== alias) {
              if (!hasNewMatrix) {
                nsMatrix = cloneNsMatrix(nsMatrix);
                hasNewMatrix = true;
              }

              nsMatrix[newalias] = alias;
              if (newalias === 'xmlns') {
                nsMatrix[uriPrefix(alias)] = nsUri;
                defaultAlias = alias;
              }

              nsMatrix[nsUriPrefix] = nsUri;
            }

            // expose xmlns(:asd)="..." in attributes
            attrs[name] = value;
            continue;
          }

          // collect attributes until all namespace
          // declarations are processed
          attrList.push(name, value);
          continue;

        } /** end if (maybeNs) */

        // handle attributes on element without
        // namespace declarations
        w = name.indexOf(':');
        if (w === -1) {
          attrs[name] = value;
          continue;
        }

        // normalize ns attribute name
        if (!(nsName = nsMatrix[name.substring(0, w)])) {
          handleWarning(missingNamespaceForPrefix(name.substring(0, w)));
          continue;
        }

        name = defaultAlias === nsName
          ? name.substr(w + 1)
          : nsName + name.substr(w);

        // end: normalize ns attribute name

        // normalize xsi:type ns attribute value
        if (name === XSI_TYPE) {
          w = value.indexOf(':');

          if (w !== -1) {
            nsName = value.substring(0, w);

            // handle default prefixes, i.e. xs:String gracefully
            nsName = nsMatrix[nsName] || nsName;
            value = nsName + value.substring(w);
          } else {
            value = defaultAlias + ':' + value;
          }
        }

        // end: normalize xsi:type ns attribute value

        attrs[name] = value;
      }


      // handle deferred, possibly namespaced attributes
      if (maybeNS) {

        // normalize captured attributes
        for (i = 0, l = attrList.length; i < l; i++) {

          name = attrList[i++];
          value = attrList[i];

          w = name.indexOf(':');

          if (w !== -1) {

            // normalize ns attribute name
            if (!(nsName = nsMatrix[name.substring(0, w)])) {
              handleWarning(missingNamespaceForPrefix(name.substring(0, w)));
              continue;
            }

            name = defaultAlias === nsName
              ? name.substr(w + 1)
              : nsName + name.substr(w);

            // end: normalize ns attribute name

            // normalize xsi:type ns attribute value
            if (name === XSI_TYPE) {
              w = value.indexOf(':');

              if (w !== -1) {
                nsName = value.substring(0, w);

                // handle default prefixes, i.e. xs:String gracefully
                nsName = nsMatrix[nsName] || nsName;
                value = nsName + value.substring(w);
              } else {
                value = defaultAlias + ':' + value;
              }
            }

            // end: normalize xsi:type ns attribute value
          }

          attrs[name] = value;
        }

        // end: normalize captured attributes
      }

      return cachedAttrs = attrs;
    }

    /**
     * Extract the parse context { line, column, part }
     * from the current parser position.
     *
     * @return {Object} parse context
     */
    function getParseContext() {
      var splitsRe = /(\r\n|\r|\n)/g;

      var line = 0;
      var column = 0;
      var startOfLine = 0;
      var endOfLine = j;
      var match;
      var data;

      while (i >= startOfLine) {

        match = splitsRe.exec(xml);

        if (!match) {
          break;
        }

        // end of line = (break idx + break chars)
        endOfLine = match[0].length + match.index;

        if (endOfLine > i) {
          break;
        }

        // advance to next line
        line += 1;

        startOfLine = endOfLine;
      }

      // EOF errors
      if (i == -1) {
        column = endOfLine;
        data = xml.substring(j);
      } else

      // start errors
      if (j === 0) {
        data = xml.substring(j, i);
      }

      // other errors
      else {
        column = i - startOfLine;
        data = (j == -1 ? xml.substring(i) : xml.substring(i, j + 1));
      }

      return {
        'data': data,
        'line': line,
        'column': column
      };
    }

    getContext = getParseContext;


    if (proxy) {
      elementProxy = Object.create({}, {
        'name': getter(function() {
          return elementName;
        }),
        'originalName': getter(function() {
          return _elementName;
        }),
        'attrs': getter(getAttrs),
        'ns': getter(function() {
          return nsMatrix;
        })
      });
    }

    // actual parse logic
    while (j !== -1) {

      if (xml.charCodeAt(j) === 60) { // "<"
        i = j;
      } else {
        i = xml.indexOf('<', j);
      }

      // parse end
      if (i === -1) {
        if (nodeStack.length) {
          return handleError('unexpected end of file');
        }

        if (j === 0) {
          return handleError('missing start tag');
        }

        if (j < xml.length) {
          if (xml.substring(j).trim()) {
            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);
          }
        }

        return;
      }

      // parse text
      if (j !== i) {

        if (nodeStack.length) {
          if (onText) {
            onText(xml.substring(j, i), decodeEntities, getContext);

            if (parseStop) {
              return;
            }
          }
        } else {
          if (xml.substring(j, i).trim()) {
            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);

            if (parseStop) {
              return;
            }
          }
        }
      }

      w = xml.charCodeAt(i+1);

      // parse comments + CDATA
      if (w === 33) { // "!"
        q = xml.charCodeAt(i+2);

        // CDATA section
        if (q === 91 && xml.substr(i + 3, 6) === 'CDATA[') { // 91 == "["
          j = xml.indexOf(']]>', i);
          if (j === -1) {
            return handleError('unclosed cdata');
          }

          if (onCDATA) {
            onCDATA(xml.substring(i + 9, j), getContext);
            if (parseStop) {
              return;
            }
          }

          j += 3;
          continue;
        }

        // comment
        if (q === 45 && xml.charCodeAt(i + 3) === 45) { // 45 == "-"
          j = xml.indexOf('-->', i);
          if (j === -1) {
            return handleError('unclosed comment');
          }


          if (onComment) {
            onComment(xml.substring(i + 4, j), decodeEntities, getContext);
            if (parseStop) {
              return;
            }
          }

          j += 3;
          continue;
        }
      }

      // parse question <? ... ?>
      if (w === 63) { // "?"
        j = xml.indexOf('?>', i);
        if (j === -1) {
          return handleError('unclosed question');
        }

        if (onQuestion) {
          onQuestion(xml.substring(i, j + 2), getContext);
          if (parseStop) {
            return;
          }
        }

        j += 2;
        continue;
      }

      // find matching closing tag for attention or standard tags
      // for that we must skip through attribute values
      // (enclosed in single or double quotes)
      for (x = i + 1; ; x++) {
        v = xml.charCodeAt(x);
        if (isNaN(v)) {
          j = -1;
          return handleError('unclosed tag');
        }

        // [10] AttValue ::= '"' ([^<&"] | Reference)* '"' | "'" ([^<&'] | Reference)* "'"
        // skips the quoted string
        // (double quotes) does not appear in a literal enclosed by (double quotes)
        // (single quote) does not appear in a literal enclosed by (single quote)
        if (v === 34) { //  '"'
          q = xml.indexOf('"', x + 1);
          x = q !== -1 ? q : x;
        } else if (v === 39) { // "'"
          q = xml.indexOf("'", x + 1);
          x = q !== -1 ? q : x;
        } else if (v === 62) { // '>'
          j = x;
          break;
        }
      }


      // parse attention <! ...>
      // previously comment and CDATA have already been parsed
      if (w === 33) { // "!"

        if (onAttention) {
          onAttention(xml.substring(i, j + 1), decodeEntities, getContext);
          if (parseStop) {
            return;
          }
        }

        j += 1;
        continue;
      }

      // don't process attributes;
      // there are none
      cachedAttrs = {};

      // if (xml.charCodeAt(i+1) === 47) { // </...
      if (w === 47) { // </...
        tagStart = false;
        tagEnd = true;

        if (!nodeStack.length) {
          return handleError('missing open tag');
        }

        // verify open <-> close tag match
        x = elementName = nodeStack.pop();
        q = i + 2 + x.length;

        if (xml.substring(i + 2, q) !== x) {
          return handleError('closing tag mismatch');
        }

        // verify chars in close tag
        for (; q < j; q++) {
          w = xml.charCodeAt(q);

          if (w === 32 || (w > 8 && w < 14)) { // \f\n\r\t\v space
            continue;
          }

          return handleError('close tag');
        }

      } else {
        if (xml.charCodeAt(j - 1) === 47) { // .../>
          x = elementName = xml.substring(i + 1, j - 1);

          tagStart = true;
          tagEnd = true;

        } else {
          x = elementName = xml.substring(i + 1, j);

          tagStart = true;
          tagEnd = false;
        }

        if (!(w > 96 && w < 123 || w > 64 && w < 91 || w === 95 || w === 58)) { // char 95"_" 58":"
          return handleError('illegal first char nodeName');
        }

        for (q = 1, y = x.length; q < y; q++) {
          w = x.charCodeAt(q);

          if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 45 || w === 95 || w == 46) {
            continue;
          }

          if (w === 32 || (w < 14 && w > 8)) { // \f\n\r\t\v space
            elementName = x.substring(0, q);

            // maybe there are attributes
            cachedAttrs = null;
            break;
          }

          return handleError('invalid nodeName');
        }

        if (!tagEnd) {
          nodeStack.push(elementName);
        }
      }

      if (isNamespace) {

        _nsMatrix = nsMatrix;

        if (tagStart) {

          // remember old namespace
          // unless we're self-closing
          if (!tagEnd) {
            nsMatrixStack.push(_nsMatrix);
          }

          if (cachedAttrs === null) {

            // quick check, whether there may be namespace
            // declarations on the node; if that is the case
            // we need to eagerly parse the node attributes
            if ((maybeNS = x.indexOf('xmlns', q) !== -1)) {
              attrsStart = q;
              attrsString = x;

              getAttrs();

              maybeNS = false;
            }
          }
        }

        _elementName = elementName;

        w = elementName.indexOf(':');
        if (w !== -1) {
          xmlns = nsMatrix[elementName.substring(0, w)];

          // prefix given; namespace must exist
          if (!xmlns) {
            return handleError('missing namespace on <' + _elementName + '>');
          }

          elementName = elementName.substr(w + 1);
        } else {
          xmlns = nsMatrix['xmlns'];

          // if no default namespace is defined,
          // we'll import the element as anonymous.
          //
          // it is up to users to correct that to the document defined
          // targetNamespace, or whatever their undersanding of the
          // XML spec mandates.
        }

        // adjust namespace prefixs as configured
        if (xmlns) {
          elementName = xmlns + ':' + elementName;
        }

      }

      if (tagStart) {
        attrsStart = q;
        attrsString = x;

        if (onOpenTag) {
          if (proxy) {
            onOpenTag(elementProxy, decodeEntities, tagEnd, getContext);
          } else {
            onOpenTag(elementName, getAttrs, decodeEntities, tagEnd, getContext);
          }

          if (parseStop) {
            return;
          }
        }

      }

      if (tagEnd) {

        if (onCloseTag) {
          onCloseTag(proxy ? elementProxy : elementName, decodeEntities, tagStart, getContext);

          if (parseStop) {
            return;
          }
        }

        // restore old namespace
        if (isNamespace) {
          if (!tagStart) {
            nsMatrix = nsMatrixStack.pop();
          } else {
            nsMatrix = _nsMatrix;
          }
        }
      }

      j += 1;
    }
  } /** end parse */

}




/***/ }),

/***/ "./node_modules/bpmn-moddle/dist/index.esm.js":
/*!****************************************************!*\
  !*** ./node_modules/bpmn-moddle/dist/index.esm.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var moddle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! moddle */ "./node_modules/moddle/dist/index.esm.js");
/* harmony import */ var moddle_xml__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! moddle-xml */ "./node_modules/moddle-xml/dist/index.esm.js");




/**
 * A sub class of {@link Moddle} with support for import and export of BPMN 2.0 xml files.
 *
 * @class BpmnModdle
 * @extends Moddle
 *
 * @param {Object|Array} packages to use for instantiating the model
 * @param {Object} [options] additional options to pass over
 */
function BpmnModdle(packages, options) {
  moddle__WEBPACK_IMPORTED_MODULE_1__["Moddle"].call(this, packages, options);
}

BpmnModdle.prototype = Object.create(moddle__WEBPACK_IMPORTED_MODULE_1__["Moddle"].prototype);


/**
 * Instantiates a BPMN model tree from a given xml string.
 *
 * @param {String}   xmlStr
 * @param {String}   [typeName='bpmn:Definitions'] name of the root element
 * @param {Object}   [options]  options to pass to the underlying reader
 * @param {Function} done       callback that is invoked with (err, result, parseContext)
 *                              once the import completes
 */
BpmnModdle.prototype.fromXML = function(xmlStr, typeName, options, done) {

  if (!Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isString"])(typeName)) {
    done = options;
    options = typeName;
    typeName = 'bpmn:Definitions';
  }

  if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(options)) {
    done = options;
    options = {};
  }

  var reader = new moddle_xml__WEBPACK_IMPORTED_MODULE_2__["Reader"](Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({ model: this, lax: true }, options));
  var rootHandler = reader.handler(typeName);

  reader.fromXML(xmlStr, rootHandler, done);
};


/**
 * Serializes a BPMN 2.0 object tree to XML.
 *
 * @param {String}   element    the root element, typically an instance of `bpmn:Definitions`
 * @param {Object}   [options]  to pass to the underlying writer
 * @param {Function} done       callback invoked with (err, xmlStr) once the import completes
 */
BpmnModdle.prototype.toXML = function(element, options, done) {

  if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(options)) {
    done = options;
    options = {};
  }

  var writer = new moddle_xml__WEBPACK_IMPORTED_MODULE_2__["Writer"](options);

  var result;
  var err;

  try {
    result = writer.toXML(element);
  } catch (e) {
    err = e;
  }

  return done(err, result);
};

var name = "BPMN20";
var uri = "http://www.omg.org/spec/BPMN/20100524/MODEL";
var associations = [
];
var types = [
	{
		name: "Interface",
		superClass: [
			"RootElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "operations",
				type: "Operation",
				isMany: true
			},
			{
				name: "implementationRef",
				type: "String",
				isAttr: true
			}
		]
	},
	{
		name: "Operation",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "inMessageRef",
				type: "Message",
				isReference: true
			},
			{
				name: "outMessageRef",
				type: "Message",
				isReference: true
			},
			{
				name: "errorRef",
				type: "Error",
				isMany: true,
				isReference: true
			},
			{
				name: "implementationRef",
				type: "String",
				isAttr: true
			}
		]
	},
	{
		name: "EndPoint",
		superClass: [
			"RootElement"
		]
	},
	{
		name: "Auditing",
		superClass: [
			"BaseElement"
		]
	},
	{
		name: "GlobalTask",
		superClass: [
			"CallableElement"
		],
		properties: [
			{
				name: "resources",
				type: "ResourceRole",
				isMany: true
			}
		]
	},
	{
		name: "Monitoring",
		superClass: [
			"BaseElement"
		]
	},
	{
		name: "Performer",
		superClass: [
			"ResourceRole"
		]
	},
	{
		name: "Process",
		superClass: [
			"FlowElementsContainer",
			"CallableElement"
		],
		properties: [
			{
				name: "processType",
				type: "ProcessType",
				isAttr: true
			},
			{
				name: "isClosed",
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "auditing",
				type: "Auditing"
			},
			{
				name: "monitoring",
				type: "Monitoring"
			},
			{
				name: "properties",
				type: "Property",
				isMany: true
			},
			{
				name: "laneSets",
				type: "LaneSet",
				isMany: true,
				replaces: "FlowElementsContainer#laneSets"
			},
			{
				name: "flowElements",
				type: "FlowElement",
				isMany: true,
				replaces: "FlowElementsContainer#flowElements"
			},
			{
				name: "artifacts",
				type: "Artifact",
				isMany: true
			},
			{
				name: "resources",
				type: "ResourceRole",
				isMany: true
			},
			{
				name: "correlationSubscriptions",
				type: "CorrelationSubscription",
				isMany: true
			},
			{
				name: "supports",
				type: "Process",
				isMany: true,
				isReference: true
			},
			{
				name: "definitionalCollaborationRef",
				type: "Collaboration",
				isAttr: true,
				isReference: true
			},
			{
				name: "isExecutable",
				isAttr: true,
				type: "Boolean"
			}
		]
	},
	{
		name: "LaneSet",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "lanes",
				type: "Lane",
				isMany: true
			},
			{
				name: "name",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "Lane",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "partitionElementRef",
				type: "BaseElement",
				isAttr: true,
				isReference: true
			},
			{
				name: "partitionElement",
				type: "BaseElement"
			},
			{
				name: "flowNodeRef",
				type: "FlowNode",
				isMany: true,
				isReference: true
			},
			{
				name: "childLaneSet",
				type: "LaneSet",
				xml: {
					serialize: "xsi:type"
				}
			}
		]
	},
	{
		name: "GlobalManualTask",
		superClass: [
			"GlobalTask"
		]
	},
	{
		name: "ManualTask",
		superClass: [
			"Task"
		]
	},
	{
		name: "UserTask",
		superClass: [
			"Task"
		],
		properties: [
			{
				name: "renderings",
				type: "Rendering",
				isMany: true
			},
			{
				name: "implementation",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "Rendering",
		superClass: [
			"BaseElement"
		]
	},
	{
		name: "HumanPerformer",
		superClass: [
			"Performer"
		]
	},
	{
		name: "PotentialOwner",
		superClass: [
			"HumanPerformer"
		]
	},
	{
		name: "GlobalUserTask",
		superClass: [
			"GlobalTask"
		],
		properties: [
			{
				name: "implementation",
				isAttr: true,
				type: "String"
			},
			{
				name: "renderings",
				type: "Rendering",
				isMany: true
			}
		]
	},
	{
		name: "Gateway",
		isAbstract: true,
		superClass: [
			"FlowNode"
		],
		properties: [
			{
				name: "gatewayDirection",
				type: "GatewayDirection",
				"default": "Unspecified",
				isAttr: true
			}
		]
	},
	{
		name: "EventBasedGateway",
		superClass: [
			"Gateway"
		],
		properties: [
			{
				name: "instantiate",
				"default": false,
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "eventGatewayType",
				type: "EventBasedGatewayType",
				isAttr: true,
				"default": "Exclusive"
			}
		]
	},
	{
		name: "ComplexGateway",
		superClass: [
			"Gateway"
		],
		properties: [
			{
				name: "activationCondition",
				type: "Expression",
				xml: {
					serialize: "xsi:type"
				}
			},
			{
				name: "default",
				type: "SequenceFlow",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "ExclusiveGateway",
		superClass: [
			"Gateway"
		],
		properties: [
			{
				name: "default",
				type: "SequenceFlow",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "InclusiveGateway",
		superClass: [
			"Gateway"
		],
		properties: [
			{
				name: "default",
				type: "SequenceFlow",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "ParallelGateway",
		superClass: [
			"Gateway"
		]
	},
	{
		name: "RootElement",
		isAbstract: true,
		superClass: [
			"BaseElement"
		]
	},
	{
		name: "Relationship",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "type",
				isAttr: true,
				type: "String"
			},
			{
				name: "direction",
				type: "RelationshipDirection",
				isAttr: true
			},
			{
				name: "source",
				isMany: true,
				isReference: true,
				type: "Element"
			},
			{
				name: "target",
				isMany: true,
				isReference: true,
				type: "Element"
			}
		]
	},
	{
		name: "BaseElement",
		isAbstract: true,
		properties: [
			{
				name: "id",
				isAttr: true,
				type: "String",
				isId: true
			},
			{
				name: "documentation",
				type: "Documentation",
				isMany: true
			},
			{
				name: "extensionDefinitions",
				type: "ExtensionDefinition",
				isMany: true,
				isReference: true
			},
			{
				name: "extensionElements",
				type: "ExtensionElements"
			}
		]
	},
	{
		name: "Extension",
		properties: [
			{
				name: "mustUnderstand",
				"default": false,
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "definition",
				type: "ExtensionDefinition",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "ExtensionDefinition",
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "extensionAttributeDefinitions",
				type: "ExtensionAttributeDefinition",
				isMany: true
			}
		]
	},
	{
		name: "ExtensionAttributeDefinition",
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "type",
				isAttr: true,
				type: "String"
			},
			{
				name: "isReference",
				"default": false,
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "extensionDefinition",
				type: "ExtensionDefinition",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "ExtensionElements",
		properties: [
			{
				name: "valueRef",
				isAttr: true,
				isReference: true,
				type: "Element"
			},
			{
				name: "values",
				type: "Element",
				isMany: true
			},
			{
				name: "extensionAttributeDefinition",
				type: "ExtensionAttributeDefinition",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "Documentation",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "text",
				type: "String",
				isBody: true
			},
			{
				name: "textFormat",
				"default": "text/plain",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "Event",
		isAbstract: true,
		superClass: [
			"FlowNode",
			"InteractionNode"
		],
		properties: [
			{
				name: "properties",
				type: "Property",
				isMany: true
			}
		]
	},
	{
		name: "IntermediateCatchEvent",
		superClass: [
			"CatchEvent"
		]
	},
	{
		name: "IntermediateThrowEvent",
		superClass: [
			"ThrowEvent"
		]
	},
	{
		name: "EndEvent",
		superClass: [
			"ThrowEvent"
		]
	},
	{
		name: "StartEvent",
		superClass: [
			"CatchEvent"
		],
		properties: [
			{
				name: "isInterrupting",
				"default": true,
				isAttr: true,
				type: "Boolean"
			}
		]
	},
	{
		name: "ThrowEvent",
		isAbstract: true,
		superClass: [
			"Event"
		],
		properties: [
			{
				name: "dataInputs",
				type: "DataInput",
				isMany: true
			},
			{
				name: "dataInputAssociations",
				type: "DataInputAssociation",
				isMany: true
			},
			{
				name: "inputSet",
				type: "InputSet"
			},
			{
				name: "eventDefinitions",
				type: "EventDefinition",
				isMany: true
			},
			{
				name: "eventDefinitionRef",
				type: "EventDefinition",
				isMany: true,
				isReference: true
			}
		]
	},
	{
		name: "CatchEvent",
		isAbstract: true,
		superClass: [
			"Event"
		],
		properties: [
			{
				name: "parallelMultiple",
				isAttr: true,
				type: "Boolean",
				"default": false
			},
			{
				name: "dataOutputs",
				type: "DataOutput",
				isMany: true
			},
			{
				name: "dataOutputAssociations",
				type: "DataOutputAssociation",
				isMany: true
			},
			{
				name: "outputSet",
				type: "OutputSet"
			},
			{
				name: "eventDefinitions",
				type: "EventDefinition",
				isMany: true
			},
			{
				name: "eventDefinitionRef",
				type: "EventDefinition",
				isMany: true,
				isReference: true
			}
		]
	},
	{
		name: "BoundaryEvent",
		superClass: [
			"CatchEvent"
		],
		properties: [
			{
				name: "cancelActivity",
				"default": true,
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "attachedToRef",
				type: "Activity",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "EventDefinition",
		isAbstract: true,
		superClass: [
			"RootElement"
		]
	},
	{
		name: "CancelEventDefinition",
		superClass: [
			"EventDefinition"
		]
	},
	{
		name: "ErrorEventDefinition",
		superClass: [
			"EventDefinition"
		],
		properties: [
			{
				name: "errorRef",
				type: "Error",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "TerminateEventDefinition",
		superClass: [
			"EventDefinition"
		]
	},
	{
		name: "EscalationEventDefinition",
		superClass: [
			"EventDefinition"
		],
		properties: [
			{
				name: "escalationRef",
				type: "Escalation",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "Escalation",
		properties: [
			{
				name: "structureRef",
				type: "ItemDefinition",
				isAttr: true,
				isReference: true
			},
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "escalationCode",
				isAttr: true,
				type: "String"
			}
		],
		superClass: [
			"RootElement"
		]
	},
	{
		name: "CompensateEventDefinition",
		superClass: [
			"EventDefinition"
		],
		properties: [
			{
				name: "waitForCompletion",
				isAttr: true,
				type: "Boolean",
				"default": true
			},
			{
				name: "activityRef",
				type: "Activity",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "TimerEventDefinition",
		superClass: [
			"EventDefinition"
		],
		properties: [
			{
				name: "timeDate",
				type: "Expression",
				xml: {
					serialize: "xsi:type"
				}
			},
			{
				name: "timeCycle",
				type: "Expression",
				xml: {
					serialize: "xsi:type"
				}
			},
			{
				name: "timeDuration",
				type: "Expression",
				xml: {
					serialize: "xsi:type"
				}
			}
		]
	},
	{
		name: "LinkEventDefinition",
		superClass: [
			"EventDefinition"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "target",
				type: "LinkEventDefinition",
				isAttr: true,
				isReference: true
			},
			{
				name: "source",
				type: "LinkEventDefinition",
				isMany: true,
				isReference: true
			}
		]
	},
	{
		name: "MessageEventDefinition",
		superClass: [
			"EventDefinition"
		],
		properties: [
			{
				name: "messageRef",
				type: "Message",
				isAttr: true,
				isReference: true
			},
			{
				name: "operationRef",
				type: "Operation",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "ConditionalEventDefinition",
		superClass: [
			"EventDefinition"
		],
		properties: [
			{
				name: "condition",
				type: "Expression",
				xml: {
					serialize: "xsi:type"
				}
			}
		]
	},
	{
		name: "SignalEventDefinition",
		superClass: [
			"EventDefinition"
		],
		properties: [
			{
				name: "signalRef",
				type: "Signal",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "Signal",
		superClass: [
			"RootElement"
		],
		properties: [
			{
				name: "structureRef",
				type: "ItemDefinition",
				isAttr: true,
				isReference: true
			},
			{
				name: "name",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "ImplicitThrowEvent",
		superClass: [
			"ThrowEvent"
		]
	},
	{
		name: "DataState",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "ItemAwareElement",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "itemSubjectRef",
				type: "ItemDefinition",
				isAttr: true,
				isReference: true
			},
			{
				name: "dataState",
				type: "DataState"
			}
		]
	},
	{
		name: "DataAssociation",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "assignment",
				type: "Assignment",
				isMany: true
			},
			{
				name: "sourceRef",
				type: "ItemAwareElement",
				isMany: true,
				isReference: true
			},
			{
				name: "targetRef",
				type: "ItemAwareElement",
				isReference: true
			},
			{
				name: "transformation",
				type: "FormalExpression",
				xml: {
					serialize: "property"
				}
			}
		]
	},
	{
		name: "DataInput",
		superClass: [
			"ItemAwareElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "isCollection",
				"default": false,
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "inputSetRef",
				type: "InputSet",
				isVirtual: true,
				isMany: true,
				isReference: true
			},
			{
				name: "inputSetWithOptional",
				type: "InputSet",
				isVirtual: true,
				isMany: true,
				isReference: true
			},
			{
				name: "inputSetWithWhileExecuting",
				type: "InputSet",
				isVirtual: true,
				isMany: true,
				isReference: true
			}
		]
	},
	{
		name: "DataOutput",
		superClass: [
			"ItemAwareElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "isCollection",
				"default": false,
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "outputSetRef",
				type: "OutputSet",
				isVirtual: true,
				isMany: true,
				isReference: true
			},
			{
				name: "outputSetWithOptional",
				type: "OutputSet",
				isVirtual: true,
				isMany: true,
				isReference: true
			},
			{
				name: "outputSetWithWhileExecuting",
				type: "OutputSet",
				isVirtual: true,
				isMany: true,
				isReference: true
			}
		]
	},
	{
		name: "InputSet",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "dataInputRefs",
				type: "DataInput",
				isMany: true,
				isReference: true
			},
			{
				name: "optionalInputRefs",
				type: "DataInput",
				isMany: true,
				isReference: true
			},
			{
				name: "whileExecutingInputRefs",
				type: "DataInput",
				isMany: true,
				isReference: true
			},
			{
				name: "outputSetRefs",
				type: "OutputSet",
				isMany: true,
				isReference: true
			}
		]
	},
	{
		name: "OutputSet",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "dataOutputRefs",
				type: "DataOutput",
				isMany: true,
				isReference: true
			},
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "inputSetRefs",
				type: "InputSet",
				isMany: true,
				isReference: true
			},
			{
				name: "optionalOutputRefs",
				type: "DataOutput",
				isMany: true,
				isReference: true
			},
			{
				name: "whileExecutingOutputRefs",
				type: "DataOutput",
				isMany: true,
				isReference: true
			}
		]
	},
	{
		name: "Property",
		superClass: [
			"ItemAwareElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "DataInputAssociation",
		superClass: [
			"DataAssociation"
		]
	},
	{
		name: "DataOutputAssociation",
		superClass: [
			"DataAssociation"
		]
	},
	{
		name: "InputOutputSpecification",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "dataInputs",
				type: "DataInput",
				isMany: true
			},
			{
				name: "dataOutputs",
				type: "DataOutput",
				isMany: true
			},
			{
				name: "inputSets",
				type: "InputSet",
				isMany: true
			},
			{
				name: "outputSets",
				type: "OutputSet",
				isMany: true
			}
		]
	},
	{
		name: "DataObject",
		superClass: [
			"FlowElement",
			"ItemAwareElement"
		],
		properties: [
			{
				name: "isCollection",
				"default": false,
				isAttr: true,
				type: "Boolean"
			}
		]
	},
	{
		name: "InputOutputBinding",
		properties: [
			{
				name: "inputDataRef",
				type: "InputSet",
				isAttr: true,
				isReference: true
			},
			{
				name: "outputDataRef",
				type: "OutputSet",
				isAttr: true,
				isReference: true
			},
			{
				name: "operationRef",
				type: "Operation",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "Assignment",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "from",
				type: "Expression",
				xml: {
					serialize: "xsi:type"
				}
			},
			{
				name: "to",
				type: "Expression",
				xml: {
					serialize: "xsi:type"
				}
			}
		]
	},
	{
		name: "DataStore",
		superClass: [
			"RootElement",
			"ItemAwareElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "capacity",
				isAttr: true,
				type: "Integer"
			},
			{
				name: "isUnlimited",
				"default": true,
				isAttr: true,
				type: "Boolean"
			}
		]
	},
	{
		name: "DataStoreReference",
		superClass: [
			"ItemAwareElement",
			"FlowElement"
		],
		properties: [
			{
				name: "dataStoreRef",
				type: "DataStore",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "DataObjectReference",
		superClass: [
			"ItemAwareElement",
			"FlowElement"
		],
		properties: [
			{
				name: "dataObjectRef",
				type: "DataObject",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "ConversationLink",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "sourceRef",
				type: "InteractionNode",
				isAttr: true,
				isReference: true
			},
			{
				name: "targetRef",
				type: "InteractionNode",
				isAttr: true,
				isReference: true
			},
			{
				name: "name",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "ConversationAssociation",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "innerConversationNodeRef",
				type: "ConversationNode",
				isAttr: true,
				isReference: true
			},
			{
				name: "outerConversationNodeRef",
				type: "ConversationNode",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "CallConversation",
		superClass: [
			"ConversationNode"
		],
		properties: [
			{
				name: "calledCollaborationRef",
				type: "Collaboration",
				isAttr: true,
				isReference: true
			},
			{
				name: "participantAssociations",
				type: "ParticipantAssociation",
				isMany: true
			}
		]
	},
	{
		name: "Conversation",
		superClass: [
			"ConversationNode"
		]
	},
	{
		name: "SubConversation",
		superClass: [
			"ConversationNode"
		],
		properties: [
			{
				name: "conversationNodes",
				type: "ConversationNode",
				isMany: true
			}
		]
	},
	{
		name: "ConversationNode",
		isAbstract: true,
		superClass: [
			"InteractionNode",
			"BaseElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "participantRef",
				type: "Participant",
				isMany: true,
				isReference: true
			},
			{
				name: "messageFlowRefs",
				type: "MessageFlow",
				isMany: true,
				isReference: true
			},
			{
				name: "correlationKeys",
				type: "CorrelationKey",
				isMany: true
			}
		]
	},
	{
		name: "GlobalConversation",
		superClass: [
			"Collaboration"
		]
	},
	{
		name: "PartnerEntity",
		superClass: [
			"RootElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "participantRef",
				type: "Participant",
				isMany: true,
				isReference: true
			}
		]
	},
	{
		name: "PartnerRole",
		superClass: [
			"RootElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "participantRef",
				type: "Participant",
				isMany: true,
				isReference: true
			}
		]
	},
	{
		name: "CorrelationProperty",
		superClass: [
			"RootElement"
		],
		properties: [
			{
				name: "correlationPropertyRetrievalExpression",
				type: "CorrelationPropertyRetrievalExpression",
				isMany: true
			},
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "type",
				type: "ItemDefinition",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "Error",
		superClass: [
			"RootElement"
		],
		properties: [
			{
				name: "structureRef",
				type: "ItemDefinition",
				isAttr: true,
				isReference: true
			},
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "errorCode",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "CorrelationKey",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "correlationPropertyRef",
				type: "CorrelationProperty",
				isMany: true,
				isReference: true
			},
			{
				name: "name",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "Expression",
		superClass: [
			"BaseElement"
		],
		isAbstract: false,
		properties: [
			{
				name: "body",
				type: "String",
				isBody: true
			}
		]
	},
	{
		name: "FormalExpression",
		superClass: [
			"Expression"
		],
		properties: [
			{
				name: "language",
				isAttr: true,
				type: "String"
			},
			{
				name: "evaluatesToTypeRef",
				type: "ItemDefinition",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "Message",
		superClass: [
			"RootElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "itemRef",
				type: "ItemDefinition",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "ItemDefinition",
		superClass: [
			"RootElement"
		],
		properties: [
			{
				name: "itemKind",
				type: "ItemKind",
				isAttr: true
			},
			{
				name: "structureRef",
				type: "String",
				isAttr: true
			},
			{
				name: "isCollection",
				"default": false,
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "import",
				type: "Import",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "FlowElement",
		isAbstract: true,
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "auditing",
				type: "Auditing"
			},
			{
				name: "monitoring",
				type: "Monitoring"
			},
			{
				name: "categoryValueRef",
				type: "CategoryValue",
				isMany: true,
				isReference: true
			}
		]
	},
	{
		name: "SequenceFlow",
		superClass: [
			"FlowElement"
		],
		properties: [
			{
				name: "isImmediate",
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "conditionExpression",
				type: "Expression",
				xml: {
					serialize: "xsi:type"
				}
			},
			{
				name: "sourceRef",
				type: "FlowNode",
				isAttr: true,
				isReference: true
			},
			{
				name: "targetRef",
				type: "FlowNode",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "FlowElementsContainer",
		isAbstract: true,
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "laneSets",
				type: "LaneSet",
				isMany: true
			},
			{
				name: "flowElements",
				type: "FlowElement",
				isMany: true
			}
		]
	},
	{
		name: "CallableElement",
		isAbstract: true,
		superClass: [
			"RootElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "ioSpecification",
				type: "InputOutputSpecification",
				xml: {
					serialize: "property"
				}
			},
			{
				name: "supportedInterfaceRef",
				type: "Interface",
				isMany: true,
				isReference: true
			},
			{
				name: "ioBinding",
				type: "InputOutputBinding",
				isMany: true,
				xml: {
					serialize: "property"
				}
			}
		]
	},
	{
		name: "FlowNode",
		isAbstract: true,
		superClass: [
			"FlowElement"
		],
		properties: [
			{
				name: "incoming",
				type: "SequenceFlow",
				isMany: true,
				isReference: true
			},
			{
				name: "outgoing",
				type: "SequenceFlow",
				isMany: true,
				isReference: true
			},
			{
				name: "lanes",
				type: "Lane",
				isVirtual: true,
				isMany: true,
				isReference: true
			}
		]
	},
	{
		name: "CorrelationPropertyRetrievalExpression",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "messagePath",
				type: "FormalExpression"
			},
			{
				name: "messageRef",
				type: "Message",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "CorrelationPropertyBinding",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "dataPath",
				type: "FormalExpression"
			},
			{
				name: "correlationPropertyRef",
				type: "CorrelationProperty",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "Resource",
		superClass: [
			"RootElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "resourceParameters",
				type: "ResourceParameter",
				isMany: true
			}
		]
	},
	{
		name: "ResourceParameter",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "isRequired",
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "type",
				type: "ItemDefinition",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "CorrelationSubscription",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "correlationKeyRef",
				type: "CorrelationKey",
				isAttr: true,
				isReference: true
			},
			{
				name: "correlationPropertyBinding",
				type: "CorrelationPropertyBinding",
				isMany: true
			}
		]
	},
	{
		name: "MessageFlow",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "sourceRef",
				type: "InteractionNode",
				isAttr: true,
				isReference: true
			},
			{
				name: "targetRef",
				type: "InteractionNode",
				isAttr: true,
				isReference: true
			},
			{
				name: "messageRef",
				type: "Message",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "MessageFlowAssociation",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "innerMessageFlowRef",
				type: "MessageFlow",
				isAttr: true,
				isReference: true
			},
			{
				name: "outerMessageFlowRef",
				type: "MessageFlow",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "InteractionNode",
		isAbstract: true,
		properties: [
			{
				name: "incomingConversationLinks",
				type: "ConversationLink",
				isVirtual: true,
				isMany: true,
				isReference: true
			},
			{
				name: "outgoingConversationLinks",
				type: "ConversationLink",
				isVirtual: true,
				isMany: true,
				isReference: true
			}
		]
	},
	{
		name: "Participant",
		superClass: [
			"InteractionNode",
			"BaseElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "interfaceRef",
				type: "Interface",
				isMany: true,
				isReference: true
			},
			{
				name: "participantMultiplicity",
				type: "ParticipantMultiplicity"
			},
			{
				name: "endPointRefs",
				type: "EndPoint",
				isMany: true,
				isReference: true
			},
			{
				name: "processRef",
				type: "Process",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "ParticipantAssociation",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "innerParticipantRef",
				type: "Participant",
				isAttr: true,
				isReference: true
			},
			{
				name: "outerParticipantRef",
				type: "Participant",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "ParticipantMultiplicity",
		properties: [
			{
				name: "minimum",
				"default": 0,
				isAttr: true,
				type: "Integer"
			},
			{
				name: "maximum",
				"default": 1,
				isAttr: true,
				type: "Integer"
			}
		],
		superClass: [
			"BaseElement"
		]
	},
	{
		name: "Collaboration",
		superClass: [
			"RootElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "isClosed",
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "participants",
				type: "Participant",
				isMany: true
			},
			{
				name: "messageFlows",
				type: "MessageFlow",
				isMany: true
			},
			{
				name: "artifacts",
				type: "Artifact",
				isMany: true
			},
			{
				name: "conversations",
				type: "ConversationNode",
				isMany: true
			},
			{
				name: "conversationAssociations",
				type: "ConversationAssociation"
			},
			{
				name: "participantAssociations",
				type: "ParticipantAssociation",
				isMany: true
			},
			{
				name: "messageFlowAssociations",
				type: "MessageFlowAssociation",
				isMany: true
			},
			{
				name: "correlationKeys",
				type: "CorrelationKey",
				isMany: true
			},
			{
				name: "choreographyRef",
				type: "Choreography",
				isMany: true,
				isReference: true
			},
			{
				name: "conversationLinks",
				type: "ConversationLink",
				isMany: true
			}
		]
	},
	{
		name: "ChoreographyActivity",
		isAbstract: true,
		superClass: [
			"FlowNode"
		],
		properties: [
			{
				name: "participantRef",
				type: "Participant",
				isMany: true,
				isReference: true
			},
			{
				name: "initiatingParticipantRef",
				type: "Participant",
				isAttr: true,
				isReference: true
			},
			{
				name: "correlationKeys",
				type: "CorrelationKey",
				isMany: true
			},
			{
				name: "loopType",
				type: "ChoreographyLoopType",
				"default": "None",
				isAttr: true
			}
		]
	},
	{
		name: "CallChoreography",
		superClass: [
			"ChoreographyActivity"
		],
		properties: [
			{
				name: "calledChoreographyRef",
				type: "Choreography",
				isAttr: true,
				isReference: true
			},
			{
				name: "participantAssociations",
				type: "ParticipantAssociation",
				isMany: true
			}
		]
	},
	{
		name: "SubChoreography",
		superClass: [
			"ChoreographyActivity",
			"FlowElementsContainer"
		],
		properties: [
			{
				name: "artifacts",
				type: "Artifact",
				isMany: true
			}
		]
	},
	{
		name: "ChoreographyTask",
		superClass: [
			"ChoreographyActivity"
		],
		properties: [
			{
				name: "messageFlowRef",
				type: "MessageFlow",
				isMany: true,
				isReference: true
			}
		]
	},
	{
		name: "Choreography",
		superClass: [
			"Collaboration",
			"FlowElementsContainer"
		]
	},
	{
		name: "GlobalChoreographyTask",
		superClass: [
			"Choreography"
		],
		properties: [
			{
				name: "initiatingParticipantRef",
				type: "Participant",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "TextAnnotation",
		superClass: [
			"Artifact"
		],
		properties: [
			{
				name: "text",
				type: "String"
			},
			{
				name: "textFormat",
				"default": "text/plain",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "Group",
		superClass: [
			"Artifact"
		],
		properties: [
			{
				name: "categoryValueRef",
				type: "CategoryValue",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "Association",
		superClass: [
			"Artifact"
		],
		properties: [
			{
				name: "associationDirection",
				type: "AssociationDirection",
				isAttr: true
			},
			{
				name: "sourceRef",
				type: "BaseElement",
				isAttr: true,
				isReference: true
			},
			{
				name: "targetRef",
				type: "BaseElement",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "Category",
		superClass: [
			"RootElement"
		],
		properties: [
			{
				name: "categoryValue",
				type: "CategoryValue",
				isMany: true
			},
			{
				name: "name",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "Artifact",
		isAbstract: true,
		superClass: [
			"BaseElement"
		]
	},
	{
		name: "CategoryValue",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "categorizedFlowElements",
				type: "FlowElement",
				isVirtual: true,
				isMany: true,
				isReference: true
			},
			{
				name: "value",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "Activity",
		isAbstract: true,
		superClass: [
			"FlowNode"
		],
		properties: [
			{
				name: "isForCompensation",
				"default": false,
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "default",
				type: "SequenceFlow",
				isAttr: true,
				isReference: true
			},
			{
				name: "ioSpecification",
				type: "InputOutputSpecification",
				xml: {
					serialize: "property"
				}
			},
			{
				name: "boundaryEventRefs",
				type: "BoundaryEvent",
				isMany: true,
				isReference: true
			},
			{
				name: "properties",
				type: "Property",
				isMany: true
			},
			{
				name: "dataInputAssociations",
				type: "DataInputAssociation",
				isMany: true
			},
			{
				name: "dataOutputAssociations",
				type: "DataOutputAssociation",
				isMany: true
			},
			{
				name: "startQuantity",
				"default": 1,
				isAttr: true,
				type: "Integer"
			},
			{
				name: "resources",
				type: "ResourceRole",
				isMany: true
			},
			{
				name: "completionQuantity",
				"default": 1,
				isAttr: true,
				type: "Integer"
			},
			{
				name: "loopCharacteristics",
				type: "LoopCharacteristics"
			}
		]
	},
	{
		name: "ServiceTask",
		superClass: [
			"Task"
		],
		properties: [
			{
				name: "implementation",
				isAttr: true,
				type: "String"
			},
			{
				name: "operationRef",
				type: "Operation",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "SubProcess",
		superClass: [
			"Activity",
			"FlowElementsContainer",
			"InteractionNode"
		],
		properties: [
			{
				name: "triggeredByEvent",
				"default": false,
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "artifacts",
				type: "Artifact",
				isMany: true
			}
		]
	},
	{
		name: "LoopCharacteristics",
		isAbstract: true,
		superClass: [
			"BaseElement"
		]
	},
	{
		name: "MultiInstanceLoopCharacteristics",
		superClass: [
			"LoopCharacteristics"
		],
		properties: [
			{
				name: "isSequential",
				"default": false,
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "behavior",
				type: "MultiInstanceBehavior",
				"default": "All",
				isAttr: true
			},
			{
				name: "loopCardinality",
				type: "Expression",
				xml: {
					serialize: "xsi:type"
				}
			},
			{
				name: "loopDataInputRef",
				type: "ItemAwareElement",
				isReference: true
			},
			{
				name: "loopDataOutputRef",
				type: "ItemAwareElement",
				isReference: true
			},
			{
				name: "inputDataItem",
				type: "DataInput",
				xml: {
					serialize: "property"
				}
			},
			{
				name: "outputDataItem",
				type: "DataOutput",
				xml: {
					serialize: "property"
				}
			},
			{
				name: "complexBehaviorDefinition",
				type: "ComplexBehaviorDefinition",
				isMany: true
			},
			{
				name: "completionCondition",
				type: "Expression",
				xml: {
					serialize: "xsi:type"
				}
			},
			{
				name: "oneBehaviorEventRef",
				type: "EventDefinition",
				isAttr: true,
				isReference: true
			},
			{
				name: "noneBehaviorEventRef",
				type: "EventDefinition",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "StandardLoopCharacteristics",
		superClass: [
			"LoopCharacteristics"
		],
		properties: [
			{
				name: "testBefore",
				"default": false,
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "loopCondition",
				type: "Expression",
				xml: {
					serialize: "xsi:type"
				}
			},
			{
				name: "loopMaximum",
				type: "Integer",
				isAttr: true
			}
		]
	},
	{
		name: "CallActivity",
		superClass: [
			"Activity"
		],
		properties: [
			{
				name: "calledElement",
				type: "String",
				isAttr: true
			}
		]
	},
	{
		name: "Task",
		superClass: [
			"Activity",
			"InteractionNode"
		]
	},
	{
		name: "SendTask",
		superClass: [
			"Task"
		],
		properties: [
			{
				name: "implementation",
				isAttr: true,
				type: "String"
			},
			{
				name: "operationRef",
				type: "Operation",
				isAttr: true,
				isReference: true
			},
			{
				name: "messageRef",
				type: "Message",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "ReceiveTask",
		superClass: [
			"Task"
		],
		properties: [
			{
				name: "implementation",
				isAttr: true,
				type: "String"
			},
			{
				name: "instantiate",
				"default": false,
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "operationRef",
				type: "Operation",
				isAttr: true,
				isReference: true
			},
			{
				name: "messageRef",
				type: "Message",
				isAttr: true,
				isReference: true
			}
		]
	},
	{
		name: "ScriptTask",
		superClass: [
			"Task"
		],
		properties: [
			{
				name: "scriptFormat",
				isAttr: true,
				type: "String"
			},
			{
				name: "script",
				type: "String"
			}
		]
	},
	{
		name: "BusinessRuleTask",
		superClass: [
			"Task"
		],
		properties: [
			{
				name: "implementation",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "AdHocSubProcess",
		superClass: [
			"SubProcess"
		],
		properties: [
			{
				name: "completionCondition",
				type: "Expression",
				xml: {
					serialize: "xsi:type"
				}
			},
			{
				name: "ordering",
				type: "AdHocOrdering",
				isAttr: true
			},
			{
				name: "cancelRemainingInstances",
				"default": true,
				isAttr: true,
				type: "Boolean"
			}
		]
	},
	{
		name: "Transaction",
		superClass: [
			"SubProcess"
		],
		properties: [
			{
				name: "protocol",
				isAttr: true,
				type: "String"
			},
			{
				name: "method",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "GlobalScriptTask",
		superClass: [
			"GlobalTask"
		],
		properties: [
			{
				name: "scriptLanguage",
				isAttr: true,
				type: "String"
			},
			{
				name: "script",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "GlobalBusinessRuleTask",
		superClass: [
			"GlobalTask"
		],
		properties: [
			{
				name: "implementation",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "ComplexBehaviorDefinition",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "condition",
				type: "FormalExpression"
			},
			{
				name: "event",
				type: "ImplicitThrowEvent"
			}
		]
	},
	{
		name: "ResourceRole",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "resourceRef",
				type: "Resource",
				isReference: true
			},
			{
				name: "resourceParameterBindings",
				type: "ResourceParameterBinding",
				isMany: true
			},
			{
				name: "resourceAssignmentExpression",
				type: "ResourceAssignmentExpression"
			},
			{
				name: "name",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "ResourceParameterBinding",
		properties: [
			{
				name: "expression",
				type: "Expression",
				xml: {
					serialize: "xsi:type"
				}
			},
			{
				name: "parameterRef",
				type: "ResourceParameter",
				isAttr: true,
				isReference: true
			}
		],
		superClass: [
			"BaseElement"
		]
	},
	{
		name: "ResourceAssignmentExpression",
		properties: [
			{
				name: "expression",
				type: "Expression",
				xml: {
					serialize: "xsi:type"
				}
			}
		],
		superClass: [
			"BaseElement"
		]
	},
	{
		name: "Import",
		properties: [
			{
				name: "importType",
				isAttr: true,
				type: "String"
			},
			{
				name: "location",
				isAttr: true,
				type: "String"
			},
			{
				name: "namespace",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "Definitions",
		superClass: [
			"BaseElement"
		],
		properties: [
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "targetNamespace",
				isAttr: true,
				type: "String"
			},
			{
				name: "expressionLanguage",
				"default": "http://www.w3.org/1999/XPath",
				isAttr: true,
				type: "String"
			},
			{
				name: "typeLanguage",
				"default": "http://www.w3.org/2001/XMLSchema",
				isAttr: true,
				type: "String"
			},
			{
				name: "imports",
				type: "Import",
				isMany: true
			},
			{
				name: "extensions",
				type: "Extension",
				isMany: true
			},
			{
				name: "rootElements",
				type: "RootElement",
				isMany: true
			},
			{
				name: "diagrams",
				isMany: true,
				type: "bpmndi:BPMNDiagram"
			},
			{
				name: "exporter",
				isAttr: true,
				type: "String"
			},
			{
				name: "relationships",
				type: "Relationship",
				isMany: true
			},
			{
				name: "exporterVersion",
				isAttr: true,
				type: "String"
			}
		]
	}
];
var enumerations = [
	{
		name: "ProcessType",
		literalValues: [
			{
				name: "None"
			},
			{
				name: "Public"
			},
			{
				name: "Private"
			}
		]
	},
	{
		name: "GatewayDirection",
		literalValues: [
			{
				name: "Unspecified"
			},
			{
				name: "Converging"
			},
			{
				name: "Diverging"
			},
			{
				name: "Mixed"
			}
		]
	},
	{
		name: "EventBasedGatewayType",
		literalValues: [
			{
				name: "Parallel"
			},
			{
				name: "Exclusive"
			}
		]
	},
	{
		name: "RelationshipDirection",
		literalValues: [
			{
				name: "None"
			},
			{
				name: "Forward"
			},
			{
				name: "Backward"
			},
			{
				name: "Both"
			}
		]
	},
	{
		name: "ItemKind",
		literalValues: [
			{
				name: "Physical"
			},
			{
				name: "Information"
			}
		]
	},
	{
		name: "ChoreographyLoopType",
		literalValues: [
			{
				name: "None"
			},
			{
				name: "Standard"
			},
			{
				name: "MultiInstanceSequential"
			},
			{
				name: "MultiInstanceParallel"
			}
		]
	},
	{
		name: "AssociationDirection",
		literalValues: [
			{
				name: "None"
			},
			{
				name: "One"
			},
			{
				name: "Both"
			}
		]
	},
	{
		name: "MultiInstanceBehavior",
		literalValues: [
			{
				name: "None"
			},
			{
				name: "One"
			},
			{
				name: "All"
			},
			{
				name: "Complex"
			}
		]
	},
	{
		name: "AdHocOrdering",
		literalValues: [
			{
				name: "Parallel"
			},
			{
				name: "Sequential"
			}
		]
	}
];
var prefix = "bpmn";
var xml = {
	tagAlias: "lowerCase",
	typePrefix: "t"
};
var BpmnPackage = {
	name: name,
	uri: uri,
	associations: associations,
	types: types,
	enumerations: enumerations,
	prefix: prefix,
	xml: xml
};

var name$1 = "BPMNDI";
var uri$1 = "http://www.omg.org/spec/BPMN/20100524/DI";
var types$1 = [
	{
		name: "BPMNDiagram",
		properties: [
			{
				name: "plane",
				type: "BPMNPlane",
				redefines: "di:Diagram#rootElement"
			},
			{
				name: "labelStyle",
				type: "BPMNLabelStyle",
				isMany: true
			}
		],
		superClass: [
			"di:Diagram"
		]
	},
	{
		name: "BPMNPlane",
		properties: [
			{
				name: "bpmnElement",
				isAttr: true,
				isReference: true,
				type: "bpmn:BaseElement",
				redefines: "di:DiagramElement#modelElement"
			}
		],
		superClass: [
			"di:Plane"
		]
	},
	{
		name: "BPMNShape",
		properties: [
			{
				name: "bpmnElement",
				isAttr: true,
				isReference: true,
				type: "bpmn:BaseElement",
				redefines: "di:DiagramElement#modelElement"
			},
			{
				name: "isHorizontal",
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "isExpanded",
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "isMarkerVisible",
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "label",
				type: "BPMNLabel"
			},
			{
				name: "isMessageVisible",
				isAttr: true,
				type: "Boolean"
			},
			{
				name: "participantBandKind",
				type: "ParticipantBandKind",
				isAttr: true
			},
			{
				name: "choreographyActivityShape",
				type: "BPMNShape",
				isAttr: true,
				isReference: true
			}
		],
		superClass: [
			"di:LabeledShape"
		]
	},
	{
		name: "BPMNEdge",
		properties: [
			{
				name: "label",
				type: "BPMNLabel"
			},
			{
				name: "bpmnElement",
				isAttr: true,
				isReference: true,
				type: "bpmn:BaseElement",
				redefines: "di:DiagramElement#modelElement"
			},
			{
				name: "sourceElement",
				isAttr: true,
				isReference: true,
				type: "di:DiagramElement",
				redefines: "di:Edge#source"
			},
			{
				name: "targetElement",
				isAttr: true,
				isReference: true,
				type: "di:DiagramElement",
				redefines: "di:Edge#target"
			},
			{
				name: "messageVisibleKind",
				type: "MessageVisibleKind",
				isAttr: true,
				"default": "initiating"
			}
		],
		superClass: [
			"di:LabeledEdge"
		]
	},
	{
		name: "BPMNLabel",
		properties: [
			{
				name: "labelStyle",
				type: "BPMNLabelStyle",
				isAttr: true,
				isReference: true,
				redefines: "di:DiagramElement#style"
			}
		],
		superClass: [
			"di:Label"
		]
	},
	{
		name: "BPMNLabelStyle",
		properties: [
			{
				name: "font",
				type: "dc:Font"
			}
		],
		superClass: [
			"di:Style"
		]
	}
];
var enumerations$1 = [
	{
		name: "ParticipantBandKind",
		literalValues: [
			{
				name: "top_initiating"
			},
			{
				name: "middle_initiating"
			},
			{
				name: "bottom_initiating"
			},
			{
				name: "top_non_initiating"
			},
			{
				name: "middle_non_initiating"
			},
			{
				name: "bottom_non_initiating"
			}
		]
	},
	{
		name: "MessageVisibleKind",
		literalValues: [
			{
				name: "initiating"
			},
			{
				name: "non_initiating"
			}
		]
	}
];
var associations$1 = [
];
var prefix$1 = "bpmndi";
var BpmnDiPackage = {
	name: name$1,
	uri: uri$1,
	types: types$1,
	enumerations: enumerations$1,
	associations: associations$1,
	prefix: prefix$1
};

var name$2 = "DC";
var uri$2 = "http://www.omg.org/spec/DD/20100524/DC";
var types$2 = [
	{
		name: "Boolean"
	},
	{
		name: "Integer"
	},
	{
		name: "Real"
	},
	{
		name: "String"
	},
	{
		name: "Font",
		properties: [
			{
				name: "name",
				type: "String",
				isAttr: true
			},
			{
				name: "size",
				type: "Real",
				isAttr: true
			},
			{
				name: "isBold",
				type: "Boolean",
				isAttr: true
			},
			{
				name: "isItalic",
				type: "Boolean",
				isAttr: true
			},
			{
				name: "isUnderline",
				type: "Boolean",
				isAttr: true
			},
			{
				name: "isStrikeThrough",
				type: "Boolean",
				isAttr: true
			}
		]
	},
	{
		name: "Point",
		properties: [
			{
				name: "x",
				type: "Real",
				"default": "0",
				isAttr: true
			},
			{
				name: "y",
				type: "Real",
				"default": "0",
				isAttr: true
			}
		]
	},
	{
		name: "Bounds",
		properties: [
			{
				name: "x",
				type: "Real",
				"default": "0",
				isAttr: true
			},
			{
				name: "y",
				type: "Real",
				"default": "0",
				isAttr: true
			},
			{
				name: "width",
				type: "Real",
				isAttr: true
			},
			{
				name: "height",
				type: "Real",
				isAttr: true
			}
		]
	}
];
var prefix$2 = "dc";
var associations$2 = [
];
var DcPackage = {
	name: name$2,
	uri: uri$2,
	types: types$2,
	prefix: prefix$2,
	associations: associations$2
};

var name$3 = "DI";
var uri$3 = "http://www.omg.org/spec/DD/20100524/DI";
var types$3 = [
	{
		name: "DiagramElement",
		isAbstract: true,
		properties: [
			{
				name: "id",
				type: "String",
				isAttr: true,
				isId: true
			},
			{
				name: "extension",
				type: "Extension"
			},
			{
				name: "owningDiagram",
				type: "Diagram",
				isReadOnly: true,
				isVirtual: true,
				isReference: true
			},
			{
				name: "owningElement",
				type: "DiagramElement",
				isReadOnly: true,
				isVirtual: true,
				isReference: true
			},
			{
				name: "modelElement",
				isReadOnly: true,
				isVirtual: true,
				isReference: true,
				type: "Element"
			},
			{
				name: "style",
				type: "Style",
				isReadOnly: true,
				isVirtual: true,
				isReference: true
			},
			{
				name: "ownedElement",
				type: "DiagramElement",
				isReadOnly: true,
				isVirtual: true,
				isMany: true
			}
		]
	},
	{
		name: "Node",
		isAbstract: true,
		superClass: [
			"DiagramElement"
		]
	},
	{
		name: "Edge",
		isAbstract: true,
		superClass: [
			"DiagramElement"
		],
		properties: [
			{
				name: "source",
				type: "DiagramElement",
				isReadOnly: true,
				isVirtual: true,
				isReference: true
			},
			{
				name: "target",
				type: "DiagramElement",
				isReadOnly: true,
				isVirtual: true,
				isReference: true
			},
			{
				name: "waypoint",
				isUnique: false,
				isMany: true,
				type: "dc:Point",
				xml: {
					serialize: "xsi:type"
				}
			}
		]
	},
	{
		name: "Diagram",
		isAbstract: true,
		properties: [
			{
				name: "id",
				type: "String",
				isAttr: true,
				isId: true
			},
			{
				name: "rootElement",
				type: "DiagramElement",
				isReadOnly: true,
				isVirtual: true
			},
			{
				name: "name",
				isAttr: true,
				type: "String"
			},
			{
				name: "documentation",
				isAttr: true,
				type: "String"
			},
			{
				name: "resolution",
				isAttr: true,
				type: "Real"
			},
			{
				name: "ownedStyle",
				type: "Style",
				isReadOnly: true,
				isVirtual: true,
				isMany: true
			}
		]
	},
	{
		name: "Shape",
		isAbstract: true,
		superClass: [
			"Node"
		],
		properties: [
			{
				name: "bounds",
				type: "dc:Bounds"
			}
		]
	},
	{
		name: "Plane",
		isAbstract: true,
		superClass: [
			"Node"
		],
		properties: [
			{
				name: "planeElement",
				type: "DiagramElement",
				subsettedProperty: "DiagramElement-ownedElement",
				isMany: true
			}
		]
	},
	{
		name: "LabeledEdge",
		isAbstract: true,
		superClass: [
			"Edge"
		],
		properties: [
			{
				name: "ownedLabel",
				type: "Label",
				isReadOnly: true,
				subsettedProperty: "DiagramElement-ownedElement",
				isVirtual: true,
				isMany: true
			}
		]
	},
	{
		name: "LabeledShape",
		isAbstract: true,
		superClass: [
			"Shape"
		],
		properties: [
			{
				name: "ownedLabel",
				type: "Label",
				isReadOnly: true,
				subsettedProperty: "DiagramElement-ownedElement",
				isVirtual: true,
				isMany: true
			}
		]
	},
	{
		name: "Label",
		isAbstract: true,
		superClass: [
			"Node"
		],
		properties: [
			{
				name: "bounds",
				type: "dc:Bounds"
			}
		]
	},
	{
		name: "Style",
		isAbstract: true,
		properties: [
			{
				name: "id",
				type: "String",
				isAttr: true,
				isId: true
			}
		]
	},
	{
		name: "Extension",
		properties: [
			{
				name: "values",
				type: "Element",
				isMany: true
			}
		]
	}
];
var associations$3 = [
];
var prefix$3 = "di";
var xml$1 = {
	tagAlias: "lowerCase"
};
var DiPackage = {
	name: name$3,
	uri: uri$3,
	types: types$3,
	associations: associations$3,
	prefix: prefix$3,
	xml: xml$1
};

var name$4 = "bpmn.io colors for BPMN";
var uri$4 = "http://bpmn.io/schema/bpmn/biocolor/1.0";
var prefix$4 = "bioc";
var types$4 = [
	{
		name: "ColoredShape",
		"extends": [
			"bpmndi:BPMNShape"
		],
		properties: [
			{
				name: "stroke",
				isAttr: true,
				type: "String"
			},
			{
				name: "fill",
				isAttr: true,
				type: "String"
			}
		]
	},
	{
		name: "ColoredEdge",
		"extends": [
			"bpmndi:BPMNEdge"
		],
		properties: [
			{
				name: "stroke",
				isAttr: true,
				type: "String"
			},
			{
				name: "fill",
				isAttr: true,
				type: "String"
			}
		]
	}
];
var enumerations$2 = [
];
var associations$4 = [
];
var BiocPackage = {
	name: name$4,
	uri: uri$4,
	prefix: prefix$4,
	types: types$4,
	enumerations: enumerations$2,
	associations: associations$4
};

var packages = {
  bpmn: BpmnPackage,
  bpmndi: BpmnDiPackage,
  dc: DcPackage,
  di: DiPackage,
  bioc: BiocPackage
};

function simple(additionalPackages, options) {
  var pks = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({}, packages, additionalPackages);

  return new BpmnModdle(pks, options);
}

/* harmony default export */ __webpack_exports__["default"] = (simple);


/***/ }),

/***/ "./node_modules/diagram-js/index.js":
/*!******************************************!*\
  !*** ./node_modules/diagram-js/index.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_Diagram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/Diagram */ "./node_modules/diagram-js/lib/Diagram.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _lib_Diagram__WEBPACK_IMPORTED_MODULE_0__["default"]; });



/***/ }),

/***/ "./node_modules/diagram-js/lib/Diagram.js":
/*!************************************************!*\
  !*** ./node_modules/diagram-js/lib/Diagram.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Diagram; });
/* harmony import */ var didi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! didi */ "./node_modules/didi/dist/index.esm.js");
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core */ "./node_modules/diagram-js/lib/core/index.js");





/**
 * Bootstrap an injector from a list of modules, instantiating a number of default components
 *
 * @ignore
 * @param {Array<didi.Module>} bootstrapModules
 *
 * @return {didi.Injector} a injector to use to access the components
 */
function bootstrap(bootstrapModules) {

  var modules = [],
      components = [];

  function hasModule(m) {
    return modules.indexOf(m) >= 0;
  }

  function addModule(m) {
    modules.push(m);
  }

  function visit(m) {
    if (hasModule(m)) {
      return;
    }

    (m.__depends__ || []).forEach(visit);

    if (hasModule(m)) {
      return;
    }

    addModule(m);

    (m.__init__ || []).forEach(function(c) {
      components.push(c);
    });
  }

  bootstrapModules.forEach(visit);

  var injector = new didi__WEBPACK_IMPORTED_MODULE_0__["Injector"](modules);

  components.forEach(function(c) {

    try {

      // eagerly resolve component (fn or string)
      injector[typeof c === 'string' ? 'get' : 'invoke'](c);
    } catch (e) {
      console.error('Failed to instantiate component');
      console.error(e.stack);

      throw e;
    }
  });

  return injector;
}

/**
 * Creates an injector from passed options.
 *
 * @ignore
 * @param  {Object} options
 * @return {didi.Injector}
 */
function createInjector(options) {

  options = options || {};

  var configModule = {
    'config': ['value', options]
  };

  var modules = [ configModule, _core__WEBPACK_IMPORTED_MODULE_1__["default"] ].concat(options.modules || []);

  return bootstrap(modules);
}


/**
 * The main diagram-js entry point that bootstraps the diagram with the given
 * configuration.
 *
 * To register extensions with the diagram, pass them as Array<didi.Module> to the constructor.
 *
 * @class djs.Diagram
 * @memberOf djs
 * @constructor
 *
 * @example
 *
 * <caption>Creating a plug-in that logs whenever a shape is added to the canvas.</caption>
 *
 * // plug-in implemenentation
 * function MyLoggingPlugin(eventBus) {
 *   eventBus.on('shape.added', function(event) {
 *     console.log('shape ', event.shape, ' was added to the diagram');
 *   });
 * }
 *
 * // export as module
 * export default {
 *   __init__: [ 'myLoggingPlugin' ],
 *     myLoggingPlugin: [ 'type', MyLoggingPlugin ]
 * };
 *
 *
 * // instantiate the diagram with the new plug-in
 *
 * import MyLoggingModule from 'path-to-my-logging-plugin';
 *
 * var diagram = new Diagram({
 *   modules: [
 *     MyLoggingModule
 *   ]
 * });
 *
 * diagram.invoke([ 'canvas', function(canvas) {
 *   // add shape to drawing canvas
 *   canvas.addShape({ x: 10, y: 10 });
 * });
 *
 * // 'shape ... was added to the diagram' logged to console
 *
 * @param {Object} options
 * @param {Array<didi.Module>} [options.modules] external modules to instantiate with the diagram
 * @param {didi.Injector} [injector] an (optional) injector to bootstrap the diagram with
 */
function Diagram(options, injector) {

  // create injector unless explicitly specified
  this.injector = injector = injector || createInjector(options);

  // API

  /**
   * Resolves a diagram service
   *
   * @method Diagram#get
   *
   * @param {String} name the name of the diagram service to be retrieved
   * @param {Boolean} [strict=true] if false, resolve missing services to null
   */
  this.get = injector.get;

  /**
   * Executes a function into which diagram services are injected
   *
   * @method Diagram#invoke
   *
   * @param {Function|Object[]} fn the function to resolve
   * @param {Object} locals a number of locals to use to resolve certain dependencies
   */
  this.invoke = injector.invoke;

  // init

  // indicate via event


  /**
   * An event indicating that all plug-ins are loaded.
   *
   * Use this event to fire other events to interested plug-ins
   *
   * @memberOf Diagram
   *
   * @event diagram.init
   *
   * @example
   *
   * eventBus.on('diagram.init', function() {
   *   eventBus.fire('my-custom-event', { foo: 'BAR' });
   * });
   *
   * @type {Object}
   */
  this.get('eventBus').fire('diagram.init');
}


/**
 * Destroys the diagram
 *
 * @method  Diagram#destroy
 */
Diagram.prototype.destroy = function() {
  this.get('eventBus').fire('diagram.destroy');
};

/**
 * Clear the diagram, removing all contents.
 */
Diagram.prototype.clear = function() {
  this.get('eventBus').fire('diagram.clear');
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/core/Canvas.js":
/*!****************************************************!*\
  !*** ./node_modules/diagram-js/lib/core/Canvas.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Canvas; });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_Collections__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Collections */ "./node_modules/diagram-js/lib/util/Collections.js");
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");











function round(number, resolution) {
  return Math.round(number * resolution) / resolution;
}

function ensurePx(number) {
  return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(number) ? number + 'px' : number;
}

/**
 * Creates a HTML container element for a SVG element with
 * the given configuration
 *
 * @param  {Object} options
 * @return {HTMLElement} the container element
 */
function createContainer(options) {

  options = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({}, { width: '100%', height: '100%' }, options);

  var container = options.container || document.body;

  // create a <div> around the svg element with the respective size
  // this way we can always get the correct container size
  // (this is impossible for <svg> elements at the moment)
  var parent = document.createElement('div');
  parent.setAttribute('class', 'djs-container');

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])(parent.style, {
    position: 'relative',
    overflow: 'hidden',
    width: ensurePx(options.width),
    height: ensurePx(options.height)
  });

  container.appendChild(parent);

  return parent;
}

function createGroup(parent, cls, childIndex) {
  var group = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_3__["create"])('g');
  Object(tiny_svg__WEBPACK_IMPORTED_MODULE_3__["classes"])(group).add(cls);

  var index = childIndex !== undefined ? childIndex : parent.childNodes.length - 1;

  // must ensure second argument is node or _null_
  // cf. https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore
  parent.insertBefore(group, parent.childNodes[index] || null);

  return group;
}

var BASE_LAYER = 'base';


var REQUIRED_MODEL_ATTRS = {
  shape: [ 'x', 'y', 'width', 'height' ],
  connection: [ 'waypoints' ]
};

/**
 * The main drawing canvas.
 *
 * @class
 * @constructor
 *
 * @emits Canvas#canvas.init
 *
 * @param {Object} config
 * @param {EventBus} eventBus
 * @param {GraphicsFactory} graphicsFactory
 * @param {ElementRegistry} elementRegistry
 */
function Canvas(config, eventBus, graphicsFactory, elementRegistry) {

  this._eventBus = eventBus;
  this._elementRegistry = elementRegistry;
  this._graphicsFactory = graphicsFactory;

  this._init(config || {});
}

Canvas.$inject = [
  'config.canvas',
  'eventBus',
  'graphicsFactory',
  'elementRegistry'
];


Canvas.prototype._init = function(config) {

  var eventBus = this._eventBus;

  // Creates a <svg> element that is wrapped into a <div>.
  // This way we are always able to correctly figure out the size of the svg element
  // by querying the parent node.
  //
  // (It is not possible to get the size of a svg element cross browser @ 2014-04-01)
  //
  // <div class="djs-container" style="width: {desired-width}, height: {desired-height}">
  //   <svg width="100%" height="100%">
  //    ...
  //   </svg>
  // </div>

  // html container
  var container = this._container = createContainer(config);

  var svg = this._svg = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_3__["create"])('svg');
  Object(tiny_svg__WEBPACK_IMPORTED_MODULE_3__["attr"])(svg, { width: '100%', height: '100%' });

  Object(tiny_svg__WEBPACK_IMPORTED_MODULE_3__["append"])(container, svg);

  var viewport = this._viewport = createGroup(svg, 'viewport');

  this._layers = {};

  // debounce canvas.viewbox.changed events
  // for smoother diagram interaction
  if (config.deferUpdate !== false) {
    this._viewboxChanged = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["debounce"])(Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["bind"])(this._viewboxChanged, this), 300);
  }

  eventBus.on('diagram.init', function() {

    /**
     * An event indicating that the canvas is ready to be drawn on.
     *
     * @memberOf Canvas
     *
     * @event canvas.init
     *
     * @type {Object}
     * @property {SVGElement} svg the created svg element
     * @property {SVGElement} viewport the direct parent of diagram elements and shapes
     */
    eventBus.fire('canvas.init', {
      svg: svg,
      viewport: viewport
    });

  }, this);

  // reset viewbox on shape changes to
  // recompute the viewbox
  eventBus.on([
    'shape.added',
    'connection.added',
    'shape.removed',
    'connection.removed',
    'elements.changed'
  ], function() {
    delete this._cachedViewbox;
  }, this);

  eventBus.on('diagram.destroy', 500, this._destroy, this);
  eventBus.on('diagram.clear', 500, this._clear, this);
};

Canvas.prototype._destroy = function(emit) {
  this._eventBus.fire('canvas.destroy', {
    svg: this._svg,
    viewport: this._viewport
  });

  var parent = this._container.parentNode;

  if (parent) {
    parent.removeChild(this._container);
  }

  delete this._svg;
  delete this._container;
  delete this._layers;
  delete this._rootElement;
  delete this._viewport;
};

Canvas.prototype._clear = function() {

  var self = this;

  var allElements = this._elementRegistry.getAll();

  // remove all elements
  allElements.forEach(function(element) {
    var type = Object(_util_Elements__WEBPACK_IMPORTED_MODULE_2__["getType"])(element);

    if (type === 'root') {
      self.setRootElement(null, true);
    } else {
      self._removeElement(element, type);
    }
  });

  // force recomputation of view box
  delete this._cachedViewbox;
};

/**
 * Returns the default layer on which
 * all elements are drawn.
 *
 * @returns {SVGElement}
 */
Canvas.prototype.getDefaultLayer = function() {
  return this.getLayer(BASE_LAYER, 0);
};

/**
 * Returns a layer that is used to draw elements
 * or annotations on it.
 *
 * Non-existing layers retrieved through this method
 * will be created. During creation, the optional index
 * may be used to create layers below or above existing layers.
 * A layer with a certain index is always created above all
 * existing layers with the same index.
 *
 * @param {String} name
 * @param {Number} index
 *
 * @returns {SVGElement}
 */
Canvas.prototype.getLayer = function(name, index) {

  if (!name) {
    throw new Error('must specify a name');
  }

  var layer = this._layers[name];

  if (!layer) {
    layer = this._layers[name] = this._createLayer(name, index);
  }

  // throw an error if layer creation / retrival is
  // requested on different index
  if (typeof index !== 'undefined' && layer.index !== index) {
    throw new Error('layer <' + name + '> already created at index <' + index + '>');
  }

  return layer.group;
};

/**
 * Creates a given layer and returns it.
 *
 * @param {String} name
 * @param {Number} [index=0]
 *
 * @return {Object} layer descriptor with { index, group: SVGGroup }
 */
Canvas.prototype._createLayer = function(name, index) {

  if (!index) {
    index = 0;
  }

  var childIndex = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["reduce"])(this._layers, function(childIndex, layer) {
    if (index >= layer.index) {
      childIndex++;
    }

    return childIndex;
  }, 0);

  return {
    group: createGroup(this._viewport, 'layer-' + name, childIndex),
    index: index
  };

};

/**
 * Returns the html element that encloses the
 * drawing canvas.
 *
 * @return {DOMNode}
 */
Canvas.prototype.getContainer = function() {
  return this._container;
};


// markers //////////////////////

Canvas.prototype._updateMarker = function(element, marker, add) {
  var container;

  if (!element.id) {
    element = this._elementRegistry.get(element);
  }

  // we need to access all
  container = this._elementRegistry._elements[element.id];

  if (!container) {
    return;
  }

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])([ container.gfx, container.secondaryGfx ], function(gfx) {
    if (gfx) {

      // invoke either addClass or removeClass based on mode
      if (add) {
        Object(tiny_svg__WEBPACK_IMPORTED_MODULE_3__["classes"])(gfx).add(marker);
      } else {
        Object(tiny_svg__WEBPACK_IMPORTED_MODULE_3__["classes"])(gfx).remove(marker);
      }
    }
  });

  /**
   * An event indicating that a marker has been updated for an element
   *
   * @event element.marker.update
   * @type {Object}
   * @property {djs.model.Element} element the shape
   * @property {Object} gfx the graphical representation of the shape
   * @property {String} marker
   * @property {Boolean} add true if the marker was added, false if it got removed
   */
  this._eventBus.fire('element.marker.update', { element: element, gfx: container.gfx, marker: marker, add: !!add });
};


/**
 * Adds a marker to an element (basically a css class).
 *
 * Fires the element.marker.update event, making it possible to
 * integrate extension into the marker life-cycle, too.
 *
 * @example
 * canvas.addMarker('foo', 'some-marker');
 *
 * var fooGfx = canvas.getGraphics('foo');
 *
 * fooGfx; // <g class="... some-marker"> ... </g>
 *
 * @param {String|djs.model.Base} element
 * @param {String} marker
 */
Canvas.prototype.addMarker = function(element, marker) {
  this._updateMarker(element, marker, true);
};


/**
 * Remove a marker from an element.
 *
 * Fires the element.marker.update event, making it possible to
 * integrate extension into the marker life-cycle, too.
 *
 * @param  {String|djs.model.Base} element
 * @param  {String} marker
 */
Canvas.prototype.removeMarker = function(element, marker) {
  this._updateMarker(element, marker, false);
};

/**
 * Check the existence of a marker on element.
 *
 * @param  {String|djs.model.Base} element
 * @param  {String} marker
 */
Canvas.prototype.hasMarker = function(element, marker) {
  if (!element.id) {
    element = this._elementRegistry.get(element);
  }

  var gfx = this.getGraphics(element);

  return Object(tiny_svg__WEBPACK_IMPORTED_MODULE_3__["classes"])(gfx).has(marker);
};

/**
 * Toggles a marker on an element.
 *
 * Fires the element.marker.update event, making it possible to
 * integrate extension into the marker life-cycle, too.
 *
 * @param  {String|djs.model.Base} element
 * @param  {String} marker
 */
Canvas.prototype.toggleMarker = function(element, marker) {
  if (this.hasMarker(element, marker)) {
    this.removeMarker(element, marker);
  } else {
    this.addMarker(element, marker);
  }
};

Canvas.prototype.getRootElement = function() {
  if (!this._rootElement) {
    this.setRootElement({ id: '__implicitroot', children: [] });
  }

  return this._rootElement;
};



// root element handling //////////////////////

/**
 * Sets a given element as the new root element for the canvas
 * and returns the new root element.
 *
 * @param {Object|djs.model.Root} element
 * @param {Boolean} [override] whether to override the current root element, if any
 *
 * @return {Object|djs.model.Root} new root element
 */
Canvas.prototype.setRootElement = function(element, override) {

  if (element) {
    this._ensureValid('root', element);
  }

  var currentRoot = this._rootElement,
      elementRegistry = this._elementRegistry,
      eventBus = this._eventBus;

  if (currentRoot) {
    if (!override) {
      throw new Error('rootElement already set, need to specify override');
    }

    // simulate element remove event sequence
    eventBus.fire('root.remove', { element: currentRoot });
    eventBus.fire('root.removed', { element: currentRoot });

    elementRegistry.remove(currentRoot);
  }

  if (element) {
    var gfx = this.getDefaultLayer();

    // resemble element add event sequence
    eventBus.fire('root.add', { element: element });

    elementRegistry.add(element, gfx, this._svg);

    eventBus.fire('root.added', { element: element, gfx: gfx });
  }

  this._rootElement = element;

  return element;
};



// add functionality //////////////////////

Canvas.prototype._ensureValid = function(type, element) {
  if (!element.id) {
    throw new Error('element must have an id');
  }

  if (this._elementRegistry.get(element.id)) {
    throw new Error('element with id ' + element.id + ' already exists');
  }

  var requiredAttrs = REQUIRED_MODEL_ATTRS[type];

  var valid = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["every"])(requiredAttrs, function(attr) {
    return typeof element[attr] !== 'undefined';
  });

  if (!valid) {
    throw new Error(
      'must supply { ' + requiredAttrs.join(', ') + ' } with ' + type);
  }
};

Canvas.prototype._setParent = function(element, parent, parentIndex) {
  Object(_util_Collections__WEBPACK_IMPORTED_MODULE_1__["add"])(parent.children, element, parentIndex);
  element.parent = parent;
};

/**
 * Adds an element to the canvas.
 *
 * This wires the parent <-> child relationship between the element and
 * a explicitly specified parent or an implicit root element.
 *
 * During add it emits the events
 *
 *  * <{type}.add> (element, parent)
 *  * <{type}.added> (element, gfx)
 *
 * Extensions may hook into these events to perform their magic.
 *
 * @param {String} type
 * @param {Object|djs.model.Base} element
 * @param {Object|djs.model.Base} [parent]
 * @param {Number} [parentIndex]
 *
 * @return {Object|djs.model.Base} the added element
 */
Canvas.prototype._addElement = function(type, element, parent, parentIndex) {

  parent = parent || this.getRootElement();

  var eventBus = this._eventBus,
      graphicsFactory = this._graphicsFactory;

  this._ensureValid(type, element);

  eventBus.fire(type + '.add', { element: element, parent: parent });

  this._setParent(element, parent, parentIndex);

  // create graphics
  var gfx = graphicsFactory.create(type, element, parentIndex);

  this._elementRegistry.add(element, gfx);

  // update its visual
  graphicsFactory.update(type, element, gfx);

  eventBus.fire(type + '.added', { element: element, gfx: gfx });

  return element;
};

/**
 * Adds a shape to the canvas
 *
 * @param {Object|djs.model.Shape} shape to add to the diagram
 * @param {djs.model.Base} [parent]
 * @param {Number} [parentIndex]
 *
 * @return {djs.model.Shape} the added shape
 */
Canvas.prototype.addShape = function(shape, parent, parentIndex) {
  return this._addElement('shape', shape, parent, parentIndex);
};

/**
 * Adds a connection to the canvas
 *
 * @param {Object|djs.model.Connection} connection to add to the diagram
 * @param {djs.model.Base} [parent]
 * @param {Number} [parentIndex]
 *
 * @return {djs.model.Connection} the added connection
 */
Canvas.prototype.addConnection = function(connection, parent, parentIndex) {
  return this._addElement('connection', connection, parent, parentIndex);
};


/**
 * Internal remove element
 */
Canvas.prototype._removeElement = function(element, type) {

  var elementRegistry = this._elementRegistry,
      graphicsFactory = this._graphicsFactory,
      eventBus = this._eventBus;

  element = elementRegistry.get(element.id || element);

  if (!element) {

    // element was removed already
    return;
  }

  eventBus.fire(type + '.remove', { element: element });

  graphicsFactory.remove(element);

  // unset parent <-> child relationship
  Object(_util_Collections__WEBPACK_IMPORTED_MODULE_1__["remove"])(element.parent && element.parent.children, element);
  element.parent = null;

  eventBus.fire(type + '.removed', { element: element });

  elementRegistry.remove(element);

  return element;
};


/**
 * Removes a shape from the canvas
 *
 * @param {String|djs.model.Shape} shape or shape id to be removed
 *
 * @return {djs.model.Shape} the removed shape
 */
Canvas.prototype.removeShape = function(shape) {

  /**
   * An event indicating that a shape is about to be removed from the canvas.
   *
   * @memberOf Canvas
   *
   * @event shape.remove
   * @type {Object}
   * @property {djs.model.Shape} element the shape descriptor
   * @property {Object} gfx the graphical representation of the shape
   */

  /**
   * An event indicating that a shape has been removed from the canvas.
   *
   * @memberOf Canvas
   *
   * @event shape.removed
   * @type {Object}
   * @property {djs.model.Shape} element the shape descriptor
   * @property {Object} gfx the graphical representation of the shape
   */
  return this._removeElement(shape, 'shape');
};


/**
 * Removes a connection from the canvas
 *
 * @param {String|djs.model.Connection} connection or connection id to be removed
 *
 * @return {djs.model.Connection} the removed connection
 */
Canvas.prototype.removeConnection = function(connection) {

  /**
   * An event indicating that a connection is about to be removed from the canvas.
   *
   * @memberOf Canvas
   *
   * @event connection.remove
   * @type {Object}
   * @property {djs.model.Connection} element the connection descriptor
   * @property {Object} gfx the graphical representation of the connection
   */

  /**
   * An event indicating that a connection has been removed from the canvas.
   *
   * @memberOf Canvas
   *
   * @event connection.removed
   * @type {Object}
   * @property {djs.model.Connection} element the connection descriptor
   * @property {Object} gfx the graphical representation of the connection
   */
  return this._removeElement(connection, 'connection');
};


/**
 * Return the graphical object underlaying a certain diagram element
 *
 * @param {String|djs.model.Base} element descriptor of the element
 * @param {Boolean} [secondary=false] whether to return the secondary connected element
 *
 * @return {SVGElement}
 */
Canvas.prototype.getGraphics = function(element, secondary) {
  return this._elementRegistry.getGraphics(element, secondary);
};


/**
 * Perform a viewbox update via a given change function.
 *
 * @param {Function} changeFn
 */
Canvas.prototype._changeViewbox = function(changeFn) {

  // notify others of the upcoming viewbox change
  this._eventBus.fire('canvas.viewbox.changing');

  // perform actual change
  changeFn.apply(this);

  // reset the cached viewbox so that
  // a new get operation on viewbox or zoom
  // triggers a viewbox re-computation
  this._cachedViewbox = null;

  // notify others of the change; this step
  // may or may not be debounced
  this._viewboxChanged();
};

Canvas.prototype._viewboxChanged = function() {
  this._eventBus.fire('canvas.viewbox.changed', { viewbox: this.viewbox() });
};


/**
 * Gets or sets the view box of the canvas, i.e. the
 * area that is currently displayed.
 *
 * The getter may return a cached viewbox (if it is currently
 * changing). To force a recomputation, pass `false` as the first argument.
 *
 * @example
 *
 * canvas.viewbox({ x: 100, y: 100, width: 500, height: 500 })
 *
 * // sets the visible area of the diagram to (100|100) -> (600|100)
 * // and and scales it according to the diagram width
 *
 * var viewbox = canvas.viewbox(); // pass `false` to force recomputing the box.
 *
 * console.log(viewbox);
 * // {
 * //   inner: Dimensions,
 * //   outer: Dimensions,
 * //   scale,
 * //   x, y,
 * //   width, height
 * // }
 *
 * // if the current diagram is zoomed and scrolled, you may reset it to the
 * // default zoom via this method, too:
 *
 * var zoomedAndScrolledViewbox = canvas.viewbox();
 *
 * canvas.viewbox({
 *   x: 0,
 *   y: 0,
 *   width: zoomedAndScrolledViewbox.outer.width,
 *   height: zoomedAndScrolledViewbox.outer.height
 * });
 *
 * @param  {Object} [box] the new view box to set
 * @param  {Number} box.x the top left X coordinate of the canvas visible in view box
 * @param  {Number} box.y the top left Y coordinate of the canvas visible in view box
 * @param  {Number} box.width the visible width
 * @param  {Number} box.height
 *
 * @return {Object} the current view box
 */
Canvas.prototype.viewbox = function(box) {

  if (box === undefined && this._cachedViewbox) {
    return this._cachedViewbox;
  }

  var viewport = this._viewport,
      innerBox,
      outerBox = this.getSize(),
      matrix,
      transform,
      scale,
      x, y;

  if (!box) {

    // compute the inner box based on the
    // diagrams default layer. This allows us to exclude
    // external components, such as overlays
    innerBox = this.getDefaultLayer().getBBox();

    transform = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_3__["transform"])(viewport);
    matrix = transform ? transform.matrix : Object(tiny_svg__WEBPACK_IMPORTED_MODULE_3__["createMatrix"])();
    scale = round(matrix.a, 1000);

    x = round(-matrix.e || 0, 1000);
    y = round(-matrix.f || 0, 1000);

    box = this._cachedViewbox = {
      x: x ? x / scale : 0,
      y: y ? y / scale : 0,
      width: outerBox.width / scale,
      height: outerBox.height / scale,
      scale: scale,
      inner: {
        width: innerBox.width,
        height: innerBox.height,
        x: innerBox.x,
        y: innerBox.y
      },
      outer: outerBox
    };

    return box;
  } else {

    this._changeViewbox(function() {
      scale = Math.min(outerBox.width / box.width, outerBox.height / box.height);

      var matrix = this._svg.createSVGMatrix()
        .scale(scale)
        .translate(-box.x, -box.y);

      Object(tiny_svg__WEBPACK_IMPORTED_MODULE_3__["transform"])(viewport, matrix);
    });
  }

  return box;
};


/**
 * Gets or sets the scroll of the canvas.
 *
 * @param {Object} [delta] the new scroll to apply.
 *
 * @param {Number} [delta.dx]
 * @param {Number} [delta.dy]
 */
Canvas.prototype.scroll = function(delta) {

  var node = this._viewport;
  var matrix = node.getCTM();

  if (delta) {
    this._changeViewbox(function() {
      delta = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({ dx: 0, dy: 0 }, delta || {});

      matrix = this._svg.createSVGMatrix().translate(delta.dx, delta.dy).multiply(matrix);

      setCTM(node, matrix);
    });
  }

  return { x: matrix.e, y: matrix.f };
};


/**
 * Gets or sets the current zoom of the canvas, optionally zooming
 * to the specified position.
 *
 * The getter may return a cached zoom level. Call it with `false` as
 * the first argument to force recomputation of the current level.
 *
 * @param {String|Number} [newScale] the new zoom level, either a number, i.e. 0.9,
 *                                   or `fit-viewport` to adjust the size to fit the current viewport
 * @param {String|Point} [center] the reference point { x: .., y: ..} to zoom to, 'auto' to zoom into mid or null
 *
 * @return {Number} the current scale
 */
Canvas.prototype.zoom = function(newScale, center) {

  if (!newScale) {
    return this.viewbox(newScale).scale;
  }

  if (newScale === 'fit-viewport') {
    return this._fitViewport(center);
  }

  var outer,
      matrix;

  this._changeViewbox(function() {

    if (typeof center !== 'object') {
      outer = this.viewbox().outer;

      center = {
        x: outer.width / 2,
        y: outer.height / 2
      };
    }

    matrix = this._setZoom(newScale, center);
  });

  return round(matrix.a, 1000);
};

function setCTM(node, m) {
  var mstr = 'matrix(' + m.a + ',' + m.b + ',' + m.c + ',' + m.d + ',' + m.e + ',' + m.f + ')';
  node.setAttribute('transform', mstr);
}

Canvas.prototype._fitViewport = function(center) {

  var vbox = this.viewbox(),
      outer = vbox.outer,
      inner = vbox.inner,
      newScale,
      newViewbox;

  // display the complete diagram without zooming in.
  // instead of relying on internal zoom, we perform a
  // hard reset on the canvas viewbox to realize this
  //
  // if diagram does not need to be zoomed in, we focus it around
  // the diagram origin instead

  if (inner.x >= 0 &&
      inner.y >= 0 &&
      inner.x + inner.width <= outer.width &&
      inner.y + inner.height <= outer.height &&
      !center) {

    newViewbox = {
      x: 0,
      y: 0,
      width: Math.max(inner.width + inner.x, outer.width),
      height: Math.max(inner.height + inner.y, outer.height)
    };
  } else {

    newScale = Math.min(1, outer.width / inner.width, outer.height / inner.height);
    newViewbox = {
      x: inner.x + (center ? inner.width / 2 - outer.width / newScale / 2 : 0),
      y: inner.y + (center ? inner.height / 2 - outer.height / newScale / 2 : 0),
      width: outer.width / newScale,
      height: outer.height / newScale
    };
  }

  this.viewbox(newViewbox);

  return this.viewbox(false).scale;
};


Canvas.prototype._setZoom = function(scale, center) {

  var svg = this._svg,
      viewport = this._viewport;

  var matrix = svg.createSVGMatrix();
  var point = svg.createSVGPoint();

  var centerPoint,
      originalPoint,
      currentMatrix,
      scaleMatrix,
      newMatrix;

  currentMatrix = viewport.getCTM();

  var currentScale = currentMatrix.a;

  if (center) {
    centerPoint = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])(point, center);

    // revert applied viewport transformations
    originalPoint = centerPoint.matrixTransform(currentMatrix.inverse());

    // create scale matrix
    scaleMatrix = matrix
      .translate(originalPoint.x, originalPoint.y)
      .scale(1 / currentScale * scale)
      .translate(-originalPoint.x, -originalPoint.y);

    newMatrix = currentMatrix.multiply(scaleMatrix);
  } else {
    newMatrix = matrix.scale(scale);
  }

  setCTM(this._viewport, newMatrix);

  return newMatrix;
};


/**
 * Returns the size of the canvas
 *
 * @return {Dimensions}
 */
Canvas.prototype.getSize = function() {
  return {
    width: this._container.clientWidth,
    height: this._container.clientHeight
  };
};


/**
 * Return the absolute bounding box for the given element
 *
 * The absolute bounding box may be used to display overlays in the
 * callers (browser) coordinate system rather than the zoomed in/out
 * canvas coordinates.
 *
 * @param  {ElementDescriptor} element
 * @return {Bounds} the absolute bounding box
 */
Canvas.prototype.getAbsoluteBBox = function(element) {
  var vbox = this.viewbox();
  var bbox;

  // connection
  // use svg bbox
  if (element.waypoints) {
    var gfx = this.getGraphics(element);

    bbox = gfx.getBBox();
  }

  // shapes
  // use data
  else {
    bbox = element;
  }

  var x = bbox.x * vbox.scale - vbox.x * vbox.scale;
  var y = bbox.y * vbox.scale - vbox.y * vbox.scale;

  var width = bbox.width * vbox.scale;
  var height = bbox.height * vbox.scale;

  return {
    x: x,
    y: y,
    width: width,
    height: height
  };
};

/**
 * Fires an event in order other modules can react to the
 * canvas resizing
 */
Canvas.prototype.resized = function() {

  // force recomputation of view box
  delete this._cachedViewbox;

  this._eventBus.fire('canvas.resized');
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/core/ElementFactory.js":
/*!************************************************************!*\
  !*** ./node_modules/diagram-js/lib/core/ElementFactory.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ElementFactory; });
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model */ "./node_modules/diagram-js/lib/model/index.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");




/**
 * A factory for diagram-js shapes
 */
function ElementFactory() {
  this._uid = 12;
}


ElementFactory.prototype.createRoot = function(attrs) {
  return this.create('root', attrs);
};

ElementFactory.prototype.createLabel = function(attrs) {
  return this.create('label', attrs);
};

ElementFactory.prototype.createShape = function(attrs) {
  return this.create('shape', attrs);
};

ElementFactory.prototype.createConnection = function(attrs) {
  return this.create('connection', attrs);
};

/**
 * Create a model element with the given type and
 * a number of pre-set attributes.
 *
 * @param  {String} type
 * @param  {Object} attrs
 * @return {djs.model.Base} the newly created model instance
 */
ElementFactory.prototype.create = function(type, attrs) {

  attrs = Object(min_dash__WEBPACK_IMPORTED_MODULE_1__["assign"])({}, attrs || {});

  if (!attrs.id) {
    attrs.id = type + '_' + (this._uid++);
  }

  return Object(_model__WEBPACK_IMPORTED_MODULE_0__["create"])(type, attrs);
};

/***/ }),

/***/ "./node_modules/diagram-js/lib/core/ElementRegistry.js":
/*!*************************************************************!*\
  !*** ./node_modules/diagram-js/lib/core/ElementRegistry.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ElementRegistry; });
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
var ELEMENT_ID = 'data-element-id';




/**
 * @class
 *
 * A registry that keeps track of all shapes in the diagram.
 */
function ElementRegistry(eventBus) {
  this._elements = {};

  this._eventBus = eventBus;
}

ElementRegistry.$inject = [ 'eventBus' ];

/**
 * Register a pair of (element, gfx, (secondaryGfx)).
 *
 * @param {djs.model.Base} element
 * @param {SVGElement} gfx
 * @param {SVGElement} [secondaryGfx] optional other element to register, too
 */
ElementRegistry.prototype.add = function(element, gfx, secondaryGfx) {

  var id = element.id;

  this._validateId(id);

  // associate dom node with element
  Object(tiny_svg__WEBPACK_IMPORTED_MODULE_0__["attr"])(gfx, ELEMENT_ID, id);

  if (secondaryGfx) {
    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_0__["attr"])(secondaryGfx, ELEMENT_ID, id);
  }

  this._elements[id] = { element: element, gfx: gfx, secondaryGfx: secondaryGfx };
};

/**
 * Removes an element from the registry.
 *
 * @param {djs.model.Base} element
 */
ElementRegistry.prototype.remove = function(element) {
  var elements = this._elements,
      id = element.id || element,
      container = id && elements[id];

  if (container) {

    // unset element id on gfx
    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_0__["attr"])(container.gfx, ELEMENT_ID, '');

    if (container.secondaryGfx) {
      Object(tiny_svg__WEBPACK_IMPORTED_MODULE_0__["attr"])(container.secondaryGfx, ELEMENT_ID, '');
    }

    delete elements[id];
  }
};

/**
 * Update the id of an element
 *
 * @param {djs.model.Base} element
 * @param {String} newId
 */
ElementRegistry.prototype.updateId = function(element, newId) {

  this._validateId(newId);

  if (typeof element === 'string') {
    element = this.get(element);
  }

  this._eventBus.fire('element.updateId', {
    element: element,
    newId: newId
  });

  var gfx = this.getGraphics(element),
      secondaryGfx = this.getGraphics(element, true);

  this.remove(element);

  element.id = newId;

  this.add(element, gfx, secondaryGfx);
};

/**
 * Return the model element for a given id or graphics.
 *
 * @example
 *
 * elementRegistry.get('SomeElementId_1');
 * elementRegistry.get(gfx);
 *
 *
 * @param {String|SVGElement} filter for selecting the element
 *
 * @return {djs.model.Base}
 */
ElementRegistry.prototype.get = function(filter) {
  var id;

  if (typeof filter === 'string') {
    id = filter;
  } else {
    id = filter && Object(tiny_svg__WEBPACK_IMPORTED_MODULE_0__["attr"])(filter, ELEMENT_ID);
  }

  var container = this._elements[id];
  return container && container.element;
};

/**
 * Return all elements that match a given filter function.
 *
 * @param {Function} fn
 *
 * @return {Array<djs.model.Base>}
 */
ElementRegistry.prototype.filter = function(fn) {

  var filtered = [];

  this.forEach(function(element, gfx) {
    if (fn(element, gfx)) {
      filtered.push(element);
    }
  });

  return filtered;
};

/**
 * Return all rendered model elements.
 *
 * @return {Array<djs.model.Base>}
 */
ElementRegistry.prototype.getAll = function() {
  return this.filter(function(e) { return e; });
};

/**
 * Iterate over all diagram elements.
 *
 * @param {Function} fn
 */
ElementRegistry.prototype.forEach = function(fn) {

  var map = this._elements;

  Object.keys(map).forEach(function(id) {
    var container = map[id],
        element = container.element,
        gfx = container.gfx;

    return fn(element, gfx);
  });
};

/**
 * Return the graphical representation of an element or its id.
 *
 * @example
 * elementRegistry.getGraphics('SomeElementId_1');
 * elementRegistry.getGraphics(rootElement); // <g ...>
 *
 * elementRegistry.getGraphics(rootElement, true); // <svg ...>
 *
 *
 * @param {String|djs.model.Base} filter
 * @param {Boolean} [secondary=false] whether to return the secondary connected element
 *
 * @return {SVGElement}
 */
ElementRegistry.prototype.getGraphics = function(filter, secondary) {
  var id = filter.id || filter;

  var container = this._elements[id];
  return container && (secondary ? container.secondaryGfx : container.gfx);
};

/**
 * Validate the suitability of the given id and signals a problem
 * with an exception.
 *
 * @param {String} id
 *
 * @throws {Error} if id is empty or already assigned
 */
ElementRegistry.prototype._validateId = function(id) {
  if (!id) {
    throw new Error('element must have an id');
  }

  if (this._elements[id]) {
    throw new Error('element with id ' + id + ' already added');
  }
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/core/EventBus.js":
/*!******************************************************!*\
  !*** ./node_modules/diagram-js/lib/core/EventBus.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EventBus; });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


var FN_REF = '__fn';

var DEFAULT_PRIORITY = 1000;

var slice = Array.prototype.slice;

/**
 * A general purpose event bus.
 *
 * This component is used to communicate across a diagram instance.
 * Other parts of a diagram can use it to listen to and broadcast events.
 *
 *
 * ## Registering for Events
 *
 * The event bus provides the {@link EventBus#on} and {@link EventBus#once}
 * methods to register for events. {@link EventBus#off} can be used to
 * remove event registrations. Listeners receive an instance of {@link Event}
 * as the first argument. It allows them to hook into the event execution.
 *
 * ```javascript
 *
 * // listen for event
 * eventBus.on('foo', function(event) {
 *
 *   // access event type
 *   event.type; // 'foo'
 *
 *   // stop propagation to other listeners
 *   event.stopPropagation();
 *
 *   // prevent event default
 *   event.preventDefault();
 * });
 *
 * // listen for event with custom payload
 * eventBus.on('bar', function(event, payload) {
 *   console.log(payload);
 * });
 *
 * // listen for event returning value
 * eventBus.on('foobar', function(event) {
 *
 *   // stop event propagation + prevent default
 *   return false;
 *
 *   // stop event propagation + return custom result
 *   return {
 *     complex: 'listening result'
 *   };
 * });
 *
 *
 * // listen with custom priority (default=1000, higher is better)
 * eventBus.on('priorityfoo', 1500, function(event) {
 *   console.log('invoked first!');
 * });
 *
 *
 * // listen for event and pass the context (`this`)
 * eventBus.on('foobar', function(event) {
 *   this.foo();
 * }, this);
 * ```
 *
 *
 * ## Emitting Events
 *
 * Events can be emitted via the event bus using {@link EventBus#fire}.
 *
 * ```javascript
 *
 * // false indicates that the default action
 * // was prevented by listeners
 * if (eventBus.fire('foo') === false) {
 *   console.log('default has been prevented!');
 * };
 *
 *
 * // custom args + return value listener
 * eventBus.on('sum', function(event, a, b) {
 *   return a + b;
 * });
 *
 * // you can pass custom arguments + retrieve result values.
 * var sum = eventBus.fire('sum', 1, 2);
 * console.log(sum); // 3
 * ```
 */
function EventBus() {
  this._listeners = {};

  // cleanup on destroy on lowest priority to allow
  // message passing until the bitter end
  this.on('diagram.destroy', 1, this._destroy, this);
}


/**
 * Register an event listener for events with the given name.
 *
 * The callback will be invoked with `event, ...additionalArguments`
 * that have been passed to {@link EventBus#fire}.
 *
 * Returning false from a listener will prevent the events default action
 * (if any is specified). To stop an event from being processed further in
 * other listeners execute {@link Event#stopPropagation}.
 *
 * Returning anything but `undefined` from a listener will stop the listener propagation.
 *
 * @param {String|Array<String>} events
 * @param {Number} [priority=1000] the priority in which this listener is called, larger is higher
 * @param {Function} callback
 * @param {Object} [that] Pass context (`this`) to the callback
 */
EventBus.prototype.on = function(events, priority, callback, that) {

  events = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isArray"])(events) ? events : [ events ];

  if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(priority)) {
    that = callback;
    callback = priority;
    priority = DEFAULT_PRIORITY;
  }

  if (!Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(priority)) {
    throw new Error('priority must be a number');
  }

  var actualCallback = callback;

  if (that) {
    actualCallback = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["bind"])(callback, that);

    // make sure we remember and are able to remove
    // bound callbacks via {@link #off} using the original
    // callback
    actualCallback[FN_REF] = callback[FN_REF] || callback;
  }

  var self = this;

  events.forEach(function(e) {
    self._addListener(e, {
      priority: priority,
      callback: actualCallback,
      next: null
    });
  });
};


/**
 * Register an event listener that is executed only once.
 *
 * @param {String} event the event name to register for
 * @param {Number} [priority=1000] the priority in which this listener is called, larger is higher
 * @param {Function} callback the callback to execute
 * @param {Object} [that] Pass context (`this`) to the callback
 */
EventBus.prototype.once = function(event, priority, callback, that) {
  var self = this;

  if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(priority)) {
    that = callback;
    callback = priority;
    priority = DEFAULT_PRIORITY;
  }

  if (!Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(priority)) {
    throw new Error('priority must be a number');
  }

  function wrappedCallback() {
    var result = callback.apply(that, arguments);

    self.off(event, wrappedCallback);

    return result;
  }

  // make sure we remember and are able to remove
  // bound callbacks via {@link #off} using the original
  // callback
  wrappedCallback[FN_REF] = callback;

  this.on(event, priority, wrappedCallback);
};


/**
 * Removes event listeners by event and callback.
 *
 * If no callback is given, all listeners for a given event name are being removed.
 *
 * @param {String|Array<String>} events
 * @param {Function} [callback]
 */
EventBus.prototype.off = function(events, callback) {

  events = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isArray"])(events) ? events : [ events ];

  var self = this;

  events.forEach(function(event) {
    self._removeListener(event, callback);
  });

};


/**
 * Create an EventBus event.
 *
 * @param {Object} data
 *
 * @return {Object} event, recognized by the eventBus
 */
EventBus.prototype.createEvent = function(data) {
  var event = new InternalEvent();

  event.init(data);

  return event;
};


/**
 * Fires a named event.
 *
 * @example
 *
 * // fire event by name
 * events.fire('foo');
 *
 * // fire event object with nested type
 * var event = { type: 'foo' };
 * events.fire(event);
 *
 * // fire event with explicit type
 * var event = { x: 10, y: 20 };
 * events.fire('element.moved', event);
 *
 * // pass additional arguments to the event
 * events.on('foo', function(event, bar) {
 *   alert(bar);
 * });
 *
 * events.fire({ type: 'foo' }, 'I am bar!');
 *
 * @param {String} [name] the optional event name
 * @param {Object} [event] the event object
 * @param {...Object} additional arguments to be passed to the callback functions
 *
 * @return {Boolean} the events return value, if specified or false if the
 *                   default action was prevented by listeners
 */
EventBus.prototype.fire = function(type, data) {
  var event,
      firstListener,
      returnValue,
      args;

  args = slice.call(arguments);

  if (typeof type === 'object') {
    data = type;
    type = data.type;
  }

  if (!type) {
    throw new Error('no event type specified');
  }

  firstListener = this._listeners[type];

  if (!firstListener) {
    return;
  }

  // we make sure we fire instances of our home made
  // events here. We wrap them only once, though
  if (data instanceof InternalEvent) {

    // we are fine, we alread have an event
    event = data;
  } else {
    event = this.createEvent(data);
  }

  // ensure we pass the event as the first parameter
  args[0] = event;

  // original event type (in case we delegate)
  var originalType = event.type;

  // update event type before delegation
  if (type !== originalType) {
    event.type = type;
  }

  try {
    returnValue = this._invokeListeners(event, args, firstListener);
  } finally {

    // reset event type after delegation
    if (type !== originalType) {
      event.type = originalType;
    }
  }

  // set the return value to false if the event default
  // got prevented and no other return value exists
  if (returnValue === undefined && event.defaultPrevented) {
    returnValue = false;
  }

  return returnValue;
};


EventBus.prototype.handleError = function(error) {
  return this.fire('error', { error: error }) === false;
};


EventBus.prototype._destroy = function() {
  this._listeners = {};
};

EventBus.prototype._invokeListeners = function(event, args, listener) {

  var returnValue;

  while (listener) {

    // handle stopped propagation
    if (event.cancelBubble) {
      break;
    }

    returnValue = this._invokeListener(event, args, listener);

    listener = listener.next;
  }

  return returnValue;
};

EventBus.prototype._invokeListener = function(event, args, listener) {

  var returnValue;

  try {

    // returning false prevents the default action
    returnValue = invokeFunction(listener.callback, args);

    // stop propagation on return value
    if (returnValue !== undefined) {
      event.returnValue = returnValue;
      event.stopPropagation();
    }

    // prevent default on return false
    if (returnValue === false) {
      event.preventDefault();
    }
  } catch (e) {
    if (!this.handleError(e)) {
      console.error('unhandled error in event listener');
      console.error(e.stack);

      throw e;
    }
  }

  return returnValue;
};

/*
 * Add new listener with a certain priority to the list
 * of listeners (for the given event).
 *
 * The semantics of listener registration / listener execution are
 * first register, first serve: New listeners will always be inserted
 * after existing listeners with the same priority.
 *
 * Example: Inserting two listeners with priority 1000 and 1300
 *
 *    * before: [ 1500, 1500, 1000, 1000 ]
 *    * after: [ 1500, 1500, (new=1300), 1000, 1000, (new=1000) ]
 *
 * @param {String} event
 * @param {Object} listener { priority, callback }
 */
EventBus.prototype._addListener = function(event, newListener) {

  var listener = this._getListeners(event),
      previousListener;

  // no prior listeners
  if (!listener) {
    this._setListeners(event, newListener);

    return;
  }

  // ensure we order listeners by priority from
  // 0 (high) to n > 0 (low)
  while (listener) {

    if (listener.priority < newListener.priority) {

      newListener.next = listener;

      if (previousListener) {
        previousListener.next = newListener;
      } else {
        this._setListeners(event, newListener);
      }

      return;
    }

    previousListener = listener;
    listener = listener.next;
  }

  // add new listener to back
  previousListener.next = newListener;
};


EventBus.prototype._getListeners = function(name) {
  return this._listeners[name];
};

EventBus.prototype._setListeners = function(name, listener) {
  this._listeners[name] = listener;
};

EventBus.prototype._removeListener = function(event, callback) {

  var listener = this._getListeners(event),
      nextListener,
      previousListener,
      listenerCallback;

  if (!callback) {

    // clear listeners
    this._setListeners(event, null);

    return;
  }

  while (listener) {

    nextListener = listener.next;

    listenerCallback = listener.callback;

    if (listenerCallback === callback || listenerCallback[FN_REF] === callback) {
      if (previousListener) {
        previousListener.next = nextListener;
      } else {

        // new first listener
        this._setListeners(event, nextListener);
      }
    }

    previousListener = listener;
    listener = nextListener;
  }
};

/**
 * A event that is emitted via the event bus.
 */
function InternalEvent() { }

InternalEvent.prototype.stopPropagation = function() {
  this.cancelBubble = true;
};

InternalEvent.prototype.preventDefault = function() {
  this.defaultPrevented = true;
};

InternalEvent.prototype.init = function(data) {
  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])(this, data || {});
};


/**
 * Invoke function. Be fast...
 *
 * @param {Function} fn
 * @param {Array<Object>} args
 *
 * @return {Any}
 */
function invokeFunction(fn, args) {
  return fn.apply(null, args);
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/core/GraphicsFactory.js":
/*!*************************************************************!*\
  !*** ./node_modules/diagram-js/lib/core/GraphicsFactory.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GraphicsFactory; });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_GraphicsUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/GraphicsUtil */ "./node_modules/diagram-js/lib/util/GraphicsUtil.js");
/* harmony import */ var _util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/SvgTransformUtil */ "./node_modules/diagram-js/lib/util/SvgTransformUtil.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");












/**
 * A factory that creates graphical elements
 *
 * @param {EventBus} eventBus
 * @param {ElementRegistry} elementRegistry
 */
function GraphicsFactory(eventBus, elementRegistry) {
  this._eventBus = eventBus;
  this._elementRegistry = elementRegistry;
}

GraphicsFactory.$inject = [ 'eventBus' , 'elementRegistry' ];


GraphicsFactory.prototype._getChildrenContainer = function(element) {

  var gfx = this._elementRegistry.getGraphics(element);

  var childrenGfx;

  // root element
  if (!element.parent) {
    childrenGfx = gfx;
  } else {
    childrenGfx = Object(_util_GraphicsUtil__WEBPACK_IMPORTED_MODULE_1__["getChildren"])(gfx);
    if (!childrenGfx) {
      childrenGfx = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_4__["create"])('g');
      Object(tiny_svg__WEBPACK_IMPORTED_MODULE_4__["classes"])(childrenGfx).add('djs-children');

      Object(tiny_svg__WEBPACK_IMPORTED_MODULE_4__["append"])(gfx.parentNode, childrenGfx);
    }
  }

  return childrenGfx;
};

/**
 * Clears the graphical representation of the element and returns the
 * cleared visual (the <g class="djs-visual" /> element).
 */
GraphicsFactory.prototype._clear = function(gfx) {
  var visual = Object(_util_GraphicsUtil__WEBPACK_IMPORTED_MODULE_1__["getVisual"])(gfx);

  Object(min_dom__WEBPACK_IMPORTED_MODULE_3__["clear"])(visual);

  return visual;
};

/**
 * Creates a gfx container for shapes and connections
 *
 * The layout is as follows:
 *
 * <g class="djs-group">
 *
 *   <!-- the gfx -->
 *   <g class="djs-element djs-(shape|connection|frame)">
 *     <g class="djs-visual">
 *       <!-- the renderer draws in here -->
 *     </g>
 *
 *     <!-- extensions (overlays, click box, ...) goes here
 *   </g>
 *
 *   <!-- the gfx child nodes -->
 *   <g class="djs-children"></g>
 * </g>
 *
 * @param {String} type the type of the element, i.e. shape | connection
 * @param {SVGElement} [childrenGfx]
 * @param {Number} [parentIndex] position to create container in parent
 * @param {Boolean} [isFrame] is frame element
 *
 * @return {SVGElement}
 */
GraphicsFactory.prototype._createContainer = function(
    type, childrenGfx, parentIndex, isFrame
) {
  var outerGfx = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_4__["create"])('g');
  Object(tiny_svg__WEBPACK_IMPORTED_MODULE_4__["classes"])(outerGfx).add('djs-group');

  // insert node at position
  if (typeof parentIndex !== 'undefined') {
    prependTo(outerGfx, childrenGfx, childrenGfx.childNodes[parentIndex]);
  } else {
    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_4__["append"])(childrenGfx, outerGfx);
  }

  var gfx = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_4__["create"])('g');
  Object(tiny_svg__WEBPACK_IMPORTED_MODULE_4__["classes"])(gfx).add('djs-element');
  Object(tiny_svg__WEBPACK_IMPORTED_MODULE_4__["classes"])(gfx).add('djs-' + type);

  if (isFrame) {
    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_4__["classes"])(gfx).add('djs-frame');
  }

  Object(tiny_svg__WEBPACK_IMPORTED_MODULE_4__["append"])(outerGfx, gfx);

  // create visual
  var visual = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_4__["create"])('g');
  Object(tiny_svg__WEBPACK_IMPORTED_MODULE_4__["classes"])(visual).add('djs-visual');

  Object(tiny_svg__WEBPACK_IMPORTED_MODULE_4__["append"])(gfx, visual);

  return gfx;
};

GraphicsFactory.prototype.create = function(type, element, parentIndex) {
  var childrenGfx = this._getChildrenContainer(element.parent);
  return this._createContainer(type, childrenGfx, parentIndex, Object(_util_Elements__WEBPACK_IMPORTED_MODULE_5__["isFrameElement"])(element));
};

GraphicsFactory.prototype.updateContainments = function(elements) {

  var self = this,
      elementRegistry = this._elementRegistry,
      parents;

  parents = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["reduce"])(elements, function(map, e) {

    if (e.parent) {
      map[e.parent.id] = e.parent;
    }

    return map;
  }, {});

  // update all parents of changed and reorganized their children
  // in the correct order (as indicated in our model)
  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(parents, function(parent) {

    var children = parent.children;

    if (!children) {
      return;
    }

    var childrenGfx = self._getChildrenContainer(parent);

    Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(children.slice().reverse(), function(child) {
      var childGfx = elementRegistry.getGraphics(child);

      prependTo(childGfx.parentNode, childrenGfx);
    });
  });
};

GraphicsFactory.prototype.drawShape = function(visual, element) {
  var eventBus = this._eventBus;

  return eventBus.fire('render.shape', { gfx: visual, element: element });
};

GraphicsFactory.prototype.getShapePath = function(element) {
  var eventBus = this._eventBus;

  return eventBus.fire('render.getShapePath', element);
};

GraphicsFactory.prototype.drawConnection = function(visual, element) {
  var eventBus = this._eventBus;

  return eventBus.fire('render.connection', { gfx: visual, element: element });
};

GraphicsFactory.prototype.getConnectionPath = function(waypoints) {
  var eventBus = this._eventBus;

  return eventBus.fire('render.getConnectionPath', waypoints);
};

GraphicsFactory.prototype.update = function(type, element, gfx) {

  // do NOT update root element
  if (!element.parent) {
    return;
  }

  var visual = this._clear(gfx);

  // redraw
  if (type === 'shape') {
    this.drawShape(visual, element);

    // update positioning
    Object(_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_2__["translate"])(gfx, element.x, element.y);
  } else
  if (type === 'connection') {
    this.drawConnection(visual, element);
  } else {
    throw new Error('unknown type: ' + type);
  }

  if (element.hidden) {
    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_4__["attr"])(gfx, 'display', 'none');
  } else {
    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_4__["attr"])(gfx, 'display', 'block');
  }
};

GraphicsFactory.prototype.remove = function(element) {
  var gfx = this._elementRegistry.getGraphics(element);

  // remove
  Object(tiny_svg__WEBPACK_IMPORTED_MODULE_4__["remove"])(gfx.parentNode);
};


// helpers //////////

function prependTo(newNode, parentNode, siblingNode) {
  var node = siblingNode || parentNode.firstChild;

  // do not prepend node to itself to prevent IE from crashing
  // https://github.com/bpmn-io/bpmn-js/issues/746
  if (newNode === node) {
    return;
  }

  parentNode.insertBefore(newNode, node);
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/core/index.js":
/*!***************************************************!*\
  !*** ./node_modules/diagram-js/lib/core/index.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../draw */ "./node_modules/diagram-js/lib/draw/index.js");
/* harmony import */ var _Canvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Canvas */ "./node_modules/diagram-js/lib/core/Canvas.js");
/* harmony import */ var _ElementRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ElementRegistry */ "./node_modules/diagram-js/lib/core/ElementRegistry.js");
/* harmony import */ var _ElementFactory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ElementFactory */ "./node_modules/diagram-js/lib/core/ElementFactory.js");
/* harmony import */ var _EventBus__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EventBus */ "./node_modules/diagram-js/lib/core/EventBus.js");
/* harmony import */ var _GraphicsFactory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GraphicsFactory */ "./node_modules/diagram-js/lib/core/GraphicsFactory.js");








/* harmony default export */ __webpack_exports__["default"] = ({
  __depends__: [ _draw__WEBPACK_IMPORTED_MODULE_0__["default"] ],
  __init__: [ 'canvas' ],
  canvas: [ 'type', _Canvas__WEBPACK_IMPORTED_MODULE_1__["default"] ],
  elementRegistry: [ 'type', _ElementRegistry__WEBPACK_IMPORTED_MODULE_2__["default"] ],
  elementFactory: [ 'type', _ElementFactory__WEBPACK_IMPORTED_MODULE_3__["default"] ],
  eventBus: [ 'type', _EventBus__WEBPACK_IMPORTED_MODULE_4__["default"] ],
  graphicsFactory: [ 'type', _GraphicsFactory__WEBPACK_IMPORTED_MODULE_5__["default"] ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/draw/BaseRenderer.js":
/*!**********************************************************!*\
  !*** ./node_modules/diagram-js/lib/draw/BaseRenderer.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BaseRenderer; });
var DEFAULT_RENDER_PRIORITY = 1000;

/**
 * The base implementation of shape and connection renderers.
 *
 * @param {EventBus} eventBus
 * @param {Number} [renderPriority=1000]
 */
function BaseRenderer(eventBus, renderPriority) {
  var self = this;

  renderPriority = renderPriority || DEFAULT_RENDER_PRIORITY;

  eventBus.on([ 'render.shape', 'render.connection' ], renderPriority, function(evt, context) {
    var type = evt.type,
        element = context.element,
        visuals = context.gfx;

    if (self.canRender(element)) {
      if (type === 'render.shape') {
        return self.drawShape(visuals, element);
      } else {
        return self.drawConnection(visuals, element);
      }
    }
  });

  eventBus.on([ 'render.getShapePath', 'render.getConnectionPath'], renderPriority, function(evt, element) {
    if (self.canRender(element)) {
      if (evt.type === 'render.getShapePath') {
        return self.getShapePath(element);
      } else {
        return self.getConnectionPath(element);
      }
    }
  });
}

/**
 * Should check whether *this* renderer can render
 * the element/connection.
 *
 * @param {element} element
 *
 * @returns {Boolean}
 */
BaseRenderer.prototype.canRender = function() {};

/**
 * Provides the shape's snap svg element to be drawn on the `canvas`.
 *
 * @param {djs.Graphics} visuals
 * @param {Shape} shape
 *
 * @returns {Snap.svg} [returns a Snap.svg paper element ]
 */
BaseRenderer.prototype.drawShape = function() {};

/**
 * Provides the shape's snap svg element to be drawn on the `canvas`.
 *
 * @param {djs.Graphics} visuals
 * @param {Connection} connection
 *
 * @returns {Snap.svg} [returns a Snap.svg paper element ]
 */
BaseRenderer.prototype.drawConnection = function() {};

/**
 * Gets the SVG path of a shape that represents it's visual bounds.
 *
 * @param {Shape} shape
 *
 * @return {string} svg path
 */
BaseRenderer.prototype.getShapePath = function() {};

/**
 * Gets the SVG path of a connection that represents it's visual bounds.
 *
 * @param {Connection} connection
 *
 * @return {string} svg path
 */
BaseRenderer.prototype.getConnectionPath = function() {};


/***/ }),

/***/ "./node_modules/diagram-js/lib/draw/DefaultRenderer.js":
/*!*************************************************************!*\
  !*** ./node_modules/diagram-js/lib/draw/DefaultRenderer.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DefaultRenderer; });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _BaseRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseRenderer */ "./node_modules/diagram-js/lib/draw/BaseRenderer.js");
/* harmony import */ var _util_RenderUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/RenderUtil */ "./node_modules/diagram-js/lib/util/RenderUtil.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");










// apply default renderer with lowest possible priority
// so that it only kicks in if noone else could render
var DEFAULT_RENDER_PRIORITY = 1;

/**
 * The default renderer used for shapes and connections.
 *
 * @param {EventBus} eventBus
 * @param {Styles} styles
 */
function DefaultRenderer(eventBus, styles) {

  //
  _BaseRenderer__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, eventBus, DEFAULT_RENDER_PRIORITY);

  this.CONNECTION_STYLE = styles.style([ 'no-fill' ], { strokeWidth: 5, stroke: 'fuchsia' });
  this.SHAPE_STYLE = styles.style({ fill: 'white', stroke: 'fuchsia', strokeWidth: 2 });
  this.FRAME_STYLE = styles.style([ 'no-fill' ], { stroke: 'fuchsia', strokeDasharray: 4, strokeWidth: 2 });
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(DefaultRenderer, _BaseRenderer__WEBPACK_IMPORTED_MODULE_1__["default"]);


DefaultRenderer.prototype.canRender = function() {
  return true;
};

DefaultRenderer.prototype.drawShape = function drawShape(visuals, element) {
  var rect = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_3__["create"])('rect');

  Object(tiny_svg__WEBPACK_IMPORTED_MODULE_3__["attr"])(rect, {
    x: 0,
    y: 0,
    width: element.width || 0,
    height: element.height || 0
  });

  if (Object(_util_Elements__WEBPACK_IMPORTED_MODULE_4__["isFrameElement"])(element)) {
    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_3__["attr"])(rect, this.FRAME_STYLE);
  } else {
    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_3__["attr"])(rect, this.SHAPE_STYLE);
  }

  Object(tiny_svg__WEBPACK_IMPORTED_MODULE_3__["append"])(visuals, rect);

  return rect;
};

DefaultRenderer.prototype.drawConnection = function drawConnection(visuals, connection) {

  var line = Object(_util_RenderUtil__WEBPACK_IMPORTED_MODULE_2__["createLine"])(connection.waypoints, this.CONNECTION_STYLE);
  Object(tiny_svg__WEBPACK_IMPORTED_MODULE_3__["append"])(visuals, line);

  return line;
};

DefaultRenderer.prototype.getShapePath = function getShapePath(shape) {

  var x = shape.x,
      y = shape.y,
      width = shape.width,
      height = shape.height;

  var shapePath = [
    ['M', x, y],
    ['l', width, 0],
    ['l', 0, height],
    ['l', -width, 0],
    ['z']
  ];

  return Object(_util_RenderUtil__WEBPACK_IMPORTED_MODULE_2__["componentsToPath"])(shapePath);
};

DefaultRenderer.prototype.getConnectionPath = function getConnectionPath(connection) {
  var waypoints = connection.waypoints;

  var idx, point, connectionPath = [];

  for (idx = 0; (point = waypoints[idx]); idx++) {

    // take invisible docking into account
    // when creating the path
    point = point.original || point;

    connectionPath.push([ idx === 0 ? 'M' : 'L', point.x, point.y ]);
  }

  return Object(_util_RenderUtil__WEBPACK_IMPORTED_MODULE_2__["componentsToPath"])(connectionPath);
};


DefaultRenderer.$inject = [ 'eventBus', 'styles' ];


/***/ }),

/***/ "./node_modules/diagram-js/lib/draw/Styles.js":
/*!****************************************************!*\
  !*** ./node_modules/diagram-js/lib/draw/Styles.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Styles; });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");



/**
 * A component that manages shape styles
 */
function Styles() {

  var defaultTraits = {

    'no-fill': {
      fill: 'none'
    },
    'no-border': {
      strokeOpacity: 0.0
    },
    'no-events': {
      pointerEvents: 'none'
    }
  };

  var self = this;

  /**
   * Builds a style definition from a className, a list of traits and an object of additional attributes.
   *
   * @param  {String} className
   * @param  {Array<String>} traits
   * @param  {Object} additionalAttrs
   *
   * @return {Object} the style defintion
   */
  this.cls = function(className, traits, additionalAttrs) {
    var attrs = this.style(traits, additionalAttrs);

    return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])(attrs, { 'class': className });
  };

  /**
   * Builds a style definition from a list of traits and an object of additional attributes.
   *
   * @param  {Array<String>} traits
   * @param  {Object} additionalAttrs
   *
   * @return {Object} the style defintion
   */
  this.style = function(traits, additionalAttrs) {

    if (!Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isArray"])(traits) && !additionalAttrs) {
      additionalAttrs = traits;
      traits = [];
    }

    var attrs = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["reduce"])(traits, function(attrs, t) {
      return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])(attrs, defaultTraits[t] || {});
    }, {});

    return additionalAttrs ? Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])(attrs, additionalAttrs) : attrs;
  };

  this.computeStyle = function(custom, traits, defaultStyles) {
    if (!Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isArray"])(traits)) {
      defaultStyles = traits;
      traits = [];
    }

    return self.style(traits || [], Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({}, defaultStyles, custom || {}));
  };
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/draw/index.js":
/*!***************************************************!*\
  !*** ./node_modules/diagram-js/lib/draw/index.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _DefaultRenderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultRenderer */ "./node_modules/diagram-js/lib/draw/DefaultRenderer.js");
/* harmony import */ var _Styles__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Styles */ "./node_modules/diagram-js/lib/draw/Styles.js");



/* harmony default export */ __webpack_exports__["default"] = ({
  __init__: [ 'defaultRenderer' ],
  defaultRenderer: [ 'type', _DefaultRenderer__WEBPACK_IMPORTED_MODULE_0__["default"] ],
  styles: [ 'type', _Styles__WEBPACK_IMPORTED_MODULE_1__["default"] ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/interaction-events/InteractionEvents.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/interaction-events/InteractionEvents.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return InteractionEvents; });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var _util_Mouse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Mouse */ "./node_modules/diagram-js/lib/util/Mouse.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var _util_RenderUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/RenderUtil */ "./node_modules/diagram-js/lib/util/RenderUtil.js");










function allowAll(e) { return true; }

var LOW_PRIORITY = 500;


/**
 * A plugin that provides interaction events for diagram elements.
 *
 * It emits the following events:
 *
 *   * element.click
 *   * element.contextmenu
 *   * element.dblclick
 *   * element.hover
 *   * element.mousedown
 *   * element.mousemove
 *   * element.mouseup
 *   * element.out
 *
 * Each event is a tuple { element, gfx, originalEvent }.
 *
 * Canceling the event via Event#preventDefault()
 * prevents the original DOM operation.
 *
 * @param {EventBus} eventBus
 */
function InteractionEvents(eventBus, elementRegistry, styles) {

  var self = this;

  /**
   * Fire an interaction event.
   *
   * @param {String} type local event name, e.g. element.click.
   * @param {DOMEvent} event native event
   * @param {djs.model.Base} [element] the diagram element to emit the event on;
   *                                   defaults to the event target
   */
  function fire(type, event, element) {

    if (isIgnored(type, event)) {
      return;
    }

    var target, gfx, returnValue;

    if (!element) {
      target = event.delegateTarget || event.target;

      if (target) {
        gfx = target;
        element = elementRegistry.get(gfx);
      }
    } else {
      gfx = elementRegistry.getGraphics(element);
    }

    if (!gfx || !element) {
      return;
    }

    returnValue = eventBus.fire(type, {
      element: element,
      gfx: gfx,
      originalEvent: event
    });

    if (returnValue === false) {
      event.stopPropagation();
      event.preventDefault();
    }
  }

  // TODO(nikku): document this
  var handlers = {};

  function mouseHandler(localEventName) {
    return handlers[localEventName];
  }

  function isIgnored(localEventName, event) {

    var filter = ignoredFilters[localEventName] || _util_Mouse__WEBPACK_IMPORTED_MODULE_2__["isPrimaryButton"];

    // only react on left mouse button interactions
    // except for interaction events that are enabled
    // for secundary mouse button
    return !filter(event);
  }

  var bindings = {
    click: 'element.click',
    contextmenu: 'element.contextmenu',
    dblclick: 'element.dblclick',
    mousedown: 'element.mousedown',
    mousemove: 'element.mousemove',
    mouseover: 'element.hover',
    mouseout: 'element.out',
    mouseup: 'element.mouseup',
  };

  var ignoredFilters = {
    'element.contextmenu': allowAll
  };


  // manual event trigger //////////

  /**
   * Trigger an interaction event (based on a native dom event)
   * on the target shape or connection.
   *
   * @param {String} eventName the name of the triggered DOM event
   * @param {MouseEvent} event
   * @param {djs.model.Base} targetElement
   */
  function triggerMouseEvent(eventName, event, targetElement) {

    // i.e. element.mousedown...
    var localEventName = bindings[eventName];

    if (!localEventName) {
      throw new Error('unmapped DOM event name <' + eventName + '>');
    }

    return fire(localEventName, event, targetElement);
  }


  var ELEMENT_SELECTOR = 'svg, .djs-element';

  // event handling ///////

  function registerEvent(node, event, localEvent, ignoredFilter) {

    var handler = handlers[localEvent] = function(event) {
      fire(localEvent, event);
    };

    if (ignoredFilter) {
      ignoredFilters[localEvent] = ignoredFilter;
    }

    handler.$delegate = min_dom__WEBPACK_IMPORTED_MODULE_1__["delegate"].bind(node, ELEMENT_SELECTOR, event, handler);
  }

  function unregisterEvent(node, event, localEvent) {

    var handler = mouseHandler(localEvent);

    if (!handler) {
      return;
    }

    min_dom__WEBPACK_IMPORTED_MODULE_1__["delegate"].unbind(node, event, handler.$delegate);
  }

  function registerEvents(svg) {
    Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(bindings, function(val, key) {
      registerEvent(svg, key, val);
    });
  }

  function unregisterEvents(svg) {
    Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(bindings, function(val, key) {
      unregisterEvent(svg, key, val);
    });
  }

  eventBus.on('canvas.destroy', function(event) {
    unregisterEvents(event.svg);
  });

  eventBus.on('canvas.init', function(event) {
    registerEvents(event.svg);
  });


  // hit box updating ////////////////

  eventBus.on([ 'shape.added', 'connection.added' ], function(event) {
    var element = event.element,
        gfx = event.gfx;

    eventBus.fire('interactionEvents.createHit', { element: element, gfx: gfx });
  });

  // Update djs-hit on change.
  // A low priortity is necessary, because djs-hit of labels has to be updated
  // after the label bounds have been updated in the renderer.
  eventBus.on([
    'shape.changed',
    'connection.changed'
  ], LOW_PRIORITY, function(event) {

    var element = event.element,
        gfx = event.gfx;

    eventBus.fire('interactionEvents.updateHit', { element: element, gfx: gfx });
  });

  eventBus.on('interactionEvents.createHit', LOW_PRIORITY, function(event) {
    var element = event.element,
        gfx = event.gfx;

    self.createDefaultHit(element, gfx);
  });

  eventBus.on('interactionEvents.updateHit', function(event) {
    var element = event.element,
        gfx = event.gfx;

    self.updateDefaultHit(element, gfx);
  });


  // hit styles ////////////

  var STROKE_HIT_STYLE = createHitStyle('djs-hit djs-hit-stroke');

  var CLICK_STROKE_HIT_STYLE = createHitStyle('djs-hit djs-hit-click-stroke');

  var ALL_HIT_STYLE = createHitStyle('djs-hit djs-hit-all');

  var HIT_TYPES = {
    'all': ALL_HIT_STYLE,
    'click-stroke': CLICK_STROKE_HIT_STYLE,
    'stroke': STROKE_HIT_STYLE
  };

  function createHitStyle(classNames, attrs) {

    attrs = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({
      stroke: 'white',
      strokeWidth: 15
    }, attrs || {});

    return styles.cls(classNames, [ 'no-fill', 'no-border' ], attrs);
  }


  // style helpers ///////////////

  function applyStyle(hit, type) {

    var attrs = HIT_TYPES[type];

    if (!attrs) {
      throw new Error('invalid hit type <' + type + '>');
    }

    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_3__["attr"])(hit, attrs);

    return hit;
  }

  function appendHit(gfx, hit) {
    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_3__["append"])(gfx, hit);
  }


  // API

  /**
   * Remove hints on the given graphics.
   *
   * @param {SVGElement} gfx
   */
  this.removeHits = function(gfx) {
    var hits = Object(min_dom__WEBPACK_IMPORTED_MODULE_1__["queryAll"])('.djs-hit', gfx);

    Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(hits, tiny_svg__WEBPACK_IMPORTED_MODULE_3__["remove"]);
  };

  /**
   * Create default hit for the given element.
   *
   * @param {djs.model.Base} element
   * @param {SVGElement} gfx
   *
   * @return {SVGElement} created hit
   */
  this.createDefaultHit = function(element, gfx) {
    var waypoints = element.waypoints,
        isFrame = element.isFrame,
        boxType;

    if (waypoints) {
      return this.createWaypointsHit(gfx, waypoints);
    } else {

      boxType = isFrame ? 'stroke' : 'all';

      return this.createBoxHit(gfx, boxType, {
        width: element.width,
        height: element.height
      });
    }
  };

  /**
   * Create hits for the given waypoints.
   *
   * @param {SVGElement} gfx
   * @param {Array<Point>} waypoints
   *
   * @return {SVGElement}
   */
  this.createWaypointsHit = function(gfx, waypoints) {

    var hit = Object(_util_RenderUtil__WEBPACK_IMPORTED_MODULE_4__["createLine"])(waypoints);

    applyStyle(hit, 'stroke');

    appendHit(gfx, hit);

    return hit;
  };

  /**
   * Create hits for a box.
   *
   * @param {SVGElement} gfx
   * @param {String} hitType
   * @param {Object} attrs
   *
   * @return {SVGElement}
   */
  this.createBoxHit = function(gfx, type, attrs) {

    attrs = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({
      x: 0,
      y: 0
    }, attrs);

    var hit = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_3__["create"])('rect');

    applyStyle(hit, type);

    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_3__["attr"])(hit, attrs);

    appendHit(gfx, hit);

    return hit;
  };

  /**
   * Update default hit of the element.
   *
   * @param  {djs.model.Base} element
   * @param  {SVGElement} gfx
   *
   * @return {SVGElement} updated hit
   */
  this.updateDefaultHit = function(element, gfx) {

    var hit = Object(min_dom__WEBPACK_IMPORTED_MODULE_1__["query"])('.djs-hit', gfx);

    if (!hit) {
      return;
    }

    if (element.waypoints) {
      Object(_util_RenderUtil__WEBPACK_IMPORTED_MODULE_4__["updateLine"])(hit, element.waypoints);
    } else {
      Object(tiny_svg__WEBPACK_IMPORTED_MODULE_3__["attr"])(hit, {
        width: element.width,
        height: element.height
      });
    }

    return hit;
  };

  this.fire = fire;

  this.triggerMouseEvent = triggerMouseEvent;

  this.mouseHandler = mouseHandler;

  this.registerEvent = registerEvent;
  this.unregisterEvent = unregisterEvent;
}


InteractionEvents.$inject = [
  'eventBus',
  'elementRegistry',
  'styles'
];


/**
 * An event indicating that the mouse hovered over an element
 *
 * @event element.hover
 *
 * @type {Object}
 * @property {djs.model.Base} element
 * @property {SVGElement} gfx
 * @property {Event} originalEvent
 */

/**
 * An event indicating that the mouse has left an element
 *
 * @event element.out
 *
 * @type {Object}
 * @property {djs.model.Base} element
 * @property {SVGElement} gfx
 * @property {Event} originalEvent
 */

/**
 * An event indicating that the mouse has clicked an element
 *
 * @event element.click
 *
 * @type {Object}
 * @property {djs.model.Base} element
 * @property {SVGElement} gfx
 * @property {Event} originalEvent
 */

/**
 * An event indicating that the mouse has double clicked an element
 *
 * @event element.dblclick
 *
 * @type {Object}
 * @property {djs.model.Base} element
 * @property {SVGElement} gfx
 * @property {Event} originalEvent
 */

/**
 * An event indicating that the mouse has gone down on an element.
 *
 * @event element.mousedown
 *
 * @type {Object}
 * @property {djs.model.Base} element
 * @property {SVGElement} gfx
 * @property {Event} originalEvent
 */

/**
 * An event indicating that the mouse has gone up on an element.
 *
 * @event element.mouseup
 *
 * @type {Object}
 * @property {djs.model.Base} element
 * @property {SVGElement} gfx
 * @property {Event} originalEvent
 */

/**
 * An event indicating that the context menu action is triggered
 * via mouse or touch controls.
 *
 * @event element.contextmenu
 *
 * @type {Object}
 * @property {djs.model.Base} element
 * @property {SVGElement} gfx
 * @property {Event} originalEvent
 */

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/interaction-events/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/interaction-events/index.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _InteractionEvents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./InteractionEvents */ "./node_modules/diagram-js/lib/features/interaction-events/InteractionEvents.js");


/* harmony default export */ __webpack_exports__["default"] = ({
  __init__: [ 'interactionEvents' ],
  interactionEvents: [ 'type', _InteractionEvents__WEBPACK_IMPORTED_MODULE_0__["default"] ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/outline/Outline.js":
/*!*****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/outline/Outline.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Outline; });
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


var LOW_PRIORITY = 500;








/**
 * @class
 *
 * A plugin that adds an outline to shapes and connections that may be activated and styled
 * via CSS classes.
 *
 * @param {EventBus} eventBus
 * @param {Styles} styles
 * @param {ElementRegistry} elementRegistry
 */
function Outline(eventBus, styles, elementRegistry) {

  this.offset = 6;

  var OUTLINE_STYLE = styles.cls('djs-outline', [ 'no-fill' ]);

  var self = this;

  function createOutline(gfx, bounds) {
    var outline = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_1__["create"])('rect');

    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_1__["attr"])(outline, Object(min_dash__WEBPACK_IMPORTED_MODULE_3__["assign"])({
      x: 10,
      y: 10,
      width: 100,
      height: 100
    }, OUTLINE_STYLE));

    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_1__["append"])(gfx, outline);

    return outline;
  }

  // A low priortity is necessary, because outlines of labels have to be updated
  // after the label bounds have been updated in the renderer.
  eventBus.on([ 'shape.added', 'shape.changed' ], LOW_PRIORITY, function(event) {
    var element = event.element,
        gfx = event.gfx;

    var outline = Object(min_dom__WEBPACK_IMPORTED_MODULE_2__["query"])('.djs-outline', gfx);

    if (!outline) {
      outline = createOutline(gfx, element);
    }

    self.updateShapeOutline(outline, element);
  });

  eventBus.on([ 'connection.added', 'connection.changed' ], function(event) {
    var element = event.element,
        gfx = event.gfx;

    var outline = Object(min_dom__WEBPACK_IMPORTED_MODULE_2__["query"])('.djs-outline', gfx);

    if (!outline) {
      outline = createOutline(gfx, element);
    }

    self.updateConnectionOutline(outline, element);
  });
}


/**
 * Updates the outline of a shape respecting the dimension of the
 * element and an outline offset.
 *
 * @param  {SVGElement} outline
 * @param  {djs.model.Base} element
 */
Outline.prototype.updateShapeOutline = function(outline, element) {

  Object(tiny_svg__WEBPACK_IMPORTED_MODULE_1__["attr"])(outline, {
    x: -this.offset,
    y: -this.offset,
    width: element.width + this.offset * 2,
    height: element.height + this.offset * 2
  });

};


/**
 * Updates the outline of a connection respecting the bounding box of
 * the connection and an outline offset.
 *
 * @param  {SVGElement} outline
 * @param  {djs.model.Base} element
 */
Outline.prototype.updateConnectionOutline = function(outline, connection) {

  var bbox = Object(_util_Elements__WEBPACK_IMPORTED_MODULE_0__["getBBox"])(connection);

  Object(tiny_svg__WEBPACK_IMPORTED_MODULE_1__["attr"])(outline, {
    x: bbox.x - this.offset,
    y: bbox.y - this.offset,
    width: bbox.width + this.offset * 2,
    height: bbox.height + this.offset * 2
  });

};


Outline.$inject = ['eventBus', 'styles', 'elementRegistry'];

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/outline/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/outline/index.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Outline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Outline */ "./node_modules/diagram-js/lib/features/outline/Outline.js");


/* harmony default export */ __webpack_exports__["default"] = ({
  __init__: [ 'outline' ],
  outline: [ 'type', _Outline__WEBPACK_IMPORTED_MODULE_0__["default"] ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/overlays/Overlays.js":
/*!*******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/overlays/Overlays.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Overlays; });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");
/* harmony import */ var _util_IdGenerator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/IdGenerator */ "./node_modules/diagram-js/lib/util/IdGenerator.js");








// document wide unique overlay ids
var ids = new _util_IdGenerator__WEBPACK_IMPORTED_MODULE_3__["default"]('ov');

var LOW_PRIORITY = 500;


/**
 * A service that allows users to attach overlays to diagram elements.
 *
 * The overlay service will take care of overlay positioning during updates.
 *
 * @example
 *
 * // add a pink badge on the top left of the shape
 * overlays.add(someShape, {
 *   position: {
 *     top: -5,
 *     left: -5
 *   },
 *   html: '<div style="width: 10px; background: fuchsia; color: white;">0</div>'
 * });
 *
 * // or add via shape id
 *
 * overlays.add('some-element-id', {
 *   position: {
 *     top: -5,
 *     left: -5
 *   }
 *   html: '<div style="width: 10px; background: fuchsia; color: white;">0</div>'
 * });
 *
 * // or add with optional type
 *
 * overlays.add(someShape, 'badge', {
 *   position: {
 *     top: -5,
 *     left: -5
 *   }
 *   html: '<div style="width: 10px; background: fuchsia; color: white;">0</div>'
 * });
 *
 *
 * // remove an overlay
 *
 * var id = overlays.add(...);
 * overlays.remove(id);
 *
 *
 * You may configure overlay defaults during tool by providing a `config` module
 * with `overlays.defaults` as an entry:
 *
 * {
 *   overlays: {
 *     defaults: {
 *       show: {
 *         minZoom: 0.7,
 *         maxZoom: 5.0
 *       },
 *       scale: {
 *         min: 1
 *       }
 *     }
 * }
 *
 * @param {Object} config
 * @param {EventBus} eventBus
 * @param {Canvas} canvas
 * @param {ElementRegistry} elementRegistry
 */
function Overlays(config, eventBus, canvas, elementRegistry) {

  this._eventBus = eventBus;
  this._canvas = canvas;
  this._elementRegistry = elementRegistry;

  this._ids = ids;

  this._overlayDefaults = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({

    // no show constraints
    show: null,

    // always scale
    scale: true
  }, config && config.defaults);

  /**
   * Mapping overlayId -> overlay
   */
  this._overlays = {};

  /**
   * Mapping elementId -> overlay container
   */
  this._overlayContainers = [];

  // root html element for all overlays
  this._overlayRoot = createRoot(canvas.getContainer());

  this._init();
}


Overlays.$inject = [
  'config.overlays',
  'eventBus',
  'canvas',
  'elementRegistry'
];


/**
 * Returns the overlay with the specified id or a list of overlays
 * for an element with a given type.
 *
 * @example
 *
 * // return the single overlay with the given id
 * overlays.get('some-id');
 *
 * // return all overlays for the shape
 * overlays.get({ element: someShape });
 *
 * // return all overlays on shape with type 'badge'
 * overlays.get({ element: someShape, type: 'badge' });
 *
 * // shape can also be specified as id
 * overlays.get({ element: 'element-id', type: 'badge' });
 *
 *
 * @param {Object} search
 * @param {String} [search.id]
 * @param {String|djs.model.Base} [search.element]
 * @param {String} [search.type]
 *
 * @return {Object|Array<Object>} the overlay(s)
 */
Overlays.prototype.get = function(search) {

  if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isString"])(search)) {
    search = { id: search };
  }

  if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isString"])(search.element)) {
    search.element = this._elementRegistry.get(search.element);
  }

  if (search.element) {
    var container = this._getOverlayContainer(search.element, true);

    // return a list of overlays when searching by element (+type)
    if (container) {
      return search.type ? Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["filter"])(container.overlays, Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["matchPattern"])({ type: search.type })) : container.overlays.slice();
    } else {
      return [];
    }
  } else
  if (search.type) {
    return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["filter"])(this._overlays, Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["matchPattern"])({ type: search.type }));
  } else {

    // return single element when searching by id
    return search.id ? this._overlays[search.id] : null;
  }
};

/**
 * Adds a HTML overlay to an element.
 *
 * @param {String|djs.model.Base}   element   attach overlay to this shape
 * @param {String}                  [type]    optional type to assign to the overlay
 * @param {Object}                  overlay   the overlay configuration
 *
 * @param {String|DOMElement}       overlay.html                 html element to use as an overlay
 * @param {Object}                  [overlay.show]               show configuration
 * @param {Number}                  [overlay.show.minZoom]       minimal zoom level to show the overlay
 * @param {Number}                  [overlay.show.maxZoom]       maximum zoom level to show the overlay
 * @param {Object}                  overlay.position             where to attach the overlay
 * @param {Number}                  [overlay.position.left]      relative to element bbox left attachment
 * @param {Number}                  [overlay.position.top]       relative to element bbox top attachment
 * @param {Number}                  [overlay.position.bottom]    relative to element bbox bottom attachment
 * @param {Number}                  [overlay.position.right]     relative to element bbox right attachment
 * @param {Boolean|Object}          [overlay.scale=true]         false to preserve the same size regardless of
 *                                                               diagram zoom
 * @param {Number}                  [overlay.scale.min]
 * @param {Number}                  [overlay.scale.max]
 *
 * @return {String}                 id that may be used to reference the overlay for update or removal
 */
Overlays.prototype.add = function(element, type, overlay) {

  if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isObject"])(type)) {
    overlay = type;
    type = null;
  }

  if (!element.id) {
    element = this._elementRegistry.get(element);
  }

  if (!overlay.position) {
    throw new Error('must specifiy overlay position');
  }

  if (!overlay.html) {
    throw new Error('must specifiy overlay html');
  }

  if (!element) {
    throw new Error('invalid element specified');
  }

  var id = this._ids.next();

  overlay = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({}, this._overlayDefaults, overlay, {
    id: id,
    type: type,
    element: element,
    html: overlay.html
  });

  this._addOverlay(overlay);

  return id;
};


/**
 * Remove an overlay with the given id or all overlays matching the given filter.
 *
 * @see Overlays#get for filter options.
 *
 * @param {String} [id]
 * @param {Object} [filter]
 */
Overlays.prototype.remove = function(filter) {

  var overlays = this.get(filter) || [];

  if (!Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isArray"])(overlays)) {
    overlays = [ overlays ];
  }

  var self = this;

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(overlays, function(overlay) {

    var container = self._getOverlayContainer(overlay.element, true);

    if (overlay) {
      Object(min_dom__WEBPACK_IMPORTED_MODULE_1__["remove"])(overlay.html);
      Object(min_dom__WEBPACK_IMPORTED_MODULE_1__["remove"])(overlay.htmlContainer);

      delete overlay.htmlContainer;
      delete overlay.element;

      delete self._overlays[overlay.id];
    }

    if (container) {
      var idx = container.overlays.indexOf(overlay);
      if (idx !== -1) {
        container.overlays.splice(idx, 1);
      }
    }
  });

};


Overlays.prototype.show = function() {
  setVisible(this._overlayRoot);
};


Overlays.prototype.hide = function() {
  setVisible(this._overlayRoot, false);
};

Overlays.prototype.clear = function() {
  this._overlays = {};

  this._overlayContainers = [];

  Object(min_dom__WEBPACK_IMPORTED_MODULE_1__["clear"])(this._overlayRoot);
};

Overlays.prototype._updateOverlayContainer = function(container) {
  var element = container.element,
      html = container.html;

  // update container left,top according to the elements x,y coordinates
  // this ensures we can attach child elements relative to this container

  var x = element.x,
      y = element.y;

  if (element.waypoints) {
    var bbox = Object(_util_Elements__WEBPACK_IMPORTED_MODULE_2__["getBBox"])(element);
    x = bbox.x;
    y = bbox.y;
  }

  setPosition(html, x, y);

  Object(min_dom__WEBPACK_IMPORTED_MODULE_1__["attr"])(container.html, 'data-container-id', element.id);
};


Overlays.prototype._updateOverlay = function(overlay) {

  var position = overlay.position,
      htmlContainer = overlay.htmlContainer,
      element = overlay.element;

  // update overlay html relative to shape because
  // it is already positioned on the element

  // update relative
  var left = position.left,
      top = position.top;

  if (position.right !== undefined) {

    var width;

    if (element.waypoints) {
      width = Object(_util_Elements__WEBPACK_IMPORTED_MODULE_2__["getBBox"])(element).width;
    } else {
      width = element.width;
    }

    left = position.right * -1 + width;
  }

  if (position.bottom !== undefined) {

    var height;

    if (element.waypoints) {
      height = Object(_util_Elements__WEBPACK_IMPORTED_MODULE_2__["getBBox"])(element).height;
    } else {
      height = element.height;
    }

    top = position.bottom * -1 + height;
  }

  setPosition(htmlContainer, left || 0, top || 0);
};


Overlays.prototype._createOverlayContainer = function(element) {
  var html = Object(min_dom__WEBPACK_IMPORTED_MODULE_1__["domify"])('<div class="djs-overlays" style="position: absolute" />');

  this._overlayRoot.appendChild(html);

  var container = {
    html: html,
    element: element,
    overlays: []
  };

  this._updateOverlayContainer(container);

  this._overlayContainers.push(container);

  return container;
};


Overlays.prototype._updateRoot = function(viewbox) {
  var scale = viewbox.scale || 1;

  var matrix = 'matrix(' +
  [
    scale,
    0,
    0,
    scale,
    -1 * viewbox.x * scale,
    -1 * viewbox.y * scale
  ].join(',') +
  ')';

  setTransform(this._overlayRoot, matrix);
};


Overlays.prototype._getOverlayContainer = function(element, raw) {
  var container = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["find"])(this._overlayContainers, function(c) {
    return c.element === element;
  });


  if (!container && !raw) {
    return this._createOverlayContainer(element);
  }

  return container;
};


Overlays.prototype._addOverlay = function(overlay) {

  var id = overlay.id,
      element = overlay.element,
      html = overlay.html,
      htmlContainer,
      overlayContainer;

  // unwrap jquery (for those who need it)
  if (html.get && html.constructor.prototype.jquery) {
    html = html.get(0);
  }

  // create proper html elements from
  // overlay HTML strings
  if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isString"])(html)) {
    html = Object(min_dom__WEBPACK_IMPORTED_MODULE_1__["domify"])(html);
  }

  overlayContainer = this._getOverlayContainer(element);

  htmlContainer = Object(min_dom__WEBPACK_IMPORTED_MODULE_1__["domify"])('<div class="djs-overlay" data-overlay-id="' + id + '" style="position: absolute">');

  htmlContainer.appendChild(html);

  if (overlay.type) {
    Object(min_dom__WEBPACK_IMPORTED_MODULE_1__["classes"])(htmlContainer).add('djs-overlay-' + overlay.type);
  }

  overlay.htmlContainer = htmlContainer;

  overlayContainer.overlays.push(overlay);
  overlayContainer.html.appendChild(htmlContainer);

  this._overlays[id] = overlay;

  this._updateOverlay(overlay);
  this._updateOverlayVisibilty(overlay, this._canvas.viewbox());
};


Overlays.prototype._updateOverlayVisibilty = function(overlay, viewbox) {
  var show = overlay.show,
      minZoom = show && show.minZoom,
      maxZoom = show && show.maxZoom,
      htmlContainer = overlay.htmlContainer,
      visible = true;

  if (show) {
    if (
      (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isDefined"])(minZoom) && minZoom > viewbox.scale) ||
      (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isDefined"])(maxZoom) && maxZoom < viewbox.scale)
    ) {
      visible = false;
    }

    setVisible(htmlContainer, visible);
  }

  this._updateOverlayScale(overlay, viewbox);
};


Overlays.prototype._updateOverlayScale = function(overlay, viewbox) {
  var shouldScale = overlay.scale,
      minScale,
      maxScale,
      htmlContainer = overlay.htmlContainer;

  var scale, transform = '';

  if (shouldScale !== true) {

    if (shouldScale === false) {
      minScale = 1;
      maxScale = 1;
    } else {
      minScale = shouldScale.min;
      maxScale = shouldScale.max;
    }

    if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isDefined"])(minScale) && viewbox.scale < minScale) {
      scale = (1 / viewbox.scale || 1) * minScale;
    }

    if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isDefined"])(maxScale) && viewbox.scale > maxScale) {
      scale = (1 / viewbox.scale || 1) * maxScale;
    }
  }

  if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isDefined"])(scale)) {
    transform = 'scale(' + scale + ',' + scale + ')';
  }

  setTransform(htmlContainer, transform);
};


Overlays.prototype._updateOverlaysVisibilty = function(viewbox) {

  var self = this;

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(this._overlays, function(overlay) {
    self._updateOverlayVisibilty(overlay, viewbox);
  });
};


Overlays.prototype._init = function() {

  var eventBus = this._eventBus;

  var self = this;


  // scroll/zoom integration

  function updateViewbox(viewbox) {
    self._updateRoot(viewbox);
    self._updateOverlaysVisibilty(viewbox);

    self.show();
  }

  eventBus.on('canvas.viewbox.changing', function(event) {
    self.hide();
  });

  eventBus.on('canvas.viewbox.changed', function(event) {
    updateViewbox(event.viewbox);
  });


  // remove integration

  eventBus.on([ 'shape.remove', 'connection.remove' ], function(e) {
    var element = e.element;
    var overlays = self.get({ element: element });

    Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(overlays, function(o) {
      self.remove(o.id);
    });

    var container = self._getOverlayContainer(element);

    if (container) {
      Object(min_dom__WEBPACK_IMPORTED_MODULE_1__["remove"])(container.html);
      var i = self._overlayContainers.indexOf(container);
      if (i !== -1) {
        self._overlayContainers.splice(i, 1);
      }
    }
  });


  // move integration

  eventBus.on('element.changed', LOW_PRIORITY, function(e) {
    var element = e.element;

    var container = self._getOverlayContainer(element, true);

    if (container) {
      Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(container.overlays, function(overlay) {
        self._updateOverlay(overlay);
      });

      self._updateOverlayContainer(container);
    }
  });


  // marker integration, simply add them on the overlays as classes, too.

  eventBus.on('element.marker.update', function(e) {
    var container = self._getOverlayContainer(e.element, true);
    if (container) {
      Object(min_dom__WEBPACK_IMPORTED_MODULE_1__["classes"])(container.html)[e.add ? 'add' : 'remove'](e.marker);
    }
  });


  // clear overlays with diagram

  eventBus.on('diagram.clear', this.clear, this);
};



// helpers /////////////////////////////

function createRoot(parentNode) {
  var root = Object(min_dom__WEBPACK_IMPORTED_MODULE_1__["domify"])(
    '<div class="djs-overlay-container" style="position: absolute; width: 0; height: 0;" />'
  );

  parentNode.insertBefore(root, parentNode.firstChild);

  return root;
}

function setPosition(el, x, y) {
  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])(el.style, { left: x + 'px', top: y + 'px' });
}

function setVisible(el, visible) {
  el.style.display = visible === false ? 'none' : '';
}

function setTransform(el, transform) {

  el.style['transform-origin'] = 'top left';

  [ '', '-ms-', '-webkit-' ].forEach(function(prefix) {
    el.style[prefix + 'transform'] = transform;
  });
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/overlays/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/overlays/index.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Overlays__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Overlays */ "./node_modules/diagram-js/lib/features/overlays/Overlays.js");


/* harmony default export */ __webpack_exports__["default"] = ({
  __init__: [ 'overlays' ],
  overlays: [ 'type', _Overlays__WEBPACK_IMPORTED_MODULE_0__["default"] ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/selection/Selection.js":
/*!*********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/selection/Selection.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Selection; });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");



/**
 * A service that offers the current selection in a diagram.
 * Offers the api to control the selection, too.
 *
 * @class
 *
 * @param {EventBus} eventBus the event bus
 */
function Selection(eventBus) {

  this._eventBus = eventBus;

  this._selectedElements = [];

  var self = this;

  eventBus.on([ 'shape.remove', 'connection.remove' ], function(e) {
    var element = e.element;
    self.deselect(element);
  });

  eventBus.on([ 'diagram.clear' ], function(e) {
    self.select(null);
  });
}

Selection.$inject = [ 'eventBus' ];


Selection.prototype.deselect = function(element) {
  var selectedElements = this._selectedElements;

  var idx = selectedElements.indexOf(element);

  if (idx !== -1) {
    var oldSelection = selectedElements.slice();

    selectedElements.splice(idx, 1);

    this._eventBus.fire('selection.changed', { oldSelection: oldSelection, newSelection: selectedElements });
  }
};


Selection.prototype.get = function() {
  return this._selectedElements;
};

Selection.prototype.isSelected = function(element) {
  return this._selectedElements.indexOf(element) !== -1;
};


/**
 * This method selects one or more elements on the diagram.
 *
 * By passing an additional add parameter you can decide whether or not the element(s)
 * should be added to the already existing selection or not.
 *
 * @method Selection#select
 *
 * @param  {Object|Object[]} elements element or array of elements to be selected
 * @param  {boolean} [add] whether the element(s) should be appended to the current selection, defaults to false
 */
Selection.prototype.select = function(elements, add) {
  var selectedElements = this._selectedElements,
      oldSelection = selectedElements.slice();

  if (!Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isArray"])(elements)) {
    elements = elements ? [ elements ] : [];
  }

  // selection may be cleared by passing an empty array or null
  // to the method
  if (add) {
    Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(elements, function(element) {
      if (selectedElements.indexOf(element) !== -1) {

        // already selected
        return;
      } else {
        selectedElements.push(element);
      }
    });
  } else {
    this._selectedElements = selectedElements = elements.slice();
  }

  this._eventBus.fire('selection.changed', { oldSelection: oldSelection, newSelection: selectedElements });
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/selection/SelectionBehavior.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/selection/SelectionBehavior.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SelectionBehavior; });
/* harmony import */ var _util_Mouse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/Mouse */ "./node_modules/diagram-js/lib/util/Mouse.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");





function SelectionBehavior(
    eventBus, selection, canvas,
    elementRegistry) {

  eventBus.on('create.end', 500, function(e) {

    var context = e.context,
        canExecute = context.canExecute,
        elements = context.elements,
        hints = context.hints || {},
        autoSelect = hints.autoSelect;

    // select elements after they have been created
    if (canExecute) {
      if (autoSelect === false) {

        // select no elements
        return;
      }

      if (Object(min_dash__WEBPACK_IMPORTED_MODULE_1__["isArray"])(autoSelect)) {
        selection.select(autoSelect);
      } else {

        // select all elements by default
        selection.select(elements.filter(isShown));
      }
    }
  });

  eventBus.on('connect.end', 500, function(e) {

    // select the connect end target
    // after a connect operation
    if (e.context.canExecute && e.context.hover) {
      selection.select(e.context.hover);
    }
  });

  eventBus.on('shape.move.end', 500, function(e) {
    var previousSelection = e.previousSelection || [];

    var shape = elementRegistry.get(e.context.shape.id);

    // make sure at least the main moved element is being
    // selected after a move operation
    var inSelection = Object(min_dash__WEBPACK_IMPORTED_MODULE_1__["find"])(previousSelection, function(selectedShape) {
      return shape.id === selectedShape.id;
    });

    if (!inSelection) {
      selection.select(shape);
    }
  });

  // Shift + click selection
  eventBus.on('element.click', function(event) {

    var element = event.element;

    // do not select the root element
    // or connections
    if (element === canvas.getRootElement()) {
      element = null;
    }

    var isSelected = selection.isSelected(element),
        isMultiSelect = selection.get().length > 1;

    // mouse-event: SELECTION_KEY
    var add = Object(_util_Mouse__WEBPACK_IMPORTED_MODULE_0__["hasPrimaryModifier"])(event);

    // select OR deselect element in multi selection
    if (isSelected && isMultiSelect) {
      if (add) {
        return selection.deselect(element);
      } else {
        return selection.select(element);
      }
    } else
    if (!isSelected) {
      selection.select(element, add);
    } else {
      selection.deselect(element);
    }
  });
}

SelectionBehavior.$inject = [
  'eventBus',
  'selection',
  'canvas',
  'elementRegistry'
];


function isShown(element) {
  return !element.hidden;
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/selection/SelectionVisuals.js":
/*!****************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/selection/SelectionVisuals.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SelectionVisuals; });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


var MARKER_HOVER = 'hover',
    MARKER_SELECTED = 'selected';


/**
 * A plugin that adds a visible selection UI to shapes and connections
 * by appending the <code>hover</code> and <code>selected</code> classes to them.
 *
 * @class
 *
 * Makes elements selectable, too.
 *
 * @param {EventBus} events
 * @param {SelectionService} selection
 * @param {Canvas} canvas
 */
function SelectionVisuals(events, canvas, selection, styles) {

  this._multiSelectionBox = null;

  function addMarker(e, cls) {
    canvas.addMarker(e, cls);
  }

  function removeMarker(e, cls) {
    canvas.removeMarker(e, cls);
  }

  events.on('element.hover', function(event) {
    addMarker(event.element, MARKER_HOVER);
  });

  events.on('element.out', function(event) {
    removeMarker(event.element, MARKER_HOVER);
  });

  events.on('selection.changed', function(event) {

    function deselect(s) {
      removeMarker(s, MARKER_SELECTED);
    }

    function select(s) {
      addMarker(s, MARKER_SELECTED);
    }

    var oldSelection = event.oldSelection,
        newSelection = event.newSelection;

    Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(oldSelection, function(e) {
      if (newSelection.indexOf(e) === -1) {
        deselect(e);
      }
    });

    Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(newSelection, function(e) {
      if (oldSelection.indexOf(e) === -1) {
        select(e);
      }
    });
  });
}

SelectionVisuals.$inject = [
  'eventBus',
  'canvas',
  'selection',
  'styles'
];

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/selection/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/selection/index.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _interaction_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interaction-events */ "./node_modules/diagram-js/lib/features/interaction-events/index.js");
/* harmony import */ var _outline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../outline */ "./node_modules/diagram-js/lib/features/outline/index.js");
/* harmony import */ var _Selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Selection */ "./node_modules/diagram-js/lib/features/selection/Selection.js");
/* harmony import */ var _SelectionVisuals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SelectionVisuals */ "./node_modules/diagram-js/lib/features/selection/SelectionVisuals.js");
/* harmony import */ var _SelectionBehavior__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SelectionBehavior */ "./node_modules/diagram-js/lib/features/selection/SelectionBehavior.js");








/* harmony default export */ __webpack_exports__["default"] = ({
  __init__: [ 'selectionVisuals', 'selectionBehavior' ],
  __depends__: [
    _interaction_events__WEBPACK_IMPORTED_MODULE_0__["default"],
    _outline__WEBPACK_IMPORTED_MODULE_1__["default"]
  ],
  selection: [ 'type', _Selection__WEBPACK_IMPORTED_MODULE_2__["default"] ],
  selectionVisuals: [ 'type', _SelectionVisuals__WEBPACK_IMPORTED_MODULE_3__["default"] ],
  selectionBehavior: [ 'type', _SelectionBehavior__WEBPACK_IMPORTED_MODULE_4__["default"] ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/i18n/translate/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/diagram-js/lib/i18n/translate/index.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _translate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./translate */ "./node_modules/diagram-js/lib/i18n/translate/translate.js");


/* harmony default export */ __webpack_exports__["default"] = ({
  translate: [ 'value', _translate__WEBPACK_IMPORTED_MODULE_0__["default"] ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/i18n/translate/translate.js":
/*!*****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/i18n/translate/translate.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return translate; });
/**
 * A simple translation stub to be used for multi-language support
 * in diagrams. Can be easily replaced with a more sophisticated
 * solution.
 *
 * @example
 *
 * // use it inside any diagram component by injecting `translate`.
 *
 * function MyService(translate) {
 *   alert(translate('HELLO {you}', { you: 'You!' }));
 * }
 *
 * @param {String} template to interpolate
 * @param {Object} [replacements] a map with substitutes
 *
 * @return {String} the translated string
 */
function translate(template, replacements) {

  replacements = replacements || {};

  return template.replace(/{([^}]+)}/g, function(_, key) {
    return replacements[key] || '{' + key + '}';
  });
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/layout/LayoutUtil.js":
/*!**********************************************************!*\
  !*** ./node_modules/diagram-js/lib/layout/LayoutUtil.js ***!
  \**********************************************************/
/*! exports provided: roundBounds, roundPoint, asTRBL, asBounds, getMid, getOrientation, getElementLineIntersection, getIntersections, filterRedundantWaypoints */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "roundBounds", function() { return roundBounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "roundPoint", function() { return roundPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asTRBL", function() { return asTRBL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asBounds", function() { return asBounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMid", function() { return getMid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOrientation", function() { return getOrientation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getElementLineIntersection", function() { return getElementLineIntersection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIntersections", function() { return getIntersections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "filterRedundantWaypoints", function() { return filterRedundantWaypoints; });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_Geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Geometry */ "./node_modules/diagram-js/lib/util/Geometry.js");
/* harmony import */ var path_intersection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path-intersection */ "./node_modules/path-intersection/intersect.js");
/* harmony import */ var path_intersection__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path_intersection__WEBPACK_IMPORTED_MODULE_2__);







function roundBounds(bounds) {
  return {
    x: Math.round(bounds.x),
    y: Math.round(bounds.y),
    width: Math.round(bounds.width),
    height: Math.round(bounds.height)
  };
}


function roundPoint(point) {

  return {
    x: Math.round(point.x),
    y: Math.round(point.y)
  };
}


/**
 * Convert the given bounds to a { top, left, bottom, right } descriptor.
 *
 * @param {Bounds|Point} bounds
 *
 * @return {Object}
 */
function asTRBL(bounds) {
  return {
    top: bounds.y,
    right: bounds.x + (bounds.width || 0),
    bottom: bounds.y + (bounds.height || 0),
    left: bounds.x
  };
}


/**
 * Convert a { top, left, bottom, right } to an objects bounds.
 *
 * @param {Object} trbl
 *
 * @return {Bounds}
 */
function asBounds(trbl) {
  return {
    x: trbl.left,
    y: trbl.top,
    width: trbl.right - trbl.left,
    height: trbl.bottom - trbl.top
  };
}


/**
 * Get the mid of the given bounds or point.
 *
 * @param {Bounds|Point} bounds
 *
 * @return {Point}
 */
function getMid(bounds) {
  return roundPoint({
    x: bounds.x + (bounds.width || 0) / 2,
    y: bounds.y + (bounds.height || 0) / 2
  });
}


// orientation utils //////////////////////

/**
 * Get orientation of the given rectangle with respect to
 * the reference rectangle.
 *
 * A padding (positive or negative) may be passed to influence
 * horizontal / vertical orientation and intersection.
 *
 * @param {Bounds} rect
 * @param {Bounds} reference
 * @param {Point|Number} padding
 *
 * @return {String} the orientation; one of top, top-left, left, ..., bottom, right or intersect.
 */
function getOrientation(rect, reference, padding) {

  padding = padding || 0;

  // make sure we can use an object, too
  // for individual { x, y } padding
  if (!Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isObject"])(padding)) {
    padding = { x: padding, y: padding };
  }


  var rectOrientation = asTRBL(rect),
      referenceOrientation = asTRBL(reference);

  var top = rectOrientation.bottom + padding.y <= referenceOrientation.top,
      right = rectOrientation.left - padding.x >= referenceOrientation.right,
      bottom = rectOrientation.top - padding.y >= referenceOrientation.bottom,
      left = rectOrientation.right + padding.x <= referenceOrientation.left;

  var vertical = top ? 'top' : (bottom ? 'bottom' : null),
      horizontal = left ? 'left' : (right ? 'right' : null);

  if (horizontal && vertical) {
    return vertical + '-' + horizontal;
  } else {
    return horizontal || vertical || 'intersect';
  }
}


// intersection utils //////////////////////

/**
 * Get intersection between an element and a line path.
 *
 * @param {PathDef} elementPath
 * @param {PathDef} linePath
 * @param {Boolean} cropStart crop from start or end
 *
 * @return {Point}
 */
function getElementLineIntersection(elementPath, linePath, cropStart) {

  var intersections = getIntersections(elementPath, linePath);

  // recognize intersections
  // only one -> choose
  // two close together -> choose first
  // two or more distinct -> pull out appropriate one
  // none -> ok (fallback to point itself)
  if (intersections.length === 1) {
    return roundPoint(intersections[0]);
  } else if (intersections.length === 2 && Object(_util_Geometry__WEBPACK_IMPORTED_MODULE_1__["pointDistance"])(intersections[0], intersections[1]) < 1) {
    return roundPoint(intersections[0]);
  } else if (intersections.length > 1) {

    // sort by intersections based on connection segment +
    // distance from start
    intersections = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["sortBy"])(intersections, function(i) {
      var distance = Math.floor(i.t2 * 100) || 1;

      distance = 100 - distance;

      distance = (distance < 10 ? '0' : '') + distance;

      // create a sort string that makes sure we sort
      // line segment ASC + line segment position DESC (for cropStart)
      // line segment ASC + line segment position ASC (for cropEnd)
      return i.segment2 + '#' + distance;
    });

    return roundPoint(intersections[cropStart ? 0 : intersections.length - 1]);
  }

  return null;
}


function getIntersections(a, b) {
  return path_intersection__WEBPACK_IMPORTED_MODULE_2___default()(a, b);
}


function filterRedundantWaypoints(waypoints) {

  // alter copy of waypoints, not original
  waypoints = waypoints.slice();

  var idx = 0,
      point,
      previousPoint,
      nextPoint;

  while (waypoints[idx]) {
    point = waypoints[idx];
    previousPoint = waypoints[idx - 1];
    nextPoint = waypoints[idx + 1];

    if (Object(_util_Geometry__WEBPACK_IMPORTED_MODULE_1__["pointDistance"])(point, nextPoint) === 0 ||
        Object(_util_Geometry__WEBPACK_IMPORTED_MODULE_1__["pointsOnLine"])(previousPoint, nextPoint, point)) {

      // remove point, if overlapping with {nextPoint}
      // or on line with {previousPoint} -> {point} -> {nextPoint}
      waypoints.splice(idx, 1);
    } else {
      idx++;
    }
  }

  return waypoints;
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/model/index.js":
/*!****************************************************!*\
  !*** ./node_modules/diagram-js/lib/model/index.js ***!
  \****************************************************/
/*! exports provided: Base, Shape, Root, Label, Connection, create */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Base", function() { return Base; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Shape", function() { return Shape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Root", function() { return Root; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Label", function() { return Label; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Connection", function() { return Connection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var object_refs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! object-refs */ "./node_modules/object-refs/index.js");
/* harmony import */ var object_refs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(object_refs__WEBPACK_IMPORTED_MODULE_2__);





var parentRefs = new object_refs__WEBPACK_IMPORTED_MODULE_2___default.a({ name: 'children', enumerable: true, collection: true }, { name: 'parent' }),
    labelRefs = new object_refs__WEBPACK_IMPORTED_MODULE_2___default.a({ name: 'labels', enumerable: true, collection: true }, { name: 'labelTarget' }),
    attacherRefs = new object_refs__WEBPACK_IMPORTED_MODULE_2___default.a({ name: 'attachers', collection: true }, { name: 'host' }),
    outgoingRefs = new object_refs__WEBPACK_IMPORTED_MODULE_2___default.a({ name: 'outgoing', collection: true }, { name: 'source' }),
    incomingRefs = new object_refs__WEBPACK_IMPORTED_MODULE_2___default.a({ name: 'incoming', collection: true }, { name: 'target' });

/**
 * @namespace djs.model
 */

/**
 * @memberOf djs.model
 */

/**
 * The basic graphical representation
 *
 * @class
 *
 * @abstract
 */
function Base() {

  /**
   * The object that backs up the shape
   *
   * @name Base#businessObject
   * @type Object
   */
  Object.defineProperty(this, 'businessObject', {
    writable: true
  });


  /**
   * Single label support, will mapped to multi label array
   *
   * @name Base#label
   * @type Object
   */
  Object.defineProperty(this, 'label', {
    get: function() {
      return this.labels[0];
    },
    set: function(newLabel) {

      var label = this.label,
          labels = this.labels;

      if (!newLabel && label) {
        labels.remove(label);
      } else {
        labels.add(newLabel, 0);
      }
    }
  });

  /**
   * The parent shape
   *
   * @name Base#parent
   * @type Shape
   */
  parentRefs.bind(this, 'parent');

  /**
   * The list of labels
   *
   * @name Base#labels
   * @type Label
   */
  labelRefs.bind(this, 'labels');

  /**
   * The list of outgoing connections
   *
   * @name Base#outgoing
   * @type Array<Connection>
   */
  outgoingRefs.bind(this, 'outgoing');

  /**
   * The list of incoming connections
   *
   * @name Base#incoming
   * @type Array<Connection>
   */
  incomingRefs.bind(this, 'incoming');
}


/**
 * A graphical object
 *
 * @class
 * @constructor
 *
 * @extends Base
 */
function Shape() {
  Base.call(this);

  /**
   * Indicates frame shapes
   *
   * @name Shape#isFrame
   * @type Boolean
   */

  /**
   * The list of children
   *
   * @name Shape#children
   * @type Array<Base>
   */
  parentRefs.bind(this, 'children');

  /**
   * @name Shape#host
   * @type Shape
   */
  attacherRefs.bind(this, 'host');

  /**
   * @name Shape#attachers
   * @type Shape
   */
  attacherRefs.bind(this, 'attachers');
}

inherits__WEBPACK_IMPORTED_MODULE_1___default()(Shape, Base);


/**
 * A root graphical object
 *
 * @class
 * @constructor
 *
 * @extends Shape
 */
function Root() {
  Shape.call(this);
}

inherits__WEBPACK_IMPORTED_MODULE_1___default()(Root, Shape);


/**
 * A label for an element
 *
 * @class
 * @constructor
 *
 * @extends Shape
 */
function Label() {
  Shape.call(this);

  /**
   * The labeled element
   *
   * @name Label#labelTarget
   * @type Base
   */
  labelRefs.bind(this, 'labelTarget');
}

inherits__WEBPACK_IMPORTED_MODULE_1___default()(Label, Shape);


/**
 * A connection between two elements
 *
 * @class
 * @constructor
 *
 * @extends Base
 */
function Connection() {
  Base.call(this);

  /**
   * The element this connection originates from
   *
   * @name Connection#source
   * @type Base
   */
  outgoingRefs.bind(this, 'source');

  /**
   * The element this connection points to
   *
   * @name Connection#target
   * @type Base
   */
  incomingRefs.bind(this, 'target');
}

inherits__WEBPACK_IMPORTED_MODULE_1___default()(Connection, Base);


var types = {
  connection: Connection,
  shape: Shape,
  label: Label,
  root: Root
};

/**
 * Creates a new model element of the specified type
 *
 * @method create
 *
 * @example
 *
 * var shape1 = Model.create('shape', { x: 10, y: 10, width: 100, height: 100 });
 * var shape2 = Model.create('shape', { x: 210, y: 210, width: 100, height: 100 });
 *
 * var connection = Model.create('connection', { waypoints: [ { x: 110, y: 55 }, {x: 210, y: 55 } ] });
 *
 * @param  {String} type lower-cased model name
 * @param  {Object} attrs attributes to initialize the new model instance with
 *
 * @return {Base} the new model instance
 */
function create(type, attrs) {
  var Type = types[type];
  if (!Type) {
    throw new Error('unknown type: <' + type + '>');
  }
  return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])(new Type(), attrs);
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/util/Collections.js":
/*!*********************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/Collections.js ***!
  \*********************************************************/
/*! exports provided: remove, add, indexOf */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "remove", function() { return remove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "indexOf", function() { return indexOf; });
/**
 * Failsafe remove an element from a collection
 *
 * @param  {Array<Object>} [collection]
 * @param  {Object} [element]
 *
 * @return {Number} the previous index of the element
 */
function remove(collection, element) {

  if (!collection || !element) {
    return -1;
  }

  var idx = collection.indexOf(element);

  if (idx !== -1) {
    collection.splice(idx, 1);
  }

  return idx;
}

/**
 * Fail save add an element to the given connection, ensuring
 * it does not yet exist.
 *
 * @param {Array<Object>} collection
 * @param {Object} element
 * @param {Number} idx
 */
function add(collection, element, idx) {

  if (!collection || !element) {
    return;
  }

  if (typeof idx !== 'number') {
    idx = -1;
  }

  var currentIdx = collection.indexOf(element);

  if (currentIdx !== -1) {

    if (currentIdx === idx) {

      // nothing to do, position has not changed
      return;
    } else {

      if (idx !== -1) {

        // remove from current position
        collection.splice(currentIdx, 1);
      } else {

        // already exists in collection
        return;
      }
    }
  }

  if (idx !== -1) {

    // insert at specified position
    collection.splice(idx, 0, element);
  } else {

    // push to end
    collection.push(element);
  }
}


/**
 * Fail save get the index of an element in a collection.
 *
 * @param {Array<Object>} collection
 * @param {Object} element
 *
 * @return {Number} the index or -1 if collection or element do
 *                  not exist or the element is not contained.
 */
function indexOf(collection, element) {

  if (!collection || !element) {
    return -1;
  }

  return collection.indexOf(element);
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/util/Elements.js":
/*!******************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/Elements.js ***!
  \******************************************************/
/*! exports provided: getParents, add, eachElement, selfAndChildren, selfAndDirectChildren, selfAndAllChildren, getClosure, getBBox, getEnclosedElements, getType, isFrameElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getParents", function() { return getParents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eachElement", function() { return eachElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selfAndChildren", function() { return selfAndChildren; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selfAndDirectChildren", function() { return selfAndDirectChildren; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selfAndAllChildren", function() { return selfAndAllChildren; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getClosure", function() { return getClosure; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBBox", function() { return getBBox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEnclosedElements", function() { return getEnclosedElements; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getType", function() { return getType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFrameElement", function() { return isFrameElement; });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");



/**
 * Get parent elements.
 *
 * @param {Array<djs.model.base>} elements
 *
 * @returns {Array<djs.model.Base>}
 */
function getParents(elements) {

  // find elements that are not children of any other elements
  return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["filter"])(elements, function(element) {
    return !Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["find"])(elements, function(e) {
      return e !== element && getParent(element, e);
    });
  });
}


function getParent(element, parent) {
  if (!parent) {
    return;
  }

  if (element === parent) {
    return parent;
  }

  if (!element.parent) {
    return;
  }

  return getParent(element.parent, parent);
}


/**
 * Adds an element to a collection and returns true if the
 * element was added.
 *
 * @param {Array<Object>} elements
 * @param {Object} e
 * @param {Boolean} unique
 */
function add(elements, e, unique) {
  var canAdd = !unique || elements.indexOf(e) === -1;

  if (canAdd) {
    elements.push(e);
  }

  return canAdd;
}


/**
 * Iterate over each element in a collection, calling the iterator function `fn`
 * with (element, index, recursionDepth).
 *
 * Recurse into all elements that are returned by `fn`.
 *
 * @param  {Object|Array<Object>} elements
 * @param  {Function} fn iterator function called with (element, index, recursionDepth)
 * @param  {Number} [depth] maximum recursion depth
 */
function eachElement(elements, fn, depth) {

  depth = depth || 0;

  if (!Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isArray"])(elements)) {
    elements = [ elements ];
  }

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(elements, function(s, i) {
    var filter = fn(s, i, depth);

    if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isArray"])(filter) && filter.length) {
      eachElement(filter, fn, depth + 1);
    }
  });
}


/**
 * Collects self + child elements up to a given depth from a list of elements.
 *
 * @param  {djs.model.Base|Array<djs.model.Base>} elements the elements to select the children from
 * @param  {Boolean} unique whether to return a unique result set (no duplicates)
 * @param  {Number} maxDepth the depth to search through or -1 for infinite
 *
 * @return {Array<djs.model.Base>} found elements
 */
function selfAndChildren(elements, unique, maxDepth) {
  var result = [],
      processedChildren = [];

  eachElement(elements, function(element, i, depth) {
    add(result, element, unique);

    var children = element.children;

    // max traversal depth not reached yet
    if (maxDepth === -1 || depth < maxDepth) {

      // children exist && children not yet processed
      if (children && add(processedChildren, children, unique)) {
        return children;
      }
    }
  });

  return result;
}

/**
 * Return self + direct children for a number of elements
 *
 * @param  {Array<djs.model.Base>} elements to query
 * @param  {Boolean} allowDuplicates to allow duplicates in the result set
 *
 * @return {Array<djs.model.Base>} the collected elements
 */
function selfAndDirectChildren(elements, allowDuplicates) {
  return selfAndChildren(elements, !allowDuplicates, 1);
}


/**
 * Return self + ALL children for a number of elements
 *
 * @param  {Array<djs.model.Base>} elements to query
 * @param  {Boolean} allowDuplicates to allow duplicates in the result set
 *
 * @return {Array<djs.model.Base>} the collected elements
 */
function selfAndAllChildren(elements, allowDuplicates) {
  return selfAndChildren(elements, !allowDuplicates, -1);
}


/**
 * Gets the the closure for all selected elements,
 * their enclosed children and connections.
 *
 * @param {Array<djs.model.Base>} elements
 * @param {Boolean} [isTopLevel=true]
 * @param {Object} [existingClosure]
 *
 * @return {Object} newClosure
 */
function getClosure(elements, isTopLevel, closure) {

  if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isUndefined"])(isTopLevel)) {
    isTopLevel = true;
  }

  if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isObject"])(isTopLevel)) {
    closure = isTopLevel;
    isTopLevel = true;
  }


  closure = closure || {};

  var allShapes = copyObject(closure.allShapes),
      allConnections = copyObject(closure.allConnections),
      enclosedElements = copyObject(closure.enclosedElements),
      enclosedConnections = copyObject(closure.enclosedConnections);

  var topLevel = copyObject(
    closure.topLevel,
    isTopLevel && Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["groupBy"])(elements, function(e) { return e.id; })
  );


  function handleConnection(c) {
    if (topLevel[c.source.id] && topLevel[c.target.id]) {
      topLevel[c.id] = [ c ];
    }

    // not enclosed as a child, but maybe logically
    // (connecting two moved elements?)
    if (allShapes[c.source.id] && allShapes[c.target.id]) {
      enclosedConnections[c.id] = enclosedElements[c.id] = c;
    }

    allConnections[c.id] = c;
  }

  function handleElement(element) {

    enclosedElements[element.id] = element;

    if (element.waypoints) {

      // remember connection
      enclosedConnections[element.id] = allConnections[element.id] = element;
    } else {

      // remember shape
      allShapes[element.id] = element;

      // remember all connections
      Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(element.incoming, handleConnection);

      Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(element.outgoing, handleConnection);

      // recurse into children
      return element.children;
    }
  }

  eachElement(elements, handleElement);

  return {
    allShapes: allShapes,
    allConnections: allConnections,
    topLevel: topLevel,
    enclosedConnections: enclosedConnections,
    enclosedElements: enclosedElements
  };
}

/**
 * Returns the surrounding bbox for all elements in
 * the array or the element primitive.
 *
 * @param {Array<djs.model.Shape>|djs.model.Shape} elements
 * @param {Boolean} stopRecursion
 */
function getBBox(elements, stopRecursion) {

  stopRecursion = !!stopRecursion;
  if (!Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isArray"])(elements)) {
    elements = [elements];
  }

  var minX,
      minY,
      maxX,
      maxY;

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(elements, function(element) {

    // If element is a connection the bbox must be computed first
    var bbox = element;
    if (element.waypoints && !stopRecursion) {
      bbox = getBBox(element.waypoints, true);
    }

    var x = bbox.x,
        y = bbox.y,
        height = bbox.height || 0,
        width = bbox.width || 0;

    if (x < minX || minX === undefined) {
      minX = x;
    }
    if (y < minY || minY === undefined) {
      minY = y;
    }

    if ((x + width) > maxX || maxX === undefined) {
      maxX = x + width;
    }
    if ((y + height) > maxY || maxY === undefined) {
      maxY = y + height;
    }
  });

  return {
    x: minX,
    y: minY,
    height: maxY - minY,
    width: maxX - minX
  };
}


/**
 * Returns all elements that are enclosed from the bounding box.
 *
 *   * If bbox.(width|height) is not specified the method returns
 *     all elements with element.x/y > bbox.x/y
 *   * If only bbox.x or bbox.y is specified, method return all elements with
 *     e.x > bbox.x or e.y > bbox.y
 *
 * @param {Array<djs.model.Shape>} elements List of Elements to search through
 * @param {djs.model.Shape} bbox the enclosing bbox.
 *
 * @return {Array<djs.model.Shape>} enclosed elements
 */
function getEnclosedElements(elements, bbox) {

  var filteredElements = {};

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(elements, function(element) {

    var e = element;

    if (e.waypoints) {
      e = getBBox(e);
    }

    if (!Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(bbox.y) && (e.x > bbox.x)) {
      filteredElements[element.id] = element;
    }
    if (!Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(bbox.x) && (e.y > bbox.y)) {
      filteredElements[element.id] = element;
    }
    if (e.x > bbox.x && e.y > bbox.y) {
      if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(bbox.width) && Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(bbox.height) &&
          e.width + e.x < bbox.width + bbox.x &&
          e.height + e.y < bbox.height + bbox.y) {

        filteredElements[element.id] = element;
      } else if (!Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(bbox.width) || !Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(bbox.height)) {
        filteredElements[element.id] = element;
      }
    }
  });

  return filteredElements;
}


function getType(element) {

  if ('waypoints' in element) {
    return 'connection';
  }

  if ('x' in element) {
    return 'shape';
  }

  return 'root';
}

function isFrameElement(element) {

  return !!(element && element.isFrame);
}

// helpers ///////////////////////////////

function copyObject(src1, src2) {
  return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({}, src1 || {}, src2 || {});
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/util/Event.js":
/*!***************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/Event.js ***!
  \***************************************************/
/*! exports provided: getOriginal, stopPropagation, toPoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOriginal", function() { return getOriginal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stopPropagation", function() { return stopPropagation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toPoint", function() { return toPoint; });
function __stopPropagation(event) {
  if (!event || typeof event.stopPropagation !== 'function') {
    return;
  }

  event.stopPropagation();
}


function getOriginal(event) {
  return event.originalEvent || event.srcEvent;
}


function stopPropagation(event, immediate) {
  __stopPropagation(event, immediate);
  __stopPropagation(getOriginal(event), immediate);
}


function toPoint(event) {

  if (event.pointers && event.pointers.length) {
    event = event.pointers[0];
  }

  if (event.touches && event.touches.length) {
    event = event.touches[0];
  }

  return event ? {
    x: event.clientX,
    y: event.clientY
  } : null;
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/util/Geometry.js":
/*!******************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/Geometry.js ***!
  \******************************************************/
/*! exports provided: pointDistance, pointsOnLine, pointsAligned, pointsAlignedHorizontally, pointsAlignedVertically, pointInRect, getMidPoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointDistance", function() { return pointDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointsOnLine", function() { return pointsOnLine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointsAligned", function() { return pointsAligned; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointsAlignedHorizontally", function() { return pointsAlignedHorizontally; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointsAlignedVertically", function() { return pointsAlignedVertically; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointInRect", function() { return pointInRect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMidPoint", function() { return getMidPoint; });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


/**
 * Computes the distance between two points
 *
 * @param  {Point}  p
 * @param  {Point}  q
 *
 * @return {Number}  distance
 */
function pointDistance(a, b) {
  if (!a || !b) {
    return -1;
  }

  return Math.sqrt(
    Math.pow(a.x - b.x, 2) +
    Math.pow(a.y - b.y, 2)
  );
}


/**
 * Returns true if the point r is on the line between p and q
 *
 * @param  {Point}  p
 * @param  {Point}  q
 * @param  {Point}  r
 * @param  {Number} [accuracy=5] accuracy for points on line check (lower is better)
 *
 * @return {Boolean}
 */
function pointsOnLine(p, q, r, accuracy) {

  if (typeof accuracy === 'undefined') {
    accuracy = 5;
  }

  if (!p || !q || !r) {
    return false;
  }

  var val = (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x),
      dist = pointDistance(p, q);

  // @see http://stackoverflow.com/a/907491/412190
  return Math.abs(val / dist) <= accuracy;
}


var ALIGNED_THRESHOLD = 2;

/**
 * Check whether two points are horizontally or vertically aligned.
 *
 * @param {Array<Point>|Point}
 * @param {Point}
 *
 * @return {string|Boolean}
 */
function pointsAligned(a, b) {
  var points;

  if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isArray"])(a)) {
    points = a;
  } else {
    points = [ a, b ];
  }

  if (pointsAlignedHorizontally(points)) {
    return 'h';
  }

  if (pointsAlignedVertically(points)) {
    return 'v';
  }

  return false;
}

function pointsAlignedHorizontally(a, b) {
  var points;

  if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isArray"])(a)) {
    points = a;
  } else {
    points = [ a, b ];
  }

  var firstPoint = points.slice().shift();

  return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["every"])(points, function(point) {
    return Math.abs(firstPoint.y - point.y) <= ALIGNED_THRESHOLD;
  });
}

function pointsAlignedVertically(a, b) {
  var points;

  if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isArray"])(a)) {
    points = a;
  } else {
    points = [ a, b ];
  }

  var firstPoint = points.slice().shift();

  return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["every"])(points, function(point) {
    return Math.abs(firstPoint.x - point.x) <= ALIGNED_THRESHOLD;
  });
}



/**
 * Returns true if the point p is inside the rectangle rect
 *
 * @param  {Point}  p
 * @param  {Rect} rect
 * @param  {Number} tolerance
 *
 * @return {Boolean}
 */
function pointInRect(p, rect, tolerance) {
  tolerance = tolerance || 0;

  return p.x > rect.x - tolerance &&
         p.y > rect.y - tolerance &&
         p.x < rect.x + rect.width + tolerance &&
         p.y < rect.y + rect.height + tolerance;
}

/**
 * Returns a point in the middle of points p and q
 *
 * @param  {Point}  p
 * @param  {Point}  q
 *
 * @return {Point} middle point
 */
function getMidPoint(p, q) {
  return {
    x: Math.round(p.x + ((q.x - p.x) / 2.0)),
    y: Math.round(p.y + ((q.y - p.y) / 2.0))
  };
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/util/GraphicsUtil.js":
/*!**********************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/GraphicsUtil.js ***!
  \**********************************************************/
/*! exports provided: getVisual, getChildren */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getVisual", function() { return getVisual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getChildren", function() { return getChildren; });
/**
 * SVGs for elements are generated by the {@link GraphicsFactory}.
 *
 * This utility gives quick access to the important semantic
 * parts of an element.
 */

/**
 * Returns the visual part of a diagram element
 *
 * @param {Snap<SVGElement>} gfx
 *
 * @return {Snap<SVGElement>}
 */
function getVisual(gfx) {
  return gfx.childNodes[0];
}

/**
 * Returns the children for a given diagram element.
 *
 * @param {Snap<SVGElement>} gfx
 * @return {Snap<SVGElement>}
 */
function getChildren(gfx) {
  return gfx.parentNode.childNodes[1];
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/util/IdGenerator.js":
/*!*********************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/IdGenerator.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IdGenerator; });
/**
 * Util that provides unique IDs.
 *
 * @class djs.util.IdGenerator
 * @constructor
 * @memberOf djs.util
 *
 * The ids can be customized via a given prefix and contain a random value to avoid collisions.
 *
 * @param {String} prefix a prefix to prepend to generated ids (for better readability)
 */
function IdGenerator(prefix) {

  this._counter = 0;
  this._prefix = (prefix ? prefix + '-' : '') + Math.floor(Math.random() * 1000000000) + '-';
}

/**
 * Returns a next unique ID.
 *
 * @method djs.util.IdGenerator#next
 *
 * @returns {String} the id
 */
IdGenerator.prototype.next = function() {
  return this._prefix + (++this._counter);
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/util/Mouse.js":
/*!***************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/Mouse.js ***!
  \***************************************************/
/*! exports provided: isMac, isPrimaryButton, hasPrimaryModifier, hasSecondaryModifier */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPrimaryButton", function() { return isPrimaryButton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasPrimaryModifier", function() { return hasPrimaryModifier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasSecondaryModifier", function() { return hasSecondaryModifier; });
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Event */ "./node_modules/diagram-js/lib/util/Event.js");
/* harmony import */ var _Platform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Platform */ "./node_modules/diagram-js/lib/util/Platform.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isMac", function() { return _Platform__WEBPACK_IMPORTED_MODULE_1__["isMac"]; });








function isPrimaryButton(event) {

  // button === 0 -> left áka primary mouse button
  return !(Object(_Event__WEBPACK_IMPORTED_MODULE_0__["getOriginal"])(event) || event).button;
}

function hasPrimaryModifier(event) {
  var originalEvent = Object(_Event__WEBPACK_IMPORTED_MODULE_0__["getOriginal"])(event) || event;

  if (!isPrimaryButton(event)) {
    return false;
  }

  // Use alt as primary modifier key for mac OS
  if (Object(_Platform__WEBPACK_IMPORTED_MODULE_1__["isMac"])()) {
    return originalEvent.metaKey;
  } else {
    return originalEvent.ctrlKey;
  }
}


function hasSecondaryModifier(event) {
  var originalEvent = Object(_Event__WEBPACK_IMPORTED_MODULE_0__["getOriginal"])(event) || event;

  return isPrimaryButton(event) && originalEvent.shiftKey;
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/util/Platform.js":
/*!******************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/Platform.js ***!
  \******************************************************/
/*! exports provided: isMac */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isMac", function() { return isMac; });
function isMac() {
  return (/mac/i).test(navigator.platform);
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/util/RenderUtil.js":
/*!********************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/RenderUtil.js ***!
  \********************************************************/
/*! exports provided: componentsToPath, toSVGPoints, createLine, updateLine */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "componentsToPath", function() { return componentsToPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toSVGPoints", function() { return toSVGPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createLine", function() { return createLine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateLine", function() { return updateLine; });
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");



function componentsToPath(elements) {
  return elements.join(',').replace(/,?([A-z]),?/g, '$1');
}

function toSVGPoints(points) {
  var result = '';

  for (var i = 0, p; (p = points[i]); i++) {
    result += p.x + ',' + p.y + ' ';
  }

  return result;
}

function createLine(points, attrs) {

  var line = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_0__["create"])('polyline');
  Object(tiny_svg__WEBPACK_IMPORTED_MODULE_0__["attr"])(line, { points: toSVGPoints(points) });

  if (attrs) {
    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_0__["attr"])(line, attrs);
  }

  return line;
}

function updateLine(gfx, points) {
  Object(tiny_svg__WEBPACK_IMPORTED_MODULE_0__["attr"])(gfx, { points: toSVGPoints(points) });

  return gfx;
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/util/SvgTransformUtil.js":
/*!**************************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/SvgTransformUtil.js ***!
  \**************************************************************/
/*! exports provided: transform, translate, rotate, scale */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transform", function() { return transform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");



/**
 * @param {<SVGElement>} element
 * @param {Number} x
 * @param {Number} y
 * @param {Number} angle
 * @param {Number} amount
 */
function transform(gfx, x, y, angle, amount) {
  var translate = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_0__["createTransform"])();
  translate.setTranslate(x, y);

  var rotate = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_0__["createTransform"])();
  rotate.setRotate(angle || 0, 0, 0);

  var scale = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_0__["createTransform"])();
  scale.setScale(amount || 1, amount || 1);

  Object(tiny_svg__WEBPACK_IMPORTED_MODULE_0__["transform"])(gfx, [ translate, rotate, scale ]);
}


/**
 * @param {SVGElement} element
 * @param {Number} x
 * @param {Number} y
 */
function translate(gfx, x, y) {
  var translate = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_0__["createTransform"])();
  translate.setTranslate(x, y);

  Object(tiny_svg__WEBPACK_IMPORTED_MODULE_0__["transform"])(gfx, translate);
}


/**
 * @param {SVGElement} element
 * @param {Number} angle
 */
function rotate(gfx, angle) {
  var rotate = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_0__["createTransform"])();
  rotate.setRotate(angle, 0, 0);

  Object(tiny_svg__WEBPACK_IMPORTED_MODULE_0__["transform"])(gfx, rotate);
}


/**
 * @param {SVGElement} element
 * @param {Number} amount
 */
function scale(gfx, amount) {
  var scale = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_0__["createTransform"])();
  scale.setScale(amount, amount);

  Object(tiny_svg__WEBPACK_IMPORTED_MODULE_0__["transform"])(gfx, scale);
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/util/Text.js":
/*!**************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/Text.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Text; });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");




var DEFAULT_BOX_PADDING = 0;

var DEFAULT_LABEL_SIZE = {
  width: 150,
  height: 50
};


function parseAlign(align) {

  var parts = align.split('-');

  return {
    horizontal: parts[0] || 'center',
    vertical: parts[1] || 'top'
  };
}

function parsePadding(padding) {

  if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isObject"])(padding)) {
    return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({ top: 0, left: 0, right: 0, bottom: 0 }, padding);
  } else {
    return {
      top: padding,
      left: padding,
      right: padding,
      bottom: padding
    };
  }
}

function getTextBBox(text, fakeText) {

  fakeText.textContent = text;

  var textBBox;

  try {
    var bbox,
        emptyLine = text === '';

    // add dummy text, when line is empty to
    // determine correct height
    fakeText.textContent = emptyLine ? 'dummy' : text;

    textBBox = fakeText.getBBox();

    // take text rendering related horizontal
    // padding into account
    bbox = {
      width: textBBox.width + textBBox.x * 2,
      height: textBBox.height
    };

    if (emptyLine) {

      // correct width
      bbox.width = 0;
    }

    return bbox;
  } catch (e) {
    return { width: 0, height: 0 };
  }
}


/**
 * Layout the next line and return the layouted element.
 *
 * Alters the lines passed.
 *
 * @param  {Array<String>} lines
 * @return {Object} the line descriptor, an object { width, height, text }
 */
function layoutNext(lines, maxWidth, fakeText) {

  var originalLine = lines.shift(),
      fitLine = originalLine;

  var textBBox;

  for (;;) {
    textBBox = getTextBBox(fitLine, fakeText);

    textBBox.width = fitLine ? textBBox.width : 0;

    // try to fit
    if (fitLine === ' ' || fitLine === '' || textBBox.width < Math.round(maxWidth) || fitLine.length < 2) {
      return fit(lines, fitLine, originalLine, textBBox);
    }

    fitLine = shortenLine(fitLine, textBBox.width, maxWidth);
  }
}

function fit(lines, fitLine, originalLine, textBBox) {
  if (fitLine.length < originalLine.length) {
    var remainder = originalLine.slice(fitLine.length).trim();

    lines.unshift(remainder);
  }

  return {
    width: textBBox.width,
    height: textBBox.height,
    text: fitLine
  };
}


/**
 * Shortens a line based on spacing and hyphens.
 * Returns the shortened result on success.
 *
 * @param  {String} line
 * @param  {Number} maxLength the maximum characters of the string
 * @return {String} the shortened string
 */
function semanticShorten(line, maxLength) {
  var parts = line.split(/(\s|-)/g),
      part,
      shortenedParts = [],
      length = 0;

  // try to shorten via spaces + hyphens
  if (parts.length > 1) {
    while ((part = parts.shift())) {
      if (part.length + length < maxLength) {
        shortenedParts.push(part);
        length += part.length;
      } else {

        // remove previous part, too if hyphen does not fit anymore
        if (part === '-') {
          shortenedParts.pop();
        }

        break;
      }
    }
  }

  return shortenedParts.join('');
}


function shortenLine(line, width, maxWidth) {
  var length = Math.max(line.length * (maxWidth / width), 1);

  // try to shorten semantically (i.e. based on spaces and hyphens)
  var shortenedLine = semanticShorten(line, length);

  if (!shortenedLine) {

    // force shorten by cutting the long word
    shortenedLine = line.slice(0, Math.max(Math.round(length - 1), 1));
  }

  return shortenedLine;
}


function getHelperSvg() {
  var helperSvg = document.getElementById('helper-svg');

  if (!helperSvg) {
    helperSvg = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_1__["create"])('svg');

    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_1__["attr"])(helperSvg, {
      id: 'helper-svg',
      width: 0,
      height: 0,
      style: 'visibility: hidden; position: fixed'
    });

    document.body.appendChild(helperSvg);
  }

  return helperSvg;
}


/**
 * Creates a new label utility
 *
 * @param {Object} config
 * @param {Dimensions} config.size
 * @param {Number} config.padding
 * @param {Object} config.style
 * @param {String} config.align
 */
function Text(config) {

  this._config = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({}, {
    size: DEFAULT_LABEL_SIZE,
    padding: DEFAULT_BOX_PADDING,
    style: {},
    align: 'center-top'
  }, config || {});
}

/**
 * Returns the layouted text as an SVG element.
 *
 * @param {String} text
 * @param {Object} options
 *
 * @return {SVGElement}
 */
Text.prototype.createText = function(text, options) {
  return this.layoutText(text, options).element;
};

/**
 * Returns a labels layouted dimensions.
 *
 * @param {String} text to layout
 * @param {Object} options
 *
 * @return {Dimensions}
 */
Text.prototype.getDimensions = function(text, options) {
  return this.layoutText(text, options).dimensions;
};

/**
 * Creates and returns a label and its bounding box.
 *
 * @method Text#createText
 *
 * @param {String} text the text to render on the label
 * @param {Object} options
 * @param {String} options.align how to align in the bounding box.
 *                               Any of { 'center-middle', 'center-top' },
 *                               defaults to 'center-top'.
 * @param {String} options.style style to be applied to the text
 * @param {boolean} options.fitBox indicates if box will be recalculated to
 *                                 fit text
 *
 * @return {Object} { element, dimensions }
 */
Text.prototype.layoutText = function(text, options) {
  var box = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({}, this._config.size, options.box),
      style = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({}, this._config.style, options.style),
      align = parseAlign(options.align || this._config.align),
      padding = parsePadding(options.padding !== undefined ? options.padding : this._config.padding),
      fitBox = options.fitBox || false;

  var lineHeight = getLineHeight(style);

  var lines = text.split(/\r?\n/g),
      layouted = [];

  var maxWidth = box.width - padding.left - padding.right;

  // ensure correct rendering by attaching helper text node to invisible SVG
  var helperText = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_1__["create"])('text');
  Object(tiny_svg__WEBPACK_IMPORTED_MODULE_1__["attr"])(helperText, { x: 0, y: 0 });
  Object(tiny_svg__WEBPACK_IMPORTED_MODULE_1__["attr"])(helperText, style);

  var helperSvg = getHelperSvg();

  Object(tiny_svg__WEBPACK_IMPORTED_MODULE_1__["append"])(helperSvg, helperText);

  while (lines.length) {
    layouted.push(layoutNext(lines, maxWidth, helperText));
  }

  if (align.vertical === 'middle') {
    padding.top = padding.bottom = 0;
  }

  var totalHeight = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["reduce"])(layouted, function(sum, line, idx) {
    return sum + (lineHeight || line.height);
  }, 0) + padding.top + padding.bottom;

  var maxLineWidth = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["reduce"])(layouted, function(sum, line, idx) {
    return line.width > sum ? line.width : sum;
  }, 0);

  // the y position of the next line
  var y = padding.top;

  if (align.vertical === 'middle') {
    y += (box.height - totalHeight) / 2;
  }

  // magic number initial offset
  y -= (lineHeight || layouted[0].height) / 4;


  var textElement = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_1__["create"])('text');

  Object(tiny_svg__WEBPACK_IMPORTED_MODULE_1__["attr"])(textElement, style);

  // layout each line taking into account that parent
  // shape might resize to fit text size
  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(layouted, function(line) {

    var x;

    y += (lineHeight || line.height);

    switch (align.horizontal) {
    case 'left':
      x = padding.left;
      break;

    case 'right':
      x = ((fitBox ? maxLineWidth : maxWidth)
        - padding.right - line.width);
      break;

    default:

      // aka center
      x = Math.max((((fitBox ? maxLineWidth : maxWidth)
        - line.width) / 2 + padding.left), 0);
    }

    var tspan = Object(tiny_svg__WEBPACK_IMPORTED_MODULE_1__["create"])('tspan');
    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_1__["attr"])(tspan, { x: x, y: y });

    tspan.textContent = line.text;

    Object(tiny_svg__WEBPACK_IMPORTED_MODULE_1__["append"])(textElement, tspan);
  });

  Object(tiny_svg__WEBPACK_IMPORTED_MODULE_1__["remove"])(helperText);

  var dimensions = {
    width: maxLineWidth,
    height: totalHeight
  };

  return {
    dimensions: dimensions,
    element: textElement
  };
};


function getLineHeight(style) {
  if ('fontSize' in style && 'lineHeight' in style) {
    return style.lineHeight * parseInt(style.fontSize, 10);
  }
}

/***/ }),

/***/ "./node_modules/didi/dist/index.esm.js":
/*!*********************************************!*\
  !*** ./node_modules/didi/dist/index.esm.js ***!
  \*********************************************/
/*! exports provided: annotate, Module, Injector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "annotate", function() { return annotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Module", function() { return Module; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Injector", function() { return Injector; });
var CLASS_PATTERN = /^class /;

function isClass(fn) {
  return CLASS_PATTERN.test(fn.toString());
}

function isArray(obj) {
  return Object.prototype.toString.call(obj) === '[object Array]';
}

function annotate() {
  var args = Array.prototype.slice.call(arguments);

  if (args.length === 1 && isArray(args[0])) {
    args = args[0];
  }

  var fn = args.pop();

  fn.$inject = args;

  return fn;
}

// Current limitations:
// - can't put into "function arg" comments
// function /* (no parenthesis like this) */ (){}
// function abc( /* xx (no parenthesis like this) */ a, b) {}
//
// Just put the comment before function or inside:
// /* (((this is fine))) */ function(a, b) {}
// function abc(a) { /* (((this is fine))) */}
//
// - can't reliably auto-annotate constructor; we'll match the
// first constructor(...) pattern found which may be the one
// of a nested class, too.

var CONSTRUCTOR_ARGS = /constructor\s*[^(]*\(\s*([^)]*)\)/m;
var FN_ARGS = /^function\s*[^(]*\(\s*([^)]*)\)/m;
var FN_ARG = /\/\*([^*]*)\*\//m;

function parse(fn) {

  if (typeof fn !== 'function') {
    throw new Error('Cannot annotate "' + fn + '". Expected a function!');
  }

  var match = fn.toString().match(isClass(fn) ? CONSTRUCTOR_ARGS : FN_ARGS);

  // may parse class without constructor
  if (!match) {
    return [];
  }

  return match[1] && match[1].split(',').map(function (arg) {
    match = arg.match(FN_ARG);
    return match ? match[1].trim() : arg.trim();
  }) || [];
}

function Module() {
  var providers = [];

  this.factory = function (name, factory) {
    providers.push([name, 'factory', factory]);
    return this;
  };

  this.value = function (name, value) {
    providers.push([name, 'value', value]);
    return this;
  };

  this.type = function (name, type) {
    providers.push([name, 'type', type]);
    return this;
  };

  this.forEach = function (iterator) {
    providers.forEach(iterator);
  };
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function Injector(modules, parent) {
  parent = parent || {
    get: function get(name, strict) {
      currentlyResolving.push(name);

      if (strict === false) {
        return null;
      } else {
        throw error('No provider for "' + name + '"!');
      }
    }
  };

  var currentlyResolving = [];
  var providers = this._providers = Object.create(parent._providers || null);
  var instances = this._instances = Object.create(null);

  var self = instances.injector = this;

  var error = function error(msg) {
    var stack = currentlyResolving.join(' -> ');
    currentlyResolving.length = 0;
    return new Error(stack ? msg + ' (Resolving: ' + stack + ')' : msg);
  };

  /**
   * Return a named service.
   *
   * @param {String} name
   * @param {Boolean} [strict=true] if false, resolve missing services to null
   *
   * @return {Object}
   */
  var get = function get(name, strict) {
    if (!providers[name] && name.indexOf('.') !== -1) {
      var parts = name.split('.');
      var pivot = get(parts.shift());

      while (parts.length) {
        pivot = pivot[parts.shift()];
      }

      return pivot;
    }

    if (hasProp(instances, name)) {
      return instances[name];
    }

    if (hasProp(providers, name)) {
      if (currentlyResolving.indexOf(name) !== -1) {
        currentlyResolving.push(name);
        throw error('Cannot resolve circular dependency!');
      }

      currentlyResolving.push(name);
      instances[name] = providers[name][0](providers[name][1]);
      currentlyResolving.pop();

      return instances[name];
    }

    return parent.get(name, strict);
  };

  var fnDef = function fnDef(fn) {
    var locals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (typeof fn !== 'function') {
      if (isArray(fn)) {
        fn = annotate(fn.slice());
      } else {
        throw new Error('Cannot invoke "' + fn + '". Expected a function!');
      }
    }

    var inject = fn.$inject || parse(fn);
    var dependencies = inject.map(function (dep) {
      if (hasProp(locals, dep)) {
        return locals[dep];
      } else {
        return get(dep);
      }
    });

    return {
      fn: fn,
      dependencies: dependencies
    };
  };

  var instantiate = function instantiate(Type) {
    var _fnDef = fnDef(Type),
        dependencies = _fnDef.dependencies,
        fn = _fnDef.fn;

    return new (Function.prototype.bind.apply(fn, [null].concat(_toConsumableArray(dependencies))))();
  };

  var invoke = function invoke(func, context, locals) {
    var _fnDef2 = fnDef(func, locals),
        dependencies = _fnDef2.dependencies,
        fn = _fnDef2.fn;

    return fn.call.apply(fn, [context].concat(_toConsumableArray(dependencies)));
  };

  var createPrivateInjectorFactory = function createPrivateInjectorFactory(privateChildInjector) {
    return annotate(function (key) {
      return privateChildInjector.get(key);
    });
  };

  var createChild = function createChild(modules, forceNewInstances) {
    if (forceNewInstances && forceNewInstances.length) {
      var fromParentModule = Object.create(null);
      var matchedScopes = Object.create(null);

      var privateInjectorsCache = [];
      var privateChildInjectors = [];
      var privateChildFactories = [];

      var provider;
      var cacheIdx;
      var privateChildInjector;
      var privateChildInjectorFactory;
      for (var name in providers) {
        provider = providers[name];

        if (forceNewInstances.indexOf(name) !== -1) {
          if (provider[2] === 'private') {
            cacheIdx = privateInjectorsCache.indexOf(provider[3]);
            if (cacheIdx === -1) {
              privateChildInjector = provider[3].createChild([], forceNewInstances);
              privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);
              privateInjectorsCache.push(provider[3]);
              privateChildInjectors.push(privateChildInjector);
              privateChildFactories.push(privateChildInjectorFactory);
              fromParentModule[name] = [privateChildInjectorFactory, name, 'private', privateChildInjector];
            } else {
              fromParentModule[name] = [privateChildFactories[cacheIdx], name, 'private', privateChildInjectors[cacheIdx]];
            }
          } else {
            fromParentModule[name] = [provider[2], provider[1]];
          }
          matchedScopes[name] = true;
        }

        if ((provider[2] === 'factory' || provider[2] === 'type') && provider[1].$scope) {
          /* jshint -W083 */
          forceNewInstances.forEach(function (scope) {
            if (provider[1].$scope.indexOf(scope) !== -1) {
              fromParentModule[name] = [provider[2], provider[1]];
              matchedScopes[scope] = true;
            }
          });
        }
      }

      forceNewInstances.forEach(function (scope) {
        if (!matchedScopes[scope]) {
          throw new Error('No provider for "' + scope + '". Cannot use provider from the parent!');
        }
      });

      modules.unshift(fromParentModule);
    }

    return new Injector(modules, self);
  };

  var factoryMap = {
    factory: invoke,
    type: instantiate,
    value: function value(_value) {
      return _value;
    }
  };

  modules.forEach(function (module) {

    function arrayUnwrap(type, value) {
      if (type !== 'value' && isArray(value)) {
        value = annotate(value.slice());
      }

      return value;
    }

    // TODO(vojta): handle wrong inputs (modules)
    if (module instanceof Module) {
      module.forEach(function (provider) {
        var name = provider[0];
        var type = provider[1];
        var value = provider[2];

        providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];
      });
    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object') {
      if (module.__exports__) {
        var clonedModule = Object.keys(module).reduce(function (m, key) {
          if (key.substring(0, 2) !== '__') {
            m[key] = module[key];
          }
          return m;
        }, Object.create(null));

        var privateInjector = new Injector((module.__modules__ || []).concat([clonedModule]), self);
        var getFromPrivateInjector = annotate(function (key) {
          return privateInjector.get(key);
        });
        module.__exports__.forEach(function (key) {
          providers[key] = [getFromPrivateInjector, key, 'private', privateInjector];
        });
      } else {
        Object.keys(module).forEach(function (name) {
          if (module[name][2] === 'private') {
            providers[name] = module[name];
            return;
          }

          var type = module[name][0];
          var value = module[name][1];

          providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];
        });
      }
    }
  });

  // public API
  this.get = get;
  this.invoke = invoke;
  this.instantiate = instantiate;
  this.createChild = createChild;
}

// helpers /////////////////

function hasProp(obj, prop) {
  return Object.hasOwnProperty.call(obj, prop);
}




/***/ }),

/***/ "./node_modules/ids/dist/index.esm.js":
/*!********************************************!*\
  !*** ./node_modules/ids/dist/index.esm.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var hat_1 = createCommonjsModule(function (module) {
var hat = module.exports = function (bits, base) {
    if (!base) base = 16;
    if (bits === undefined) bits = 128;
    if (bits <= 0) return '0';
    
    var digits = Math.log(Math.pow(2, bits)) / Math.log(base);
    for (var i = 2; digits === Infinity; i *= 2) {
        digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;
    }
    
    var rem = digits - Math.floor(digits);
    
    var res = '';
    
    for (var i = 0; i < Math.floor(digits); i++) {
        var x = Math.floor(Math.random() * base).toString(base);
        res = x + res;
    }
    
    if (rem) {
        var b = Math.pow(base, rem);
        var x = Math.floor(Math.random() * b).toString(base);
        res = x + res;
    }
    
    var parsed = parseInt(res, base);
    if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {
        return hat(bits, base)
    }
    else return res;
};

hat.rack = function (bits, base, expandBy) {
    var fn = function (data) {
        var iters = 0;
        do {
            if (iters ++ > 10) {
                if (expandBy) bits += expandBy;
                else throw new Error('too many ID collisions, use more bits')
            }
            
            var id = hat(bits, base);
        } while (Object.hasOwnProperty.call(hats, id));
        
        hats[id] = data;
        return id;
    };
    var hats = fn.hats = {};
    
    fn.get = function (id) {
        return fn.hats[id];
    };
    
    fn.set = function (id, value) {
        fn.hats[id] = value;
        return fn;
    };
    
    fn.bits = bits || 128;
    fn.base = base || 16;
    return fn;
};
});

/**
 * Create a new id generator / cache instance.
 *
 * You may optionally provide a seed that is used internally.
 *
 * @param {Seed} seed
 */

function Ids(seed) {
  if (!(this instanceof Ids)) {
    return new Ids(seed);
  }

  seed = seed || [128, 36, 1];
  this._seed = seed.length ? hat_1.rack(seed[0], seed[1], seed[2]) : seed;
}
/**
 * Generate a next id.
 *
 * @param {Object} [element] element to bind the id to
 *
 * @return {String} id
 */

Ids.prototype.next = function (element) {
  return this._seed(element || true);
};
/**
 * Generate a next id with a given prefix.
 *
 * @param {Object} [element] element to bind the id to
 *
 * @return {String} id
 */


Ids.prototype.nextPrefixed = function (prefix, element) {
  var id;

  do {
    id = prefix + this.next(true);
  } while (this.assigned(id)); // claim {prefix}{random}


  this.claim(id, element); // return

  return id;
};
/**
 * Manually claim an existing id.
 *
 * @param {String} id
 * @param {String} [element] element the id is claimed by
 */


Ids.prototype.claim = function (id, element) {
  this._seed.set(id, element || true);
};
/**
 * Returns true if the given id has already been assigned.
 *
 * @param  {String} id
 * @return {Boolean}
 */


Ids.prototype.assigned = function (id) {
  return this._seed.get(id) || false;
};
/**
 * Unclaim an id.
 *
 * @param  {String} id the id to unclaim
 */


Ids.prototype.unclaim = function (id) {
  delete this._seed.hats[id];
};
/**
 * Clear all claimed ids.
 */


Ids.prototype.clear = function () {
  var hats = this._seed.hats,
      id;

  for (id in hats) {
    this.unclaim(id);
  }
};

/* harmony default export */ __webpack_exports__["default"] = (Ids);
//# sourceMappingURL=index.esm.js.map


/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "./node_modules/min-dash/dist/index.esm.js":
/*!*************************************************!*\
  !*** ./node_modules/min-dash/dist/index.esm.js ***!
  \*************************************************/
/*! exports provided: flatten, find, findIndex, filter, forEach, without, reduce, every, some, map, keys, size, values, groupBy, uniqueBy, unionBy, sortBy, matchPattern, debounce, throttle, bind, isUndefined, isDefined, isNil, isArray, isObject, isNumber, isFunction, isString, ensureArray, has, assign, pick, omit, merge */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flatten", function() { return flatten; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "find", function() { return find; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findIndex", function() { return findIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "filter", function() { return filter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "without", function() { return without; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reduce", function() { return reduce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "every", function() { return every; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "some", function() { return some; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "map", function() { return map; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keys", function() { return keys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "size", function() { return size; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "values", function() { return values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "groupBy", function() { return groupBy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uniqueBy", function() { return uniqueBy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unionBy", function() { return unionBy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sortBy", function() { return sortBy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matchPattern", function() { return matchPattern; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "debounce", function() { return debounce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "throttle", function() { return throttle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bind", function() { return bind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isUndefined", function() { return isUndefined; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDefined", function() { return isDefined; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNil", function() { return isNil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isArray", function() { return isArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObject", function() { return isObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNumber", function() { return isNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFunction", function() { return isFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isString", function() { return isString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ensureArray", function() { return ensureArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "has", function() { return has; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assign", function() { return assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pick", function() { return pick; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "omit", function() { return omit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return merge; });
/**
 * Flatten array, one level deep.
 *
 * @param {Array<?>} arr
 *
 * @return {Array<?>}
 */
function flatten(arr) {
  return Array.prototype.concat.apply([], arr);
}

var nativeToString = Object.prototype.toString;
var nativeHasOwnProperty = Object.prototype.hasOwnProperty;
function isUndefined(obj) {
  return obj === undefined;
}
function isDefined(obj) {
  return obj !== undefined;
}
function isNil(obj) {
  return obj == null;
}
function isArray(obj) {
  return nativeToString.call(obj) === '[object Array]';
}
function isObject(obj) {
  return nativeToString.call(obj) === '[object Object]';
}
function isNumber(obj) {
  return nativeToString.call(obj) === '[object Number]';
}
function isFunction(obj) {
  var tag = nativeToString.call(obj);
  return tag === '[object Function]' || tag === '[object AsyncFunction]' || tag === '[object GeneratorFunction]' || tag === '[object AsyncGeneratorFunction]' || tag === '[object Proxy]';
}
function isString(obj) {
  return nativeToString.call(obj) === '[object String]';
}
/**
 * Ensure collection is an array.
 *
 * @param {Object} obj
 */

function ensureArray(obj) {
  if (isArray(obj)) {
    return;
  }

  throw new Error('must supply array');
}
/**
 * Return true, if target owns a property with the given key.
 *
 * @param {Object} target
 * @param {String} key
 *
 * @return {Boolean}
 */

function has(target, key) {
  return nativeHasOwnProperty.call(target, key);
}

/**
 * Find element in collection.
 *
 * @param  {Array|Object} collection
 * @param  {Function|Object} matcher
 *
 * @return {Object}
 */

function find(collection, matcher) {
  matcher = toMatcher(matcher);
  var match;
  forEach(collection, function (val, key) {
    if (matcher(val, key)) {
      match = val;
      return false;
    }
  });
  return match;
}
/**
 * Find element index in collection.
 *
 * @param  {Array|Object} collection
 * @param  {Function} matcher
 *
 * @return {Object}
 */

function findIndex(collection, matcher) {
  matcher = toMatcher(matcher);
  var idx = isArray(collection) ? -1 : undefined;
  forEach(collection, function (val, key) {
    if (matcher(val, key)) {
      idx = key;
      return false;
    }
  });
  return idx;
}
/**
 * Find element in collection.
 *
 * @param  {Array|Object} collection
 * @param  {Function} matcher
 *
 * @return {Array} result
 */

function filter(collection, matcher) {
  var result = [];
  forEach(collection, function (val, key) {
    if (matcher(val, key)) {
      result.push(val);
    }
  });
  return result;
}
/**
 * Iterate over collection; returning something
 * (non-undefined) will stop iteration.
 *
 * @param  {Array|Object} collection
 * @param  {Function} iterator
 *
 * @return {Object} return result that stopped the iteration
 */

function forEach(collection, iterator) {
  var val, result;

  if (isUndefined(collection)) {
    return;
  }

  var convertKey = isArray(collection) ? toNum : identity;

  for (var key in collection) {
    if (has(collection, key)) {
      val = collection[key];
      result = iterator(val, convertKey(key));

      if (result === false) {
        return val;
      }
    }
  }
}
/**
 * Return collection without element.
 *
 * @param  {Array} arr
 * @param  {Function} matcher
 *
 * @return {Array}
 */

function without(arr, matcher) {
  if (isUndefined(arr)) {
    return [];
  }

  ensureArray(arr);
  matcher = toMatcher(matcher);
  return arr.filter(function (el, idx) {
    return !matcher(el, idx);
  });
}
/**
 * Reduce collection, returning a single result.
 *
 * @param  {Object|Array} collection
 * @param  {Function} iterator
 * @param  {Any} result
 *
 * @return {Any} result returned from last iterator
 */

function reduce(collection, iterator, result) {
  forEach(collection, function (value, idx) {
    result = iterator(result, value, idx);
  });
  return result;
}
/**
 * Return true if every element in the collection
 * matches the criteria.
 *
 * @param  {Object|Array} collection
 * @param  {Function} matcher
 *
 * @return {Boolean}
 */

function every(collection, matcher) {
  return !!reduce(collection, function (matches, val, key) {
    return matches && matcher(val, key);
  }, true);
}
/**
 * Return true if some elements in the collection
 * match the criteria.
 *
 * @param  {Object|Array} collection
 * @param  {Function} matcher
 *
 * @return {Boolean}
 */

function some(collection, matcher) {
  return !!find(collection, matcher);
}
/**
 * Transform a collection into another collection
 * by piping each member through the given fn.
 *
 * @param  {Object|Array}   collection
 * @param  {Function} fn
 *
 * @return {Array} transformed collection
 */

function map(collection, fn) {
  var result = [];
  forEach(collection, function (val, key) {
    result.push(fn(val, key));
  });
  return result;
}
/**
 * Get the collections keys.
 *
 * @param  {Object|Array} collection
 *
 * @return {Array}
 */

function keys(collection) {
  return collection && Object.keys(collection) || [];
}
/**
 * Shorthand for `keys(o).length`.
 *
 * @param  {Object|Array} collection
 *
 * @return {Number}
 */

function size(collection) {
  return keys(collection).length;
}
/**
 * Get the values in the collection.
 *
 * @param  {Object|Array} collection
 *
 * @return {Array}
 */

function values(collection) {
  return map(collection, function (val) {
    return val;
  });
}
/**
 * Group collection members by attribute.
 *
 * @param  {Object|Array} collection
 * @param  {Function} extractor
 *
 * @return {Object} map with { attrValue => [ a, b, c ] }
 */

function groupBy(collection, extractor) {
  var grouped = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  extractor = toExtractor(extractor);
  forEach(collection, function (val) {
    var discriminator = extractor(val) || '_';
    var group = grouped[discriminator];

    if (!group) {
      group = grouped[discriminator] = [];
    }

    group.push(val);
  });
  return grouped;
}
function uniqueBy(extractor) {
  extractor = toExtractor(extractor);
  var grouped = {};

  for (var _len = arguments.length, collections = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    collections[_key - 1] = arguments[_key];
  }

  forEach(collections, function (c) {
    return groupBy(c, extractor, grouped);
  });
  var result = map(grouped, function (val, key) {
    return val[0];
  });
  return result;
}
var unionBy = uniqueBy;
/**
 * Sort collection by criteria.
 *
 * @param  {Object|Array} collection
 * @param  {String|Function} extractor
 *
 * @return {Array}
 */

function sortBy(collection, extractor) {
  extractor = toExtractor(extractor);
  var sorted = [];
  forEach(collection, function (value, key) {
    var disc = extractor(value, key);
    var entry = {
      d: disc,
      v: value
    };

    for (var idx = 0; idx < sorted.length; idx++) {
      var d = sorted[idx].d;

      if (disc < d) {
        sorted.splice(idx, 0, entry);
        return;
      }
    } // not inserted, append (!)


    sorted.push(entry);
  });
  return map(sorted, function (e) {
    return e.v;
  });
}
/**
 * Create an object pattern matcher.
 *
 * @example
 *
 * const matcher = matchPattern({ id: 1 });
 *
 * var element = find(elements, matcher);
 *
 * @param  {Object} pattern
 *
 * @return {Function} matcherFn
 */

function matchPattern(pattern) {
  return function (el) {
    return every(pattern, function (val, key) {
      return el[key] === val;
    });
  };
}

function toExtractor(extractor) {
  return isFunction(extractor) ? extractor : function (e) {
    return e[extractor];
  };
}

function toMatcher(matcher) {
  return isFunction(matcher) ? matcher : function (e) {
    return e === matcher;
  };
}

function identity(arg) {
  return arg;
}

function toNum(arg) {
  return Number(arg);
}

/**
 * Debounce fn, calling it only once if
 * the given time elapsed between calls.
 *
 * @param  {Function} fn
 * @param  {Number} timeout
 *
 * @return {Function} debounced function
 */
function debounce(fn, timeout) {
  var timer;
  var lastArgs;
  var lastThis;
  var lastNow;

  function fire() {
    var now = Date.now();
    var scheduledDiff = lastNow + timeout - now;

    if (scheduledDiff > 0) {
      return schedule(scheduledDiff);
    }

    fn.apply(lastThis, lastArgs);
    timer = lastNow = lastArgs = lastThis = undefined;
  }

  function schedule(timeout) {
    timer = setTimeout(fire, timeout);
  }

  return function () {
    lastNow = Date.now();

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    lastArgs = args;
    lastThis = this; // ensure an execution is scheduled

    if (!timer) {
      schedule(timeout);
    }
  };
}
/**
 * Throttle fn, calling at most once
 * in the given interval.
 *
 * @param  {Function} fn
 * @param  {Number} interval
 *
 * @return {Function} throttled function
 */

function throttle(fn, interval) {
  var throttling = false;
  return function () {
    if (throttling) {
      return;
    }

    fn.apply(void 0, arguments);
    throttling = true;
    setTimeout(function () {
      throttling = false;
    }, interval);
  };
}
/**
 * Bind function against target <this>.
 *
 * @param  {Function} fn
 * @param  {Object}   target
 *
 * @return {Function} bound function
 */

function bind(fn, target) {
  return fn.bind(target);
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/**
 * Convenience wrapper for `Object.assign`.
 *
 * @param {Object} target
 * @param {...Object} others
 *
 * @return {Object} the target
 */

function assign(target) {
  for (var _len = arguments.length, others = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    others[_key - 1] = arguments[_key];
  }

  return _extends.apply(void 0, [target].concat(others));
}
/**
 * Pick given properties from the target object.
 *
 * @param {Object} target
 * @param {Array} properties
 *
 * @return {Object} target
 */

function pick(target, properties) {
  var result = {};
  var obj = Object(target);
  forEach(properties, function (prop) {
    if (prop in obj) {
      result[prop] = target[prop];
    }
  });
  return result;
}
/**
 * Pick all target properties, excluding the given ones.
 *
 * @param {Object} target
 * @param {Array} properties
 *
 * @return {Object} target
 */

function omit(target, properties) {
  var result = {};
  var obj = Object(target);
  forEach(obj, function (prop, key) {
    if (properties.indexOf(key) === -1) {
      result[key] = prop;
    }
  });
  return result;
}
/**
 * Recursively merge `...sources` into given target.
 *
 * Does support merging objects; does not support merging arrays.
 *
 * @param {Object} target
 * @param {...Object} sources
 *
 * @return {Object} the target
 */

function merge(target) {
  for (var _len2 = arguments.length, sources = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    sources[_key2 - 1] = arguments[_key2];
  }

  if (!sources.length) {
    return target;
  }

  forEach(sources, function (source) {
    // skip non-obj sources, i.e. null
    if (!source || !isObject(source)) {
      return;
    }

    forEach(source, function (sourceVal, key) {
      if (key === '__proto__') {
        return;
      }

      var targetVal = target[key];

      if (isObject(sourceVal)) {
        if (!isObject(targetVal)) {
          // override target[key] with object
          targetVal = {};
        }

        target[key] = merge(targetVal, sourceVal);
      } else {
        target[key] = sourceVal;
      }
    });
  });
  return target;
}




/***/ }),

/***/ "./node_modules/min-dom/dist/index.esm.js":
/*!************************************************!*\
  !*** ./node_modules/min-dom/dist/index.esm.js ***!
  \************************************************/
/*! exports provided: attr, classes, clear, closest, delegate, domify, event, matches, query, queryAll, remove */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "attr", function() { return attr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "classes", function() { return classes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closest", function() { return closest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "delegate", function() { return delegateEvents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "domify", function() { return domify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "event", function() { return componentEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matches", function() { return matchesSelector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "query", function() { return query; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "queryAll", function() { return all; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "remove", function() { return remove; });
/**
 * Set attribute `name` to `val`, or get attr `name`.
 *
 * @param {Element} el
 * @param {String} name
 * @param {String} [val]
 * @api public
 */
function attr(el, name, val) {
  // get
  if (arguments.length == 2) {
    return el.getAttribute(name);
  }

  // remove
  if (val === null) {
    return el.removeAttribute(name);
  }

  // set
  el.setAttribute(name, val);

  return el;
}

var indexOf = [].indexOf;

var indexof = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};

/**
 * Taken from https://github.com/component/classes
 *
 * Without the component bits.
 */

/**
 * Whitespace regexp.
 */

var re = /\s+/;

/**
 * toString reference.
 */

var toString = Object.prototype.toString;

/**
 * Wrap `el` in a `ClassList`.
 *
 * @param {Element} el
 * @return {ClassList}
 * @api public
 */

function classes(el) {
  return new ClassList(el);
}

/**
 * Initialize a new ClassList for `el`.
 *
 * @param {Element} el
 * @api private
 */

function ClassList(el) {
  if (!el || !el.nodeType) {
    throw new Error('A DOM element reference is required');
  }
  this.el = el;
  this.list = el.classList;
}

/**
 * Add class `name` if not already present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.add = function (name) {
  // classList
  if (this.list) {
    this.list.add(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = indexof(arr, name);
  if (!~i) arr.push(name);
  this.el.className = arr.join(' ');
  return this;
};

/**
 * Remove class `name` when present, or
 * pass a regular expression to remove
 * any which match.
 *
 * @param {String|RegExp} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.remove = function (name) {
  if ('[object RegExp]' == toString.call(name)) {
    return this.removeMatching(name);
  }

  // classList
  if (this.list) {
    this.list.remove(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = indexof(arr, name);
  if (~i) arr.splice(i, 1);
  this.el.className = arr.join(' ');
  return this;
};

/**
 * Remove all classes matching `re`.
 *
 * @param {RegExp} re
 * @return {ClassList}
 * @api private
 */

ClassList.prototype.removeMatching = function (re) {
  var arr = this.array();
  for (var i = 0; i < arr.length; i++) {
    if (re.test(arr[i])) {
      this.remove(arr[i]);
    }
  }
  return this;
};

/**
 * Toggle class `name`, can force state via `force`.
 *
 * For browsers that support classList, but do not support `force` yet,
 * the mistake will be detected and corrected.
 *
 * @param {String} name
 * @param {Boolean} force
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.toggle = function (name, force) {
  // classList
  if (this.list) {
    if ('undefined' !== typeof force) {
      if (force !== this.list.toggle(name, force)) {
        this.list.toggle(name); // toggle again to correct
      }
    } else {
      this.list.toggle(name);
    }
    return this;
  }

  // fallback
  if ('undefined' !== typeof force) {
    if (!force) {
      this.remove(name);
    } else {
      this.add(name);
    }
  } else {
    if (this.has(name)) {
      this.remove(name);
    } else {
      this.add(name);
    }
  }

  return this;
};

/**
 * Return an array of classes.
 *
 * @return {Array}
 * @api public
 */

ClassList.prototype.array = function () {
  var className = this.el.getAttribute('class') || '';
  var str = className.replace(/^\s+|\s+$/g, '');
  var arr = str.split(re);
  if ('' === arr[0]) arr.shift();
  return arr;
};

/**
 * Check if class `name` is present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.has = ClassList.prototype.contains = function (name) {
  return this.list ? this.list.contains(name) : !!~indexof(this.array(), name);
};

/**
 * Remove all children from the given element.
 */
function clear(el) {

  var c;

  while (el.childNodes.length) {
    c = el.childNodes[0];
    el.removeChild(c);
  }

  return el;
}

var proto = typeof Element !== 'undefined' ? Element.prototype : {};
var vendor = proto.matches
  || proto.matchesSelector
  || proto.webkitMatchesSelector
  || proto.mozMatchesSelector
  || proto.msMatchesSelector
  || proto.oMatchesSelector;

var matchesSelector = match;

/**
 * Match `el` to `selector`.
 *
 * @param {Element} el
 * @param {String} selector
 * @return {Boolean}
 * @api public
 */

function match(el, selector) {
  if (!el || el.nodeType !== 1) return false;
  if (vendor) return vendor.call(el, selector);
  var nodes = el.parentNode.querySelectorAll(selector);
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i] == el) return true;
  }
  return false;
}

/**
 * Closest
 *
 * @param {Element} el
 * @param {String} selector
 * @param {Boolean} checkYourSelf (optional)
 */
function closest (element, selector, checkYourSelf) {
  var currentElem = checkYourSelf ? element : element.parentNode;

  while (currentElem && currentElem.nodeType !== document.DOCUMENT_NODE && currentElem.nodeType !== document.DOCUMENT_FRAGMENT_NODE) {

    if (matchesSelector(currentElem, selector)) {
      return currentElem;
    }

    currentElem = currentElem.parentNode;
  }

  return matchesSelector(currentElem, selector) ? currentElem : null;
}

/**
 * Element prototype.
 */

var proto$1 = Element.prototype;

/**
 * Vendor function.
 */

var vendor$1 = proto$1.matchesSelector
  || proto$1.webkitMatchesSelector
  || proto$1.mozMatchesSelector
  || proto$1.msMatchesSelector
  || proto$1.oMatchesSelector;

/**
 * Expose `match()`.
 */

var matchesSelector$1 = match$1;

/**
 * Match `el` to `selector`.
 *
 * @param {Element} el
 * @param {String} selector
 * @return {Boolean}
 * @api public
 */

function match$1(el, selector) {
  if (vendor$1) return vendor$1.call(el, selector);
  var nodes = el.parentNode.querySelectorAll(selector);
  for (var i = 0; i < nodes.length; ++i) {
    if (nodes[i] == el) return true;
  }
  return false;
}

var closest$1 = function (element, selector, checkYoSelf) {
  var parent = checkYoSelf ? element : element.parentNode;

  while (parent && parent !== document) {
    if (matchesSelector$1(parent, selector)) return parent;
    parent = parent.parentNode;
  }
};

var bind = window.addEventListener ? 'addEventListener' : 'attachEvent',
    unbind = window.removeEventListener ? 'removeEventListener' : 'detachEvent',
    prefix = bind !== 'addEventListener' ? 'on' : '';

/**
 * Bind `el` event `type` to `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

var bind_1 = function(el, type, fn, capture){
  el[bind](prefix + type, fn, capture || false);
  return fn;
};

/**
 * Unbind `el` event `type`'s callback `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

var unbind_1 = function(el, type, fn, capture){
  el[unbind](prefix + type, fn, capture || false);
  return fn;
};

var componentEvent = {
	bind: bind_1,
	unbind: unbind_1
};

/**
 * Module dependencies.
 */



/**
 * Delegate event `type` to `selector`
 * and invoke `fn(e)`. A callback function
 * is returned which may be passed to `.unbind()`.
 *
 * @param {Element} el
 * @param {String} selector
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

// Some events don't bubble, so we want to bind to the capture phase instead
// when delegating.
var forceCaptureEvents = ['focus', 'blur'];

var bind$1 = function(el, selector, type, fn, capture){
  if (forceCaptureEvents.indexOf(type) !== -1) capture = true;

  return componentEvent.bind(el, type, function(e){
    var target = e.target || e.srcElement;
    e.delegateTarget = closest$1(target, selector, true, el);
    if (e.delegateTarget) fn.call(el, e);
  }, capture);
};

/**
 * Unbind event `type`'s callback `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @api public
 */

var unbind$1 = function(el, type, fn, capture){
  if (forceCaptureEvents.indexOf(type) !== -1) capture = true;

  componentEvent.unbind(el, type, fn, capture);
};

var delegateEvents = {
	bind: bind$1,
	unbind: unbind$1
};

/**
 * Expose `parse`.
 */

var domify = parse;

/**
 * Tests for browser support.
 */

var innerHTMLBug = false;
var bugTestDiv;
if (typeof document !== 'undefined') {
  bugTestDiv = document.createElement('div');
  // Setup
  bugTestDiv.innerHTML = '  <link/><table></table><a href="/a">a</a><input type="checkbox"/>';
  // Make sure that link elements get serialized correctly by innerHTML
  // This requires a wrapper element in IE
  innerHTMLBug = !bugTestDiv.getElementsByTagName('link').length;
  bugTestDiv = undefined;
}

/**
 * Wrap map from jquery.
 */

var map = {
  legend: [1, '<fieldset>', '</fieldset>'],
  tr: [2, '<table><tbody>', '</tbody></table>'],
  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
  // for script/link/style tags to work in IE6-8, you have to wrap
  // in a div with a non-whitespace character in front, ha!
  _default: innerHTMLBug ? [1, 'X<div>', '</div>'] : [0, '', '']
};

map.td =
map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

map.option =
map.optgroup = [1, '<select multiple="multiple">', '</select>'];

map.thead =
map.tbody =
map.colgroup =
map.caption =
map.tfoot = [1, '<table>', '</table>'];

map.polyline =
map.ellipse =
map.polygon =
map.circle =
map.text =
map.line =
map.path =
map.rect =
map.g = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">','</svg>'];

/**
 * Parse `html` and return a DOM Node instance, which could be a TextNode,
 * HTML DOM Node of some kind (<div> for example), or a DocumentFragment
 * instance, depending on the contents of the `html` string.
 *
 * @param {String} html - HTML string to "domify"
 * @param {Document} doc - The `document` instance to create the Node for
 * @return {DOMNode} the TextNode, DOM Node, or DocumentFragment instance
 * @api private
 */

function parse(html, doc) {
  if ('string' != typeof html) throw new TypeError('String expected');

  // default to the global `document` object
  if (!doc) doc = document;

  // tag name
  var m = /<([\w:]+)/.exec(html);
  if (!m) return doc.createTextNode(html);

  html = html.replace(/^\s+|\s+$/g, ''); // Remove leading/trailing whitespace

  var tag = m[1];

  // body support
  if (tag == 'body') {
    var el = doc.createElement('html');
    el.innerHTML = html;
    return el.removeChild(el.lastChild);
  }

  // wrap map
  var wrap = map[tag] || map._default;
  var depth = wrap[0];
  var prefix = wrap[1];
  var suffix = wrap[2];
  var el = doc.createElement('div');
  el.innerHTML = prefix + html + suffix;
  while (depth--) el = el.lastChild;

  // one element
  if (el.firstChild == el.lastChild) {
    return el.removeChild(el.firstChild);
  }

  // several elements
  var fragment = doc.createDocumentFragment();
  while (el.firstChild) {
    fragment.appendChild(el.removeChild(el.firstChild));
  }

  return fragment;
}

function query(selector, el) {
  el = el || document;

  return el.querySelector(selector);
}

function all(selector, el) {
  el = el || document;

  return el.querySelectorAll(selector);
}

function remove(el) {
  el.parentNode && el.parentNode.removeChild(el);
}




/***/ }),

/***/ "./node_modules/moddle-xml/dist/index.esm.js":
/*!***************************************************!*\
  !*** ./node_modules/moddle-xml/dist/index.esm.js ***!
  \***************************************************/
/*! exports provided: Reader, Writer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Reader", function() { return Reader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Writer", function() { return Writer; });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var saxen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! saxen */ "./node_modules/saxen/dist/index.esm.js");
/* harmony import */ var moddle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! moddle */ "./node_modules/moddle/dist/index.esm.js");




function hasLowerCaseAlias(pkg) {
  return pkg.xml && pkg.xml.tagAlias === 'lowerCase';
}

var DEFAULT_NS_MAP = {
  'xsi': 'http://www.w3.org/2001/XMLSchema-instance'
};

var XSI_TYPE = 'xsi:type';

function serializeFormat(element) {
  return element.xml && element.xml.serialize;
}

function serializeAsType(element) {
  return serializeFormat(element) === XSI_TYPE;
}

function serializeAsProperty(element) {
  return serializeFormat(element) === 'property';
}

function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function aliasToName(aliasNs, pkg) {

  if (!hasLowerCaseAlias(pkg)) {
    return aliasNs.name;
  }

  return aliasNs.prefix + ':' + capitalize(aliasNs.localName);
}

function prefixedToName(nameNs, pkg) {

  var name = nameNs.name,
      localName = nameNs.localName;

  var typePrefix = pkg.xml && pkg.xml.typePrefix;

  if (typePrefix && localName.indexOf(typePrefix) === 0) {
    return nameNs.prefix + ':' + localName.slice(typePrefix.length);
  } else {
    return name;
  }
}

function normalizeXsiTypeName(name, model) {

  var nameNs = Object(moddle__WEBPACK_IMPORTED_MODULE_2__["parseNameNS"])(name);
  var pkg = model.getPackage(nameNs.prefix);

  return prefixedToName(nameNs, pkg);
}

function error(message) {
  return new Error(message);
}

/**
 * Get the moddle descriptor for a given instance or type.
 *
 * @param  {ModdleElement|Function} element
 *
 * @return {Object} the moddle descriptor
 */
function getModdleDescriptor(element) {
  return element.$descriptor;
}

function defer(fn) {
  setTimeout(fn, 0);
}

/**
 * A parse context.
 *
 * @class
 *
 * @param {Object} options
 * @param {ElementHandler} options.rootHandler the root handler for parsing a document
 * @param {boolean} [options.lax=false] whether or not to ignore invalid elements
 */
function Context(options) {

  /**
   * @property {ElementHandler} rootHandler
   */

  /**
   * @property {Boolean} lax
   */

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])(this, options);

  this.elementsById = {};
  this.references = [];
  this.warnings = [];

  /**
   * Add an unresolved reference.
   *
   * @param {Object} reference
   */
  this.addReference = function(reference) {
    this.references.push(reference);
  };

  /**
   * Add a processed element.
   *
   * @param {ModdleElement} element
   */
  this.addElement = function(element) {

    if (!element) {
      throw error('expected element');
    }

    var elementsById = this.elementsById;

    var descriptor = getModdleDescriptor(element);

    var idProperty = descriptor.idProperty,
        id;

    if (idProperty) {
      id = element.get(idProperty.name);

      if (id) {
        // for QName validation as per http://www.w3.org/TR/REC-xml/#NT-NameChar
        if (!/^([a-z][\w-.]*:)?[a-z_][\w-.]*$/i.test(id)) {
          throw new Error('illegal ID <' + id + '>');
        }

        if (elementsById[id]) {
          throw error('duplicate ID <' + id + '>');
        }

        elementsById[id] = element;
      }
    }
  };

  /**
   * Add an import warning.
   *
   * @param {Object} warning
   * @param {String} warning.message
   * @param {Error} [warning.error]
   */
  this.addWarning = function(warning) {
    this.warnings.push(warning);
  };
}

function BaseHandler() {}

BaseHandler.prototype.handleEnd = function() {};
BaseHandler.prototype.handleText = function() {};
BaseHandler.prototype.handleNode = function() {};


/**
 * A simple pass through handler that does nothing except for
 * ignoring all input it receives.
 *
 * This is used to ignore unknown elements and
 * attributes.
 */
function NoopHandler() { }

NoopHandler.prototype = Object.create(BaseHandler.prototype);

NoopHandler.prototype.handleNode = function() {
  return this;
};

function BodyHandler() {}

BodyHandler.prototype = Object.create(BaseHandler.prototype);

BodyHandler.prototype.handleText = function(text) {
  this.body = (this.body || '') + text;
};

function ReferenceHandler(property, context) {
  this.property = property;
  this.context = context;
}

ReferenceHandler.prototype = Object.create(BodyHandler.prototype);

ReferenceHandler.prototype.handleNode = function(node) {

  if (this.element) {
    throw error('expected no sub nodes');
  } else {
    this.element = this.createReference(node);
  }

  return this;
};

ReferenceHandler.prototype.handleEnd = function() {
  this.element.id = this.body;
};

ReferenceHandler.prototype.createReference = function(node) {
  return {
    property: this.property.ns.name,
    id: ''
  };
};

function ValueHandler(propertyDesc, element) {
  this.element = element;
  this.propertyDesc = propertyDesc;
}

ValueHandler.prototype = Object.create(BodyHandler.prototype);

ValueHandler.prototype.handleEnd = function() {

  var value = this.body || '',
      element = this.element,
      propertyDesc = this.propertyDesc;

  value = Object(moddle__WEBPACK_IMPORTED_MODULE_2__["coerceType"])(propertyDesc.type, value);

  if (propertyDesc.isMany) {
    element.get(propertyDesc.name).push(value);
  } else {
    element.set(propertyDesc.name, value);
  }
};


function BaseElementHandler() {}

BaseElementHandler.prototype = Object.create(BodyHandler.prototype);

BaseElementHandler.prototype.handleNode = function(node) {
  var parser = this,
      element = this.element;

  if (!element) {
    element = this.element = this.createElement(node);

    this.context.addElement(element);
  } else {
    parser = this.handleChild(node);
  }

  return parser;
};

/**
 * @class Reader.ElementHandler
 *
 */
function ElementHandler(model, typeName, context) {
  this.model = model;
  this.type = model.getType(typeName);
  this.context = context;
}

ElementHandler.prototype = Object.create(BaseElementHandler.prototype);

ElementHandler.prototype.addReference = function(reference) {
  this.context.addReference(reference);
};

ElementHandler.prototype.handleText = function(text) {

  var element = this.element,
      descriptor = getModdleDescriptor(element),
      bodyProperty = descriptor.bodyProperty;

  if (!bodyProperty) {
    throw error('unexpected body text <' + text + '>');
  }

  BodyHandler.prototype.handleText.call(this, text);
};

ElementHandler.prototype.handleEnd = function() {

  var value = this.body,
      element = this.element,
      descriptor = getModdleDescriptor(element),
      bodyProperty = descriptor.bodyProperty;

  if (bodyProperty && value !== undefined) {
    value = Object(moddle__WEBPACK_IMPORTED_MODULE_2__["coerceType"])(bodyProperty.type, value);
    element.set(bodyProperty.name, value);
  }
};

/**
 * Create an instance of the model from the given node.
 *
 * @param  {Element} node the xml node
 */
ElementHandler.prototype.createElement = function(node) {
  var attributes = node.attributes,
      Type = this.type,
      descriptor = getModdleDescriptor(Type),
      context = this.context,
      instance = new Type({}),
      model = this.model,
      propNameNs;

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(attributes, function(value, name) {

    var prop = descriptor.propertiesByName[name],
        values;

    if (prop && prop.isReference) {

      if (!prop.isMany) {
        context.addReference({
          element: instance,
          property: prop.ns.name,
          id: value
        });
      } else {
        // IDREFS: parse references as whitespace-separated list
        values = value.split(' ');

        Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(values, function(v) {
          context.addReference({
            element: instance,
            property: prop.ns.name,
            id: v
          });
        });
      }

    } else {
      if (prop) {
        value = Object(moddle__WEBPACK_IMPORTED_MODULE_2__["coerceType"])(prop.type, value);
      } else
      if (name !== 'xmlns') {
        propNameNs = Object(moddle__WEBPACK_IMPORTED_MODULE_2__["parseNameNS"])(name, descriptor.ns.prefix);

        // check whether attribute is defined in a well-known namespace
        // if that is the case we emit a warning to indicate potential misuse
        if (model.getPackage(propNameNs.prefix)) {

          context.addWarning({
            message: 'unknown attribute <' + name + '>',
            element: instance,
            property: name,
            value: value
          });
        }
      }

      instance.set(name, value);
    }
  });

  return instance;
};

ElementHandler.prototype.getPropertyForNode = function(node) {

  var name = node.name;
  var nameNs = Object(moddle__WEBPACK_IMPORTED_MODULE_2__["parseNameNS"])(name);

  var type = this.type,
      model = this.model,
      descriptor = getModdleDescriptor(type);

  var propertyName = nameNs.name,
      property = descriptor.propertiesByName[propertyName],
      elementTypeName,
      elementType;

  // search for properties by name first

  if (property) {

    if (serializeAsType(property)) {
      elementTypeName = node.attributes[XSI_TYPE];

      // xsi type is optional, if it does not exists the
      // default type is assumed
      if (elementTypeName) {

        // take possible type prefixes from XML
        // into account, i.e.: xsi:type="t{ActualType}"
        elementTypeName = normalizeXsiTypeName(elementTypeName, model);

        elementType = model.getType(elementTypeName);

        return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({}, property, {
          effectiveType: getModdleDescriptor(elementType).name
        });
      }
    }

    // search for properties by name first
    return property;
  }

  var pkg = model.getPackage(nameNs.prefix);

  if (pkg) {
    elementTypeName = aliasToName(nameNs, pkg);
    elementType = model.getType(elementTypeName);

    // search for collection members later
    property = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["find"])(descriptor.properties, function(p) {
      return !p.isVirtual && !p.isReference && !p.isAttribute && elementType.hasType(p.type);
    });

    if (property) {
      return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({}, property, {
        effectiveType: getModdleDescriptor(elementType).name
      });
    }
  } else {
    // parse unknown element (maybe extension)
    property = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["find"])(descriptor.properties, function(p) {
      return !p.isReference && !p.isAttribute && p.type === 'Element';
    });

    if (property) {
      return property;
    }
  }

  throw error('unrecognized element <' + nameNs.name + '>');
};

ElementHandler.prototype.toString = function() {
  return 'ElementDescriptor[' + getModdleDescriptor(this.type).name + ']';
};

ElementHandler.prototype.valueHandler = function(propertyDesc, element) {
  return new ValueHandler(propertyDesc, element);
};

ElementHandler.prototype.referenceHandler = function(propertyDesc) {
  return new ReferenceHandler(propertyDesc, this.context);
};

ElementHandler.prototype.handler = function(type) {
  if (type === 'Element') {
    return new GenericElementHandler(this.model, type, this.context);
  } else {
    return new ElementHandler(this.model, type, this.context);
  }
};

/**
 * Handle the child element parsing
 *
 * @param  {Element} node the xml node
 */
ElementHandler.prototype.handleChild = function(node) {
  var propertyDesc, type, element, childHandler;

  propertyDesc = this.getPropertyForNode(node);
  element = this.element;

  type = propertyDesc.effectiveType || propertyDesc.type;

  if (Object(moddle__WEBPACK_IMPORTED_MODULE_2__["isSimpleType"])(type)) {
    return this.valueHandler(propertyDesc, element);
  }

  if (propertyDesc.isReference) {
    childHandler = this.referenceHandler(propertyDesc).handleNode(node);
  } else {
    childHandler = this.handler(type).handleNode(node);
  }

  var newElement = childHandler.element;

  // child handles may decide to skip elements
  // by not returning anything
  if (newElement !== undefined) {

    if (propertyDesc.isMany) {
      element.get(propertyDesc.name).push(newElement);
    } else {
      element.set(propertyDesc.name, newElement);
    }

    if (propertyDesc.isReference) {
      Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])(newElement, {
        element: element
      });

      this.context.addReference(newElement);
    } else {
      // establish child -> parent relationship
      newElement.$parent = element;
    }
  }

  return childHandler;
};

/**
 * An element handler that performs special validation
 * to ensure the node it gets initialized with matches
 * the handlers type (namespace wise).
 *
 * @param {Moddle} model
 * @param {String} typeName
 * @param {Context} context
 */
function RootElementHandler(model, typeName, context) {
  ElementHandler.call(this, model, typeName, context);
}

RootElementHandler.prototype = Object.create(ElementHandler.prototype);

RootElementHandler.prototype.createElement = function(node) {

  var name = node.name,
      nameNs = Object(moddle__WEBPACK_IMPORTED_MODULE_2__["parseNameNS"])(name),
      model = this.model,
      type = this.type,
      pkg = model.getPackage(nameNs.prefix),
      typeName = pkg && aliasToName(nameNs, pkg) || name;

  // verify the correct namespace if we parse
  // the first element in the handler tree
  //
  // this ensures we don't mistakenly import wrong namespace elements
  if (!type.hasType(typeName)) {
    throw error('unexpected element <' + node.originalName + '>');
  }

  return ElementHandler.prototype.createElement.call(this, node);
};


function GenericElementHandler(model, typeName, context) {
  this.model = model;
  this.context = context;
}

GenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);

GenericElementHandler.prototype.createElement = function(node) {

  var name = node.name,
      ns = Object(moddle__WEBPACK_IMPORTED_MODULE_2__["parseNameNS"])(name),
      prefix = ns.prefix,
      uri = node.ns[prefix + '$uri'],
      attributes = node.attributes;

  return this.model.createAny(name, uri, attributes);
};

GenericElementHandler.prototype.handleChild = function(node) {

  var handler = new GenericElementHandler(this.model, 'Element', this.context).handleNode(node),
      element = this.element;

  var newElement = handler.element,
      children;

  if (newElement !== undefined) {
    children = element.$children = element.$children || [];
    children.push(newElement);

    // establish child -> parent relationship
    newElement.$parent = element;
  }

  return handler;
};

GenericElementHandler.prototype.handleEnd = function() {
  if (this.body) {
    this.element.$body = this.body;
  }
};

/**
 * A reader for a meta-model
 *
 * @param {Object} options
 * @param {Model} options.model used to read xml files
 * @param {Boolean} options.lax whether to make parse errors warnings
 */
function Reader(options) {

  if (options instanceof moddle__WEBPACK_IMPORTED_MODULE_2__["Moddle"]) {
    options = {
      model: options
    };
  }

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])(this, { lax: false }, options);
}


/**
 * Parse the given XML into a moddle document tree.
 *
 * @param {String} xml
 * @param {ElementHandler|Object} options or rootHandler
 * @param  {Function} done
 */
Reader.prototype.fromXML = function(xml, options, done) {

  var rootHandler = options.rootHandler;

  if (options instanceof ElementHandler) {
    // root handler passed via (xml, { rootHandler: ElementHandler }, ...)
    rootHandler = options;
    options = {};
  } else {
    if (typeof options === 'string') {
      // rootHandler passed via (xml, 'someString', ...)
      rootHandler = this.handler(options);
      options = {};
    } else if (typeof rootHandler === 'string') {
      // rootHandler passed via (xml, { rootHandler: 'someString' }, ...)
      rootHandler = this.handler(rootHandler);
    }
  }

  var model = this.model,
      lax = this.lax;

  var context = new Context(Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({}, options, { rootHandler: rootHandler })),
      parser = new saxen__WEBPACK_IMPORTED_MODULE_1__["Parser"]({ proxy: true }),
      stack = createStack();

  rootHandler.context = context;

  // push root handler
  stack.push(rootHandler);


  /**
   * Handle error.
   *
   * @param  {Error} err
   * @param  {Function} getContext
   * @param  {boolean} lax
   *
   * @return {boolean} true if handled
   */
  function handleError(err, getContext, lax) {

    var ctx = getContext();

    var line = ctx.line,
        column = ctx.column,
        data = ctx.data;

    // we receive the full context data here,
    // for elements trim down the information
    // to the tag name, only
    if (data.charAt(0) === '<' && data.indexOf(' ') !== -1) {
      data = data.slice(0, data.indexOf(' ')) + '>';
    }

    var message =
      'unparsable content ' + (data ? data + ' ' : '') + 'detected\n\t' +
        'line: ' + line + '\n\t' +
        'column: ' + column + '\n\t' +
        'nested error: ' + err.message;

    if (lax) {
      context.addWarning({
        message: message,
        error: err
      });

      return true;
    } else {
      throw error(message);
    }
  }

  function handleWarning(err, getContext) {
    // just like handling errors in <lax=true> mode
    return handleError(err, getContext, true);
  }

  /**
   * Resolve collected references on parse end.
   */
  function resolveReferences() {

    var elementsById = context.elementsById;
    var references = context.references;

    var i, r;

    for (i = 0; (r = references[i]); i++) {
      var element = r.element;
      var reference = elementsById[r.id];
      var property = getModdleDescriptor(element).propertiesByName[r.property];

      if (!reference) {
        context.addWarning({
          message: 'unresolved reference <' + r.id + '>',
          element: r.element,
          property: r.property,
          value: r.id
        });
      }

      if (property.isMany) {
        var collection = element.get(property.name),
            idx = collection.indexOf(r);

        // we replace an existing place holder (idx != -1) or
        // append to the collection instead
        if (idx === -1) {
          idx = collection.length;
        }

        if (!reference) {
          // remove unresolvable reference
          collection.splice(idx, 1);
        } else {
          // add or update reference in collection
          collection[idx] = reference;
        }
      } else {
        element.set(property.name, reference);
      }
    }
  }

  function handleClose() {
    stack.pop().handleEnd();
  }

  var PREAMBLE_START_PATTERN = /^<\?xml /i;

  var ENCODING_PATTERN = / encoding="([^"]+)"/i;

  var UTF_8_PATTERN = /^utf-8$/i;

  function handleQuestion(question) {

    if (!PREAMBLE_START_PATTERN.test(question)) {
      return;
    }

    var match = ENCODING_PATTERN.exec(question);
    var encoding = match && match[1];

    if (!encoding || UTF_8_PATTERN.test(encoding)) {
      return;
    }

    context.addWarning({
      message:
        'unsupported document encoding <' + encoding + '>, ' +
        'falling back to UTF-8'
    });
  }

  function handleOpen(node, getContext) {
    var handler = stack.peek();

    try {
      stack.push(handler.handleNode(node));
    } catch (err) {

      if (handleError(err, getContext, lax)) {
        stack.push(new NoopHandler());
      }
    }
  }

  function handleCData(text, getContext) {

    try {
      stack.peek().handleText(text);
    } catch (err) {
      handleWarning(err, getContext);
    }
  }

  function handleText(text, getContext) {
    // strip whitespace only nodes, i.e. before
    // <!CDATA[ ... ]> sections and in between tags
    text = text.trim();

    if (!text) {
      return;
    }

    handleCData(text, getContext);
  }

  var uriMap = model.getPackages().reduce(function(uriMap, p) {
    uriMap[p.uri] = p.prefix;

    return uriMap;
  }, {});

  parser
    .ns(uriMap)
    .on('openTag', function(obj, decodeStr, selfClosing, getContext) {

      // gracefully handle unparsable attributes (attrs=false)
      var attrs = obj.attrs || {};

      var decodedAttrs = Object.keys(attrs).reduce(function(d, key) {
        var value = decodeStr(attrs[key]);

        d[key] = value;

        return d;
      }, {});

      var node = {
        name: obj.name,
        originalName: obj.originalName,
        attributes: decodedAttrs,
        ns: obj.ns
      };

      handleOpen(node, getContext);
    })
    .on('question', handleQuestion)
    .on('closeTag', handleClose)
    .on('cdata', handleCData)
    .on('text', function(text, decodeEntities, getContext) {
      handleText(decodeEntities(text), getContext);
    })
    .on('error', handleError)
    .on('warn', handleWarning);

  // deferred parse XML to make loading really ascnchronous
  // this ensures the execution environment (node or browser)
  // is kept responsive and that certain optimization strategies
  // can kick in
  defer(function() {
    var err;

    try {
      parser.parse(xml);

      resolveReferences();
    } catch (e) {
      err = e;
    }

    var element = rootHandler.element;

    // handle the situation that we could not extract
    // the desired root element from the document
    if (!err && !element) {
      err = error('failed to parse document as <' + rootHandler.type.$descriptor.name + '>');
    }

    done(err, err ? undefined : element, context);
  });
};

Reader.prototype.handler = function(name) {
  return new RootElementHandler(this.model, name);
};


// helpers //////////////////////////

function createStack() {
  var stack = [];

  Object.defineProperty(stack, 'peek', {
    value: function() {
      return this[this.length - 1];
    }
  });

  return stack;
}

var XML_PREAMBLE = '<?xml version="1.0" encoding="UTF-8"?>\n';

var ESCAPE_ATTR_CHARS = /<|>|'|"|&|\n\r|\n/g;
var ESCAPE_CHARS = /<|>|&/g;


function Namespaces(parent) {

  var prefixMap = {};
  var uriMap = {};
  var used = {};

  var wellknown = [];
  var custom = [];

  // API

  this.byUri = function(uri) {
    return uriMap[uri] || (
      parent && parent.byUri(uri)
    );
  };

  this.add = function(ns, isWellknown) {

    uriMap[ns.uri] = ns;

    if (isWellknown) {
      wellknown.push(ns);
    } else {
      custom.push(ns);
    }

    this.mapPrefix(ns.prefix, ns.uri);
  };

  this.uriByPrefix = function(prefix) {
    return prefixMap[prefix || 'xmlns'];
  };

  this.mapPrefix = function(prefix, uri) {
    prefixMap[prefix || 'xmlns'] = uri;
  };

  this.logUsed = function(ns) {
    var uri = ns.uri;

    used[uri] = this.byUri(uri);
  };

  this.getUsed = function(ns) {

    function isUsed(ns) {
      return used[ns.uri];
    }

    var allNs = [].concat(wellknown, custom);

    return allNs.filter(isUsed);
  };

}

function lower(string) {
  return string.charAt(0).toLowerCase() + string.slice(1);
}

function nameToAlias(name, pkg) {
  if (hasLowerCaseAlias(pkg)) {
    return lower(name);
  } else {
    return name;
  }
}

function inherits(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
}

function nsName(ns) {
  if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isString"])(ns)) {
    return ns;
  } else {
    return (ns.prefix ? ns.prefix + ':' : '') + ns.localName;
  }
}

function getNsAttrs(namespaces) {

  return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["map"])(namespaces.getUsed(), function(ns) {
    var name = 'xmlns' + (ns.prefix ? ':' + ns.prefix : '');
    return { name: name, value: ns.uri };
  });

}

function getElementNs(ns, descriptor) {
  if (descriptor.isGeneric) {
    return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({ localName: descriptor.ns.localName }, ns);
  } else {
    return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({ localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg) }, ns);
  }
}

function getPropertyNs(ns, descriptor) {
  return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({ localName: descriptor.ns.localName }, ns);
}

function getSerializableProperties(element) {
  var descriptor = element.$descriptor;

  return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["filter"])(descriptor.properties, function(p) {
    var name = p.name;

    if (p.isVirtual) {
      return false;
    }

    // do not serialize defaults
    if (!element.hasOwnProperty(name)) {
      return false;
    }

    var value = element[name];

    // do not serialize default equals
    if (value === p.default) {
      return false;
    }

    // do not serialize null properties
    if (value === null) {
      return false;
    }

    return p.isMany ? value.length : true;
  });
}

var ESCAPE_ATTR_MAP = {
  '\n': '#10',
  '\n\r': '#10',
  '"': '#34',
  '\'': '#39',
  '<': '#60',
  '>': '#62',
  '&': '#38'
};

var ESCAPE_MAP = {
  '<': 'lt',
  '>': 'gt',
  '&': 'amp'
};

function escape(str, charPattern, replaceMap) {

  // ensure we are handling strings here
  str = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isString"])(str) ? str : '' + str;

  return str.replace(charPattern, function(s) {
    return '&' + replaceMap[s] + ';';
  });
}

/**
 * Escape a string attribute to not contain any bad values (line breaks, '"', ...)
 *
 * @param {String} str the string to escape
 * @return {String} the escaped string
 */
function escapeAttr(str) {
  return escape(str, ESCAPE_ATTR_CHARS, ESCAPE_ATTR_MAP);
}

function escapeBody(str) {
  return escape(str, ESCAPE_CHARS, ESCAPE_MAP);
}

function filterAttributes(props) {
  return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["filter"])(props, function(p) { return p.isAttr; });
}

function filterContained(props) {
  return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["filter"])(props, function(p) { return !p.isAttr; });
}


function ReferenceSerializer(tagName) {
  this.tagName = tagName;
}

ReferenceSerializer.prototype.build = function(element) {
  this.element = element;
  return this;
};

ReferenceSerializer.prototype.serializeTo = function(writer) {
  writer
    .appendIndent()
    .append('<' + this.tagName + '>' + this.element.id + '</' + this.tagName + '>')
    .appendNewLine();
};

function BodySerializer() {}

BodySerializer.prototype.serializeValue =
BodySerializer.prototype.serializeTo = function(writer) {
  writer.append(
    this.escape
      ? escapeBody(this.value)
      : this.value
  );
};

BodySerializer.prototype.build = function(prop, value) {
  this.value = value;

  if (prop.type === 'String' && value.search(ESCAPE_CHARS) !== -1) {
    this.escape = true;
  }

  return this;
};

function ValueSerializer(tagName) {
  this.tagName = tagName;
}

inherits(ValueSerializer, BodySerializer);

ValueSerializer.prototype.serializeTo = function(writer) {

  writer
    .appendIndent()
    .append('<' + this.tagName + '>');

  this.serializeValue(writer);

  writer
    .append('</' + this.tagName + '>')
    .appendNewLine();
};

function ElementSerializer(parent, propertyDescriptor) {
  this.body = [];
  this.attrs = [];

  this.parent = parent;
  this.propertyDescriptor = propertyDescriptor;
}

ElementSerializer.prototype.build = function(element) {
  this.element = element;

  var elementDescriptor = element.$descriptor,
      propertyDescriptor = this.propertyDescriptor;

  var otherAttrs,
      properties;

  var isGeneric = elementDescriptor.isGeneric;

  if (isGeneric) {
    otherAttrs = this.parseGeneric(element);
  } else {
    otherAttrs = this.parseNsAttributes(element);
  }

  if (propertyDescriptor) {
    this.ns = this.nsPropertyTagName(propertyDescriptor);
  } else {
    this.ns = this.nsTagName(elementDescriptor);
  }

  // compute tag name
  this.tagName = this.addTagName(this.ns);

  if (!isGeneric) {
    properties = getSerializableProperties(element);

    this.parseAttributes(filterAttributes(properties));
    this.parseContainments(filterContained(properties));
  }

  this.parseGenericAttributes(element, otherAttrs);

  return this;
};

ElementSerializer.prototype.nsTagName = function(descriptor) {
  var effectiveNs = this.logNamespaceUsed(descriptor.ns);
  return getElementNs(effectiveNs, descriptor);
};

ElementSerializer.prototype.nsPropertyTagName = function(descriptor) {
  var effectiveNs = this.logNamespaceUsed(descriptor.ns);
  return getPropertyNs(effectiveNs, descriptor);
};

ElementSerializer.prototype.isLocalNs = function(ns) {
  return ns.uri === this.ns.uri;
};

/**
 * Get the actual ns attribute name for the given element.
 *
 * @param {Object} element
 * @param {Boolean} [element.inherited=false]
 *
 * @return {Object} nsName
 */
ElementSerializer.prototype.nsAttributeName = function(element) {

  var ns;

  if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isString"])(element)) {
    ns = Object(moddle__WEBPACK_IMPORTED_MODULE_2__["parseNameNS"])(element);
  } else {
    ns = element.ns;
  }

  // return just local name for inherited attributes
  if (element.inherited) {
    return { localName: ns.localName };
  }

  // parse + log effective ns
  var effectiveNs = this.logNamespaceUsed(ns);

  // LOG ACTUAL namespace use
  this.getNamespaces().logUsed(effectiveNs);

  // strip prefix if same namespace like parent
  if (this.isLocalNs(effectiveNs)) {
    return { localName: ns.localName };
  } else {
    return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({ localName: ns.localName }, effectiveNs);
  }
};

ElementSerializer.prototype.parseGeneric = function(element) {

  var self = this,
      body = this.body;

  var attributes = [];

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(element, function(val, key) {

    var nonNsAttr;

    if (key === '$body') {
      body.push(new BodySerializer().build({ type: 'String' }, val));
    } else
    if (key === '$children') {
      Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(val, function(child) {
        body.push(new ElementSerializer(self).build(child));
      });
    } else
    if (key.indexOf('$') !== 0) {
      nonNsAttr = self.parseNsAttribute(element, key, val);

      if (nonNsAttr) {
        attributes.push({ name: key, value: val });
      }
    }
  });

  return attributes;
};

ElementSerializer.prototype.parseNsAttribute = function(element, name, value) {
  var model = element.$model;

  var nameNs = Object(moddle__WEBPACK_IMPORTED_MODULE_2__["parseNameNS"])(name);

  var ns;

  // parse xmlns:foo="http://foo.bar"
  if (nameNs.prefix === 'xmlns') {
    ns = { prefix: nameNs.localName, uri: value };
  }

  // parse xmlns="http://foo.bar"
  if (!nameNs.prefix && nameNs.localName === 'xmlns') {
    ns = { uri: value };
  }

  if (!ns) {
    return {
      name: name,
      value: value
    };
  }

  if (model && model.getPackage(value)) {
    // register well known namespace
    this.logNamespace(ns, true, true);
  } else {
    // log custom namespace directly as used
    var actualNs = this.logNamespaceUsed(ns, true);

    this.getNamespaces().logUsed(actualNs);
  }
};


/**
 * Parse namespaces and return a list of left over generic attributes
 *
 * @param  {Object} element
 * @return {Array<Object>}
 */
ElementSerializer.prototype.parseNsAttributes = function(element, attrs) {
  var self = this;

  var genericAttrs = element.$attrs;

  var attributes = [];

  // parse namespace attributes first
  // and log them. push non namespace attributes to a list
  // and process them later
  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(genericAttrs, function(value, name) {

    var nonNsAttr = self.parseNsAttribute(element, name, value);

    if (nonNsAttr) {
      attributes.push(nonNsAttr);
    }
  });

  return attributes;
};

ElementSerializer.prototype.parseGenericAttributes = function(element, attributes) {

  var self = this;

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(attributes, function(attr) {

    // do not serialize xsi:type attribute
    // it is set manually based on the actual implementation type
    if (attr.name === XSI_TYPE) {
      return;
    }

    try {
      self.addAttribute(self.nsAttributeName(attr.name), attr.value);
    } catch (e) {
      console.warn(
        'missing namespace information for ',
        attr.name, '=', attr.value, 'on', element,
        e);
    }
  });
};

ElementSerializer.prototype.parseContainments = function(properties) {

  var self = this,
      body = this.body,
      element = this.element;

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(properties, function(p) {
    var value = element.get(p.name),
        isReference = p.isReference,
        isMany = p.isMany;

    if (!isMany) {
      value = [ value ];
    }

    if (p.isBody) {
      body.push(new BodySerializer().build(p, value[0]));
    } else
    if (Object(moddle__WEBPACK_IMPORTED_MODULE_2__["isSimpleType"])(p.type)) {
      Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(value, function(v) {
        body.push(new ValueSerializer(self.addTagName(self.nsPropertyTagName(p))).build(p, v));
      });
    } else
    if (isReference) {
      Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(value, function(v) {
        body.push(new ReferenceSerializer(self.addTagName(self.nsPropertyTagName(p))).build(v));
      });
    } else {
      // allow serialization via type
      // rather than element name
      var asType = serializeAsType(p),
          asProperty = serializeAsProperty(p);

      Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(value, function(v) {
        var serializer;

        if (asType) {
          serializer = new TypeSerializer(self, p);
        } else
        if (asProperty) {
          serializer = new ElementSerializer(self, p);
        } else {
          serializer = new ElementSerializer(self);
        }

        body.push(serializer.build(v));
      });
    }
  });
};

ElementSerializer.prototype.getNamespaces = function(local) {

  var namespaces = this.namespaces,
      parent = this.parent,
      parentNamespaces;

  if (!namespaces) {
    parentNamespaces = parent && parent.getNamespaces();

    if (local || !parentNamespaces) {
      this.namespaces = namespaces = new Namespaces(parentNamespaces);
    } else {
      namespaces = parentNamespaces;
    }
  }

  return namespaces;
};

ElementSerializer.prototype.logNamespace = function(ns, wellknown, local) {
  var namespaces = this.getNamespaces(local);

  var nsUri = ns.uri,
      nsPrefix = ns.prefix;

  var existing = namespaces.byUri(nsUri);

  if (!existing) {
    namespaces.add(ns, wellknown);
  }

  namespaces.mapPrefix(nsPrefix, nsUri);

  return ns;
};

ElementSerializer.prototype.logNamespaceUsed = function(ns, local) {
  var element = this.element,
      model = element.$model,
      namespaces = this.getNamespaces(local);

  // ns may be
  //
  //   * prefix only
  //   * prefix:uri
  //   * localName only

  var prefix = ns.prefix,
      uri = ns.uri,
      newPrefix, idx,
      wellknownUri;

  // handle anonymous namespaces (elementForm=unqualified), cf. #23
  if (!prefix && !uri) {
    return { localName: ns.localName };
  }

  wellknownUri = DEFAULT_NS_MAP[prefix] || model && (model.getPackage(prefix) || {}).uri;

  uri = uri || wellknownUri || namespaces.uriByPrefix(prefix);

  if (!uri) {
    throw new Error('no namespace uri given for prefix <' + prefix + '>');
  }

  ns = namespaces.byUri(uri);

  if (!ns) {
    newPrefix = prefix;
    idx = 1;

    // find a prefix that is not mapped yet
    while (namespaces.uriByPrefix(newPrefix)) {
      newPrefix = prefix + '_' + idx++;
    }

    ns = this.logNamespace({ prefix: newPrefix, uri: uri }, wellknownUri === uri);
  }

  if (prefix) {
    namespaces.mapPrefix(prefix, uri);
  }

  return ns;
};

ElementSerializer.prototype.parseAttributes = function(properties) {
  var self = this,
      element = this.element;

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(properties, function(p) {

    var value = element.get(p.name);

    if (p.isReference) {

      if (!p.isMany) {
        value = value.id;
      }
      else {
        var values = [];
        Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(value, function(v) {
          values.push(v.id);
        });
        // IDREFS is a whitespace-separated list of references.
        value = values.join(' ');
      }

    }

    self.addAttribute(self.nsAttributeName(p), value);
  });
};

ElementSerializer.prototype.addTagName = function(nsTagName) {
  var actualNs = this.logNamespaceUsed(nsTagName);

  this.getNamespaces().logUsed(actualNs);

  return nsName(nsTagName);
};

ElementSerializer.prototype.addAttribute = function(name, value) {
  var attrs = this.attrs;

  if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isString"])(value)) {
    value = escapeAttr(value);
  }

  attrs.push({ name: name, value: value });
};

ElementSerializer.prototype.serializeAttributes = function(writer) {
  var attrs = this.attrs,
      namespaces = this.namespaces;

  if (namespaces) {
    attrs = getNsAttrs(namespaces).concat(attrs);
  }

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(attrs, function(a) {
    writer
      .append(' ')
      .append(nsName(a.name)).append('="').append(a.value).append('"');
  });
};

ElementSerializer.prototype.serializeTo = function(writer) {
  var firstBody = this.body[0],
      indent = firstBody && firstBody.constructor !== BodySerializer;

  writer
    .appendIndent()
    .append('<' + this.tagName);

  this.serializeAttributes(writer);

  writer.append(firstBody ? '>' : ' />');

  if (firstBody) {

    if (indent) {
      writer
        .appendNewLine()
        .indent();
    }

    Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(this.body, function(b) {
      b.serializeTo(writer);
    });

    if (indent) {
      writer
        .unindent()
        .appendIndent();
    }

    writer.append('</' + this.tagName + '>');
  }

  writer.appendNewLine();
};

/**
 * A serializer for types that handles serialization of data types
 */
function TypeSerializer(parent, propertyDescriptor) {
  ElementSerializer.call(this, parent, propertyDescriptor);
}

inherits(TypeSerializer, ElementSerializer);

TypeSerializer.prototype.parseNsAttributes = function(element) {

  // extracted attributes
  var attributes = ElementSerializer.prototype.parseNsAttributes.call(this, element);

  var descriptor = element.$descriptor;

  // only serialize xsi:type if necessary
  if (descriptor.name === this.propertyDescriptor.type) {
    return attributes;
  }

  var typeNs = this.typeNs = this.nsTagName(descriptor);
  this.getNamespaces().logUsed(this.typeNs);

  // add xsi:type attribute to represent the elements
  // actual type

  var pkg = element.$model.getPackage(typeNs.uri),
      typePrefix = (pkg.xml && pkg.xml.typePrefix) || '';

  this.addAttribute(
    this.nsAttributeName(XSI_TYPE),
    (typeNs.prefix ? typeNs.prefix + ':' : '') + typePrefix + descriptor.ns.localName
  );

  return attributes;
};

TypeSerializer.prototype.isLocalNs = function(ns) {
  return ns.uri === (this.typeNs || this.ns).uri;
};

function SavingWriter() {
  this.value = '';

  this.write = function(str) {
    this.value += str;
  };
}

function FormatingWriter(out, format) {

  var indent = [''];

  this.append = function(str) {
    out.write(str);

    return this;
  };

  this.appendNewLine = function() {
    if (format) {
      out.write('\n');
    }

    return this;
  };

  this.appendIndent = function() {
    if (format) {
      out.write(indent.join('  '));
    }

    return this;
  };

  this.indent = function() {
    indent.push('');
    return this;
  };

  this.unindent = function() {
    indent.pop();
    return this;
  };
}

/**
 * A writer for meta-model backed document trees
 *
 * @param {Object} options output options to pass into the writer
 */
function Writer(options) {

  options = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({ format: false, preamble: true }, options || {});

  function toXML(tree, writer) {
    var internalWriter = writer || new SavingWriter();
    var formatingWriter = new FormatingWriter(internalWriter, options.format);

    if (options.preamble) {
      formatingWriter.append(XML_PREAMBLE);
    }

    new ElementSerializer().build(tree).serializeTo(formatingWriter);

    if (!writer) {
      return internalWriter.value;
    }
  }

  return {
    toXML: toXML
  };
}




/***/ }),

/***/ "./node_modules/moddle/dist/index.esm.js":
/*!***********************************************!*\
  !*** ./node_modules/moddle/dist/index.esm.js ***!
  \***********************************************/
/*! exports provided: Moddle, coerceType, isBuiltInType, isSimpleType, parseNameNS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Moddle", function() { return Moddle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "coerceType", function() { return coerceType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBuiltInType", function() { return isBuiltIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSimpleType", function() { return isSimple; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseNameNS", function() { return parseName; });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


/**
 * Moddle base element.
 */
function Base() { }

Base.prototype.get = function(name) {
  return this.$model.properties.get(this, name);
};

Base.prototype.set = function(name, value) {
  this.$model.properties.set(this, name, value);
};

/**
 * A model element factory.
 *
 * @param {Moddle} model
 * @param {Properties} properties
 */
function Factory(model, properties) {
  this.model = model;
  this.properties = properties;
}


Factory.prototype.createType = function(descriptor) {

  var model = this.model;

  var props = this.properties,
      prototype = Object.create(Base.prototype);

  // initialize default values
  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(descriptor.properties, function(p) {
    if (!p.isMany && p.default !== undefined) {
      prototype[p.name] = p.default;
    }
  });

  props.defineModel(prototype, model);
  props.defineDescriptor(prototype, descriptor);

  var name = descriptor.ns.name;

  /**
   * The new type constructor
   */
  function ModdleElement(attrs) {
    props.define(this, '$type', { value: name, enumerable: true });
    props.define(this, '$attrs', { value: {} });
    props.define(this, '$parent', { writable: true });

    Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(attrs, Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["bind"])(function(val, key) {
      this.set(key, val);
    }, this));
  }

  ModdleElement.prototype = prototype;

  ModdleElement.hasType = prototype.$instanceOf = this.model.hasType;

  // static links
  props.defineModel(ModdleElement, model);
  props.defineDescriptor(ModdleElement, descriptor);

  return ModdleElement;
};

/**
 * Built-in moddle types
 */
var BUILTINS = {
  String: true,
  Boolean: true,
  Integer: true,
  Real: true,
  Element: true
};

/**
 * Converters for built in types from string representations
 */
var TYPE_CONVERTERS = {
  String: function(s) { return s; },
  Boolean: function(s) { return s === 'true'; },
  Integer: function(s) { return parseInt(s, 10); },
  Real: function(s) { return parseFloat(s, 10); }
};

/**
 * Convert a type to its real representation
 */
function coerceType(type, value) {

  var converter = TYPE_CONVERTERS[type];

  if (converter) {
    return converter(value);
  } else {
    return value;
  }
}

/**
 * Return whether the given type is built-in
 */
function isBuiltIn(type) {
  return !!BUILTINS[type];
}

/**
 * Return whether the given type is simple
 */
function isSimple(type) {
  return !!TYPE_CONVERTERS[type];
}

/**
 * Parses a namespaced attribute name of the form (ns:)localName to an object,
 * given a default prefix to assume in case no explicit namespace is given.
 *
 * @param {String} name
 * @param {String} [defaultPrefix] the default prefix to take, if none is present.
 *
 * @return {Object} the parsed name
 */
function parseName(name, defaultPrefix) {
  var parts = name.split(/:/),
      localName, prefix;

  // no prefix (i.e. only local name)
  if (parts.length === 1) {
    localName = name;
    prefix = defaultPrefix;
  } else
  // prefix + local name
  if (parts.length === 2) {
    localName = parts[1];
    prefix = parts[0];
  } else {
    throw new Error('expected <prefix:localName> or <localName>, got ' + name);
  }

  name = (prefix ? prefix + ':' : '') + localName;

  return {
    name: name,
    prefix: prefix,
    localName: localName
  };
}

/**
 * A utility to build element descriptors.
 */
function DescriptorBuilder(nameNs) {
  this.ns = nameNs;
  this.name = nameNs.name;
  this.allTypes = [];
  this.allTypesByName = {};
  this.properties = [];
  this.propertiesByName = {};
}


DescriptorBuilder.prototype.build = function() {
  return Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["pick"])(this, [
    'ns',
    'name',
    'allTypes',
    'allTypesByName',
    'properties',
    'propertiesByName',
    'bodyProperty',
    'idProperty'
  ]);
};

/**
 * Add property at given index.
 *
 * @param {Object} p
 * @param {Number} [idx]
 * @param {Boolean} [validate=true]
 */
DescriptorBuilder.prototype.addProperty = function(p, idx, validate) {

  if (typeof idx === 'boolean') {
    validate = idx;
    idx = undefined;
  }

  this.addNamedProperty(p, validate !== false);

  var properties = this.properties;

  if (idx !== undefined) {
    properties.splice(idx, 0, p);
  } else {
    properties.push(p);
  }
};


DescriptorBuilder.prototype.replaceProperty = function(oldProperty, newProperty, replace) {
  var oldNameNs = oldProperty.ns;

  var props = this.properties,
      propertiesByName = this.propertiesByName,
      rename = oldProperty.name !== newProperty.name;

  if (oldProperty.isId) {
    if (!newProperty.isId) {
      throw new Error(
        'property <' + newProperty.ns.name + '> must be id property ' +
        'to refine <' + oldProperty.ns.name + '>');
    }

    this.setIdProperty(newProperty, false);
  }

  if (oldProperty.isBody) {

    if (!newProperty.isBody) {
      throw new Error(
        'property <' + newProperty.ns.name + '> must be body property ' +
        'to refine <' + oldProperty.ns.name + '>');
    }

    // TODO: Check compatibility
    this.setBodyProperty(newProperty, false);
  }

  // validate existence and get location of old property
  var idx = props.indexOf(oldProperty);
  if (idx === -1) {
    throw new Error('property <' + oldNameNs.name + '> not found in property list');
  }

  // remove old property
  props.splice(idx, 1);

  // replacing the named property is intentional
  //
  //  * validate only if this is a "rename" operation
  //  * add at specific index unless we "replace"
  //
  this.addProperty(newProperty, replace ? undefined : idx, rename);

  // make new property available under old name
  propertiesByName[oldNameNs.name] = propertiesByName[oldNameNs.localName] = newProperty;
};


DescriptorBuilder.prototype.redefineProperty = function(p, targetPropertyName, replace) {

  var nsPrefix = p.ns.prefix;
  var parts = targetPropertyName.split('#');

  var name = parseName(parts[0], nsPrefix);
  var attrName = parseName(parts[1], name.prefix).name;

  var redefinedProperty = this.propertiesByName[attrName];
  if (!redefinedProperty) {
    throw new Error('refined property <' + attrName + '> not found');
  } else {
    this.replaceProperty(redefinedProperty, p, replace);
  }

  delete p.redefines;
};

DescriptorBuilder.prototype.addNamedProperty = function(p, validate) {
  var ns = p.ns,
      propsByName = this.propertiesByName;

  if (validate) {
    this.assertNotDefined(p, ns.name);
    this.assertNotDefined(p, ns.localName);
  }

  propsByName[ns.name] = propsByName[ns.localName] = p;
};

DescriptorBuilder.prototype.removeNamedProperty = function(p) {
  var ns = p.ns,
      propsByName = this.propertiesByName;

  delete propsByName[ns.name];
  delete propsByName[ns.localName];
};

DescriptorBuilder.prototype.setBodyProperty = function(p, validate) {

  if (validate && this.bodyProperty) {
    throw new Error(
      'body property defined multiple times ' +
      '(<' + this.bodyProperty.ns.name + '>, <' + p.ns.name + '>)');
  }

  this.bodyProperty = p;
};

DescriptorBuilder.prototype.setIdProperty = function(p, validate) {

  if (validate && this.idProperty) {
    throw new Error(
      'id property defined multiple times ' +
      '(<' + this.idProperty.ns.name + '>, <' + p.ns.name + '>)');
  }

  this.idProperty = p;
};

DescriptorBuilder.prototype.assertNotDefined = function(p, name) {
  var propertyName = p.name,
      definedProperty = this.propertiesByName[propertyName];

  if (definedProperty) {
    throw new Error(
      'property <' + propertyName + '> already defined; ' +
      'override of <' + definedProperty.definedBy.ns.name + '#' + definedProperty.ns.name + '> by ' +
      '<' + p.definedBy.ns.name + '#' + p.ns.name + '> not allowed without redefines');
  }
};

DescriptorBuilder.prototype.hasProperty = function(name) {
  return this.propertiesByName[name];
};

DescriptorBuilder.prototype.addTrait = function(t, inherited) {

  var typesByName = this.allTypesByName,
      types = this.allTypes;

  var typeName = t.name;

  if (typeName in typesByName) {
    return;
  }

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(t.properties, Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["bind"])(function(p) {

    // clone property to allow extensions
    p = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({}, p, {
      name: p.ns.localName,
      inherited: inherited
    });

    Object.defineProperty(p, 'definedBy', {
      value: t
    });

    var replaces = p.replaces,
        redefines = p.redefines;

    // add replace/redefine support
    if (replaces || redefines) {
      this.redefineProperty(p, replaces || redefines, replaces);
    } else {
      if (p.isBody) {
        this.setBodyProperty(p);
      }
      if (p.isId) {
        this.setIdProperty(p);
      }
      this.addProperty(p);
    }
  }, this));

  types.push(t);
  typesByName[typeName] = t;
};

/**
 * A registry of Moddle packages.
 *
 * @param {Array<Package>} packages
 * @param {Properties} properties
 */
function Registry(packages, properties) {
  this.packageMap = {};
  this.typeMap = {};

  this.packages = [];

  this.properties = properties;

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(packages, Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["bind"])(this.registerPackage, this));
}


Registry.prototype.getPackage = function(uriOrPrefix) {
  return this.packageMap[uriOrPrefix];
};

Registry.prototype.getPackages = function() {
  return this.packages;
};


Registry.prototype.registerPackage = function(pkg) {

  // copy package
  pkg = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({}, pkg);

  var pkgMap = this.packageMap;

  ensureAvailable(pkgMap, pkg, 'prefix');
  ensureAvailable(pkgMap, pkg, 'uri');

  // register types
  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(pkg.types, Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["bind"])(function(descriptor) {
    this.registerType(descriptor, pkg);
  }, this));

  pkgMap[pkg.uri] = pkgMap[pkg.prefix] = pkg;
  this.packages.push(pkg);
};


/**
 * Register a type from a specific package with us
 */
Registry.prototype.registerType = function(type, pkg) {

  type = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])({}, type, {
    superClass: (type.superClass || []).slice(),
    extends: (type.extends || []).slice(),
    properties: (type.properties || []).slice(),
    meta: Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])((type.meta || {}))
  });

  var ns = parseName(type.name, pkg.prefix),
      name = ns.name,
      propertiesByName = {};

  // parse properties
  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(type.properties, Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["bind"])(function(p) {

    // namespace property names
    var propertyNs = parseName(p.name, ns.prefix),
        propertyName = propertyNs.name;

    // namespace property types
    if (!isBuiltIn(p.type)) {
      p.type = parseName(p.type, propertyNs.prefix).name;
    }

    Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])(p, {
      ns: propertyNs,
      name: propertyName
    });

    propertiesByName[propertyName] = p;
  }, this));

  // update ns + name
  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["assign"])(type, {
    ns: ns,
    name: name,
    propertiesByName: propertiesByName
  });

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(type.extends, Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["bind"])(function(extendsName) {
    var extended = this.typeMap[extendsName];

    extended.traits = extended.traits || [];
    extended.traits.push(name);
  }, this));

  // link to package
  this.definePackage(type, pkg);

  // register
  this.typeMap[name] = type;
};


/**
 * Traverse the type hierarchy from bottom to top,
 * calling iterator with (type, inherited) for all elements in
 * the inheritance chain.
 *
 * @param {Object} nsName
 * @param {Function} iterator
 * @param {Boolean} [trait=false]
 */
Registry.prototype.mapTypes = function(nsName, iterator, trait) {

  var type = isBuiltIn(nsName.name) ? { name: nsName.name } : this.typeMap[nsName.name];

  var self = this;

  /**
   * Traverse the selected trait.
   *
   * @param {String} cls
   */
  function traverseTrait(cls) {
    return traverseSuper(cls, true);
  }

  /**
   * Traverse the selected super type or trait
   *
   * @param {String} cls
   * @param {Boolean} [trait=false]
   */
  function traverseSuper(cls, trait) {
    var parentNs = parseName(cls, isBuiltIn(cls) ? '' : nsName.prefix);
    self.mapTypes(parentNs, iterator, trait);
  }

  if (!type) {
    throw new Error('unknown type <' + nsName.name + '>');
  }

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(type.superClass, trait ? traverseTrait : traverseSuper);

  // call iterator with (type, inherited=!trait)
  iterator(type, !trait);

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(type.traits, traverseTrait);
};


/**
 * Returns the effective descriptor for a type.
 *
 * @param  {String} type the namespaced name (ns:localName) of the type
 *
 * @return {Descriptor} the resulting effective descriptor
 */
Registry.prototype.getEffectiveDescriptor = function(name) {

  var nsName = parseName(name);

  var builder = new DescriptorBuilder(nsName);

  this.mapTypes(nsName, function(type, inherited) {
    builder.addTrait(type, inherited);
  });

  var descriptor = builder.build();

  // define package link
  this.definePackage(descriptor, descriptor.allTypes[descriptor.allTypes.length - 1].$pkg);

  return descriptor;
};


Registry.prototype.definePackage = function(target, pkg) {
  this.properties.define(target, '$pkg', { value: pkg });
};



///////// helpers ////////////////////////////

function ensureAvailable(packageMap, pkg, identifierKey) {

  var value = pkg[identifierKey];

  if (value in packageMap) {
    throw new Error('package with ' + identifierKey + ' <' + value + '> already defined');
  }
}

/**
 * A utility that gets and sets properties of model elements.
 *
 * @param {Model} model
 */
function Properties(model) {
  this.model = model;
}


/**
 * Sets a named property on the target element.
 * If the value is undefined, the property gets deleted.
 *
 * @param {Object} target
 * @param {String} name
 * @param {Object} value
 */
Properties.prototype.set = function(target, name, value) {

  var property = this.model.getPropertyDescriptor(target, name);

  var propertyName = property && property.name;

  if (isUndefined(value)) {
    // unset the property, if the specified value is undefined;
    // delete from $attrs (for extensions) or the target itself
    if (property) {
      delete target[propertyName];
    } else {
      delete target.$attrs[name];
    }
  } else {
    // set the property, defining well defined properties on the fly
    // or simply updating them in target.$attrs (for extensions)
    if (property) {
      if (propertyName in target) {
        target[propertyName] = value;
      } else {
        defineProperty(target, property, value);
      }
    } else {
      target.$attrs[name] = value;
    }
  }
};

/**
 * Returns the named property of the given element
 *
 * @param  {Object} target
 * @param  {String} name
 *
 * @return {Object}
 */
Properties.prototype.get = function(target, name) {

  var property = this.model.getPropertyDescriptor(target, name);

  if (!property) {
    return target.$attrs[name];
  }

  var propertyName = property.name;

  // check if access to collection property and lazily initialize it
  if (!target[propertyName] && property.isMany) {
    defineProperty(target, property, []);
  }

  return target[propertyName];
};


/**
 * Define a property on the target element
 *
 * @param  {Object} target
 * @param  {String} name
 * @param  {Object} options
 */
Properties.prototype.define = function(target, name, options) {
  Object.defineProperty(target, name, options);
};


/**
 * Define the descriptor for an element
 */
Properties.prototype.defineDescriptor = function(target, descriptor) {
  this.define(target, '$descriptor', { value: descriptor });
};

/**
 * Define the model for an element
 */
Properties.prototype.defineModel = function(target, model) {
  this.define(target, '$model', { value: model });
};


function isUndefined(val) {
  return typeof val === 'undefined';
}

function defineProperty(target, property, value) {
  Object.defineProperty(target, property.name, {
    enumerable: !property.isReference,
    writable: true,
    value: value,
    configurable: true
  });
}

//// Moddle implementation /////////////////////////////////////////////////

/**
 * @class Moddle
 *
 * A model that can be used to create elements of a specific type.
 *
 * @example
 *
 * var Moddle = require('moddle');
 *
 * var pkg = {
 *   name: 'mypackage',
 *   prefix: 'my',
 *   types: [
 *     { name: 'Root' }
 *   ]
 * };
 *
 * var moddle = new Moddle([pkg]);
 *
 * @param {Array<Package>} packages the packages to contain
 */
function Moddle(packages) {

  this.properties = new Properties(this);

  this.factory = new Factory(this, this.properties);
  this.registry = new Registry(packages, this.properties);

  this.typeCache = {};
}


/**
 * Create an instance of the specified type.
 *
 * @method Moddle#create
 *
 * @example
 *
 * var foo = moddle.create('my:Foo');
 * var bar = moddle.create('my:Bar', { id: 'BAR_1' });
 *
 * @param  {String|Object} descriptor the type descriptor or name know to the model
 * @param  {Object} attrs   a number of attributes to initialize the model instance with
 * @return {Object}         model instance
 */
Moddle.prototype.create = function(descriptor, attrs) {
  var Type = this.getType(descriptor);

  if (!Type) {
    throw new Error('unknown type <' + descriptor + '>');
  }

  return new Type(attrs);
};


/**
 * Returns the type representing a given descriptor
 *
 * @method Moddle#getType
 *
 * @example
 *
 * var Foo = moddle.getType('my:Foo');
 * var foo = new Foo({ 'id' : 'FOO_1' });
 *
 * @param  {String|Object} descriptor the type descriptor or name know to the model
 * @return {Object}         the type representing the descriptor
 */
Moddle.prototype.getType = function(descriptor) {

  var cache = this.typeCache;

  var name = Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isString"])(descriptor) ? descriptor : descriptor.ns.name;

  var type = cache[name];

  if (!type) {
    descriptor = this.registry.getEffectiveDescriptor(name);
    type = cache[name] = this.factory.createType(descriptor);
  }

  return type;
};


/**
 * Creates an any-element type to be used within model instances.
 *
 * This can be used to create custom elements that lie outside the meta-model.
 * The created element contains all the meta-data required to serialize it
 * as part of meta-model elements.
 *
 * @method Moddle#createAny
 *
 * @example
 *
 * var foo = moddle.createAny('vendor:Foo', 'http://vendor', {
 *   value: 'bar'
 * });
 *
 * var container = moddle.create('my:Container', 'http://my', {
 *   any: [ foo ]
 * });
 *
 * // go ahead and serialize the stuff
 *
 *
 * @param  {String} name  the name of the element
 * @param  {String} nsUri the namespace uri of the element
 * @param  {Object} [properties] a map of properties to initialize the instance with
 * @return {Object} the any type instance
 */
Moddle.prototype.createAny = function(name, nsUri, properties) {

  var nameNs = parseName(name);

  var element = {
    $type: name,
    $instanceOf: function(type) {
      return type === this.$type;
    }
  };

  var descriptor = {
    name: name,
    isGeneric: true,
    ns: {
      prefix: nameNs.prefix,
      localName: nameNs.localName,
      uri: nsUri
    }
  };

  this.properties.defineDescriptor(element, descriptor);
  this.properties.defineModel(element, this);
  this.properties.define(element, '$parent', { enumerable: false, writable: true });

  Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["forEach"])(properties, function(a, key) {
    if (Object(min_dash__WEBPACK_IMPORTED_MODULE_0__["isObject"])(a) && a.value !== undefined) {
      element[a.name] = a.value;
    } else {
      element[key] = a;
    }
  });

  return element;
};

/**
 * Returns a registered package by uri or prefix
 *
 * @return {Object} the package
 */
Moddle.prototype.getPackage = function(uriOrPrefix) {
  return this.registry.getPackage(uriOrPrefix);
};

/**
 * Returns a snapshot of all known packages
 *
 * @return {Object} the package
 */
Moddle.prototype.getPackages = function() {
  return this.registry.getPackages();
};

/**
 * Returns the descriptor for an element
 */
Moddle.prototype.getElementDescriptor = function(element) {
  return element.$descriptor;
};

/**
 * Returns true if the given descriptor or instance
 * represents the given type.
 *
 * May be applied to this, if element is omitted.
 */
Moddle.prototype.hasType = function(element, type) {
  if (type === undefined) {
    type = element;
    element = this;
  }

  var descriptor = element.$model.getElementDescriptor(element);

  return (type in descriptor.allTypesByName);
};

/**
 * Returns the descriptor of an elements named property
 */
Moddle.prototype.getPropertyDescriptor = function(element, property) {
  return this.getElementDescriptor(element).propertiesByName[property];
};

/**
 * Returns a mapped type's descriptor
 */
Moddle.prototype.getTypeDescriptor = function(type) {
  return this.registry.typeMap[type];
};




/***/ }),

/***/ "./node_modules/object-refs/index.js":
/*!*******************************************!*\
  !*** ./node_modules/object-refs/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/refs */ "./node_modules/object-refs/lib/refs.js");

module.exports.Collection = __webpack_require__(/*! ./lib/collection */ "./node_modules/object-refs/lib/collection.js");

/***/ }),

/***/ "./node_modules/object-refs/lib/collection.js":
/*!****************************************************!*\
  !*** ./node_modules/object-refs/lib/collection.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * An empty collection stub. Use {@link RefsCollection.extend} to extend a
 * collection with ref semantics.
 *
 * @class RefsCollection
 */

/**
 * Extends a collection with {@link Refs} aware methods
 *
 * @memberof RefsCollection
 * @static
 *
 * @param  {Array<Object>} collection
 * @param  {Refs} refs instance
 * @param  {Object} property represented by the collection
 * @param  {Object} target object the collection is attached to
 *
 * @return {RefsCollection<Object>} the extended array
 */
function extend(collection, refs, property, target) {

  var inverseProperty = property.inverse;

  /**
   * Removes the given element from the array and returns it.
   *
   * @method RefsCollection#remove
   *
   * @param {Object} element the element to remove
   */
  Object.defineProperty(collection, 'remove', {
    value: function(element) {
      var idx = this.indexOf(element);
      if (idx !== -1) {
        this.splice(idx, 1);

        // unset inverse
        refs.unset(element, inverseProperty, target);
      }

      return element;
    }
  });

  /**
   * Returns true if the collection contains the given element
   *
   * @method RefsCollection#contains
   *
   * @param {Object} element the element to check for
   */
  Object.defineProperty(collection, 'contains', {
    value: function(element) {
      return this.indexOf(element) !== -1;
    }
  });

  /**
   * Adds an element to the array, unless it exists already (set semantics).
   *
   * @method RefsCollection#add
   *
   * @param {Object} element the element to add
   * @param {Number} optional index to add element to
   *                 (possibly moving other elements around)
   */
  Object.defineProperty(collection, 'add', {
    value: function(element, idx) {

      var currentIdx = this.indexOf(element);

      if (typeof idx === 'undefined') {

        if (currentIdx !== -1) {
          // element already in collection (!)
          return;
        }

        // add to end of array, as no idx is specified
        idx = this.length;
      }

      // handle already in collection
      if (currentIdx !== -1) {

        // remove element from currentIdx
        this.splice(currentIdx, 1);
      }

      // add element at idx
      this.splice(idx, 0, element);

      if (currentIdx === -1) {
        // set inverse, unless element was
        // in collection already
        refs.set(element, inverseProperty, target);
      }
    }
  });

  // a simple marker, identifying this element
  // as being a refs collection
  Object.defineProperty(collection, '__refs_collection', {
    value: true
  });

  return collection;
}


function isExtended(collection) {
  return collection.__refs_collection === true;
}

module.exports.extend = extend;

module.exports.isExtended = isExtended;

/***/ }),

/***/ "./node_modules/object-refs/lib/refs.js":
/*!**********************************************!*\
  !*** ./node_modules/object-refs/lib/refs.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Collection = __webpack_require__(/*! ./collection */ "./node_modules/object-refs/lib/collection.js");

function hasOwnProperty(e, property) {
  return Object.prototype.hasOwnProperty.call(e, property.name || property);
}

function defineCollectionProperty(ref, property, target) {

  var collection = Collection.extend(target[property.name] || [], ref, property, target);

  Object.defineProperty(target, property.name, {
    enumerable: property.enumerable,
    value: collection
  });

  if (collection.length) {

    collection.forEach(function(o) {
      ref.set(o, property.inverse, target);
    });
  }
}


function defineProperty(ref, property, target) {

  var inverseProperty = property.inverse;

  var _value = target[property.name];

  Object.defineProperty(target, property.name, {
    configurable: property.configurable,
    enumerable: property.enumerable,

    get: function() {
      return _value;
    },

    set: function(value) {

      // return if we already performed all changes
      if (value === _value) {
        return;
      }

      var old = _value;

      // temporary set null
      _value = null;

      if (old) {
        ref.unset(old, inverseProperty, target);
      }

      // set new value
      _value = value;

      // set inverse value
      ref.set(_value, inverseProperty, target);
    }
  });

}

/**
 * Creates a new references object defining two inversly related
 * attribute descriptors a and b.
 *
 * <p>
 *   When bound to an object using {@link Refs#bind} the references
 *   get activated and ensure that add and remove operations are applied
 *   reversely, too.
 * </p>
 *
 * <p>
 *   For attributes represented as collections {@link Refs} provides the
 *   {@link RefsCollection#add}, {@link RefsCollection#remove} and {@link RefsCollection#contains} extensions
 *   that must be used to properly hook into the inverse change mechanism.
 * </p>
 *
 * @class Refs
 *
 * @classdesc A bi-directional reference between two attributes.
 *
 * @param {Refs.AttributeDescriptor} a property descriptor
 * @param {Refs.AttributeDescriptor} b property descriptor
 *
 * @example
 *
 * var refs = Refs({ name: 'wheels', collection: true, enumerable: true }, { name: 'car' });
 *
 * var car = { name: 'toyota' };
 * var wheels = [{ pos: 'front-left' }, { pos: 'front-right' }];
 *
 * refs.bind(car, 'wheels');
 *
 * car.wheels // []
 * car.wheels.add(wheels[0]);
 * car.wheels.add(wheels[1]);
 *
 * car.wheels // [{ pos: 'front-left' }, { pos: 'front-right' }]
 *
 * wheels[0].car // { name: 'toyota' };
 * car.wheels.remove(wheels[0]);
 *
 * wheels[0].car // undefined
 */
function Refs(a, b) {

  if (!(this instanceof Refs)) {
    return new Refs(a, b);
  }

  // link
  a.inverse = b;
  b.inverse = a;

  this.props = {};
  this.props[a.name] = a;
  this.props[b.name] = b;
}

/**
 * Binds one side of a bi-directional reference to a
 * target object.
 *
 * @memberOf Refs
 *
 * @param  {Object} target
 * @param  {String} property
 */
Refs.prototype.bind = function(target, property) {
  if (typeof property === 'string') {
    if (!this.props[property]) {
      throw new Error('no property <' + property + '> in ref');
    }
    property = this.props[property];
  }

  if (property.collection) {
    defineCollectionProperty(this, property, target);
  } else {
    defineProperty(this, property, target);
  }
};

Refs.prototype.ensureRefsCollection = function(target, property) {

  var collection = target[property.name];

  if (!Collection.isExtended(collection)) {
    defineCollectionProperty(this, property, target);
  }

  return collection;
};

Refs.prototype.ensureBound = function(target, property) {
  if (!hasOwnProperty(target, property)) {
    this.bind(target, property);
  }
};

Refs.prototype.unset = function(target, property, value) {

  if (target) {
    this.ensureBound(target, property);

    if (property.collection) {
      this.ensureRefsCollection(target, property).remove(value);
    } else {
      target[property.name] = undefined;
    }
  }
};

Refs.prototype.set = function(target, property, value) {

  if (target) {
    this.ensureBound(target, property);

    if (property.collection) {
      this.ensureRefsCollection(target, property).add(value);
    } else {
      target[property.name] = value;
    }
  }
};

module.exports = Refs;


/**
 * An attribute descriptor to be used specify an attribute in a {@link Refs} instance
 *
 * @typedef {Object} Refs.AttributeDescriptor
 * @property {String} name
 * @property {boolean} [collection=false]
 * @property {boolean} [enumerable=false]
 */

/***/ }),

/***/ "./node_modules/path-intersection/intersect.js":
/*!*****************************************************!*\
  !*** ./node_modules/path-intersection/intersect.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * This file contains source code adapted from Snap.svg (licensed Apache-2.0).
 *
 * @see https://github.com/adobe-webplatform/Snap.svg/blob/master/src/path.js
 */

/* eslint no-fallthrough: "off" */

var p2s = /,?([a-z]),?/gi,
    toFloat = parseFloat,
    math = Math,
    PI = math.PI,
    mmin = math.min,
    mmax = math.max,
    pow = math.pow,
    abs = math.abs,
    pathCommand = /([a-z])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?[\s]*,?[\s]*)+)/ig,
    pathValues = /(-?\d*\.?\d*(?:e[-+]?\\d+)?)[\s]*,?[\s]*/ig;

var isArray = Array.isArray || function(o) { return o instanceof Array; };

function hasProperty(obj, property) {
  return Object.prototype.hasOwnProperty.call(obj, property);
}

function clone(obj) {

  if (typeof obj == 'function' || Object(obj) !== obj) {
    return obj;
  }

  var res = new obj.constructor;

  for (var key in obj) {
    if (hasProperty(obj, key)) {
      res[key] = clone(obj[key]);
    }
  }

  return res;
}

function repush(array, item) {
  for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {
    return array.push(array.splice(i, 1)[0]);
  }
}

function cacher(f) {

  function newf() {

    var arg = Array.prototype.slice.call(arguments, 0),
        args = arg.join('\u2400'),
        cache = newf.cache = newf.cache || {},
        count = newf.count = newf.count || [];

    if (hasProperty(cache, args)) {
      repush(count, args);
      return cache[args];
    }

    count.length >= 1e3 && delete cache[count.shift()];
    count.push(args);
    cache[args] = f.apply(0, arg);

    return cache[args];
  }
  return newf;
}

function parsePathString(pathString) {

  if (!pathString) {
    return null;
  }

  var pth = paths(pathString);

  if (pth.arr) {
    return clone(pth.arr);
  }

  var paramCounts = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 },
      data = [];

  if (isArray(pathString) && isArray(pathString[0])) { // rough assumption
    data = clone(pathString);
  }

  if (!data.length) {

    String(pathString).replace(pathCommand, function(a, b, c) {
      var params = [],
          name = b.toLowerCase();

      c.replace(pathValues, function(a, b) {
        b && params.push(+b);
      });

      if (name == 'm' && params.length > 2) {
        data.push([b].concat(params.splice(0, 2)));
        name = 'l';
        b = b == 'm' ? 'l' : 'L';
      }

      while (params.length >= paramCounts[name]) {
        data.push([b].concat(params.splice(0, paramCounts[name])));
        if (!paramCounts[name]) {
          break;
        }
      }
    });
  }

  data.toString = paths.toString;
  pth.arr = clone(data);

  return data;
}

function paths(ps) {
  var p = paths.ps = paths.ps || {};

  if (p[ps]) {
    p[ps].sleep = 100;
  } else {
    p[ps] = {
      sleep: 100
    };
  }

  setTimeout(function() {
    for (var key in p) {
      if (hasProperty(p, key) && key != ps) {
        p[key].sleep--;
        !p[key].sleep && delete p[key];
      }
    }
  });

  return p[ps];
}

function rectBBox(x, y, width, height) {

  if (arguments.length === 1) {
    y = x.y;
    width = x.width;
    height = x.height;
    x = x.x;
  }

  return {
    x: x,
    y: y,
    width: width,
    height: height,
    x2: x + width,
    y2: y + height
  };
}

function pathToString() {
  return this.join(',').replace(p2s, '$1');
}

function pathClone(pathArray) {
  var res = clone(pathArray);
  res.toString = pathToString;
  return res;
}

function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
  var t1 = 1 - t,
      t13 = pow(t1, 3),
      t12 = pow(t1, 2),
      t2 = t * t,
      t3 = t2 * t,
      x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
      y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y;

  return {
    x: fixError(x),
    y: fixError(y)
  };
}

function bezierBBox(points) {

  var bbox = curveBBox.apply(null, points);

  return rectBBox(
    bbox.x0,
    bbox.y0,
    bbox.x1 - bbox.x0,
    bbox.y1 - bbox.y0
  );
}

function isPointInsideBBox(bbox, x, y) {
  return x >= bbox.x &&
    x <= bbox.x + bbox.width &&
    y >= bbox.y &&
    y <= bbox.y + bbox.height;
}

function isBBoxIntersect(bbox1, bbox2) {
  bbox1 = rectBBox(bbox1);
  bbox2 = rectBBox(bbox2);
  return isPointInsideBBox(bbox2, bbox1.x, bbox1.y)
    || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y)
    || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2)
    || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2)
    || isPointInsideBBox(bbox1, bbox2.x, bbox2.y)
    || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y)
    || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2)
    || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2)
    || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x
        || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)
    && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y
        || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
}

function base3(t, p1, p2, p3, p4) {
  var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
      t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
  return t * t2 - 3 * p1 + 3 * p2;
}

function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {

  if (z == null) {
    z = 1;
  }

  z = z > 1 ? 1 : z < 0 ? 0 : z;

  var z2 = z / 2,
      n = 12,
      Tvalues = [-.1252,.1252,-.3678,.3678,-.5873,.5873,-.7699,.7699,-.9041,.9041,-.9816,.9816],
      Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],
      sum = 0;

  for (var i = 0; i < n; i++) {
    var ct = z2 * Tvalues[i] + z2,
        xbase = base3(ct, x1, x2, x3, x4),
        ybase = base3(ct, y1, y2, y3, y4),
        comb = xbase * xbase + ybase * ybase;

    sum += Cvalues[i] * math.sqrt(comb);
  }

  return z2 * sum;
}


function intersectLines(x1, y1, x2, y2, x3, y3, x4, y4) {

  if (
    mmax(x1, x2) < mmin(x3, x4) ||
      mmin(x1, x2) > mmax(x3, x4) ||
      mmax(y1, y2) < mmin(y3, y4) ||
      mmin(y1, y2) > mmax(y3, y4)
  ) {
    return;
  }

  var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
      denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

  if (!denominator) {
    return;
  }

  var px = fixError(nx / denominator),
      py = fixError(ny / denominator),
      px2 = +px.toFixed(2),
      py2 = +py.toFixed(2);

  if (
    px2 < +mmin(x1, x2).toFixed(2) ||
      px2 > +mmax(x1, x2).toFixed(2) ||
      px2 < +mmin(x3, x4).toFixed(2) ||
      px2 > +mmax(x3, x4).toFixed(2) ||
      py2 < +mmin(y1, y2).toFixed(2) ||
      py2 > +mmax(y1, y2).toFixed(2) ||
      py2 < +mmin(y3, y4).toFixed(2) ||
      py2 > +mmax(y3, y4).toFixed(2)
  ) {
    return;
  }

  return { x: px, y: py };
}

function fixError(number) {
  return Math.round(number * 100000000000) / 100000000000;
}

function findBezierIntersections(bez1, bez2, justCount) {
  var bbox1 = bezierBBox(bez1),
      bbox2 = bezierBBox(bez2);

  if (!isBBoxIntersect(bbox1, bbox2)) {
    return justCount ? 0 : [];
  }

  // As an optimization, lines will have only 1 segment

  var l1 = bezlen.apply(0, bez1),
      l2 = bezlen.apply(0, bez2),
      n1 = isLine(bez1) ? 1 : ~~(l1 / 5) || 1,
      n2 = isLine(bez2) ? 1 : ~~(l2 / 5) || 1,
      dots1 = [],
      dots2 = [],
      xy = {},
      res = justCount ? 0 : [];

  for (var i = 0; i < n1 + 1; i++) {
    var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));
    dots1.push({ x: p.x, y: p.y, t: i / n1 });
  }

  for (i = 0; i < n2 + 1; i++) {
    p = findDotsAtSegment.apply(0, bez2.concat(i / n2));
    dots2.push({ x: p.x, y: p.y, t: i / n2 });
  }

  for (i = 0; i < n1; i++) {

    for (var j = 0; j < n2; j++) {
      var di = dots1[i],
          di1 = dots1[i + 1],
          dj = dots2[j],
          dj1 = dots2[j + 1],
          ci = abs(di1.x - di.x) < .01 ? 'y' : 'x',
          cj = abs(dj1.x - dj.x) < .01 ? 'y' : 'x',
          is = intersectLines(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y),
          key;

      if (is) {
        key = is.x.toFixed(9) + '#' + is.y.toFixed(9);

        if (xy[key]) {
          continue;
        }

        xy[key] = true;

        var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
            t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);

        if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {

          if (justCount) {
            res++;
          } else {
            res.push({
              x: is.x,
              y: is.y,
              t1: t1,
              t2: t2
            });
          }
        }
      }
    }
  }

  return res;
}


/**
 * Find or counts the intersections between two SVG paths.
 *
 * Returns a number in counting mode and a list of intersections otherwise.
 *
 * A single intersection entry contains the intersection coordinates (x, y)
 * as well as additional information regarding the intersecting segments
 * on each path (segment1, segment2) and the relative location of the
 * intersection on these segments (t1, t2).
 *
 * The path may be an SVG path string or a list of path components
 * such as `[ [ 'M', 0, 10 ], [ 'L', 20, 0 ] ]`.
 *
 * @example
 *
 * var intersections = findPathIntersections(
 *   'M0,0L100,100',
 *   [ [ 'M', 0, 100 ], [ 'L', 100, 0 ] ]
 * );
 *
 * // intersections = [
 * //   { x: 50, y: 50, segment1: 1, segment2: 1, t1: 0.5, t2: 0.5 }
 * // ]
 *
 * @param {String|Array<PathDef>} path1
 * @param {String|Array<PathDef>} path2
 * @param {Boolean} [justCount=false]
 *
 * @return {Array<Intersection>|Number}
 */
function findPathIntersections(path1, path2, justCount) {
  path1 = pathToCurve(path1);
  path2 = pathToCurve(path2);

  var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,
      res = justCount ? 0 : [];

  for (var i = 0, ii = path1.length; i < ii; i++) {
    var pi = path1[i];

    if (pi[0] == 'M') {
      x1 = x1m = pi[1];
      y1 = y1m = pi[2];
    } else {

      if (pi[0] == 'C') {
        bez1 = [x1, y1].concat(pi.slice(1));
        x1 = bez1[6];
        y1 = bez1[7];
      } else {
        bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
        x1 = x1m;
        y1 = y1m;
      }

      for (var j = 0, jj = path2.length; j < jj; j++) {
        var pj = path2[j];

        if (pj[0] == 'M') {
          x2 = x2m = pj[1];
          y2 = y2m = pj[2];
        } else {

          if (pj[0] == 'C') {
            bez2 = [x2, y2].concat(pj.slice(1));
            x2 = bez2[6];
            y2 = bez2[7];
          } else {
            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
            x2 = x2m;
            y2 = y2m;
          }

          var intr = findBezierIntersections(bez1, bez2, justCount);

          if (justCount) {
            res += intr;
          } else {

            for (var k = 0, kk = intr.length; k < kk; k++) {
              intr[k].segment1 = i;
              intr[k].segment2 = j;
              intr[k].bez1 = bez1;
              intr[k].bez2 = bez2;
            }

            res = res.concat(intr);
          }
        }
      }
    }
  }

  return res;
}


function pathToAbsolute(pathArray) {
  var pth = paths(pathArray);

  if (pth.abs) {
    return pathClone(pth.abs);
  }

  if (!isArray(pathArray) || !isArray(pathArray && pathArray[0])) { // rough assumption
    pathArray = parsePathString(pathArray);
  }

  if (!pathArray || !pathArray.length) {
    return [['M', 0, 0]];
  }

  var res = [],
      x = 0,
      y = 0,
      mx = 0,
      my = 0,
      start = 0,
      pa0;

  if (pathArray[0][0] == 'M') {
    x = +pathArray[0][1];
    y = +pathArray[0][2];
    mx = x;
    my = y;
    start++;
    res[0] = ['M', x, y];
  }

  for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
    res.push(r = []);
    pa = pathArray[i];
    pa0 = pa[0];

    if (pa0 != pa0.toUpperCase()) {
      r[0] = pa0.toUpperCase();

      switch (r[0]) {
      case 'A':
        r[1] = pa[1];
        r[2] = pa[2];
        r[3] = pa[3];
        r[4] = pa[4];
        r[5] = pa[5];
        r[6] = +pa[6] + x;
        r[7] = +pa[7] + y;
        break;
      case 'V':
        r[1] = +pa[1] + y;
        break;
      case 'H':
        r[1] = +pa[1] + x;
        break;
      case 'M':
        mx = +pa[1] + x;
        my = +pa[2] + y;
      default:
        for (var j = 1, jj = pa.length; j < jj; j++) {
          r[j] = +pa[j] + ((j % 2) ? x : y);
        }
      }
    } else {
      for (var k = 0, kk = pa.length; k < kk; k++) {
        r[k] = pa[k];
      }
    }
    pa0 = pa0.toUpperCase();

    switch (r[0]) {
    case 'Z':
      x = +mx;
      y = +my;
      break;
    case 'H':
      x = r[1];
      break;
    case 'V':
      y = r[1];
      break;
    case 'M':
      mx = r[r.length - 2];
      my = r[r.length - 1];
    default:
      x = r[r.length - 2];
      y = r[r.length - 1];
    }
  }

  res.toString = pathToString;
  pth.abs = pathClone(res);

  return res;
}

function isLine(bez) {
  return (
    bez[0] === bez[2] &&
    bez[1] === bez[3] &&
    bez[4] === bez[6] &&
    bez[5] === bez[7]
  );
}

function lineToCurve(x1, y1, x2, y2) {
  return [
    x1, y1, x2,
    y2, x2, y2
  ];
}

function qubicToCurve(x1, y1, ax, ay, x2, y2) {
  var _13 = 1 / 3,
      _23 = 2 / 3;

  return [
    _13 * x1 + _23 * ax,
    _13 * y1 + _23 * ay,
    _13 * x2 + _23 * ax,
    _13 * y2 + _23 * ay,
    x2,
    y2
  ];
}

function arcToCurve(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {

  // for more information of where this math came from visit:
  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
  var _120 = PI * 120 / 180,
      rad = PI / 180 * (+angle || 0),
      res = [],
      xy,
      rotate = cacher(function(x, y, rad) {
        var X = x * math.cos(rad) - y * math.sin(rad),
            Y = x * math.sin(rad) + y * math.cos(rad);

        return { x: X, y: Y };
      });

  if (!recursive) {
    xy = rotate(x1, y1, -rad);
    x1 = xy.x;
    y1 = xy.y;
    xy = rotate(x2, y2, -rad);
    x2 = xy.x;
    y2 = xy.y;

    var x = (x1 - x2) / 2,
        y = (y1 - y2) / 2;

    var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);

    if (h > 1) {
      h = math.sqrt(h);
      rx = h * rx;
      ry = h * ry;
    }

    var rx2 = rx * rx,
        ry2 = ry * ry,
        k = (large_arc_flag == sweep_flag ? -1 : 1) *
            math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
        cx = k * rx * y / ry + (x1 + x2) / 2,
        cy = k * -ry * x / rx + (y1 + y2) / 2,
        f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
        f2 = math.asin(((y2 - cy) / ry).toFixed(9));

    f1 = x1 < cx ? PI - f1 : f1;
    f2 = x2 < cx ? PI - f2 : f2;
    f1 < 0 && (f1 = PI * 2 + f1);
    f2 < 0 && (f2 = PI * 2 + f2);

    if (sweep_flag && f1 > f2) {
      f1 = f1 - PI * 2;
    }
    if (!sweep_flag && f2 > f1) {
      f2 = f2 - PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }

  var df = f2 - f1;

  if (abs(df) > _120) {
    var f2old = f2,
        x2old = x2,
        y2old = y2;

    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * math.cos(f2);
    y2 = cy + ry * math.sin(f2);
    res = arcToCurve(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
  }

  df = f2 - f1;

  var c1 = math.cos(f1),
      s1 = math.sin(f1),
      c2 = math.cos(f2),
      s2 = math.sin(f2),
      t = math.tan(df / 4),
      hx = 4 / 3 * rx * t,
      hy = 4 / 3 * ry * t,
      m1 = [x1, y1],
      m2 = [x1 + hx * s1, y1 - hy * c1],
      m3 = [x2 + hx * s2, y2 - hy * c2],
      m4 = [x2, y2];

  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];

  if (recursive) {
    return [m2, m3, m4].concat(res);
  } else {
    res = [m2, m3, m4].concat(res).join().split(',');
    var newres = [];

    for (var i = 0, ii = res.length; i < ii; i++) {
      newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
    }

    return newres;
  }
}

// Returns bounding box of cubic bezier curve.
// Source: http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
// Original version: NISHIO Hirokazu
// Modifications: https://github.com/timo22345
function curveBBox(x0, y0, x1, y1, x2, y2, x3, y3) {
  var tvalues = [],
      bounds = [[], []],
      a, b, c, t, t1, t2, b2ac, sqrtb2ac;

  for (var i = 0; i < 2; ++i) {

    if (i == 0) {
      b = 6 * x0 - 12 * x1 + 6 * x2;
      a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
      c = 3 * x1 - 3 * x0;
    } else {
      b = 6 * y0 - 12 * y1 + 6 * y2;
      a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
      c = 3 * y1 - 3 * y0;
    }

    if (abs(a) < 1e-12) {

      if (abs(b) < 1e-12) {
        continue;
      }

      t = -c / b;

      if (0 < t && t < 1) {
        tvalues.push(t);
      }

      continue;
    }

    b2ac = b * b - 4 * c * a;
    sqrtb2ac = math.sqrt(b2ac);

    if (b2ac < 0) {
      continue;
    }

    t1 = (-b + sqrtb2ac) / (2 * a);

    if (0 < t1 && t1 < 1) {
      tvalues.push(t1);
    }

    t2 = (-b - sqrtb2ac) / (2 * a);

    if (0 < t2 && t2 < 1) {
      tvalues.push(t2);
    }
  }

  var j = tvalues.length,
      jlen = j,
      mt;

  while (j--) {
    t = tvalues[j];
    mt = 1 - t;
    bounds[0][j] = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);
    bounds[1][j] = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);
  }

  bounds[0][jlen] = x0;
  bounds[1][jlen] = y0;
  bounds[0][jlen + 1] = x3;
  bounds[1][jlen + 1] = y3;
  bounds[0].length = bounds[1].length = jlen + 2;

  return {
    x0: mmin.apply(0, bounds[0]),
    y0: mmin.apply(0, bounds[1]),
    x1: mmax.apply(0, bounds[0]),
    y1: mmax.apply(0, bounds[1])
  };
}

function pathToCurve(path) {

  var pth = paths(path);

  // return cached curve, if existing
  if (pth.curve) {
    return pathClone(pth.curve);
  }

  var curvedPath = pathToAbsolute(path),
      attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null },
      processPath = function(path, d, pathCommand) {
        var nx, ny;

        if (!path) {
          return ['C', d.x, d.y, d.x, d.y, d.x, d.y];
        }

        !(path[0] in { T: 1, Q: 1 }) && (d.qx = d.qy = null);

        switch (path[0]) {
        case 'M':
          d.X = path[1];
          d.Y = path[2];
          break;
        case 'A':
          path = ['C'].concat(arcToCurve.apply(0, [d.x, d.y].concat(path.slice(1))));
          break;
        case 'S':
          if (pathCommand == 'C' || pathCommand == 'S') {
            // In 'S' case we have to take into account, if the previous command is C/S.
            nx = d.x * 2 - d.bx;
            // And reflect the previous
            ny = d.y * 2 - d.by;
            // command's control point relative to the current point.
          }
          else {
            // or some else or nothing
            nx = d.x;
            ny = d.y;
          }
          path = ['C', nx, ny].concat(path.slice(1));
          break;
        case 'T':
          if (pathCommand == 'Q' || pathCommand == 'T') {
            // In 'T' case we have to take into account, if the previous command is Q/T.
            d.qx = d.x * 2 - d.qx;
            // And make a reflection similar
            d.qy = d.y * 2 - d.qy;
            // to case 'S'.
          }
          else {
            // or something else or nothing
            d.qx = d.x;
            d.qy = d.y;
          }
          path = ['C'].concat(qubicToCurve(d.x, d.y, d.qx, d.qy, path[1], path[2]));
          break;
        case 'Q':
          d.qx = path[1];
          d.qy = path[2];
          path = ['C'].concat(qubicToCurve(d.x, d.y, path[1], path[2], path[3], path[4]));
          break;
        case 'L':
          path = ['C'].concat(lineToCurve(d.x, d.y, path[1], path[2]));
          break;
        case 'H':
          path = ['C'].concat(lineToCurve(d.x, d.y, path[1], d.y));
          break;
        case 'V':
          path = ['C'].concat(lineToCurve(d.x, d.y, d.x, path[1]));
          break;
        case 'Z':
          path = ['C'].concat(lineToCurve(d.x, d.y, d.X, d.Y));
          break;
        }

        return path;
      },

      fixArc = function(pp, i) {

        if (pp[i].length > 7) {
          pp[i].shift();
          var pi = pp[i];

          while (pi.length) {
            pathCommands[i] = 'A'; // if created multiple C:s, their original seg is saved
            pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));
          }

          pp.splice(i, 1);
          ii = curvedPath.length;
        }
      },

      pathCommands = [], // path commands of original path p
      pfirst = '', // temporary holder for original path command
      pathCommand = ''; // holder for previous path command of original path

  for (var i = 0, ii = curvedPath.length; i < ii; i++) {
    curvedPath[i] && (pfirst = curvedPath[i][0]); // save current path command

    if (pfirst != 'C') // C is not saved yet, because it may be result of conversion
    {
      pathCommands[i] = pfirst; // Save current path command
      i && (pathCommand = pathCommands[i - 1]); // Get previous path command pathCommand
    }
    curvedPath[i] = processPath(curvedPath[i], attrs, pathCommand); // Previous path command is inputted to processPath

    if (pathCommands[i] != 'A' && pfirst == 'C') pathCommands[i] = 'C'; // A is the only command
    // which may produce multiple C:s
    // so we have to make sure that C is also C in original path

    fixArc(curvedPath, i); // fixArc adds also the right amount of A:s to pathCommands

    var seg = curvedPath[i],
        seglen = seg.length;

    attrs.x = seg[seglen - 2];
    attrs.y = seg[seglen - 1];
    attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
    attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
  }

  // cache curve
  pth.curve = pathClone(curvedPath);

  return curvedPath;
}

module.exports = findPathIntersections;


/***/ }),

/***/ "./node_modules/saxen/dist/index.esm.js":
/*!**********************************************!*\
  !*** ./node_modules/saxen/dist/index.esm.js ***!
  \**********************************************/
/*! exports provided: Parser, decode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Parser", function() { return Parser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decode", function() { return decodeEntities; });
var fromCharCode = String.fromCharCode;

var hasOwnProperty = Object.prototype.hasOwnProperty;

var ENTITY_PATTERN = /&#(\d+);|&#x([0-9a-f]+);|&(\w+);/ig;

var ENTITY_MAPPING = {
  'amp': '&',
  'apos': '\'',
  'gt': '>',
  'lt': '<',
  'quot': '"'
};

// map UPPERCASE variants of supported special chars
Object.keys(ENTITY_MAPPING).forEach(function(k) {
  ENTITY_MAPPING[k.toUpperCase()] = ENTITY_MAPPING[k];
});


function replaceEntities(_, d, x, z) {

  // reserved names, i.e. &nbsp;
  if (z) {
    if (hasOwnProperty.call(ENTITY_MAPPING, z)) {
      return ENTITY_MAPPING[z];
    } else {
      // fall back to original value
      return '&' + z + ';';
    }
  }

  // decimal encoded char
  if (d) {
    return fromCharCode(d);
  }

  // hex encoded char
  return fromCharCode(parseInt(x, 16));
}


/**
 * A basic entity decoder that can decode a minimal
 * sub-set of reserved names (&amp;) as well as
 * hex (&#xaaf;) and decimal (&#1231;) encoded characters.
 *
 * @param {string} str
 *
 * @return {string} decoded string
 */
function decodeEntities(s) {
  if (s.length > 3 && s.indexOf('&') !== -1) {
    return s.replace(ENTITY_PATTERN, replaceEntities);
  }

  return s;
}

var XSI_URI = 'http://www.w3.org/2001/XMLSchema-instance';
var XSI_PREFIX = 'xsi';
var XSI_TYPE = 'xsi:type';

var NON_WHITESPACE_OUTSIDE_ROOT_NODE = 'non-whitespace outside of root node';

function error(msg) {
  return new Error(msg);
}

function missingNamespaceForPrefix(prefix) {
  return 'missing namespace for prefix <' + prefix + '>';
}

function getter(getFn) {
  return {
    'get': getFn,
    'enumerable': true
  };
}

function cloneNsMatrix(nsMatrix) {
  var clone = {}, key;
  for (key in nsMatrix) {
    clone[key] = nsMatrix[key];
  }
  return clone;
}

function uriPrefix(prefix) {
  return prefix + '$uri';
}

function buildNsMatrix(nsUriToPrefix) {
  var nsMatrix = {},
      uri,
      prefix;

  for (uri in nsUriToPrefix) {
    prefix = nsUriToPrefix[uri];
    nsMatrix[prefix] = prefix;
    nsMatrix[uriPrefix(prefix)] = uri;
  }

  return nsMatrix;
}

function noopGetContext() {
  return { 'line': 0, 'column': 0 };
}

function throwFunc(err) {
  throw err;
}

/**
 * Creates a new parser with the given options.
 *
 * @constructor
 *
 * @param  {!Object<string, ?>=} options
 */
function Parser(options) {

  if (!this) {
    return new Parser(options);
  }

  var proxy = options && options['proxy'];

  var onText,
      onOpenTag,
      onCloseTag,
      onCDATA,
      onError = throwFunc,
      onWarning,
      onComment,
      onQuestion,
      onAttention;

  var getContext = noopGetContext;

  /**
   * Do we need to parse the current elements attributes for namespaces?
   *
   * @type {boolean}
   */
  var maybeNS = false;

  /**
   * Do we process namespaces at all?
   *
   * @type {boolean}
   */
  var isNamespace = false;

  /**
   * The caught error returned on parse end
   *
   * @type {Error}
   */
  var returnError = null;

  /**
   * Should we stop parsing?
   *
   * @type {boolean}
   */
  var parseStop = false;

  /**
   * A map of { uri: prefix } used by the parser.
   *
   * This map will ensure we can normalize prefixes during processing;
   * for each uri, only one prefix will be exposed to the handlers.
   *
   * @type {!Object<string, string>}}
   */
  var nsUriToPrefix;

  /**
   * Handle parse error.
   *
   * @param  {string|Error} err
   */
  function handleError(err) {
    if (!(err instanceof Error)) {
      err = error(err);
    }

    returnError = err;

    onError(err, getContext);
  }

  /**
   * Handle parse error.
   *
   * @param  {string|Error} err
   */
  function handleWarning(err) {

    if (!onWarning) {
      return;
    }

    if (!(err instanceof Error)) {
      err = error(err);
    }

    onWarning(err, getContext);
  }

  /**
   * Register parse listener.
   *
   * @param  {string}   name
   * @param  {Function} cb
   *
   * @return {Parser}
   */
  this['on'] = function(name, cb) {

    if (typeof cb !== 'function') {
      throw error('required args <name, cb>');
    }

    switch (name) {
    case 'openTag': onOpenTag = cb; break;
    case 'text': onText = cb; break;
    case 'closeTag': onCloseTag = cb; break;
    case 'error': onError = cb; break;
    case 'warn': onWarning = cb; break;
    case 'cdata': onCDATA = cb; break;
    case 'attention': onAttention = cb; break; // <!XXXXX zzzz="eeee">
    case 'question': onQuestion = cb; break; // <? ....  ?>
    case 'comment': onComment = cb; break;
    default:
      throw error('unsupported event: ' + name);
    }

    return this;
  };

  /**
   * Set the namespace to prefix mapping.
   *
   * @example
   *
   * parser.ns({
   *   'http://foo': 'foo',
   *   'http://bar': 'bar'
   * });
   *
   * @param  {!Object<string, string>} nsMap
   *
   * @return {Parser}
   */
  this['ns'] = function(nsMap) {

    if (typeof nsMap === 'undefined') {
      nsMap = {};
    }

    if (typeof nsMap !== 'object') {
      throw error('required args <nsMap={}>');
    }

    var _nsUriToPrefix = {}, k;

    for (k in nsMap) {
      _nsUriToPrefix[k] = nsMap[k];
    }

    // FORCE default mapping for schema instance
    _nsUriToPrefix[XSI_URI] = XSI_PREFIX;

    isNamespace = true;
    nsUriToPrefix = _nsUriToPrefix;

    return this;
  };

  /**
   * Parse xml string.
   *
   * @param  {string} xml
   *
   * @return {Error} returnError, if not thrown
   */
  this['parse'] = function(xml) {
    if (typeof xml !== 'string') {
      throw error('required args <xml=string>');
    }

    returnError = null;

    parse(xml);

    getContext = noopGetContext;
    parseStop = false;

    return returnError;
  };

  /**
   * Stop parsing.
   */
  this['stop'] = function() {
    parseStop = true;
  };

  /**
   * Parse string, invoking configured listeners on element.
   *
   * @param  {string} xml
   */
  function parse(xml) {
    var nsMatrixStack = isNamespace ? [] : null,
        nsMatrix = isNamespace ? buildNsMatrix(nsUriToPrefix) : null,
        _nsMatrix,
        nodeStack = [],
        anonymousNsCount = 0,
        tagStart = false,
        tagEnd = false,
        i = 0, j = 0,
        x, y, q, w,
        xmlns,
        elementName,
        _elementName,
        elementProxy
        ;

    var attrsString = '',
        attrsStart = 0,
        cachedAttrs // false = parsed with errors, null = needs parsing
        ;

    /**
     * Parse attributes on demand and returns the parsed attributes.
     *
     * Return semantics: (1) `false` on attribute parse error,
     * (2) object hash on extracted attrs.
     *
     * @return {boolean|Object}
     */
    function getAttrs() {
      if (cachedAttrs !== null) {
        return cachedAttrs;
      }

      var nsUri,
          nsUriPrefix,
          nsName,
          defaultAlias = isNamespace && nsMatrix['xmlns'],
          attrList = isNamespace && maybeNS ? [] : null,
          i = attrsStart,
          s = attrsString,
          l = s.length,
          hasNewMatrix,
          newalias,
          value,
          alias,
          name,
          attrs = {},
          seenAttrs = {},
          skipAttr,
          w,
          j;

      parseAttr:
      for (; i < l; i++) {
        skipAttr = false;
        w = s.charCodeAt(i);

        if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE={ \f\n\r\t\v}
          continue;
        }

        // wait for non whitespace character
        if (w < 65 || w > 122 || (w > 90 && w < 97)) {
          if (w !== 95 && w !== 58) { // char 95"_" 58":"
            handleWarning('illegal first char attribute name');
            skipAttr = true;
          }
        }

        // parse attribute name
        for (j = i + 1; j < l; j++) {
          w = s.charCodeAt(j);

          if (
            w > 96 && w < 123 ||
            w > 64 && w < 91 ||
            w > 47 && w < 59 ||
            w === 46 || // '.'
            w === 45 || // '-'
            w === 95 // '_'
          ) {
            continue;
          }

          // unexpected whitespace
          if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE
            handleWarning('missing attribute value');
            i = j;

            continue parseAttr;
          }

          // expected "="
          if (w === 61) { // "=" == 61
            break;
          }

          handleWarning('illegal attribute name char');
          skipAttr = true;
        }

        name = s.substring(i, j);

        if (name === 'xmlns:xmlns') {
          handleWarning('illegal declaration of xmlns');
          skipAttr = true;
        }

        w = s.charCodeAt(j + 1);

        if (w === 34) { // '"'
          j = s.indexOf('"', i = j + 2);

          if (j === -1) {
            j = s.indexOf('\'', i);

            if (j !== -1) {
              handleWarning('attribute value quote missmatch');
              skipAttr = true;
            }
          }

        } else if (w === 39) { // "'"
          j = s.indexOf('\'', i = j + 2);

          if (j === -1) {
            j = s.indexOf('"', i);

            if (j !== -1) {
              handleWarning('attribute value quote missmatch');
              skipAttr = true;
            }
          }

        } else {
          handleWarning('missing attribute value quotes');
          skipAttr = true;

          // skip to next space
          for (j = j + 1; j < l; j++) {
            w = s.charCodeAt(j + 1);

            if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE
              break;
            }
          }

        }

        if (j === -1) {
          handleWarning('missing closing quotes');

          j = l;
          skipAttr = true;
        }

        if (!skipAttr) {
          value = s.substring(i, j);
        }

        i = j;

        // ensure SPACE follows attribute
        // skip illegal content otherwise
        // example a="b"c
        for (; j + 1 < l; j++) {
          w = s.charCodeAt(j + 1);

          if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE
            break;
          }

          // FIRST ILLEGAL CHAR
          if (i === j) {
            handleWarning('illegal character after attribute end');
            skipAttr = true;
          }
        }

        // advance cursor to next attribute
        i = j + 1;

        if (skipAttr) {
          continue parseAttr;
        }

        // check attribute re-declaration
        if (name in seenAttrs) {
          handleWarning('attribute <' + name + '> already defined');
          continue;
        }

        seenAttrs[name] = true;

        if (!isNamespace) {
          attrs[name] = value;
          continue;
        }

        // try to extract namespace information
        if (maybeNS) {
          newalias = (
            name === 'xmlns'
              ? 'xmlns'
              : (name.charCodeAt(0) === 120 && name.substr(0, 6) === 'xmlns:')
                ? name.substr(6)
                : null
          );

          // handle xmlns(:alias) assignment
          if (newalias !== null) {
            nsUri = decodeEntities(value);
            nsUriPrefix = uriPrefix(newalias);

            alias = nsUriToPrefix[nsUri];

            if (!alias) {
              // no prefix defined or prefix collision
              if (
                (newalias === 'xmlns') ||
                (nsUriPrefix in nsMatrix && nsMatrix[nsUriPrefix] !== nsUri)
              ) {
                // alocate free ns prefix
                do {
                  alias = 'ns' + (anonymousNsCount++);
                } while (typeof nsMatrix[alias] !== 'undefined');
              } else {
                alias = newalias;
              }

              nsUriToPrefix[nsUri] = alias;
            }

            if (nsMatrix[newalias] !== alias) {
              if (!hasNewMatrix) {
                nsMatrix = cloneNsMatrix(nsMatrix);
                hasNewMatrix = true;
              }

              nsMatrix[newalias] = alias;
              if (newalias === 'xmlns') {
                nsMatrix[uriPrefix(alias)] = nsUri;
                defaultAlias = alias;
              }

              nsMatrix[nsUriPrefix] = nsUri;
            }

            // expose xmlns(:asd)="..." in attributes
            attrs[name] = value;
            continue;
          }

          // collect attributes until all namespace
          // declarations are processed
          attrList.push(name, value);
          continue;

        } /** end if (maybeNs) */

        // handle attributes on element without
        // namespace declarations
        w = name.indexOf(':');
        if (w === -1) {
          attrs[name] = value;
          continue;
        }

        // normalize ns attribute name
        if (!(nsName = nsMatrix[name.substring(0, w)])) {
          handleWarning(missingNamespaceForPrefix(name.substring(0, w)));
          continue;
        }

        name = defaultAlias === nsName
          ? name.substr(w + 1)
          : nsName + name.substr(w);
        // end: normalize ns attribute name

        // normalize xsi:type ns attribute value
        if (name === XSI_TYPE) {
          w = value.indexOf(':');

          if (w !== -1) {
            nsName = value.substring(0, w);
            // handle default prefixes, i.e. xs:String gracefully
            nsName = nsMatrix[nsName] || nsName;
            value = nsName + value.substring(w);
          } else {
            value = defaultAlias + ':' + value;
          }
        }
        // end: normalize xsi:type ns attribute value

        attrs[name] = value;
      }


      // handle deferred, possibly namespaced attributes
      if (maybeNS) {

        // normalize captured attributes
        for (i = 0, l = attrList.length; i < l; i++) {

          name = attrList[i++];
          value = attrList[i];

          w = name.indexOf(':');

          if (w !== -1) {
            // normalize ns attribute name
            if (!(nsName = nsMatrix[name.substring(0, w)])) {
              handleWarning(missingNamespaceForPrefix(name.substring(0, w)));
              continue;
            }

            name = defaultAlias === nsName
              ? name.substr(w + 1)
              : nsName + name.substr(w);
            // end: normalize ns attribute name

            // normalize xsi:type ns attribute value
            if (name === XSI_TYPE) {
              w = value.indexOf(':');

              if (w !== -1) {
                nsName = value.substring(0, w);
                // handle default prefixes, i.e. xs:String gracefully
                nsName = nsMatrix[nsName] || nsName;
                value = nsName + value.substring(w);
              } else {
                value = defaultAlias + ':' + value;
              }
            }
            // end: normalize xsi:type ns attribute value
          }

          attrs[name] = value;
        }
        // end: normalize captured attributes
      }

      return cachedAttrs = attrs;
    }

    /**
     * Extract the parse context { line, column, part }
     * from the current parser position.
     *
     * @return {Object} parse context
     */
    function getParseContext() {
      var splitsRe = /(\r\n|\r|\n)/g;

      var line = 0;
      var column = 0;
      var startOfLine = 0;
      var endOfLine = j;
      var match;
      var data;

      while (i >= startOfLine) {

        match = splitsRe.exec(xml);

        if (!match) {
          break;
        }

        // end of line = (break idx + break chars)
        endOfLine = match[0].length + match.index;

        if (endOfLine > i) {
          break;
        }

        // advance to next line
        line += 1;

        startOfLine = endOfLine;
      }

      // EOF errors
      if (i == -1) {
        column = endOfLine;
        data = xml.substring(j);
      } else
      // start errors
      if (j === 0) {
        console.log(i - startOfLine);
        data = xml.substring(j, i);
      }
      // other errors
      else {
        column = i - startOfLine;
        data = (j == -1 ? xml.substring(i) : xml.substring(i, j + 1));
      }

      return {
        'data': data,
        'line': line,
        'column': column
      };
    }

    getContext = getParseContext;


    if (proxy) {
      elementProxy = Object.create({}, {
        'name': getter(function() {
          return elementName;
        }),
        'originalName': getter(function() {
          return _elementName;
        }),
        'attrs': getter(getAttrs),
        'ns': getter(function() {
          return nsMatrix;
        })
      });
    }

    // actual parse logic
    while (j !== -1) {

      if (xml.charCodeAt(j) === 60) { // "<"
        i = j;
      } else {
        i = xml.indexOf('<', j);
      }

      // parse end
      if (i === -1) {
        if (nodeStack.length) {
          return handleError('unexpected end of file');
        }

        if (j === 0) {
          return handleError('missing start tag');
        }

        if (j < xml.length) {
          if (xml.substring(j).trim()) {
            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);
          }
        }

        return;
      }

      // parse text
      if (j !== i) {

        if (nodeStack.length) {
          if (onText) {
            onText(xml.substring(j, i), decodeEntities, getContext);

            if (parseStop) {
              return;
            }
          }
        } else {
          if (xml.substring(j, i).trim()) {
            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);

            if (parseStop) {
              return;
            }
          }
        }
      }

      w = xml.charCodeAt(i+1);

      // parse comments + CDATA
      if (w === 33) { // "!"
        w = xml.charCodeAt(i+2);
        if (w === 91 && xml.substr(i + 3, 6) === 'CDATA[') { // 91 == "["
          j = xml.indexOf(']]>', i);
          if (j === -1) {
            return handleError('unclosed cdata');
          }

          if (onCDATA) {
            onCDATA(xml.substring(i + 9, j), getContext);
            if (parseStop) {
              return;
            }
          }

          j += 3;
          continue;
        }


        if (w === 45 && xml.charCodeAt(i + 3) === 45) { // 45 == "-"
          j = xml.indexOf('-->', i);
          if (j === -1) {
            return handleError('unclosed comment');
          }


          if (onComment) {
            onComment(xml.substring(i + 4, j), decodeEntities, getContext);
            if (parseStop) {
              return;
            }
          }

          j += 3;
          continue;
        }

        j = xml.indexOf('>', i + 1);
        if (j === -1) {
          return handleError('unclosed tag');
        }

        if (onAttention) {
          onAttention(xml.substring(i, j + 1), decodeEntities, getContext);
          if (parseStop) {
            return;
          }
        }

        j += 1;
        continue;
      }

      if (w === 63) { // "?"
        j = xml.indexOf('?>', i);
        if (j === -1) {
          return handleError('unclosed question');
        }

        if (onQuestion) {
          onQuestion(xml.substring(i, j + 2), getContext);
          if (parseStop) {
            return;
          }
        }

        j += 2;
        continue;
      }

      j = xml.indexOf('>', i + 1);

      if (j == -1) {
        return handleError('unclosed tag');
      }

      // don't process attributes;
      // there are none
      cachedAttrs = {};

      // if (xml.charCodeAt(i+1) === 47) { // </...
      if (w === 47) { // </...
        tagStart = false;
        tagEnd = true;

        if (!nodeStack.length) {
          return handleError('missing open tag');
        }

        // verify open <-> close tag match
        x = elementName = nodeStack.pop();
        q = i + 2 + x.length;

        if (xml.substring(i + 2, q) !== x) {
          return handleError('closing tag mismatch');
        }

        // verify chars in close tag
        for (; q < j; q++) {
          w = xml.charCodeAt(q);

          if (w === 32 || (w > 8 && w < 14)) { // \f\n\r\t\v space
            continue;
          }

          return handleError('close tag');
        }

      } else {
        if (xml.charCodeAt(j - 1) === 47) { // .../>
          x = elementName = xml.substring(i + 1, j - 1);

          tagStart = true;
          tagEnd = true;

        } else {
          x = elementName = xml.substring(i + 1, j);

          tagStart = true;
          tagEnd = false;
        }

        if (!(w > 96 && w < 123 || w > 64 && w < 91 || w === 95 || w === 58)) { // char 95"_" 58":"
          return handleError('illegal first char nodeName');
        }

        for (q = 1, y = x.length; q < y; q++) {
          w = x.charCodeAt(q);

          if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 45 || w === 95 || w == 46) {
            continue;
          }

          if (w === 32 || (w < 14 && w > 8)) { // \f\n\r\t\v space
            elementName = x.substring(0, q);
            // maybe there are attributes
            cachedAttrs = null;
            break;
          }

          return handleError('invalid nodeName');
        }

        if (!tagEnd) {
          nodeStack.push(elementName);
        }
      }

      if (isNamespace) {

        _nsMatrix = nsMatrix;

        if (tagStart) {
          // remember old namespace
          // unless we're self-closing
          if (!tagEnd) {
            nsMatrixStack.push(_nsMatrix);
          }

          if (cachedAttrs === null) {
            // quick check, whether there may be namespace
            // declarations on the node; if that is the case
            // we need to eagerly parse the node attributes
            if ((maybeNS = x.indexOf('xmlns', q) !== -1)) {
              attrsStart = q;
              attrsString = x;

              getAttrs();

              maybeNS = false;
            }
          }
        }

        _elementName = elementName;

        w = elementName.indexOf(':');
        if (w !== -1) {
          xmlns = nsMatrix[elementName.substring(0, w)];

          // prefix given; namespace must exist
          if (!xmlns) {
            return handleError('missing namespace on <' + _elementName + '>');
          }

          elementName = elementName.substr(w + 1);
        } else {
          xmlns = nsMatrix['xmlns'];

          // if no default namespace is defined,
          // we'll import the element as anonymous.
          //
          // it is up to users to correct that to the document defined
          // targetNamespace, or whatever their undersanding of the
          // XML spec mandates.
        }

        // adjust namespace prefixs as configured
        if (xmlns) {
          elementName = xmlns + ':' + elementName;
        }

      }

      if (tagStart) {
        attrsStart = q;
        attrsString = x;

        if (onOpenTag) {
          if (proxy) {
            onOpenTag(elementProxy, decodeEntities, tagEnd, getContext);
          } else {
            onOpenTag(elementName, getAttrs, decodeEntities, tagEnd, getContext);
          }

          if (parseStop) {
            return;
          }
        }

      }

      if (tagEnd) {

        if (onCloseTag) {
          onCloseTag(proxy ? elementProxy : elementName, decodeEntities, tagStart, getContext);

          if (parseStop) {
            return;
          }
        }

        // restore old namespace
        if (isNamespace) {
          if (!tagStart) {
            nsMatrix = nsMatrixStack.pop();
          } else {
            nsMatrix = _nsMatrix;
          }
        }
      }

      j += 1;
    }
  } /** end parse */

}




/***/ }),

/***/ "./node_modules/tiny-svg/dist/index.esm.js":
/*!*************************************************!*\
  !*** ./node_modules/tiny-svg/dist/index.esm.js ***!
  \*************************************************/
/*! exports provided: append, appendTo, attr, classes, clear, clone, create, innerSVG, prepend, prependTo, remove, replace, transform, on, off, createPoint, createMatrix, createTransform, select, selectAll */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "append", function() { return append; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "appendTo", function() { return appendTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "attr", function() { return attr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "classes", function() { return classes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "innerSVG", function() { return innerSVG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prepend", function() { return prepend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prependTo", function() { return prependTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "remove", function() { return remove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "replace", function() { return replace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transform", function() { return transform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "on", function() { return on; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "off", function() { return off; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createPoint", function() { return createPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createMatrix", function() { return createMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createTransform", function() { return createTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "select", function() { return select; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selectAll", function() { return selectAll; });
function ensureImported(element, target) {

  if (element.ownerDocument !== target.ownerDocument) {
    try {
      // may fail on webkit
      return target.ownerDocument.importNode(element, true);
    } catch (e) {
      // ignore
    }
  }

  return element;
}

/**
 * appendTo utility
 */

/**
 * Append a node to a target element and return the appended node.
 *
 * @param  {SVGElement} element
 * @param  {SVGElement} target
 *
 * @return {SVGElement} the appended node
 */
function appendTo(element, target) {
  return target.appendChild(ensureImported(element, target));
}

/**
 * append utility
 */

/**
 * Append a node to an element
 *
 * @param  {SVGElement} element
 * @param  {SVGElement} node
 *
 * @return {SVGElement} the element
 */
function append(target, node) {
  appendTo(node, target);
  return target;
}

/**
 * attribute accessor utility
 */

var LENGTH_ATTR = 2;

var CSS_PROPERTIES = {
  'alignment-baseline': 1,
  'baseline-shift': 1,
  'clip': 1,
  'clip-path': 1,
  'clip-rule': 1,
  'color': 1,
  'color-interpolation': 1,
  'color-interpolation-filters': 1,
  'color-profile': 1,
  'color-rendering': 1,
  'cursor': 1,
  'direction': 1,
  'display': 1,
  'dominant-baseline': 1,
  'enable-background': 1,
  'fill': 1,
  'fill-opacity': 1,
  'fill-rule': 1,
  'filter': 1,
  'flood-color': 1,
  'flood-opacity': 1,
  'font': 1,
  'font-family': 1,
  'font-size': LENGTH_ATTR,
  'font-size-adjust': 1,
  'font-stretch': 1,
  'font-style': 1,
  'font-variant': 1,
  'font-weight': 1,
  'glyph-orientation-horizontal': 1,
  'glyph-orientation-vertical': 1,
  'image-rendering': 1,
  'kerning': 1,
  'letter-spacing': 1,
  'lighting-color': 1,
  'marker': 1,
  'marker-end': 1,
  'marker-mid': 1,
  'marker-start': 1,
  'mask': 1,
  'opacity': 1,
  'overflow': 1,
  'pointer-events': 1,
  'shape-rendering': 1,
  'stop-color': 1,
  'stop-opacity': 1,
  'stroke': 1,
  'stroke-dasharray': 1,
  'stroke-dashoffset': 1,
  'stroke-linecap': 1,
  'stroke-linejoin': 1,
  'stroke-miterlimit': 1,
  'stroke-opacity': 1,
  'stroke-width': LENGTH_ATTR,
  'text-anchor': 1,
  'text-decoration': 1,
  'text-rendering': 1,
  'unicode-bidi': 1,
  'visibility': 1,
  'word-spacing': 1,
  'writing-mode': 1
};


function getAttribute(node, name) {
  if (CSS_PROPERTIES[name]) {
    return node.style[name];
  } else {
    return node.getAttributeNS(null, name);
  }
}

function setAttribute(node, name, value) {
  var hyphenated = name.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();

  var type = CSS_PROPERTIES[hyphenated];

  if (type) {
    // append pixel unit, unless present
    if (type === LENGTH_ATTR && typeof value === 'number') {
      value = String(value) + 'px';
    }

    node.style[hyphenated] = value;
  } else {
    node.setAttributeNS(null, name, value);
  }
}

function setAttributes(node, attrs) {

  var names = Object.keys(attrs), i, name;

  for (i = 0, name; (name = names[i]); i++) {
    setAttribute(node, name, attrs[name]);
  }
}

/**
 * Gets or sets raw attributes on a node.
 *
 * @param  {SVGElement} node
 * @param  {Object} [attrs]
 * @param  {String} [name]
 * @param  {String} [value]
 *
 * @return {String}
 */
function attr(node, name, value) {
  if (typeof name === 'string') {
    if (value !== undefined) {
      setAttribute(node, name, value);
    } else {
      return getAttribute(node, name);
    }
  } else {
    setAttributes(node, name);
  }

  return node;
}

/**
 * Clear utility
 */
function index(arr, obj) {
  if (arr.indexOf) {
    return arr.indexOf(obj);
  }


  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) {
      return i;
    }
  }

  return -1;
}

var re = /\s+/;

var toString = Object.prototype.toString;

function defined(o) {
  return typeof o !== 'undefined';
}

/**
 * Wrap `el` in a `ClassList`.
 *
 * @param {Element} el
 * @return {ClassList}
 * @api public
 */

function classes(el) {
  return new ClassList(el);
}

function ClassList(el) {
  if (!el || !el.nodeType) {
    throw new Error('A DOM element reference is required');
  }
  this.el = el;
  this.list = el.classList;
}

/**
 * Add class `name` if not already present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.add = function(name) {

  // classList
  if (this.list) {
    this.list.add(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = index(arr, name);
  if (!~i) {
    arr.push(name);
  }

  if (defined(this.el.className.baseVal)) {
    this.el.className.baseVal = arr.join(' ');
  } else {
    this.el.className = arr.join(' ');
  }

  return this;
};

/**
 * Remove class `name` when present, or
 * pass a regular expression to remove
 * any which match.
 *
 * @param {String|RegExp} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.remove = function(name) {
  if ('[object RegExp]' === toString.call(name)) {
    return this.removeMatching(name);
  }

  // classList
  if (this.list) {
    this.list.remove(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = index(arr, name);
  if (~i) {
    arr.splice(i, 1);
  }
  this.el.className.baseVal = arr.join(' ');
  return this;
};

/**
 * Remove all classes matching `re`.
 *
 * @param {RegExp} re
 * @return {ClassList}
 * @api private
 */

ClassList.prototype.removeMatching = function(re) {
  var arr = this.array();
  for (var i = 0; i < arr.length; i++) {
    if (re.test(arr[i])) {
      this.remove(arr[i]);
    }
  }
  return this;
};

/**
 * Toggle class `name`, can force state via `force`.
 *
 * For browsers that support classList, but do not support `force` yet,
 * the mistake will be detected and corrected.
 *
 * @param {String} name
 * @param {Boolean} force
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.toggle = function(name, force) {
  // classList
  if (this.list) {
    if (defined(force)) {
      if (force !== this.list.toggle(name, force)) {
        this.list.toggle(name); // toggle again to correct
      }
    } else {
      this.list.toggle(name);
    }
    return this;
  }

  // fallback
  if (defined(force)) {
    if (!force) {
      this.remove(name);
    } else {
      this.add(name);
    }
  } else {
    if (this.has(name)) {
      this.remove(name);
    } else {
      this.add(name);
    }
  }

  return this;
};

/**
 * Return an array of classes.
 *
 * @return {Array}
 * @api public
 */

ClassList.prototype.array = function() {
  var className = this.el.getAttribute('class') || '';
  var str = className.replace(/^\s+|\s+$/g, '');
  var arr = str.split(re);
  if ('' === arr[0]) {
    arr.shift();
  }
  return arr;
};

/**
 * Check if class `name` is present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.has =
ClassList.prototype.contains = function(name) {
  return (
    this.list ?
      this.list.contains(name) :
      !! ~index(this.array(), name)
  );
};

function remove(element) {
  var parent = element.parentNode;

  if (parent) {
    parent.removeChild(element);
  }

  return element;
}

/**
 * Clear utility
 */

/**
 * Removes all children from the given element
 *
 * @param  {DOMElement} element
 * @return {DOMElement} the element (for chaining)
 */
function clear(element) {
  var child;

  while ((child = element.firstChild)) {
    remove(child);
  }

  return element;
}

function clone(element) {
  return element.cloneNode(true);
}

var ns = {
  svg: 'http://www.w3.org/2000/svg'
};

/**
 * DOM parsing utility
 */

var SVG_START = '<svg xmlns="' + ns.svg + '"';

function parse(svg) {

  var unwrap = false;

  // ensure we import a valid svg document
  if (svg.substring(0, 4) === '<svg') {
    if (svg.indexOf(ns.svg) === -1) {
      svg = SVG_START + svg.substring(4);
    }
  } else {
    // namespace svg
    svg = SVG_START + '>' + svg + '</svg>';
    unwrap = true;
  }

  var parsed = parseDocument(svg);

  if (!unwrap) {
    return parsed;
  }

  var fragment = document.createDocumentFragment();

  var parent = parsed.firstChild;

  while (parent.firstChild) {
    fragment.appendChild(parent.firstChild);
  }

  return fragment;
}

function parseDocument(svg) {

  var parser;

  // parse
  parser = new DOMParser();
  parser.async = false;

  return parser.parseFromString(svg, 'text/xml');
}

/**
 * Create utility for SVG elements
 */


/**
 * Create a specific type from name or SVG markup.
 *
 * @param {String} name the name or markup of the element
 * @param {Object} [attrs] attributes to set on the element
 *
 * @returns {SVGElement}
 */
function create(name, attrs) {
  var element;

  if (name.charAt(0) === '<') {
    element = parse(name).firstChild;
    element = document.importNode(element, true);
  } else {
    element = document.createElementNS(ns.svg, name);
  }

  if (attrs) {
    attr(element, attrs);
  }

  return element;
}

/**
 * Events handling utility
 */

function on(node, event, listener, useCapture) {
  node.addEventListener(event, listener, useCapture);
}

function off(node, event, listener, useCapture) {
  node.removeEventListener(event, listener, useCapture);
}

/**
 * Geometry helpers
 */

// fake node used to instantiate svg geometry elements
var node = create('svg');

function extend(object, props) {
  var i, k, keys = Object.keys(props);

  for (i = 0; (k = keys[i]); i++) {
    object[k] = props[k];
  }

  return object;
}


function createPoint(x, y) {
  var point = node.createSVGPoint();

  switch (arguments.length) {
  case 0:
    return point;
  case 2:
    x = {
      x: x,
      y: y
    };
    break;
  }

  return extend(point, x);
}

/**
 * Create matrix via args.
 *
 * @example
 *
 * createMatrix({ a: 1, b: 1 });
 * createMatrix();
 * createMatrix(1, 2, 0, 0, 30, 20);
 *
 * @return {SVGMatrix}
 */
function createMatrix(a, b, c, d, e, f) {
  var matrix = node.createSVGMatrix();

  switch (arguments.length) {
  case 0:
    return matrix;
  case 1:
    return extend(matrix, a);
  case 6:
    return extend(matrix, {
      a: a,
      b: b,
      c: c,
      d: d,
      e: e,
      f: f
    });
  }
}

function createTransform(matrix) {
  if (matrix) {
    return node.createSVGTransformFromMatrix(matrix);
  } else {
    return node.createSVGTransform();
  }
}

/**
 * Serialization util
 */

var TEXT_ENTITIES = /([&<>]{1})/g;
var ATTR_ENTITIES = /([\n\r"]{1})/g;

var ENTITY_REPLACEMENT = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '\''
};

function escape(str, pattern) {

  function replaceFn(match, entity) {
    return ENTITY_REPLACEMENT[entity] || entity;
  }

  return str.replace(pattern, replaceFn);
}

function serialize(node, output) {

  var i, len, attrMap, attrNode, childNodes;

  switch (node.nodeType) {
  // TEXT
  case 3:
    // replace special XML characters
    output.push(escape(node.textContent, TEXT_ENTITIES));
    break;

  // ELEMENT
  case 1:
    output.push('<', node.tagName);

    if (node.hasAttributes()) {
      attrMap = node.attributes;
      for (i = 0, len = attrMap.length; i < len; ++i) {
        attrNode = attrMap.item(i);
        output.push(' ', attrNode.name, '="', escape(attrNode.value, ATTR_ENTITIES), '"');
      }
    }

    if (node.hasChildNodes()) {
      output.push('>');
      childNodes = node.childNodes;
      for (i = 0, len = childNodes.length; i < len; ++i) {
        serialize(childNodes.item(i), output);
      }
      output.push('</', node.tagName, '>');
    } else {
      output.push('/>');
    }
    break;

  // COMMENT
  case 8:
    output.push('<!--', escape(node.nodeValue, TEXT_ENTITIES), '-->');
    break;

  // CDATA
  case 4:
    output.push('<![CDATA[', node.nodeValue, ']]>');
    break;

  default:
    throw new Error('unable to handle node ' + node.nodeType);
  }

  return output;
}

/**
 * innerHTML like functionality for SVG elements.
 * based on innerSVG (https://code.google.com/p/innersvg)
 */


function set(element, svg) {

  var parsed = parse(svg);

  // clear element contents
  clear(element);

  if (!svg) {
    return;
  }

  if (!isFragment(parsed)) {
    // extract <svg> from parsed document
    parsed = parsed.documentElement;
  }

  var nodes = slice(parsed.childNodes);

  // import + append each node
  for (var i = 0; i < nodes.length; i++) {
    appendTo(nodes[i], element);
  }

}

function get(element) {
  var child = element.firstChild,
      output = [];

  while (child) {
    serialize(child, output);
    child = child.nextSibling;
  }

  return output.join('');
}

function isFragment(node) {
  return node.nodeName === '#document-fragment';
}

function innerSVG(element, svg) {

  if (svg !== undefined) {

    try {
      set(element, svg);
    } catch (e) {
      throw new Error('error parsing SVG: ' + e.message);
    }

    return element;
  } else {
    return get(element);
  }
}


function slice(arr) {
  return Array.prototype.slice.call(arr);
}

/**
 * Selection utilities
 */

function select(node, selector) {
  return node.querySelector(selector);
}

function selectAll(node, selector) {
  var nodes = node.querySelectorAll(selector);

  return [].map.call(nodes, function(element) {
    return element;
  });
}

/**
 * prependTo utility
 */

/**
 * Prepend a node to a target element and return the prepended node.
 *
 * @param  {SVGElement} node
 * @param  {SVGElement} target
 *
 * @return {SVGElement} the prepended node
 */
function prependTo(node, target) {
  return target.insertBefore(ensureImported(node, target), target.firstChild || null);
}

/**
 * prepend utility
 */

/**
 * Prepend a node to a target element
 *
 * @param  {SVGElement} target
 * @param  {SVGElement} node
 *
 * @return {SVGElement} the target element
 */
function prepend(target, node) {
  prependTo(node, target);
  return target;
}

/**
 * Replace utility
 */

function replace(element, replacement) {
  element.parentNode.replaceChild(ensureImported(replacement, element), element);
  return replacement;
}

/**
 * transform accessor utility
 */

function wrapMatrix(transformList, transform) {
  if (transform instanceof SVGMatrix) {
    return transformList.createSVGTransformFromMatrix(transform);
  }

  return transform;
}


function setTransforms(transformList, transforms) {
  var i, t;

  transformList.clear();

  for (i = 0; (t = transforms[i]); i++) {
    transformList.appendItem(wrapMatrix(transformList, t));
  }
}

/**
 * Get or set the transforms on the given node.
 *
 * @param {SVGElement} node
 * @param  {SVGTransform|SVGMatrix|Array<SVGTransform|SVGMatrix>} [transforms]
 *
 * @return {SVGTransform} the consolidated transform
 */
function transform(node, transforms) {
  var transformList = node.transform.baseVal;

  if (transforms) {

    if (!Array.isArray(transforms)) {
      transforms = [ transforms ];
    }

    setTransforms(transformList, transforms);
  }

  return transformList.consolidate();
}




/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var bpmn_moddle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bpmn-moddle */ "./node_modules/bpmn-moddle/dist/index.esm.js");
/* harmony import */ var bpmn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bpmn-js */ "./node_modules/bpmn-js/index.js");
/* harmony import */ var _xml__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./xml */ "./src/xml.js");




var viewer = new bpmn_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
  container: document.getElementById("bpmn"),
});

document.upload = async function (evt) {
  console.log(evt, document.getElementById("bpmn-file"));
  const bpmn = await document.getElementById("bpmn-file").files[0].text();
  loadViewer(bpmn);
};

// function addOverlays() {

// }

function loadViewer(bpmnXml) {
  viewer.importXML(bpmnXml, async function (err, definitions) {
    // Traverse the Process
    console.log(err, definitions);

    var elements = viewer._definitions.rootElements[0].flowElements;
    const startEvent = elements.find((el) => {
      return el.$type === "bpmn:StartEvent";
    });

    const idToElementMap = {};
    elements.forEach((element) => {
      idToElementMap[element.id] = element;
    });

    const readyElements = [];
    let current;
    readyElements.push(...startEvent.outgoing);

    const processVariables = {};

    while ((current = readyElements.shift())) {
      current = current.targetRef;
      console.log(current);
      if (current.$type === "bpmn:ScriptTask") {
        var result = async function (str) {
          await eval(current.script);
        }.call(processVariables);
        await result;
      }

      if (current.$type === "bpmn:ParallelGateway") {
        current.waitingTokens = current.waitingTokens
          ? current.waitingTokens + 1
          : 1;

        if (current.incoming.length > current.waitingTokens) {
          continue;
        }
        current.waitingTokens -= current.incoming.length;
      }

      if (current.$type === "bpmn:ExclusiveGateway") {
        let defaultPath;
        var possibleGateways = current.outgoing.filter((val) => {
          if (
            !val.conditionExpression ||
            (val.conditionExpression && !val.conditionExpression.body)
          ) {
            // Probably default path
            defaultPath = val;
            return false;
          }
          return function () {
            return eval(val.conditionExpression.body);
          }.call(processVariables);
        });

        if (!possibleGateways.length && !defaultPath) {
          console.error("No possible Path found at element " + current);
          continue;
        }
        readyElements.push(possibleGateways[0] || defaultPath);
        continue;
      }

      // Default behaviour

      if (current.outgoing && current.outgoing[0].targetRef) {
        readyElements.push(...current.outgoing);
      }
    }
  });
}


/***/ }),

/***/ "./src/xml.js":
/*!********************!*\
  !*** ./src/xml.js ***!
  \********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (`<?xml version="1.0" encoding="UTF-8"?>
<bpmn:definitions xmlns:bpmn="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:dc="http://www.omg.org/spec/DD/20100524/DC" xmlns:di="http://www.omg.org/spec/DD/20100524/DI" id="Definitions_1hp6wik" targetNamespace="http://bpmn.io/schema/bpmn" exporter="Camunda Modeler" exporterVersion="3.5.0">
  <bpmn:process id="Process_09qh5h4" isExecutable="true">
    <bpmn:startEvent id="StartEvent_1">
      <bpmn:outgoing>SequenceFlow_08uoep0</bpmn:outgoing>
    </bpmn:startEvent>
    <bpmn:sequenceFlow id="SequenceFlow_08uoep0" sourceRef="StartEvent_1" targetRef="Task_18yhr5r" />
    <bpmn:scriptTask id="Task_18yhr5r" scriptFormat="javascript">
      <bpmn:incoming>SequenceFlow_08uoep0</bpmn:incoming>
      <bpmn:outgoing>SequenceFlow_0r49ag5</bpmn:outgoing>
      <bpmn:script>var x = 42;
console.log('foo', x);

window.fooBar = 'baz';</bpmn:script>
    </bpmn:scriptTask>
    <bpmn:endEvent id="EndEvent_0oyp4ec">
      <bpmn:incoming>SequenceFlow_0r49ag5</bpmn:incoming>
    </bpmn:endEvent>
    <bpmn:sequenceFlow id="SequenceFlow_0r49ag5" sourceRef="Task_18yhr5r" targetRef="EndEvent_0oyp4ec" />
  </bpmn:process>
  <bpmndi:BPMNDiagram id="BPMNDiagram_1">
    <bpmndi:BPMNPlane id="BPMNPlane_1" bpmnElement="Process_09qh5h4">
      <bpmndi:BPMNShape id="_BPMNShape_StartEvent_2" bpmnElement="StartEvent_1">
        <dc:Bounds x="179" y="99" width="36" height="36" />
      </bpmndi:BPMNShape>
      <bpmndi:BPMNEdge id="SequenceFlow_08uoep0_di" bpmnElement="SequenceFlow_08uoep0">
        <di:waypoint x="215" y="117" />
        <di:waypoint x="270" y="117" />
      </bpmndi:BPMNEdge>
      <bpmndi:BPMNShape id="ScriptTask_0tvoxxr_di" bpmnElement="Task_18yhr5r">
        <dc:Bounds x="270" y="77" width="100" height="80" />
      </bpmndi:BPMNShape>
      <bpmndi:BPMNShape id="EndEvent_0oyp4ec_di" bpmnElement="EndEvent_0oyp4ec">
        <dc:Bounds x="432" y="99" width="36" height="36" />
      </bpmndi:BPMNShape>
      <bpmndi:BPMNEdge id="SequenceFlow_0r49ag5_di" bpmnElement="SequenceFlow_0r49ag5">
        <di:waypoint x="370" y="117" />
        <di:waypoint x="432" y="117" />
      </bpmndi:BPMNEdge>
    </bpmndi:BPMNPlane>
  </bpmndi:BPMNDiagram>
</bpmn:definitions>

`);

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JwbW4tanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JwbW4tanMvbGliL0Jhc2VWaWV3ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JwbW4tanMvbGliL1ZpZXdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnBtbi1qcy9saWIvY29yZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnBtbi1qcy9saWIvZHJhdy9CcG1uUmVuZGVyVXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnBtbi1qcy9saWIvZHJhdy9CcG1uUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JwbW4tanMvbGliL2RyYXcvUGF0aE1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnBtbi1qcy9saWIvZHJhdy9UZXh0UmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JwbW4tanMvbGliL2RyYXcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JwbW4tanMvbGliL2ZlYXR1cmVzL2xhYmVsLWVkaXRpbmcvTGFiZWxVdGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icG1uLWpzL2xpYi9pbXBvcnQvQnBtbkltcG9ydGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icG1uLWpzL2xpYi9pbXBvcnQvQnBtblRyZWVXYWxrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JwbW4tanMvbGliL2ltcG9ydC9JbXBvcnRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnBtbi1qcy9saWIvaW1wb3J0L1V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JwbW4tanMvbGliL2ltcG9ydC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnBtbi1qcy9saWIvdXRpbC9EaVV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JwbW4tanMvbGliL3V0aWwvTGFiZWxVdGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icG1uLWpzL2xpYi91dGlsL01vZGVsVXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnBtbi1qcy9saWIvdXRpbC9Qb3dlcmVkQnlVdGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icG1uLWpzL25vZGVfbW9kdWxlcy9icG1uLW1vZGRsZS9kaXN0L2luZGV4LmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnBtbi1qcy9ub2RlX21vZHVsZXMvbW9kZGxlLXhtbC9kaXN0L2luZGV4LmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnBtbi1qcy9ub2RlX21vZHVsZXMvc2F4ZW4vZGlzdC9pbmRleC5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JwbW4tbW9kZGxlL2Rpc3QvaW5kZXguZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9EaWFncmFtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9jb3JlL0NhbnZhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvY29yZS9FbGVtZW50RmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvY29yZS9FbGVtZW50UmVnaXN0cnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2NvcmUvRXZlbnRCdXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2NvcmUvR3JhcGhpY3NGYWN0b3J5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9jb3JlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9kcmF3L0Jhc2VSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZHJhdy9EZWZhdWx0UmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2RyYXcvU3R5bGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9kcmF3L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9pbnRlcmFjdGlvbi1ldmVudHMvSW50ZXJhY3Rpb25FdmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2ludGVyYWN0aW9uLWV2ZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvb3V0bGluZS9PdXRsaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9vdXRsaW5lL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9vdmVybGF5cy9PdmVybGF5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvb3ZlcmxheXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3NlbGVjdGlvbi9TZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3NlbGVjdGlvbi9TZWxlY3Rpb25CZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvc2VsZWN0aW9uL1NlbGVjdGlvblZpc3VhbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3NlbGVjdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvaTE4bi90cmFuc2xhdGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2kxOG4vdHJhbnNsYXRlL3RyYW5zbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvbGF5b3V0L0xheW91dFV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL21vZGVsL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi91dGlsL0NvbGxlY3Rpb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi91dGlsL0VsZW1lbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi91dGlsL0V2ZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi91dGlsL0dlb21ldHJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi91dGlsL0dyYXBoaWNzVXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvdXRpbC9JZEdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvdXRpbC9Nb3VzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvdXRpbC9QbGF0Zm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvdXRpbC9SZW5kZXJVdGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi91dGlsL1N2Z1RyYW5zZm9ybVV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL3V0aWwvVGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlkaS9kaXN0L2luZGV4LmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaWRzL2Rpc3QvaW5kZXguZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9taW4tZGFzaC9kaXN0L2luZGV4LmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWluLWRvbS9kaXN0L2luZGV4LmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9kZGxlLXhtbC9kaXN0L2luZGV4LmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9kZGxlL2Rpc3QvaW5kZXguZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYmplY3QtcmVmcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2JqZWN0LXJlZnMvbGliL2NvbGxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29iamVjdC1yZWZzL2xpYi9yZWZzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYXRoLWludGVyc2VjdGlvbi9pbnRlcnNlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NheGVuL2Rpc3QvaW5kZXguZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aW55LXN2Zy9kaXN0L2luZGV4LmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3htbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQUE7QUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7O0FDQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9rQjs7QUFNRDs7QUFJQzs7QUFFZTtBQUNJOztBQUVMOztBQUlMOzs7QUFHM0I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGFBQWEsR0FBRyxzQkFBc0IsS0FBSyxjQUFjO0FBQzVFO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxXQUFXO0FBQ3RC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Q0EsS0FBSztBQUNMO0FBQ0EsYUFBYSxHQUFHLEVBQUUsR0FBRztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWEsR0FBRyxFQUFFLEdBQUc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWEsR0FBRyxFQUFFLEdBQUcsTUFBTSxLQUFLLElBQUksS0FBSyxTQUFTLEtBQUssTUFBTSxLQUFLLEVBQUUsS0FBSyxJQUFJLEtBQUssR0FBRyxLQUFLO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsYUFBYSxHQUFHLEVBQUUsR0FBRztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhLEdBQUcsRUFBRSxHQUFHO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsYUFBYSxHQUFHLEVBQUUsR0FBRztBQUNyQjtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWEsR0FBRyxFQUFFLEdBQUc7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWEsR0FBRyxFQUFFLEdBQUc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWEsR0FBRyxFQUFFLEdBQUc7QUFDckIsS0FBSztBQUNMO0FBQ0EsYUFBYSxHQUFHLEVBQUUsR0FBRztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsYUFBYSxHQUFHLEVBQUUsR0FBRztBQUNyQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsYUFBYSxHQUFHLEVBQUUsR0FBRztBQUNyQixLQUFLO0FBQ0w7QUFDQSxhQUFhLEdBQUcs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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksdURBQU0sR0FBRzs7QUFFckI7QUFDQTs7QUFFZSxxRUFBTSxFQUFDOzs7Ozs7Ozs7Ozs7O0FDamxIdEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXdFO0FBQ3pDO0FBQ3dDOztBQUV2RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBLGVBQWUsMERBQVc7QUFDMUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7O0FBRUE7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4Qjs7QUFFQSxFQUFFLHVEQUFNOztBQUVSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSx5REFBVTs7QUFFcEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVkseURBQVU7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7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cUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixFQUFFO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLFNBQVMscUJBQXFCO0FBQzlCO0FBQ0E7QUFDQSxTQUFTLHFCQUFxQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDO0FBQzFDLHFCQUFxQjtBQUNyQjtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksdURBQU0sR0FBRzs7QUFFckI7QUFDQTs7QUFFZSxxRUFBTSxFQUFDOzs7Ozs7Ozs7Ozs7O0FDamxIdEI7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUFBO0FBQUE7QUFBQTtBQUFnQzs7QUFFQTs7O0FBR2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFD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UztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRyxJQUFJOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxPQUFPLElBQUk7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FB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O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxTQUFTLHFEQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLE9BQU87O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFNEM7Ozs7Ozs7Ozs7Ozs7QUNsaEM1QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksV0FBVztBQUN2QjtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksV0FBVztBQUN2QjtBQUNB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QUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDIiwiZmlsZSI6Im1haW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9pbmRleC5qc1wiKTtcbiIsImV4cG9ydCB7XG4gIGRlZmF1bHRcbn0gZnJvbSAnLi9saWIvVmlld2VyJzsiLCIvKipcbiAqIFRoZSBjb2RlIGluIHRoZSA8cHJvamVjdC1sb2dvPjwvcHJvamVjdC1sb2dvPiBhcmVhXG4gKiBtdXN0IG5vdCBiZSBjaGFuZ2VkLlxuICpcbiAqIEBzZWUgaHR0cDovL2JwbW4uaW8vbGljZW5zZSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqL1xuaW1wb3J0IHtcbiAgYXNzaWduLFxuICBmaW5kLFxuICBpc0Z1bmN0aW9uLFxuICBpc051bWJlcixcbiAgb21pdFxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGRvbWlmeSxcbiAgcXVlcnkgYXMgZG9tUXVlcnksXG4gIHJlbW92ZSBhcyBkb21SZW1vdmVcbn0gZnJvbSAnbWluLWRvbSc7XG5cbmltcG9ydCB7XG4gIGlubmVyU1ZHXG59IGZyb20gJ3Rpbnktc3ZnJztcblxuaW1wb3J0IERpYWdyYW0gZnJvbSAnZGlhZ3JhbS1qcyc7XG5pbXBvcnQgQnBtbk1vZGRsZSBmcm9tICdicG1uLW1vZGRsZSc7XG5cbmltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5cbmltcG9ydCB7XG4gIGltcG9ydEJwbW5EaWFncmFtXG59IGZyb20gJy4vaW1wb3J0L0ltcG9ydGVyJztcblxuXG4vKipcbiAqIEEgYmFzZSB2aWV3ZXIgZm9yIEJQTU4gMi4wIGRpYWdyYW1zLlxuICpcbiAqIEhhdmUgYSBsb29rIGF0IHtAbGluayBWaWV3ZXJ9LCB7QGxpbmsgTmF2aWdhdGVkVmlld2VyfSBvciB7QGxpbmsgTW9kZWxlcn0gZm9yXG4gKiBidW5kbGVzIHRoYXQgaW5jbHVkZSBhY3R1YWwgZmVhdHVyZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgdmlld2VyXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IFtvcHRpb25zLmNvbnRhaW5lcl0gdGhlIGNvbnRhaW5lciB0byByZW5kZXIgdGhlIHZpZXdlciBpbiwgZGVmYXVsdHMgdG8gYm9keS5cbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gW29wdGlvbnMud2lkdGhdIHRoZSB3aWR0aCBvZiB0aGUgdmlld2VyXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gdGhlIGhlaWdodCBvZiB0aGUgdmlld2VyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubW9kZGxlRXh0ZW5zaW9uc10gZXh0ZW5zaW9uIHBhY2thZ2VzIHRvIHByb3ZpZGVcbiAqIEBwYXJhbSB7QXJyYXk8ZGlkaS5Nb2R1bGU+fSBbb3B0aW9ucy5tb2R1bGVzXSBhIGxpc3Qgb2YgbW9kdWxlcyB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBtb2R1bGVzXG4gKiBAcGFyYW0ge0FycmF5PGRpZGkuTW9kdWxlPn0gW29wdGlvbnMuYWRkaXRpb25hbE1vZHVsZXNdIGEgbGlzdCBvZiBtb2R1bGVzIHRvIHVzZSB3aXRoIHRoZSBkZWZhdWx0IG1vZHVsZXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQmFzZVZpZXdlcihvcHRpb25zKSB7XG5cbiAgb3B0aW9ucyA9IGFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcblxuICB0aGlzLl9tb2RkbGUgPSB0aGlzLl9jcmVhdGVNb2RkbGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fY29udGFpbmVyID0gdGhpcy5fY3JlYXRlQ29udGFpbmVyKG9wdGlvbnMpO1xuXG4gIC8qIDxwcm9qZWN0LWxvZ28+ICovXG5cbiAgYWRkUHJvamVjdExvZ28odGhpcy5fY29udGFpbmVyKTtcblxuICAvKiA8L3Byb2plY3QtbG9nbz4gKi9cblxuICB0aGlzLl9pbml0KHRoaXMuX2NvbnRhaW5lciwgdGhpcy5fbW9kZGxlLCBvcHRpb25zKTtcbn1cblxuaW5oZXJpdHMoQmFzZVZpZXdlciwgRGlhZ3JhbSk7XG5cblxuLyoqXG4gKiBQYXJzZSBhbmQgcmVuZGVyIGEgQlBNTiAyLjAgZGlhZ3JhbS5cbiAqXG4gKiBPbmNlIGZpbmlzaGVkIHRoZSB2aWV3ZXIgcmVwb3J0cyBiYWNrIHRoZSByZXN1bHQgdG8gdGhlXG4gKiBwcm92aWRlZCBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIChlcnIsIHdhcm5pbmdzKS5cbiAqXG4gKiAjIyBMaWZlLUN5Y2xlIEV2ZW50c1xuICpcbiAqIER1cmluZyBpbXBvcnQgdGhlIHZpZXdlciB3aWxsIGZpcmUgbGlmZS1jeWNsZSBldmVudHM6XG4gKlxuICogICAqIGltcG9ydC5wYXJzZS5zdGFydCAoYWJvdXQgdG8gcmVhZCBtb2RlbCBmcm9tIHhtbClcbiAqICAgKiBpbXBvcnQucGFyc2UuY29tcGxldGUgKG1vZGVsIHJlYWQ7IG1heSBoYXZlIHdvcmtlZCBvciBub3QpXG4gKiAgICogaW1wb3J0LnJlbmRlci5zdGFydCAoZ3JhcGhpY2FsIGltcG9ydCBzdGFydClcbiAqICAgKiBpbXBvcnQucmVuZGVyLmNvbXBsZXRlIChncmFwaGljYWwgaW1wb3J0IGZpbmlzaGVkKVxuICogICAqIGltcG9ydC5kb25lIChldmVyeXRoaW5nIGRvbmUpXG4gKlxuICogWW91IGNhbiB1c2UgdGhlc2UgZXZlbnRzIHRvIGhvb2sgaW50byB0aGUgbGlmZS1jeWNsZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30geG1sIHRoZSBCUE1OIDIuMCB4bWxcbiAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudDxCUE1ORGlhZ3JhbT58U3RyaW5nfSBbYnBtbkRpYWdyYW1dIEJQTU4gZGlhZ3JhbSBvciBpZCBvZiBkaWFncmFtIHRvIHJlbmRlciAoaWYgbm90IHByb3ZpZGVkLCB0aGUgZmlyc3Qgb25lIHdpbGwgYmUgcmVuZGVyZWQpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZG9uZV0gaW52b2tlZCB3aXRoIChlcnIsIHdhcm5pbmdzPVtdKVxuICovXG5CYXNlVmlld2VyLnByb3RvdHlwZS5pbXBvcnRYTUwgPSBmdW5jdGlvbih4bWwsIGJwbW5EaWFncmFtLCBkb25lKSB7XG5cbiAgaWYgKGlzRnVuY3Rpb24oYnBtbkRpYWdyYW0pKSB7XG4gICAgZG9uZSA9IGJwbW5EaWFncmFtO1xuICAgIGJwbW5EaWFncmFtID0gbnVsbDtcbiAgfVxuXG4gIC8vIGRvbmUgaXMgb3B0aW9uYWxcbiAgZG9uZSA9IGRvbmUgfHwgZnVuY3Rpb24oKSB7fTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gaG9vayBpbiBwcmUtcGFyc2UgbGlzdGVuZXJzICtcbiAgLy8gYWxsb3cgeG1sIG1hbmlwdWxhdGlvblxuICB4bWwgPSB0aGlzLl9lbWl0KCdpbXBvcnQucGFyc2Uuc3RhcnQnLCB7IHhtbDogeG1sIH0pIHx8IHhtbDtcblxuICB0aGlzLl9tb2RkbGUuZnJvbVhNTCh4bWwsICdicG1uOkRlZmluaXRpb25zJywgZnVuY3Rpb24oZXJyLCBkZWZpbml0aW9ucywgY29udGV4dCkge1xuXG4gICAgLy8gaG9vayBpbiBwb3N0IHBhcnNlIGxpc3RlbmVycyArXG4gICAgLy8gYWxsb3cgZGVmaW5pdGlvbnMgbWFuaXB1bGF0aW9uXG4gICAgZGVmaW5pdGlvbnMgPSBzZWxmLl9lbWl0KCdpbXBvcnQucGFyc2UuY29tcGxldGUnLCB7XG4gICAgICBlcnJvcjogZXJyLFxuICAgICAgZGVmaW5pdGlvbnM6IGRlZmluaXRpb25zLFxuICAgICAgY29udGV4dDogY29udGV4dFxuICAgIH0pIHx8IGRlZmluaXRpb25zO1xuXG4gICAgdmFyIHBhcnNlV2FybmluZ3MgPSBjb250ZXh0Lndhcm5pbmdzO1xuXG4gICAgaWYgKGVycikge1xuICAgICAgZXJyID0gY2hlY2tWYWxpZGF0aW9uRXJyb3IoZXJyKTtcblxuICAgICAgc2VsZi5fZW1pdCgnaW1wb3J0LmRvbmUnLCB7IGVycm9yOiBlcnIsIHdhcm5pbmdzOiBwYXJzZVdhcm5pbmdzIH0pO1xuXG4gICAgICByZXR1cm4gZG9uZShlcnIsIHBhcnNlV2FybmluZ3MpO1xuICAgIH1cblxuICAgIHNlbGYuaW1wb3J0RGVmaW5pdGlvbnMoZGVmaW5pdGlvbnMsIGJwbW5EaWFncmFtLCBmdW5jdGlvbihlcnIsIGltcG9ydFdhcm5pbmdzKSB7XG4gICAgICB2YXIgYWxsV2FybmluZ3MgPSBbXS5jb25jYXQocGFyc2VXYXJuaW5ncywgaW1wb3J0V2FybmluZ3MgfHwgW10pO1xuXG4gICAgICBzZWxmLl9lbWl0KCdpbXBvcnQuZG9uZScsIHsgZXJyb3I6IGVyciwgd2FybmluZ3M6IGFsbFdhcm5pbmdzIH0pO1xuXG4gICAgICBkb25lKGVyciwgYWxsV2FybmluZ3MpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogSW1wb3J0IHBhcnNlZCBkZWZpbml0aW9ucyBhbmQgcmVuZGVyIGEgQlBNTiAyLjAgZGlhZ3JhbS5cbiAqXG4gKiBPbmNlIGZpbmlzaGVkIHRoZSB2aWV3ZXIgcmVwb3J0cyBiYWNrIHRoZSByZXN1bHQgdG8gdGhlXG4gKiBwcm92aWRlZCBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIChlcnIsIHdhcm5pbmdzKS5cbiAqXG4gKiAjIyBMaWZlLUN5Y2xlIEV2ZW50c1xuICpcbiAqIER1cmluZyBpbXBvcnQgdGhlIHZpZXdlciB3aWxsIGZpcmUgbGlmZS1jeWNsZSBldmVudHM6XG4gKlxuICogICAqIGltcG9ydC5yZW5kZXIuc3RhcnQgKGdyYXBoaWNhbCBpbXBvcnQgc3RhcnQpXG4gKiAgICogaW1wb3J0LnJlbmRlci5jb21wbGV0ZSAoZ3JhcGhpY2FsIGltcG9ydCBmaW5pc2hlZClcbiAqXG4gKiBZb3UgY2FuIHVzZSB0aGVzZSBldmVudHMgdG8gaG9vayBpbnRvIHRoZSBsaWZlLWN5Y2xlLlxuICpcbiAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudDxEZWZpbml0aW9ucz59IGRlZmluaXRpb25zIHBhcnNlZCBCUE1OIDIuMCBkZWZpbml0aW9uc1xuICogQHBhcmFtIHtNb2RkbGVFbGVtZW50PEJQTU5EaWFncmFtPnxTdHJpbmd9IFticG1uRGlhZ3JhbV0gQlBNTiBkaWFncmFtIG9yIGlkIG9mIGRpYWdyYW0gdG8gcmVuZGVyIChpZiBub3QgcHJvdmlkZWQsIHRoZSBmaXJzdCBvbmUgd2lsbCBiZSByZW5kZXJlZClcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtkb25lXSBpbnZva2VkIHdpdGggKGVyciwgd2FybmluZ3M9W10pXG4gKi9cbkJhc2VWaWV3ZXIucHJvdG90eXBlLmltcG9ydERlZmluaXRpb25zID0gZnVuY3Rpb24oZGVmaW5pdGlvbnMsIGJwbW5EaWFncmFtLCBkb25lKSB7XG5cbiAgaWYgKGlzRnVuY3Rpb24oYnBtbkRpYWdyYW0pKSB7XG4gICAgZG9uZSA9IGJwbW5EaWFncmFtO1xuICAgIGJwbW5EaWFncmFtID0gbnVsbDtcbiAgfVxuXG4gIC8vIGRvbmUgaXMgb3B0aW9uYWxcbiAgZG9uZSA9IGRvbmUgfHwgZnVuY3Rpb24oKSB7fTtcblxuICB0aGlzLl9zZXREZWZpbml0aW9ucyhkZWZpbml0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXMub3BlbihicG1uRGlhZ3JhbSwgZG9uZSk7XG59O1xuXG4vKipcbiAqIE9wZW4gZGlhZ3JhbSBvZiBwcmV2aW91c2x5IGltcG9ydGVkIFhNTC5cbiAqXG4gKiBPbmNlIGZpbmlzaGVkIHRoZSB2aWV3ZXIgcmVwb3J0cyBiYWNrIHRoZSByZXN1bHQgdG8gdGhlXG4gKiBwcm92aWRlZCBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIChlcnIsIHdhcm5pbmdzKS5cbiAqXG4gKiAjIyBMaWZlLUN5Y2xlIEV2ZW50c1xuICpcbiAqIER1cmluZyBzd2l0Y2ggdGhlIHZpZXdlciB3aWxsIGZpcmUgbGlmZS1jeWNsZSBldmVudHM6XG4gKlxuICogICAqIGltcG9ydC5yZW5kZXIuc3RhcnQgKGdyYXBoaWNhbCBpbXBvcnQgc3RhcnQpXG4gKiAgICogaW1wb3J0LnJlbmRlci5jb21wbGV0ZSAoZ3JhcGhpY2FsIGltcG9ydCBmaW5pc2hlZClcbiAqXG4gKiBZb3UgY2FuIHVzZSB0aGVzZSBldmVudHMgdG8gaG9vayBpbnRvIHRoZSBsaWZlLWN5Y2xlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE1vZGRsZUVsZW1lbnQ8QlBNTkRpYWdyYW0+fSBbYnBtbkRpYWdyYW1PcklkXSBpZCBvciB0aGUgZGlhZ3JhbSB0byBvcGVuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZG9uZV0gaW52b2tlZCB3aXRoIChlcnIsIHdhcm5pbmdzPVtdKVxuICovXG5CYXNlVmlld2VyLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24oYnBtbkRpYWdyYW1PcklkLCBkb25lKSB7XG5cbiAgaWYgKGlzRnVuY3Rpb24oYnBtbkRpYWdyYW1PcklkKSkge1xuICAgIGRvbmUgPSBicG1uRGlhZ3JhbU9ySWQ7XG4gICAgYnBtbkRpYWdyYW1PcklkID0gbnVsbDtcbiAgfVxuXG4gIHZhciBkZWZpbml0aW9ucyA9IHRoaXMuX2RlZmluaXRpb25zO1xuICB2YXIgYnBtbkRpYWdyYW0gPSBicG1uRGlhZ3JhbU9ySWQ7XG5cbiAgLy8gZG9uZSBpcyBvcHRpb25hbFxuICBkb25lID0gZG9uZSB8fCBmdW5jdGlvbigpIHt9O1xuXG4gIGlmICghZGVmaW5pdGlvbnMpIHtcbiAgICByZXR1cm4gZG9uZShuZXcgRXJyb3IoJ25vIFhNTCBpbXBvcnRlZCcpKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYnBtbkRpYWdyYW1PcklkID09PSAnc3RyaW5nJykge1xuICAgIGJwbW5EaWFncmFtID0gZmluZEJQTU5EaWFncmFtKGRlZmluaXRpb25zLCBicG1uRGlhZ3JhbU9ySWQpO1xuXG4gICAgaWYgKCFicG1uRGlhZ3JhbSkge1xuICAgICAgcmV0dXJuIGRvbmUobmV3IEVycm9yKCdCUE1ORGlhZ3JhbSA8JyArIGJwbW5EaWFncmFtT3JJZCArICc+IG5vdCBmb3VuZCcpKTtcbiAgICB9XG4gIH1cblxuICAvLyBjbGVhciBleGlzdGluZyByZW5kZXJlZCBkaWFncmFtXG4gIC8vIGNhdGNoIHN5bmNocm9ub3VzIGV4Y2VwdGlvbnMgZHVyaW5nICNjbGVhcigpXG4gIHRyeSB7XG4gICAgdGhpcy5jbGVhcigpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBkb25lKGVycm9yKTtcbiAgfVxuXG4gIC8vIHBlcmZvcm0gZ3JhcGhpY2FsIGltcG9ydFxuICByZXR1cm4gaW1wb3J0QnBtbkRpYWdyYW0odGhpcywgZGVmaW5pdGlvbnMsIGJwbW5EaWFncmFtLCBkb25lKTtcbn07XG5cbi8qKlxuICogRXhwb3J0IHRoZSBjdXJyZW50bHkgZGlzcGxheWVkIEJQTU4gMi4wIGRpYWdyYW0gYXNcbiAqIGEgQlBNTiAyLjAgWE1MIGRvY3VtZW50LlxuICpcbiAqICMjIExpZmUtQ3ljbGUgRXZlbnRzXG4gKlxuICogRHVyaW5nIFhNTCBzYXZpbmcgdGhlIHZpZXdlciB3aWxsIGZpcmUgbGlmZS1jeWNsZSBldmVudHM6XG4gKlxuICogICAqIHNhdmVYTUwuc3RhcnQgKGJlZm9yZSBzZXJpYWxpemF0aW9uKVxuICogICAqIHNhdmVYTUwuc2VyaWFsaXplZCAoYWZ0ZXIgeG1sIGdlbmVyYXRpb24pXG4gKiAgICogc2F2ZVhNTC5kb25lIChldmVyeXRoaW5nIGRvbmUpXG4gKlxuICogWW91IGNhbiB1c2UgdGhlc2UgZXZlbnRzIHRvIGhvb2sgaW50byB0aGUgbGlmZS1jeWNsZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIGV4cG9ydCBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZvcm1hdD1mYWxzZV0gb3V0cHV0IGZvcm1hdHRlZCBYTUxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucHJlYW1ibGU9dHJ1ZV0gb3V0cHV0IHByZWFtYmxlXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZSBpbnZva2VkIHdpdGggKGVyciwgeG1sKVxuICovXG5CYXNlVmlld2VyLnByb3RvdHlwZS5zYXZlWE1MID0gZnVuY3Rpb24ob3B0aW9ucywgZG9uZSkge1xuXG4gIGlmICghZG9uZSkge1xuICAgIGRvbmUgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgZGVmaW5pdGlvbnMgPSB0aGlzLl9kZWZpbml0aW9ucztcblxuICBpZiAoIWRlZmluaXRpb25zKSB7XG4gICAgcmV0dXJuIGRvbmUobmV3IEVycm9yKCdubyBkZWZpbml0aW9ucyBsb2FkZWQnKSk7XG4gIH1cblxuICAvLyBhbGxvdyB0byBmaWRkbGUgYXJvdW5kIHdpdGggZGVmaW5pdGlvbnNcbiAgZGVmaW5pdGlvbnMgPSB0aGlzLl9lbWl0KCdzYXZlWE1MLnN0YXJ0Jywge1xuICAgIGRlZmluaXRpb25zOiBkZWZpbml0aW9uc1xuICB9KSB8fCBkZWZpbml0aW9ucztcblxuICB0aGlzLl9tb2RkbGUudG9YTUwoZGVmaW5pdGlvbnMsIG9wdGlvbnMsIGZ1bmN0aW9uKGVyciwgeG1sKSB7XG5cbiAgICB0cnkge1xuICAgICAgeG1sID0gc2VsZi5fZW1pdCgnc2F2ZVhNTC5zZXJpYWxpemVkJywge1xuICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICB4bWw6IHhtbFxuICAgICAgfSkgfHwgeG1sO1xuXG4gICAgICBzZWxmLl9lbWl0KCdzYXZlWE1MLmRvbmUnLCB7XG4gICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgIHhtbDogeG1sXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdlcnJvciBpbiBzYXZlWE1MIGxpZmUtY3ljbGUgbGlzdGVuZXInLCBlKTtcbiAgICB9XG5cbiAgICBkb25lKGVyciwgeG1sKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEV4cG9ydCB0aGUgY3VycmVudGx5IGRpc3BsYXllZCBCUE1OIDIuMCBkaWFncmFtIGFzXG4gKiBhbiBTVkcgaW1hZ2UuXG4gKlxuICogIyMgTGlmZS1DeWNsZSBFdmVudHNcbiAqXG4gKiBEdXJpbmcgU1ZHIHNhdmluZyB0aGUgdmlld2VyIHdpbGwgZmlyZSBsaWZlLWN5Y2xlIGV2ZW50czpcbiAqXG4gKiAgICogc2F2ZVNWRy5zdGFydCAoYmVmb3JlIHNlcmlhbGl6YXRpb24pXG4gKiAgICogc2F2ZVNWRy5kb25lIChldmVyeXRoaW5nIGRvbmUpXG4gKlxuICogWW91IGNhbiB1c2UgdGhlc2UgZXZlbnRzIHRvIGhvb2sgaW50byB0aGUgbGlmZS1jeWNsZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lIGludm9rZWQgd2l0aCAoZXJyLCBzdmdTdHIpXG4gKi9cbkJhc2VWaWV3ZXIucHJvdG90eXBlLnNhdmVTVkcgPSBmdW5jdGlvbihvcHRpb25zLCBkb25lKSB7XG5cbiAgaWYgKCFkb25lKSB7XG4gICAgZG9uZSA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdGhpcy5fZW1pdCgnc2F2ZVNWRy5zdGFydCcpO1xuXG4gIHZhciBzdmcsIGVycjtcblxuICB0cnkge1xuICAgIHZhciBjYW52YXMgPSB0aGlzLmdldCgnY2FudmFzJyk7XG5cbiAgICB2YXIgY29udGVudE5vZGUgPSBjYW52YXMuZ2V0RGVmYXVsdExheWVyKCksXG4gICAgICAgIGRlZnNOb2RlID0gZG9tUXVlcnkoJ2RlZnMnLCBjYW52YXMuX3N2Zyk7XG5cbiAgICB2YXIgY29udGVudHMgPSBpbm5lclNWRyhjb250ZW50Tm9kZSksXG4gICAgICAgIGRlZnMgPSBkZWZzTm9kZSA/ICc8ZGVmcz4nICsgaW5uZXJTVkcoZGVmc05vZGUpICsgJzwvZGVmcz4nIDogJyc7XG5cbiAgICB2YXIgYmJveCA9IGNvbnRlbnROb2RlLmdldEJCb3goKTtcblxuICAgIHN2ZyA9XG4gICAgICAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwidXRmLThcIj8+XFxuJyArXG4gICAgICAnPCEtLSBjcmVhdGVkIHdpdGggYnBtbi1qcyAvIGh0dHA6Ly9icG1uLmlvIC0tPlxcbicgK1xuICAgICAgJzwhRE9DVFlQRSBzdmcgUFVCTElDIFwiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU5cIiBcImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZFwiPlxcbicgK1xuICAgICAgJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiICcgK1xuICAgICAgICAgICAnd2lkdGg9XCInICsgYmJveC53aWR0aCArICdcIiBoZWlnaHQ9XCInICsgYmJveC5oZWlnaHQgKyAnXCIgJyArXG4gICAgICAgICAgICd2aWV3Qm94PVwiJyArIGJib3gueCArICcgJyArIGJib3gueSArICcgJyArIGJib3gud2lkdGggKyAnICcgKyBiYm94LmhlaWdodCArICdcIiB2ZXJzaW9uPVwiMS4xXCI+JyArXG4gICAgICAgIGRlZnMgKyBjb250ZW50cyArXG4gICAgICAnPC9zdmc+JztcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVyciA9IGU7XG4gIH1cblxuICB0aGlzLl9lbWl0KCdzYXZlU1ZHLmRvbmUnLCB7XG4gICAgZXJyb3I6IGVycixcbiAgICBzdmc6IHN2Z1xuICB9KTtcblxuICBkb25lKGVyciwgc3ZnKTtcbn07XG5cbi8qKlxuICogR2V0IGEgbmFtZWQgZGlhZ3JhbSBzZXJ2aWNlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGVsZW1lbnRSZWdpc3RyeSA9IHZpZXdlci5nZXQoJ2VsZW1lbnRSZWdpc3RyeScpO1xuICogdmFyIHN0YXJ0RXZlbnRTaGFwZSA9IGVsZW1lbnRSZWdpc3RyeS5nZXQoJ1N0YXJ0RXZlbnRfMScpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBkaWFncmFtIHNlcnZpY2UgaW5zdGFuY2VcbiAqXG4gKiBAbWV0aG9kIEJhc2VWaWV3ZXIjZ2V0XG4gKi9cblxuLyoqXG4gKiBJbnZva2UgYSBmdW5jdGlvbiBpbiB0aGUgY29udGV4dCBvZiB0aGlzIHZpZXdlci5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZpZXdlci5pbnZva2UoZnVuY3Rpb24oZWxlbWVudFJlZ2lzdHJ5KSB7XG4gKiAgIHZhciBzdGFydEV2ZW50U2hhcGUgPSBlbGVtZW50UmVnaXN0cnkuZ2V0KCdTdGFydEV2ZW50XzEnKTtcbiAqIH0pO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIHRvIGJlIGludm9rZWRcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBmdW5jdGlvbnMgcmV0dXJuIHZhbHVlXG4gKlxuICogQG1ldGhvZCBCYXNlVmlld2VyI2ludm9rZVxuICovXG5cblxuQmFzZVZpZXdlci5wcm90b3R5cGUuX3NldERlZmluaXRpb25zID0gZnVuY3Rpb24oZGVmaW5pdGlvbnMpIHtcbiAgdGhpcy5fZGVmaW5pdGlvbnMgPSBkZWZpbml0aW9ucztcbn07XG5cbkJhc2VWaWV3ZXIucHJvdG90eXBlLmdldE1vZHVsZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX21vZHVsZXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgZHJhd24gZWxlbWVudHMgZnJvbSB0aGUgdmlld2VyLlxuICpcbiAqIEFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgdGhlIHZpZXdlciBjYW4gc3RpbGxcbiAqIGJlIHJldXNlZCBmb3Igb3BlbmluZyBhbm90aGVyIGRpYWdyYW0uXG4gKlxuICogQG1ldGhvZCBCYXNlVmlld2VyI2NsZWFyXG4gKi9cbkJhc2VWaWV3ZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5nZXREZWZpbml0aW9ucygpKSB7XG5cbiAgICAvLyBubyBkaWFncmFtIHRvIGNsZWFyXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGJ1c2luZXNzT2JqZWN0I2RpIGJpbmRpbmdcbiAgLy9cbiAgLy8gdGhpcyBpcyBuZWNlc3NhcnksIGFzIHdlIGVzdGFibGlzaCB0aGUgYmluZGluZ3NcbiAgLy8gaW4gdGhlIEJwbW5UcmVlV2Fsa2VyIChhbmQgYXNzdW1lIG5vbmUgYXJlIGdpdmVuXG4gIC8vIG9uIHJlaW1wb3J0KVxuICB0aGlzLmdldCgnZWxlbWVudFJlZ2lzdHJ5JykuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgdmFyIGJvID0gZWxlbWVudC5idXNpbmVzc09iamVjdDtcblxuICAgIGlmIChibyAmJiBiby5kaSkge1xuICAgICAgZGVsZXRlIGJvLmRpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcmVtb3ZlIGRyYXduIGVsZW1lbnRzXG4gIERpYWdyYW0ucHJvdG90eXBlLmNsZWFyLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIERlc3Ryb3kgdGhlIHZpZXdlciBpbnN0YW5jZSBhbmQgcmVtb3ZlIGFsbCBpdHNcbiAqIHJlbWFpbmRlcnMgZnJvbSB0aGUgZG9jdW1lbnQgdHJlZS5cbiAqL1xuQmFzZVZpZXdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXG4gIC8vIGRpYWdyYW0gZGVzdHJveVxuICBEaWFncmFtLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG5cbiAgLy8gZG9tIGRldGFjaFxuICBkb21SZW1vdmUodGhpcy5fY29udGFpbmVyKTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXJcbiAqXG4gKiBSZW1vdmUgYSBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVyIHZpYSB7QGxpbmsgI29mZihldmVudCwgY2FsbGJhY2spfS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBbcHJpb3JpdHldXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IFt0aGF0XVxuICovXG5CYXNlVmlld2VyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2ZW50LCBwcmlvcml0eSwgY2FsbGJhY2ssIHRhcmdldCkge1xuICByZXR1cm4gdGhpcy5nZXQoJ2V2ZW50QnVzJykub24oZXZlbnQsIHByaW9yaXR5LCBjYWxsYmFjaywgdGFyZ2V0KTtcbn07XG5cbi8qKlxuICogRGUtcmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cbkJhc2VWaWV3ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKGV2ZW50LCBjYWxsYmFjaykge1xuICB0aGlzLmdldCgnZXZlbnRCdXMnKS5vZmYoZXZlbnQsIGNhbGxiYWNrKTtcbn07XG5cbkJhc2VWaWV3ZXIucHJvdG90eXBlLmF0dGFjaFRvID0gZnVuY3Rpb24ocGFyZW50Tm9kZSkge1xuXG4gIGlmICghcGFyZW50Tm9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncGFyZW50Tm9kZSByZXF1aXJlZCcpO1xuICB9XG5cbiAgLy8gZW5zdXJlIHdlIGRldGFjaCBmcm9tIHRoZVxuICAvLyBwcmV2aW91cywgb2xkIHBhcmVudFxuICB0aGlzLmRldGFjaCgpO1xuXG4gIC8vIHVud3JhcCBqUXVlcnkgaWYgcHJvdmlkZWRcbiAgaWYgKHBhcmVudE5vZGUuZ2V0ICYmIHBhcmVudE5vZGUuY29uc3RydWN0b3IucHJvdG90eXBlLmpxdWVyeSkge1xuICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLmdldCgwKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGFyZW50Tm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICBwYXJlbnROb2RlID0gZG9tUXVlcnkocGFyZW50Tm9kZSk7XG4gIH1cblxuICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG5cbiAgdGhpcy5fZW1pdCgnYXR0YWNoJywge30pO1xuXG4gIHRoaXMuZ2V0KCdjYW52YXMnKS5yZXNpemVkKCk7XG59O1xuXG5CYXNlVmlld2VyLnByb3RvdHlwZS5nZXREZWZpbml0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZGVmaW5pdGlvbnM7XG59O1xuXG5CYXNlVmlld2VyLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbigpIHtcblxuICB2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyLFxuICAgICAgcGFyZW50Tm9kZSA9IGNvbnRhaW5lci5wYXJlbnROb2RlO1xuXG4gIGlmICghcGFyZW50Tm9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2VtaXQoJ2RldGFjaCcsIHt9KTtcblxuICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvbnRhaW5lcik7XG59O1xuXG5CYXNlVmlld2VyLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgbW9kZGxlLCBvcHRpb25zKSB7XG5cbiAgdmFyIGJhc2VNb2R1bGVzID0gb3B0aW9ucy5tb2R1bGVzIHx8IHRoaXMuZ2V0TW9kdWxlcygpLFxuICAgICAgYWRkaXRpb25hbE1vZHVsZXMgPSBvcHRpb25zLmFkZGl0aW9uYWxNb2R1bGVzIHx8IFtdLFxuICAgICAgc3RhdGljTW9kdWxlcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGJwbW5qczogWyAndmFsdWUnLCB0aGlzIF0sXG4gICAgICAgICAgbW9kZGxlOiBbICd2YWx1ZScsIG1vZGRsZSBdXG4gICAgICAgIH1cbiAgICAgIF07XG5cbiAgdmFyIGRpYWdyYW1Nb2R1bGVzID0gW10uY29uY2F0KHN0YXRpY01vZHVsZXMsIGJhc2VNb2R1bGVzLCBhZGRpdGlvbmFsTW9kdWxlcyk7XG5cbiAgdmFyIGRpYWdyYW1PcHRpb25zID0gYXNzaWduKG9taXQob3B0aW9ucywgWyAnYWRkaXRpb25hbE1vZHVsZXMnIF0pLCB7XG4gICAgY2FudmFzOiBhc3NpZ24oe30sIG9wdGlvbnMuY2FudmFzLCB7IGNvbnRhaW5lcjogY29udGFpbmVyIH0pLFxuICAgIG1vZHVsZXM6IGRpYWdyYW1Nb2R1bGVzXG4gIH0pO1xuXG4gIC8vIGludm9rZSBkaWFncmFtIGNvbnN0cnVjdG9yXG4gIERpYWdyYW0uY2FsbCh0aGlzLCBkaWFncmFtT3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jb250YWluZXIpIHtcbiAgICB0aGlzLmF0dGFjaFRvKG9wdGlvbnMuY29udGFpbmVyKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFbWl0IGFuIGV2ZW50IG9uIHRoZSB1bmRlcmx5aW5nIHtAbGluayBFdmVudEJ1c31cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSAge09iamVjdH0gZXZlbnRcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGV2ZW50IHByb2Nlc3NpbmcgcmVzdWx0IChpZiBhbnkpXG4gKi9cbkJhc2VWaWV3ZXIucHJvdG90eXBlLl9lbWl0ID0gZnVuY3Rpb24odHlwZSwgZXZlbnQpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0KCdldmVudEJ1cycpLmZpcmUodHlwZSwgZXZlbnQpO1xufTtcblxuQmFzZVZpZXdlci5wcm90b3R5cGUuX2NyZWF0ZUNvbnRhaW5lciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblxuICB2YXIgY29udGFpbmVyID0gZG9taWZ5KCc8ZGl2IGNsYXNzPVwiYmpzLWNvbnRhaW5lclwiPjwvZGl2PicpO1xuXG4gIGFzc2lnbihjb250YWluZXIuc3R5bGUsIHtcbiAgICB3aWR0aDogZW5zdXJlVW5pdChvcHRpb25zLndpZHRoKSxcbiAgICBoZWlnaHQ6IGVuc3VyZVVuaXQob3B0aW9ucy5oZWlnaHQpLFxuICAgIHBvc2l0aW9uOiBvcHRpb25zLnBvc2l0aW9uXG4gIH0pO1xuXG4gIHJldHVybiBjb250YWluZXI7XG59O1xuXG5CYXNlVmlld2VyLnByb3RvdHlwZS5fY3JlYXRlTW9kZGxlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgbW9kZGxlT3B0aW9ucyA9IGFzc2lnbih7fSwgdGhpcy5fbW9kZGxlRXh0ZW5zaW9ucywgb3B0aW9ucy5tb2RkbGVFeHRlbnNpb25zKTtcblxuICByZXR1cm4gbmV3IEJwbW5Nb2RkbGUobW9kZGxlT3B0aW9ucyk7XG59O1xuXG5CYXNlVmlld2VyLnByb3RvdHlwZS5fbW9kdWxlcyA9IFtdO1xuXG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGNoZWNrVmFsaWRhdGlvbkVycm9yKGVycikge1xuXG4gIC8vIGNoZWNrIGlmIHdlIGNhbiBoZWxwIHRoZSB1c2VyIGJ5IGluZGljYXRpbmcgd3JvbmcgQlBNTiAyLjAgeG1sXG4gIC8vIChpbiBjYXNlIGhlIG9yIHRoZSBleHBvcnRpbmcgdG9vbCBkaWQgbm90IGdldCB0aGF0IHJpZ2h0KVxuXG4gIHZhciBwYXR0ZXJuID0gL3VucGFyc2FibGUgY29udGVudCA8KFtePl0rKT4gZGV0ZWN0ZWQoW1xcc1xcU10qKSQvO1xuICB2YXIgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoZXJyLm1lc3NhZ2UpO1xuXG4gIGlmIChtYXRjaCkge1xuICAgIGVyci5tZXNzYWdlID1cbiAgICAgICd1bnBhcnNhYmxlIGNvbnRlbnQgPCcgKyBtYXRjaFsxXSArICc+IGRldGVjdGVkOyAnICtcbiAgICAgICd0aGlzIG1heSBpbmRpY2F0ZSBhbiBpbnZhbGlkIEJQTU4gMi4wIGRpYWdyYW0gZmlsZScgKyBtYXRjaFsyXTtcbiAgfVxuXG4gIHJldHVybiBlcnI7XG59XG5cbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIHdpZHRoOiAnMTAwJScsXG4gIGhlaWdodDogJzEwMCUnLFxuICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xufTtcblxuXG4vKipcbiAqIEVuc3VyZSB0aGUgcGFzc2VkIGFyZ3VtZW50IGlzIGEgcHJvcGVyIHVuaXQgKGRlZmF1bHRpbmcgdG8gcHgpXG4gKi9cbmZ1bmN0aW9uIGVuc3VyZVVuaXQodmFsKSB7XG4gIHJldHVybiB2YWwgKyAoaXNOdW1iZXIodmFsKSA/ICdweCcgOiAnJyk7XG59XG5cblxuLyoqXG4gKiBGaW5kIEJQTU5EaWFncmFtIGluIGRlZmluaXRpb25zIGJ5IElEXG4gKlxuICogQHBhcmFtIHtNb2RkbGVFbGVtZW50PERlZmluaXRpb25zPn0gZGVmaW5pdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBkaWFncmFtSWRcbiAqXG4gKiBAcmV0dXJuIHtNb2RkbGVFbGVtZW50PEJQTU5EaWFncmFtPnxudWxsfVxuICovXG5mdW5jdGlvbiBmaW5kQlBNTkRpYWdyYW0oZGVmaW5pdGlvbnMsIGRpYWdyYW1JZCkge1xuICBpZiAoIWRpYWdyYW1JZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGZpbmQoZGVmaW5pdGlvbnMuZGlhZ3JhbXMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5pZCA9PT0gZGlhZ3JhbUlkO1xuICB9KSB8fCBudWxsO1xufVxuXG5cbi8qIDxwcm9qZWN0LWxvZ28+ICovXG5cbmltcG9ydCB7XG4gIG9wZW4gYXMgb3BlblBvd2VyZWRCeSxcbiAgQlBNTklPX0lNR1xufSBmcm9tICcuL3V0aWwvUG93ZXJlZEJ5VXRpbCc7XG5cbmltcG9ydCB7XG4gIGV2ZW50IGFzIGRvbUV2ZW50XG59IGZyb20gJ21pbi1kb20nO1xuXG4vKipcbiAqIEFkZHMgdGhlIHByb2plY3QgbG9nbyB0byB0aGUgZGlhZ3JhbSBjb250YWluZXIgYXNcbiAqIHJlcXVpcmVkIGJ5IHRoZSBicG1uLmlvIGxpY2Vuc2UuXG4gKlxuICogQHNlZSBodHRwOi8vYnBtbi5pby9saWNlbnNlXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXJcbiAqL1xuZnVuY3Rpb24gYWRkUHJvamVjdExvZ28oY29udGFpbmVyKSB7XG4gIHZhciBpbWcgPSBCUE1OSU9fSU1HO1xuXG4gIHZhciBsaW5rTWFya3VwID1cbiAgICAnPGEgaHJlZj1cImh0dHA6Ly9icG1uLmlvXCIgJyArXG4gICAgICAgJ3RhcmdldD1cIl9ibGFua1wiICcgK1xuICAgICAgICdjbGFzcz1cImJqcy1wb3dlcmVkLWJ5XCIgJyArXG4gICAgICAgJ3RpdGxlPVwiUG93ZXJlZCBieSBicG1uLmlvXCIgJyArXG4gICAgICAgJ3N0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyBib3R0b206IDE1cHg7IHJpZ2h0OiAxNXB4OyB6LWluZGV4OiAxMDBcIj4nICtcbiAgICAgIGltZyArXG4gICAgJzwvYT4nO1xuXG4gIHZhciBsaW5rRWxlbWVudCA9IGRvbWlmeShsaW5rTWFya3VwKTtcblxuICBjb250YWluZXIuYXBwZW5kQ2hpbGQobGlua0VsZW1lbnQpO1xuXG4gIGRvbUV2ZW50LmJpbmQobGlua0VsZW1lbnQsICdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgb3BlblBvd2VyZWRCeSgpO1xuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG59XG5cbi8qIDwvcHJvamVjdC1sb2dvPiAqLyIsImltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5cbmltcG9ydCBDb3JlTW9kdWxlIGZyb20gJy4vY29yZSc7XG5pbXBvcnQgVHJhbnNsYXRlTW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL2kxOG4vdHJhbnNsYXRlJztcbmltcG9ydCBTZWxlY3Rpb25Nb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvc2VsZWN0aW9uJztcbmltcG9ydCBPdmVybGF5c01vZHVsZSBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9vdmVybGF5cyc7XG5cbmltcG9ydCBCYXNlVmlld2VyIGZyb20gJy4vQmFzZVZpZXdlcic7XG5cblxuLyoqXG4gKiBBIHZpZXdlciBmb3IgQlBNTiAyLjAgZGlhZ3JhbXMuXG4gKlxuICogSGF2ZSBhIGxvb2sgYXQge0BsaW5rIE5hdmlnYXRlZFZpZXdlcn0gb3Ige0BsaW5rIE1vZGVsZXJ9IGZvciBidW5kbGVzIHRoYXQgaW5jbHVkZVxuICogYWRkaXRpb25hbCBmZWF0dXJlcy5cbiAqXG4gKlxuICogIyMgRXh0ZW5kaW5nIHRoZSBWaWV3ZXJcbiAqXG4gKiBJbiBvcmRlciB0byBleHRlbmQgdGhlIHZpZXdlciBwYXNzIGV4dGVuc2lvbiBtb2R1bGVzIHRvIGJvb3RzdHJhcCB2aWEgdGhlXG4gKiBgYWRkaXRpb25hbE1vZHVsZXNgIG9wdGlvbi4gQW4gZXh0ZW5zaW9uIG1vZHVsZSBpcyBhbiBvYmplY3QgdGhhdCBleHBvc2VzXG4gKiBuYW1lZCBzZXJ2aWNlcy5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgZGVwaWN0cyB0aGUgaW50ZWdyYXRpb24gb2YgYSBzaW1wbGVcbiAqIGxvZ2dpbmcgY29tcG9uZW50IHRoYXQgaW50ZWdyYXRlcyB3aXRoIGludGVyYWN0aW9uIGV2ZW50czpcbiAqXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICpcbiAqIC8vIGxvZ2dpbmcgY29tcG9uZW50XG4gKiBmdW5jdGlvbiBJbnRlcmFjdGlvbkxvZ2dlcihldmVudEJ1cykge1xuICogICBldmVudEJ1cy5vbignZWxlbWVudC5ob3ZlcicsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gKiAgICAgY29uc29sZS5sb2coKVxuICogICB9KVxuICogfVxuICpcbiAqIEludGVyYWN0aW9uTG9nZ2VyLiRpbmplY3QgPSBbICdldmVudEJ1cycgXTsgLy8gbWluaWZpY2F0aW9uIHNhdmVcbiAqXG4gKiAvLyBleHRlbnNpb24gbW9kdWxlXG4gKiB2YXIgZXh0ZW5zaW9uTW9kdWxlID0ge1xuICogICBfX2luaXRfXzogWyAnaW50ZXJhY3Rpb25Mb2dnZXInIF0sXG4gKiAgIGludGVyYWN0aW9uTG9nZ2VyOiBbICd0eXBlJywgSW50ZXJhY3Rpb25Mb2dnZXIgXVxuICogfTtcbiAqXG4gKiAvLyBleHRlbmQgdGhlIHZpZXdlclxuICogdmFyIGJwbW5WaWV3ZXIgPSBuZXcgVmlld2VyKHsgYWRkaXRpb25hbE1vZHVsZXM6IFsgZXh0ZW5zaW9uTW9kdWxlIF0gfSk7XG4gKiBicG1uVmlld2VyLmltcG9ydFhNTCguLi4pO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgdmlld2VyXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IFtvcHRpb25zLmNvbnRhaW5lcl0gdGhlIGNvbnRhaW5lciB0byByZW5kZXIgdGhlIHZpZXdlciBpbiwgZGVmYXVsdHMgdG8gYm9keS5cbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gW29wdGlvbnMud2lkdGhdIHRoZSB3aWR0aCBvZiB0aGUgdmlld2VyXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gdGhlIGhlaWdodCBvZiB0aGUgdmlld2VyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubW9kZGxlRXh0ZW5zaW9uc10gZXh0ZW5zaW9uIHBhY2thZ2VzIHRvIHByb3ZpZGVcbiAqIEBwYXJhbSB7QXJyYXk8ZGlkaS5Nb2R1bGU+fSBbb3B0aW9ucy5tb2R1bGVzXSBhIGxpc3Qgb2YgbW9kdWxlcyB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBtb2R1bGVzXG4gKiBAcGFyYW0ge0FycmF5PGRpZGkuTW9kdWxlPn0gW29wdGlvbnMuYWRkaXRpb25hbE1vZHVsZXNdIGEgbGlzdCBvZiBtb2R1bGVzIHRvIHVzZSB3aXRoIHRoZSBkZWZhdWx0IG1vZHVsZXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVmlld2VyKG9wdGlvbnMpIHtcbiAgQmFzZVZpZXdlci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5pbmhlcml0cyhWaWV3ZXIsIEJhc2VWaWV3ZXIpO1xuXG4vLyBtb2R1bGVzIHRoZSB2aWV3ZXIgaXMgY29tcG9zZWQgb2ZcblZpZXdlci5wcm90b3R5cGUuX21vZHVsZXMgPSBbXG4gIENvcmVNb2R1bGUsXG4gIFRyYW5zbGF0ZU1vZHVsZSxcbiAgU2VsZWN0aW9uTW9kdWxlLFxuICBPdmVybGF5c01vZHVsZVxuXTtcblxuLy8gZGVmYXVsdCBtb2RkbGUgZXh0ZW5zaW9ucyB0aGUgdmlld2VyIGlzIGNvbXBvc2VkIG9mXG5WaWV3ZXIucHJvdG90eXBlLl9tb2RkbGVFeHRlbnNpb25zID0ge307IiwiaW1wb3J0IERyYXdNb2R1bGUgZnJvbSAnLi4vZHJhdyc7XG5pbXBvcnQgSW1wb3J0TW9kdWxlIGZyb20gJy4uL2ltcG9ydCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19kZXBlbmRzX186IFtcbiAgICBEcmF3TW9kdWxlLFxuICAgIEltcG9ydE1vZHVsZVxuICBdXG59OyIsImltcG9ydCB7XG4gIGV2ZXJ5LFxuICBzb21lXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHtcbiAgY29tcG9uZW50c1RvUGF0aFxufSBmcm9tICdkaWFncmFtLWpzL2xpYi91dGlsL1JlbmRlclV0aWwnO1xuXG5cbi8vIGVsZW1lbnQgdXRpbHMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIENoZWNrcyBpZiBldmVudERlZmluaXRpb24gb2YgdGhlIGdpdmVuIGVsZW1lbnQgbWF0Y2hlcyB3aXRoIHNlbWFudGljIHR5cGUuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBlbGVtZW50IGlzIG9mIHRoZSBnaXZlbiBzZW1hbnRpYyB0eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1R5cGVkRXZlbnQoZXZlbnQsIGV2ZW50RGVmaW5pdGlvblR5cGUsIGZpbHRlcikge1xuXG4gIGZ1bmN0aW9uIG1hdGNoZXMoZGVmaW5pdGlvbiwgZmlsdGVyKSB7XG4gICAgcmV0dXJuIGV2ZXJ5KGZpbHRlciwgZnVuY3Rpb24odmFsLCBrZXkpIHtcblxuICAgICAgLy8gd2Ugd2FudCBhID09IGNvbnZlcnNpb24gaGVyZSwgdG8gYmUgYWJsZSB0byBjYXRjaFxuICAgICAgLy8gdW5kZWZpbmVkID09IGZhbHNlIGFuZCBmcmllbmRzXG4gICAgICAvKiBqc2hpbnQgLVcxMTYgKi9cbiAgICAgIHJldHVybiBkZWZpbml0aW9uW2tleV0gPT0gdmFsO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHNvbWUoZXZlbnQuZXZlbnREZWZpbml0aW9ucywgZnVuY3Rpb24oZGVmaW5pdGlvbikge1xuICAgIHJldHVybiBkZWZpbml0aW9uLiR0eXBlID09PSBldmVudERlZmluaXRpb25UeXBlICYmIG1hdGNoZXMoZXZlbnQsIGZpbHRlcik7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNUaHJvd0V2ZW50KGV2ZW50KSB7XG4gIHJldHVybiAoZXZlbnQuJHR5cGUgPT09ICdicG1uOkludGVybWVkaWF0ZVRocm93RXZlbnQnKSB8fCAoZXZlbnQuJHR5cGUgPT09ICdicG1uOkVuZEV2ZW50Jyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0NvbGxlY3Rpb24oZWxlbWVudCkge1xuICB2YXIgZGF0YU9iamVjdCA9IGVsZW1lbnQuZGF0YU9iamVjdFJlZjtcblxuICByZXR1cm4gZWxlbWVudC5pc0NvbGxlY3Rpb24gfHwgKGRhdGFPYmplY3QgJiYgZGF0YU9iamVjdC5pc0NvbGxlY3Rpb24pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGkoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC5idXNpbmVzc09iamVjdC5kaTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlbWFudGljKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQuYnVzaW5lc3NPYmplY3Q7XG59XG5cblxuLy8gY29sb3IgYWNjZXNzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZpbGxDb2xvcihlbGVtZW50LCBkZWZhdWx0Q29sb3IpIHtcbiAgcmV0dXJuIGdldERpKGVsZW1lbnQpLmdldCgnYmlvYzpmaWxsJykgfHwgZGVmYXVsdENvbG9yIHx8ICd3aGl0ZSc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0Q29sb3IpIHtcbiAgcmV0dXJuIGdldERpKGVsZW1lbnQpLmdldCgnYmlvYzpzdHJva2UnKSB8fCBkZWZhdWx0Q29sb3IgfHwgJ2JsYWNrJztcbn1cblxuXG4vLyBjcm9wcGluZyBwYXRoIGN1c3RvbWl6YXRpb25zIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENpcmNsZVBhdGgoc2hhcGUpIHtcblxuICB2YXIgY3ggPSBzaGFwZS54ICsgc2hhcGUud2lkdGggLyAyLFxuICAgICAgY3kgPSBzaGFwZS55ICsgc2hhcGUuaGVpZ2h0IC8gMixcbiAgICAgIHJhZGl1cyA9IHNoYXBlLndpZHRoIC8gMjtcblxuICB2YXIgY2lyY2xlUGF0aCA9IFtcbiAgICBbJ00nLCBjeCwgY3ldLFxuICAgIFsnbScsIDAsIC1yYWRpdXNdLFxuICAgIFsnYScsIHJhZGl1cywgcmFkaXVzLCAwLCAxLCAxLCAwLCAyICogcmFkaXVzXSxcbiAgICBbJ2EnLCByYWRpdXMsIHJhZGl1cywgMCwgMSwgMSwgMCwgLTIgKiByYWRpdXNdLFxuICAgIFsneiddXG4gIF07XG5cbiAgcmV0dXJuIGNvbXBvbmVudHNUb1BhdGgoY2lyY2xlUGF0aCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3VuZFJlY3RQYXRoKHNoYXBlLCBib3JkZXJSYWRpdXMpIHtcblxuICB2YXIgeCA9IHNoYXBlLngsXG4gICAgICB5ID0gc2hhcGUueSxcbiAgICAgIHdpZHRoID0gc2hhcGUud2lkdGgsXG4gICAgICBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG5cbiAgdmFyIHJvdW5kUmVjdFBhdGggPSBbXG4gICAgWydNJywgeCArIGJvcmRlclJhZGl1cywgeV0sXG4gICAgWydsJywgd2lkdGggLSBib3JkZXJSYWRpdXMgKiAyLCAwXSxcbiAgICBbJ2EnLCBib3JkZXJSYWRpdXMsIGJvcmRlclJhZGl1cywgMCwgMCwgMSwgYm9yZGVyUmFkaXVzLCBib3JkZXJSYWRpdXNdLFxuICAgIFsnbCcsIDAsIGhlaWdodCAtIGJvcmRlclJhZGl1cyAqIDJdLFxuICAgIFsnYScsIGJvcmRlclJhZGl1cywgYm9yZGVyUmFkaXVzLCAwLCAwLCAxLCAtYm9yZGVyUmFkaXVzLCBib3JkZXJSYWRpdXNdLFxuICAgIFsnbCcsIGJvcmRlclJhZGl1cyAqIDIgLSB3aWR0aCwgMF0sXG4gICAgWydhJywgYm9yZGVyUmFkaXVzLCBib3JkZXJSYWRpdXMsIDAsIDAsIDEsIC1ib3JkZXJSYWRpdXMsIC1ib3JkZXJSYWRpdXNdLFxuICAgIFsnbCcsIDAsIGJvcmRlclJhZGl1cyAqIDIgLSBoZWlnaHRdLFxuICAgIFsnYScsIGJvcmRlclJhZGl1cywgYm9yZGVyUmFkaXVzLCAwLCAwLCAxLCBib3JkZXJSYWRpdXMsIC1ib3JkZXJSYWRpdXNdLFxuICAgIFsneiddXG4gIF07XG5cbiAgcmV0dXJuIGNvbXBvbmVudHNUb1BhdGgocm91bmRSZWN0UGF0aCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREaWFtb25kUGF0aChzaGFwZSkge1xuXG4gIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0LFxuICAgICAgeCA9IHNoYXBlLngsXG4gICAgICB5ID0gc2hhcGUueSxcbiAgICAgIGhhbGZXaWR0aCA9IHdpZHRoIC8gMixcbiAgICAgIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuXG4gIHZhciBkaWFtb25kUGF0aCA9IFtcbiAgICBbJ00nLCB4ICsgaGFsZldpZHRoLCB5XSxcbiAgICBbJ2wnLCBoYWxmV2lkdGgsIGhhbGZIZWlnaHRdLFxuICAgIFsnbCcsIC1oYWxmV2lkdGgsIGhhbGZIZWlnaHRdLFxuICAgIFsnbCcsIC1oYWxmV2lkdGgsIC1oYWxmSGVpZ2h0XSxcbiAgICBbJ3onXVxuICBdO1xuXG4gIHJldHVybiBjb21wb25lbnRzVG9QYXRoKGRpYW1vbmRQYXRoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlY3RQYXRoKHNoYXBlKSB7XG4gIHZhciB4ID0gc2hhcGUueCxcbiAgICAgIHkgPSBzaGFwZS55LFxuICAgICAgd2lkdGggPSBzaGFwZS53aWR0aCxcbiAgICAgIGhlaWdodCA9IHNoYXBlLmhlaWdodDtcblxuICB2YXIgcmVjdFBhdGggPSBbXG4gICAgWydNJywgeCwgeV0sXG4gICAgWydsJywgd2lkdGgsIDBdLFxuICAgIFsnbCcsIDAsIGhlaWdodF0sXG4gICAgWydsJywgLXdpZHRoLCAwXSxcbiAgICBbJ3onXVxuICBdO1xuXG4gIHJldHVybiBjb21wb25lbnRzVG9QYXRoKHJlY3RQYXRoKTtcbn0iLCJpbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuXG5pbXBvcnQge1xuICBpc09iamVjdCxcbiAgYXNzaWduLFxuICBmb3JFYWNoXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IEJhc2VSZW5kZXJlciBmcm9tICdkaWFncmFtLWpzL2xpYi9kcmF3L0Jhc2VSZW5kZXJlcic7XG5cbmltcG9ydCB7XG4gIGlzRXhwYW5kZWQsXG4gIGlzRXZlbnRTdWJQcm9jZXNzXG59IGZyb20gJy4uL3V0aWwvRGlVdGlsJztcblxuaW1wb3J0IHtcbiAgZ2V0TGFiZWxcbn0gZnJvbSAnLi4vZmVhdHVyZXMvbGFiZWwtZWRpdGluZy9MYWJlbFV0aWwnO1xuXG5pbXBvcnQgeyBpcyB9IGZyb20gJy4uL3V0aWwvTW9kZWxVdGlsJztcblxuaW1wb3J0IHtcbiAgY3JlYXRlTGluZVxufSBmcm9tICdkaWFncmFtLWpzL2xpYi91dGlsL1JlbmRlclV0aWwnO1xuXG5pbXBvcnQge1xuICBpc1R5cGVkRXZlbnQsXG4gIGlzVGhyb3dFdmVudCxcbiAgaXNDb2xsZWN0aW9uLFxuICBnZXREaSxcbiAgZ2V0U2VtYW50aWMsXG4gIGdldENpcmNsZVBhdGgsXG4gIGdldFJvdW5kUmVjdFBhdGgsXG4gIGdldERpYW1vbmRQYXRoLFxuICBnZXRSZWN0UGF0aCxcbiAgZ2V0RmlsbENvbG9yLFxuICBnZXRTdHJva2VDb2xvclxufSBmcm9tICcuL0JwbW5SZW5kZXJVdGlsJztcblxuaW1wb3J0IHtcbiAgcXVlcnkgYXMgZG9tUXVlcnlcbn0gZnJvbSAnbWluLWRvbSc7XG5cbmltcG9ydCB7XG4gIGFwcGVuZCBhcyBzdmdBcHBlbmQsXG4gIGF0dHIgYXMgc3ZnQXR0cixcbiAgY3JlYXRlIGFzIHN2Z0NyZWF0ZSxcbiAgY2xhc3NlcyBhcyBzdmdDbGFzc2VzXG59IGZyb20gJ3Rpbnktc3ZnJztcblxuaW1wb3J0IHtcbiAgcm90YXRlLFxuICB0cmFuc2Zvcm0sXG4gIHRyYW5zbGF0ZVxufSBmcm9tICdkaWFncmFtLWpzL2xpYi91dGlsL1N2Z1RyYW5zZm9ybVV0aWwnO1xuXG5pbXBvcnQgSWRzIGZyb20gJ2lkcyc7XG5cbnZhciBSRU5ERVJFUl9JRFMgPSBuZXcgSWRzKCk7XG5cbnZhciBUQVNLX0JPUkRFUl9SQURJVVMgPSAxMDtcbnZhciBJTk5FUl9PVVRFUl9ESVNUID0gMztcblxudmFyIERFRkFVTFRfRklMTF9PUEFDSVRZID0gLjk1LFxuICAgIEhJR0hfRklMTF9PUEFDSVRZID0gLjM1O1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEJwbW5SZW5kZXJlcihcbiAgICBjb25maWcsIGV2ZW50QnVzLCBzdHlsZXMsIHBhdGhNYXAsXG4gICAgY2FudmFzLCB0ZXh0UmVuZGVyZXIsIHByaW9yaXR5KSB7XG5cbiAgQmFzZVJlbmRlcmVyLmNhbGwodGhpcywgZXZlbnRCdXMsIHByaW9yaXR5KTtcblxuICB2YXIgZGVmYXVsdEZpbGxDb2xvciA9IGNvbmZpZyAmJiBjb25maWcuZGVmYXVsdEZpbGxDb2xvcixcbiAgICAgIGRlZmF1bHRTdHJva2VDb2xvciA9IGNvbmZpZyAmJiBjb25maWcuZGVmYXVsdFN0cm9rZUNvbG9yO1xuXG4gIHZhciByZW5kZXJlcklkID0gUkVOREVSRVJfSURTLm5leHQoKTtcblxuICB2YXIgbWFya2VycyA9IHt9O1xuXG4gIHZhciBjb21wdXRlU3R5bGUgPSBzdHlsZXMuY29tcHV0ZVN0eWxlO1xuXG4gIGZ1bmN0aW9uIGFkZE1hcmtlcihpZCwgb3B0aW9ucykge1xuICAgIHZhciBhdHRycyA9IGFzc2lnbih7XG4gICAgICBmaWxsOiAnYmxhY2snLFxuICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICBzdHJva2VMaW5lY2FwOiAncm91bmQnLFxuICAgICAgc3Ryb2tlRGFzaGFycmF5OiAnbm9uZSdcbiAgICB9LCBvcHRpb25zLmF0dHJzKTtcblxuICAgIHZhciByZWYgPSBvcHRpb25zLnJlZiB8fCB7IHg6IDAsIHk6IDAgfTtcblxuICAgIHZhciBzY2FsZSA9IG9wdGlvbnMuc2NhbGUgfHwgMTtcblxuICAgIC8vIGZpeCBmb3Igc2FmYXJpIC8gY2hyb21lIC8gZmlyZWZveCBidWcgbm90IGNvcnJlY3RseVxuICAgIC8vIHJlc2V0dGluZyBzdHJva2UgZGFzaCBhcnJheVxuICAgIGlmIChhdHRycy5zdHJva2VEYXNoYXJyYXkgPT09ICdub25lJykge1xuICAgICAgYXR0cnMuc3Ryb2tlRGFzaGFycmF5ID0gWzEwMDAwLCAxXTtcbiAgICB9XG5cbiAgICB2YXIgbWFya2VyID0gc3ZnQ3JlYXRlKCdtYXJrZXInKTtcblxuICAgIHN2Z0F0dHIob3B0aW9ucy5lbGVtZW50LCBhdHRycyk7XG5cbiAgICBzdmdBcHBlbmQobWFya2VyLCBvcHRpb25zLmVsZW1lbnQpO1xuXG4gICAgc3ZnQXR0cihtYXJrZXIsIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIHZpZXdCb3g6ICcwIDAgMjAgMjAnLFxuICAgICAgcmVmWDogcmVmLngsXG4gICAgICByZWZZOiByZWYueSxcbiAgICAgIG1hcmtlcldpZHRoOiAyMCAqIHNjYWxlLFxuICAgICAgbWFya2VySGVpZ2h0OiAyMCAqIHNjYWxlLFxuICAgICAgb3JpZW50OiAnYXV0bydcbiAgICB9KTtcblxuICAgIHZhciBkZWZzID0gZG9tUXVlcnkoJ2RlZnMnLCBjYW52YXMuX3N2Zyk7XG5cbiAgICBpZiAoIWRlZnMpIHtcbiAgICAgIGRlZnMgPSBzdmdDcmVhdGUoJ2RlZnMnKTtcblxuICAgICAgc3ZnQXBwZW5kKGNhbnZhcy5fc3ZnLCBkZWZzKTtcbiAgICB9XG5cbiAgICBzdmdBcHBlbmQoZGVmcywgbWFya2VyKTtcblxuICAgIG1hcmtlcnNbaWRdID0gbWFya2VyO1xuICB9XG5cbiAgZnVuY3Rpb24gY29sb3JFc2NhcGUoc3RyKSB7XG5cbiAgICAvLyBvbmx5IGFsbG93IGNoYXJhY3RlcnMgYW5kIG51bWJlcnNcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1teMC05YS16QS16XSsvZywgJ18nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtlcih0eXBlLCBmaWxsLCBzdHJva2UpIHtcbiAgICB2YXIgaWQgPSB0eXBlICsgJy0nICsgY29sb3JFc2NhcGUoZmlsbCkgKyAnLScgKyBjb2xvckVzY2FwZShzdHJva2UpICsgJy0nICsgcmVuZGVyZXJJZDtcblxuICAgIGlmICghbWFya2Vyc1tpZF0pIHtcbiAgICAgIGNyZWF0ZU1hcmtlcihpZCwgdHlwZSwgZmlsbCwgc3Ryb2tlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJ3VybCgjJyArIGlkICsgJyknO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTWFya2VyKGlkLCB0eXBlLCBmaWxsLCBzdHJva2UpIHtcblxuICAgIGlmICh0eXBlID09PSAnc2VxdWVuY2VmbG93LWVuZCcpIHtcbiAgICAgIHZhciBzZXF1ZW5jZWZsb3dFbmQgPSBzdmdDcmVhdGUoJ3BhdGgnKTtcbiAgICAgIHN2Z0F0dHIoc2VxdWVuY2VmbG93RW5kLCB7IGQ6ICdNIDEgNSBMIDExIDEwIEwgMSAxNSBaJyB9KTtcblxuICAgICAgYWRkTWFya2VyKGlkLCB7XG4gICAgICAgIGVsZW1lbnQ6IHNlcXVlbmNlZmxvd0VuZCxcbiAgICAgICAgcmVmOiB7IHg6IDExLCB5OiAxMCB9LFxuICAgICAgICBzY2FsZTogMC41LFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIGZpbGw6IHN0cm9rZSxcbiAgICAgICAgICBzdHJva2U6IHN0cm9rZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ21lc3NhZ2VmbG93LXN0YXJ0Jykge1xuICAgICAgdmFyIG1lc3NhZ2VmbG93U3RhcnQgPSBzdmdDcmVhdGUoJ2NpcmNsZScpO1xuICAgICAgc3ZnQXR0cihtZXNzYWdlZmxvd1N0YXJ0LCB7IGN4OiA2LCBjeTogNiwgcjogMy41IH0pO1xuXG4gICAgICBhZGRNYXJrZXIoaWQsIHtcbiAgICAgICAgZWxlbWVudDogbWVzc2FnZWZsb3dTdGFydCxcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBmaWxsOiBmaWxsLFxuICAgICAgICAgIHN0cm9rZTogc3Ryb2tlXG4gICAgICAgIH0sXG4gICAgICAgIHJlZjogeyB4OiA2LCB5OiA2IH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnbWVzc2FnZWZsb3ctZW5kJykge1xuICAgICAgdmFyIG1lc3NhZ2VmbG93RW5kID0gc3ZnQ3JlYXRlKCdwYXRoJyk7XG4gICAgICBzdmdBdHRyKG1lc3NhZ2VmbG93RW5kLCB7IGQ6ICdtIDEgNSBsIDAgLTMgbCA3IDMgbCAtNyAzIHonIH0pO1xuXG4gICAgICBhZGRNYXJrZXIoaWQsIHtcbiAgICAgICAgZWxlbWVudDogbWVzc2FnZWZsb3dFbmQsXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgICAgICBzdHJva2VMaW5lY2FwOiAnYnV0dCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVmOiB7IHg6IDguNSwgeTogNSB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ2Fzc29jaWF0aW9uLXN0YXJ0Jykge1xuICAgICAgdmFyIGFzc29jaWF0aW9uU3RhcnQgPSBzdmdDcmVhdGUoJ3BhdGgnKTtcbiAgICAgIHN2Z0F0dHIoYXNzb2NpYXRpb25TdGFydCwgeyBkOiAnTSAxMSA1IEwgMSAxMCBMIDExIDE1JyB9KTtcblxuICAgICAgYWRkTWFya2VyKGlkLCB7XG4gICAgICAgIGVsZW1lbnQ6IGFzc29jaWF0aW9uU3RhcnQsXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiAxLjVcbiAgICAgICAgfSxcbiAgICAgICAgcmVmOiB7IHg6IDEsIHk6IDEwIH0sXG4gICAgICAgIHNjYWxlOiAwLjVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnYXNzb2NpYXRpb24tZW5kJykge1xuICAgICAgdmFyIGFzc29jaWF0aW9uRW5kID0gc3ZnQ3JlYXRlKCdwYXRoJyk7XG4gICAgICBzdmdBdHRyKGFzc29jaWF0aW9uRW5kLCB7IGQ6ICdNIDEgNSBMIDExIDEwIEwgMSAxNScgfSk7XG5cbiAgICAgIGFkZE1hcmtlcihpZCwge1xuICAgICAgICBlbGVtZW50OiBhc3NvY2lhdGlvbkVuZCxcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBmaWxsOiAnbm9uZScsXG4gICAgICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IDEuNVxuICAgICAgICB9LFxuICAgICAgICByZWY6IHsgeDogMTIsIHk6IDEwIH0sXG4gICAgICAgIHNjYWxlOiAwLjVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnY29uZGl0aW9uYWwtZmxvdy1tYXJrZXInKSB7XG4gICAgICB2YXIgY29uZGl0aW9uYWxmbG93TWFya2VyID0gc3ZnQ3JlYXRlKCdwYXRoJyk7XG4gICAgICBzdmdBdHRyKGNvbmRpdGlvbmFsZmxvd01hcmtlciwgeyBkOiAnTSAwIDEwIEwgOCA2IEwgMTYgMTAgTCA4IDE0IFonIH0pO1xuXG4gICAgICBhZGRNYXJrZXIoaWQsIHtcbiAgICAgICAgZWxlbWVudDogY29uZGl0aW9uYWxmbG93TWFya2VyLFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIGZpbGw6IGZpbGwsXG4gICAgICAgICAgc3Ryb2tlOiBzdHJva2VcbiAgICAgICAgfSxcbiAgICAgICAgcmVmOiB7IHg6IC0xLCB5OiAxMCB9LFxuICAgICAgICBzY2FsZTogMC41XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ2NvbmRpdGlvbmFsLWRlZmF1bHQtZmxvdy1tYXJrZXInKSB7XG4gICAgICB2YXIgY29uZGl0aW9uYWxkZWZhdWx0Zmxvd01hcmtlciA9IHN2Z0NyZWF0ZSgncGF0aCcpO1xuICAgICAgc3ZnQXR0cihjb25kaXRpb25hbGRlZmF1bHRmbG93TWFya2VyLCB7IGQ6ICdNIDYgNCBMIDEwIDE2JyB9KTtcblxuICAgICAgYWRkTWFya2VyKGlkLCB7XG4gICAgICAgIGVsZW1lbnQ6IGNvbmRpdGlvbmFsZGVmYXVsdGZsb3dNYXJrZXIsXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgc3Ryb2tlOiBzdHJva2VcbiAgICAgICAgfSxcbiAgICAgICAgcmVmOiB7IHg6IDAsIHk6IDEwIH0sXG4gICAgICAgIHNjYWxlOiAwLjVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYXdDaXJjbGUocGFyZW50R2Z4LCB3aWR0aCwgaGVpZ2h0LCBvZmZzZXQsIGF0dHJzKSB7XG5cbiAgICBpZiAoaXNPYmplY3Qob2Zmc2V0KSkge1xuICAgICAgYXR0cnMgPSBvZmZzZXQ7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgYXR0cnMgPSBjb21wdXRlU3R5bGUoYXR0cnMsIHtcbiAgICAgIHN0cm9rZTogJ2JsYWNrJyxcbiAgICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgICAgZmlsbDogJ3doaXRlJ1xuICAgIH0pO1xuXG4gICAgaWYgKGF0dHJzLmZpbGwgPT09ICdub25lJykge1xuICAgICAgZGVsZXRlIGF0dHJzLmZpbGxPcGFjaXR5O1xuICAgIH1cblxuICAgIHZhciBjeCA9IHdpZHRoIC8gMixcbiAgICAgICAgY3kgPSBoZWlnaHQgLyAyO1xuXG4gICAgdmFyIGNpcmNsZSA9IHN2Z0NyZWF0ZSgnY2lyY2xlJyk7XG4gICAgc3ZnQXR0cihjaXJjbGUsIHtcbiAgICAgIGN4OiBjeCxcbiAgICAgIGN5OiBjeSxcbiAgICAgIHI6IE1hdGgucm91bmQoKHdpZHRoICsgaGVpZ2h0KSAvIDQgLSBvZmZzZXQpXG4gICAgfSk7XG4gICAgc3ZnQXR0cihjaXJjbGUsIGF0dHJzKTtcblxuICAgIHN2Z0FwcGVuZChwYXJlbnRHZngsIGNpcmNsZSk7XG5cbiAgICByZXR1cm4gY2lyY2xlO1xuICB9XG5cbiAgZnVuY3Rpb24gZHJhd1JlY3QocGFyZW50R2Z4LCB3aWR0aCwgaGVpZ2h0LCByLCBvZmZzZXQsIGF0dHJzKSB7XG5cbiAgICBpZiAoaXNPYmplY3Qob2Zmc2V0KSkge1xuICAgICAgYXR0cnMgPSBvZmZzZXQ7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgYXR0cnMgPSBjb21wdXRlU3R5bGUoYXR0cnMsIHtcbiAgICAgIHN0cm9rZTogJ2JsYWNrJyxcbiAgICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgICAgZmlsbDogJ3doaXRlJ1xuICAgIH0pO1xuXG4gICAgdmFyIHJlY3QgPSBzdmdDcmVhdGUoJ3JlY3QnKTtcbiAgICBzdmdBdHRyKHJlY3QsIHtcbiAgICAgIHg6IG9mZnNldCxcbiAgICAgIHk6IG9mZnNldCxcbiAgICAgIHdpZHRoOiB3aWR0aCAtIG9mZnNldCAqIDIsXG4gICAgICBoZWlnaHQ6IGhlaWdodCAtIG9mZnNldCAqIDIsXG4gICAgICByeDogcixcbiAgICAgIHJ5OiByXG4gICAgfSk7XG4gICAgc3ZnQXR0cihyZWN0LCBhdHRycyk7XG5cbiAgICBzdmdBcHBlbmQocGFyZW50R2Z4LCByZWN0KTtcblxuICAgIHJldHVybiByZWN0O1xuICB9XG5cbiAgZnVuY3Rpb24gZHJhd0RpYW1vbmQocGFyZW50R2Z4LCB3aWR0aCwgaGVpZ2h0LCBhdHRycykge1xuXG4gICAgdmFyIHhfMiA9IHdpZHRoIC8gMjtcbiAgICB2YXIgeV8yID0gaGVpZ2h0IC8gMjtcblxuICAgIHZhciBwb2ludHMgPSBbeyB4OiB4XzIsIHk6IDAgfSwgeyB4OiB3aWR0aCwgeTogeV8yIH0sIHsgeDogeF8yLCB5OiBoZWlnaHQgfSwgeyB4OiAwLCB5OiB5XzIgfV07XG5cbiAgICB2YXIgcG9pbnRzU3RyaW5nID0gcG9pbnRzLm1hcChmdW5jdGlvbihwb2ludCkge1xuICAgICAgcmV0dXJuIHBvaW50LnggKyAnLCcgKyBwb2ludC55O1xuICAgIH0pLmpvaW4oJyAnKTtcblxuICAgIGF0dHJzID0gY29tcHV0ZVN0eWxlKGF0dHJzLCB7XG4gICAgICBzdHJva2U6ICdibGFjaycsXG4gICAgICBzdHJva2VXaWR0aDogMixcbiAgICAgIGZpbGw6ICd3aGl0ZSdcbiAgICB9KTtcblxuICAgIHZhciBwb2x5Z29uID0gc3ZnQ3JlYXRlKCdwb2x5Z29uJyk7XG4gICAgc3ZnQXR0cihwb2x5Z29uLCB7XG4gICAgICBwb2ludHM6IHBvaW50c1N0cmluZ1xuICAgIH0pO1xuICAgIHN2Z0F0dHIocG9seWdvbiwgYXR0cnMpO1xuXG4gICAgc3ZnQXBwZW5kKHBhcmVudEdmeCwgcG9seWdvbik7XG5cbiAgICByZXR1cm4gcG9seWdvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYXdMaW5lKHBhcmVudEdmeCwgd2F5cG9pbnRzLCBhdHRycykge1xuICAgIGF0dHJzID0gY29tcHV0ZVN0eWxlKGF0dHJzLCBbICduby1maWxsJyBdLCB7XG4gICAgICBzdHJva2U6ICdibGFjaycsXG4gICAgICBzdHJva2VXaWR0aDogMixcbiAgICAgIGZpbGw6ICdub25lJ1xuICAgIH0pO1xuXG4gICAgdmFyIGxpbmUgPSBjcmVhdGVMaW5lKHdheXBvaW50cywgYXR0cnMpO1xuXG4gICAgc3ZnQXBwZW5kKHBhcmVudEdmeCwgbGluZSk7XG5cbiAgICByZXR1cm4gbGluZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYXdQYXRoKHBhcmVudEdmeCwgZCwgYXR0cnMpIHtcblxuICAgIGF0dHJzID0gY29tcHV0ZVN0eWxlKGF0dHJzLCBbICduby1maWxsJyBdLCB7XG4gICAgICBzdHJva2VXaWR0aDogMixcbiAgICAgIHN0cm9rZTogJ2JsYWNrJ1xuICAgIH0pO1xuXG4gICAgdmFyIHBhdGggPSBzdmdDcmVhdGUoJ3BhdGgnKTtcbiAgICBzdmdBdHRyKHBhdGgsIHsgZDogZCB9KTtcbiAgICBzdmdBdHRyKHBhdGgsIGF0dHJzKTtcblxuICAgIHN2Z0FwcGVuZChwYXJlbnRHZngsIHBhdGgpO1xuXG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cblxuICBmdW5jdGlvbiBkcmF3TWFya2VyKHR5cGUsIHBhcmVudEdmeCwgcGF0aCwgYXR0cnMpIHtcbiAgICByZXR1cm4gZHJhd1BhdGgocGFyZW50R2Z4LCBwYXRoLCBhc3NpZ24oeyAnZGF0YS1tYXJrZXInOiB0eXBlIH0sIGF0dHJzKSk7XG4gIH1cblxuICBmdW5jdGlvbiBhcyh0eXBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGhhbmRsZXJzW3R5cGVdKHBhcmVudEdmeCwgZWxlbWVudCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlcmVyKHR5cGUpIHtcbiAgICByZXR1cm4gaGFuZGxlcnNbdHlwZV07XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJFdmVudENvbnRlbnQoZWxlbWVudCwgcGFyZW50R2Z4KSB7XG5cbiAgICB2YXIgZXZlbnQgPSBnZXRTZW1hbnRpYyhlbGVtZW50KTtcbiAgICB2YXIgaXNUaHJvd2luZyA9IGlzVGhyb3dFdmVudChldmVudCk7XG5cbiAgICBpZiAoZXZlbnQuZXZlbnREZWZpbml0aW9ucyAmJiBldmVudC5ldmVudERlZmluaXRpb25zLmxlbmd0aD4xKSB7XG4gICAgICBpZiAoZXZlbnQucGFyYWxsZWxNdWx0aXBsZSkge1xuICAgICAgICByZXR1cm4gcmVuZGVyZXIoJ2JwbW46UGFyYWxsZWxNdWx0aXBsZUV2ZW50RGVmaW5pdGlvbicpKHBhcmVudEdmeCwgZWxlbWVudCwgaXNUaHJvd2luZyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVyKCdicG1uOk11bHRpcGxlRXZlbnREZWZpbml0aW9uJykocGFyZW50R2Z4LCBlbGVtZW50LCBpc1Rocm93aW5nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNUeXBlZEV2ZW50KGV2ZW50LCAnYnBtbjpNZXNzYWdlRXZlbnREZWZpbml0aW9uJykpIHtcbiAgICAgIHJldHVybiByZW5kZXJlcignYnBtbjpNZXNzYWdlRXZlbnREZWZpbml0aW9uJykocGFyZW50R2Z4LCBlbGVtZW50LCBpc1Rocm93aW5nKTtcbiAgICB9XG5cbiAgICBpZiAoaXNUeXBlZEV2ZW50KGV2ZW50LCAnYnBtbjpUaW1lckV2ZW50RGVmaW5pdGlvbicpKSB7XG4gICAgICByZXR1cm4gcmVuZGVyZXIoJ2JwbW46VGltZXJFdmVudERlZmluaXRpb24nKShwYXJlbnRHZngsIGVsZW1lbnQsIGlzVGhyb3dpbmcpO1xuICAgIH1cblxuICAgIGlmIChpc1R5cGVkRXZlbnQoZXZlbnQsICdicG1uOkNvbmRpdGlvbmFsRXZlbnREZWZpbml0aW9uJykpIHtcbiAgICAgIHJldHVybiByZW5kZXJlcignYnBtbjpDb25kaXRpb25hbEV2ZW50RGVmaW5pdGlvbicpKHBhcmVudEdmeCwgZWxlbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKGlzVHlwZWRFdmVudChldmVudCwgJ2JwbW46U2lnbmFsRXZlbnREZWZpbml0aW9uJykpIHtcbiAgICAgIHJldHVybiByZW5kZXJlcignYnBtbjpTaWduYWxFdmVudERlZmluaXRpb24nKShwYXJlbnRHZngsIGVsZW1lbnQsIGlzVGhyb3dpbmcpO1xuICAgIH1cblxuICAgIGlmIChpc1R5cGVkRXZlbnQoZXZlbnQsICdicG1uOkVzY2FsYXRpb25FdmVudERlZmluaXRpb24nKSkge1xuICAgICAgcmV0dXJuIHJlbmRlcmVyKCdicG1uOkVzY2FsYXRpb25FdmVudERlZmluaXRpb24nKShwYXJlbnRHZngsIGVsZW1lbnQsIGlzVGhyb3dpbmcpO1xuICAgIH1cblxuICAgIGlmIChpc1R5cGVkRXZlbnQoZXZlbnQsICdicG1uOkxpbmtFdmVudERlZmluaXRpb24nKSkge1xuICAgICAgcmV0dXJuIHJlbmRlcmVyKCdicG1uOkxpbmtFdmVudERlZmluaXRpb24nKShwYXJlbnRHZngsIGVsZW1lbnQsIGlzVGhyb3dpbmcpO1xuICAgIH1cblxuICAgIGlmIChpc1R5cGVkRXZlbnQoZXZlbnQsICdicG1uOkVycm9yRXZlbnREZWZpbml0aW9uJykpIHtcbiAgICAgIHJldHVybiByZW5kZXJlcignYnBtbjpFcnJvckV2ZW50RGVmaW5pdGlvbicpKHBhcmVudEdmeCwgZWxlbWVudCwgaXNUaHJvd2luZyk7XG4gICAgfVxuXG4gICAgaWYgKGlzVHlwZWRFdmVudChldmVudCwgJ2JwbW46Q2FuY2VsRXZlbnREZWZpbml0aW9uJykpIHtcbiAgICAgIHJldHVybiByZW5kZXJlcignYnBtbjpDYW5jZWxFdmVudERlZmluaXRpb24nKShwYXJlbnRHZngsIGVsZW1lbnQsIGlzVGhyb3dpbmcpO1xuICAgIH1cblxuICAgIGlmIChpc1R5cGVkRXZlbnQoZXZlbnQsICdicG1uOkNvbXBlbnNhdGVFdmVudERlZmluaXRpb24nKSkge1xuICAgICAgcmV0dXJuIHJlbmRlcmVyKCdicG1uOkNvbXBlbnNhdGVFdmVudERlZmluaXRpb24nKShwYXJlbnRHZngsIGVsZW1lbnQsIGlzVGhyb3dpbmcpO1xuICAgIH1cblxuICAgIGlmIChpc1R5cGVkRXZlbnQoZXZlbnQsICdicG1uOlRlcm1pbmF0ZUV2ZW50RGVmaW5pdGlvbicpKSB7XG4gICAgICByZXR1cm4gcmVuZGVyZXIoJ2JwbW46VGVybWluYXRlRXZlbnREZWZpbml0aW9uJykocGFyZW50R2Z4LCBlbGVtZW50LCBpc1Rocm93aW5nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlckxhYmVsKHBhcmVudEdmeCwgbGFiZWwsIG9wdGlvbnMpIHtcblxuICAgIG9wdGlvbnMgPSBhc3NpZ24oe1xuICAgICAgc2l6ZToge1xuICAgICAgICB3aWR0aDogMTAwXG4gICAgICB9XG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICB2YXIgdGV4dCA9IHRleHRSZW5kZXJlci5jcmVhdGVUZXh0KGxhYmVsIHx8ICcnLCBvcHRpb25zKTtcblxuICAgIHN2Z0NsYXNzZXModGV4dCkuYWRkKCdkanMtbGFiZWwnKTtcblxuICAgIHN2Z0FwcGVuZChwYXJlbnRHZngsIHRleHQpO1xuXG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJFbWJlZGRlZExhYmVsKHBhcmVudEdmeCwgZWxlbWVudCwgYWxpZ24pIHtcbiAgICB2YXIgc2VtYW50aWMgPSBnZXRTZW1hbnRpYyhlbGVtZW50KTtcblxuICAgIHJldHVybiByZW5kZXJMYWJlbChwYXJlbnRHZngsIHNlbWFudGljLm5hbWUsIHtcbiAgICAgIGJveDogZWxlbWVudCxcbiAgICAgIGFsaWduOiBhbGlnbixcbiAgICAgIHBhZGRpbmc6IDUsXG4gICAgICBzdHlsZToge1xuICAgICAgICBmaWxsOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJFeHRlcm5hbExhYmVsKHBhcmVudEdmeCwgZWxlbWVudCkge1xuXG4gICAgdmFyIGJveCA9IHtcbiAgICAgIHdpZHRoOiA5MCxcbiAgICAgIGhlaWdodDogMzAsXG4gICAgICB4OiBlbGVtZW50LndpZHRoIC8gMiArIGVsZW1lbnQueCxcbiAgICAgIHk6IGVsZW1lbnQuaGVpZ2h0IC8gMiArIGVsZW1lbnQueVxuICAgIH07XG5cbiAgICByZXR1cm4gcmVuZGVyTGFiZWwocGFyZW50R2Z4LCBnZXRMYWJlbChlbGVtZW50KSwge1xuICAgICAgYm94OiBib3gsXG4gICAgICBmaXRCb3g6IHRydWUsXG4gICAgICBzdHlsZTogYXNzaWduKFxuICAgICAgICB7fSxcbiAgICAgICAgdGV4dFJlbmRlcmVyLmdldEV4dGVybmFsU3R5bGUoKSxcbiAgICAgICAge1xuICAgICAgICAgIGZpbGw6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvcilcbiAgICAgICAgfVxuICAgICAgKVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyTGFuZUxhYmVsKHBhcmVudEdmeCwgdGV4dCwgZWxlbWVudCkge1xuICAgIHZhciB0ZXh0Qm94ID0gcmVuZGVyTGFiZWwocGFyZW50R2Z4LCB0ZXh0LCB7XG4gICAgICBib3g6IHtcbiAgICAgICAgaGVpZ2h0OiAzMCxcbiAgICAgICAgd2lkdGg6IGVsZW1lbnQuaGVpZ2h0XG4gICAgICB9LFxuICAgICAgYWxpZ246ICdjZW50ZXItbWlkZGxlJyxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGZpbGw6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvcilcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciB0b3AgPSAtMSAqIGVsZW1lbnQuaGVpZ2h0O1xuXG4gICAgdHJhbnNmb3JtKHRleHRCb3gsIDAsIC10b3AsIDI3MCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQYXRoRnJvbUNvbm5lY3Rpb24oY29ubmVjdGlvbikge1xuICAgIHZhciB3YXlwb2ludHMgPSBjb25uZWN0aW9uLndheXBvaW50cztcblxuICAgIHZhciBwYXRoRGF0YSA9ICdtICAnICsgd2F5cG9pbnRzWzBdLnggKyAnLCcgKyB3YXlwb2ludHNbMF0ueTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHdheXBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgcGF0aERhdGEgKz0gJ0wnICsgd2F5cG9pbnRzW2ldLnggKyAnLCcgKyB3YXlwb2ludHNbaV0ueSArICcgJztcbiAgICB9XG4gICAgcmV0dXJuIHBhdGhEYXRhO1xuICB9XG5cbiAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycyA9IHtcbiAgICAnYnBtbjpFdmVudCc6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMpIHtcblxuICAgICAgaWYgKCEoJ2ZpbGxPcGFjaXR5JyBpbiBhdHRycykpIHtcbiAgICAgICAgYXR0cnMuZmlsbE9wYWNpdHkgPSBERUZBVUxUX0ZJTExfT1BBQ0lUWTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRyYXdDaXJjbGUocGFyZW50R2Z4LCBlbGVtZW50LndpZHRoLCBlbGVtZW50LmhlaWdodCwgYXR0cnMpO1xuICAgIH0sXG4gICAgJ2JwbW46U3RhcnRFdmVudCc6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCkge1xuICAgICAgdmFyIGF0dHJzID0ge1xuICAgICAgICBmaWxsOiBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvciksXG4gICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKVxuICAgICAgfTtcblxuICAgICAgdmFyIHNlbWFudGljID0gZ2V0U2VtYW50aWMoZWxlbWVudCk7XG5cbiAgICAgIGlmICghc2VtYW50aWMuaXNJbnRlcnJ1cHRpbmcpIHtcbiAgICAgICAgYXR0cnMgPSB7XG4gICAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiAnNicsXG4gICAgICAgICAgc3Ryb2tlTGluZWNhcDogJ3JvdW5kJyxcbiAgICAgICAgICBmaWxsOiBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvciksXG4gICAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBjaXJjbGUgPSByZW5kZXJlcignYnBtbjpFdmVudCcpKHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMpO1xuXG4gICAgICByZW5kZXJFdmVudENvbnRlbnQoZWxlbWVudCwgcGFyZW50R2Z4KTtcblxuICAgICAgcmV0dXJuIGNpcmNsZTtcbiAgICB9LFxuICAgICdicG1uOk1lc3NhZ2VFdmVudERlZmluaXRpb24nOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQsIGlzVGhyb3dpbmcpIHtcbiAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGhNYXAuZ2V0U2NhbGVkUGF0aCgnRVZFTlRfTUVTU0FHRScsIHtcbiAgICAgICAgeFNjYWxlRmFjdG9yOiAwLjksXG4gICAgICAgIHlTY2FsZUZhY3RvcjogMC45LFxuICAgICAgICBjb250YWluZXJXaWR0aDogZWxlbWVudC53aWR0aCxcbiAgICAgICAgY29udGFpbmVySGVpZ2h0OiBlbGVtZW50LmhlaWdodCxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICBteDogMC4yMzUsXG4gICAgICAgICAgbXk6IDAuMzE1XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgZmlsbCA9IGlzVGhyb3dpbmcgPyBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpIDogZ2V0RmlsbENvbG9yKGVsZW1lbnQsIGRlZmF1bHRGaWxsQ29sb3IpO1xuICAgICAgdmFyIHN0cm9rZSA9IGlzVGhyb3dpbmcgPyBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvcikgOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpO1xuXG4gICAgICB2YXIgbWVzc2FnZVBhdGggPSBkcmF3UGF0aChwYXJlbnRHZngsIHBhdGhEYXRhLCB7XG4gICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICBmaWxsOiBmaWxsLFxuICAgICAgICBzdHJva2U6IHN0cm9rZVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBtZXNzYWdlUGF0aDtcbiAgICB9LFxuICAgICdicG1uOlRpbWVyRXZlbnREZWZpbml0aW9uJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50KSB7XG4gICAgICB2YXIgY2lyY2xlID0gZHJhd0NpcmNsZShwYXJlbnRHZngsIGVsZW1lbnQud2lkdGgsIGVsZW1lbnQuaGVpZ2h0LCAwLjIgKiBlbGVtZW50LmhlaWdodCwge1xuICAgICAgICBzdHJva2VXaWR0aDogMixcbiAgICAgICAgZmlsbDogZ2V0RmlsbENvbG9yKGVsZW1lbnQsIGRlZmF1bHRGaWxsQ29sb3IpLFxuICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvcilcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgcGF0aERhdGEgPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ0VWRU5UX1RJTUVSX1dIJywge1xuICAgICAgICB4U2NhbGVGYWN0b3I6IDAuNzUsXG4gICAgICAgIHlTY2FsZUZhY3RvcjogMC43NSxcbiAgICAgICAgY29udGFpbmVyV2lkdGg6IGVsZW1lbnQud2lkdGgsXG4gICAgICAgIGNvbnRhaW5lckhlaWdodDogZWxlbWVudC5oZWlnaHQsXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgbXg6IDAuNSxcbiAgICAgICAgICBteTogMC41XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBkcmF3UGF0aChwYXJlbnRHZngsIHBhdGhEYXRhLCB7XG4gICAgICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgICAgICBzdHJva2VMaW5lY2FwOiAnc3F1YXJlJyxcbiAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpXG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IDEyOyBpKyspIHtcblxuICAgICAgICB2YXIgbGluZVBhdGhEYXRhID0gcGF0aE1hcC5nZXRTY2FsZWRQYXRoKCdFVkVOVF9USU1FUl9MSU5FJywge1xuICAgICAgICAgIHhTY2FsZUZhY3RvcjogMC43NSxcbiAgICAgICAgICB5U2NhbGVGYWN0b3I6IDAuNzUsXG4gICAgICAgICAgY29udGFpbmVyV2lkdGg6IGVsZW1lbnQud2lkdGgsXG4gICAgICAgICAgY29udGFpbmVySGVpZ2h0OiBlbGVtZW50LmhlaWdodCxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgbXg6IDAuNSxcbiAgICAgICAgICAgIG15OiAwLjVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciB3aWR0aCA9IGVsZW1lbnQud2lkdGggLyAyO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gZWxlbWVudC5oZWlnaHQgLyAyO1xuXG4gICAgICAgIGRyYXdQYXRoKHBhcmVudEdmeCwgbGluZVBhdGhEYXRhLCB7XG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgICAgc3Ryb2tlTGluZWNhcDogJ3NxdWFyZScsXG4gICAgICAgICAgdHJhbnNmb3JtOiAncm90YXRlKCcgKyAoaSAqIDMwKSArICcsJyArIGhlaWdodCArICcsJyArIHdpZHRoICsgJyknLFxuICAgICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNpcmNsZTtcbiAgICB9LFxuICAgICdicG1uOkVzY2FsYXRpb25FdmVudERlZmluaXRpb24nOiBmdW5jdGlvbihwYXJlbnRHZngsIGV2ZW50LCBpc1Rocm93aW5nKSB7XG4gICAgICB2YXIgcGF0aERhdGEgPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ0VWRU5UX0VTQ0FMQVRJT04nLCB7XG4gICAgICAgIHhTY2FsZUZhY3RvcjogMSxcbiAgICAgICAgeVNjYWxlRmFjdG9yOiAxLFxuICAgICAgICBjb250YWluZXJXaWR0aDogZXZlbnQud2lkdGgsXG4gICAgICAgIGNvbnRhaW5lckhlaWdodDogZXZlbnQuaGVpZ2h0LFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIG14OiAwLjUsXG4gICAgICAgICAgbXk6IDAuMlxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdmFyIGZpbGwgPSBpc1Rocm93aW5nID8gZ2V0U3Ryb2tlQ29sb3IoZXZlbnQsIGRlZmF1bHRTdHJva2VDb2xvcikgOiAnbm9uZSc7XG5cbiAgICAgIHJldHVybiBkcmF3UGF0aChwYXJlbnRHZngsIHBhdGhEYXRhLCB7XG4gICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICBmaWxsOiBmaWxsLFxuICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGV2ZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpXG4gICAgICB9KTtcbiAgICB9LFxuICAgICdicG1uOkNvbmRpdGlvbmFsRXZlbnREZWZpbml0aW9uJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBldmVudCkge1xuICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aE1hcC5nZXRTY2FsZWRQYXRoKCdFVkVOVF9DT05ESVRJT05BTCcsIHtcbiAgICAgICAgeFNjYWxlRmFjdG9yOiAxLFxuICAgICAgICB5U2NhbGVGYWN0b3I6IDEsXG4gICAgICAgIGNvbnRhaW5lcldpZHRoOiBldmVudC53aWR0aCxcbiAgICAgICAgY29udGFpbmVySGVpZ2h0OiBldmVudC5oZWlnaHQsXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgbXg6IDAuNSxcbiAgICAgICAgICBteTogMC4yMjJcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBkcmF3UGF0aChwYXJlbnRHZngsIHBhdGhEYXRhLCB7XG4gICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGV2ZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpXG4gICAgICB9KTtcbiAgICB9LFxuICAgICdicG1uOkxpbmtFdmVudERlZmluaXRpb24nOiBmdW5jdGlvbihwYXJlbnRHZngsIGV2ZW50LCBpc1Rocm93aW5nKSB7XG4gICAgICB2YXIgcGF0aERhdGEgPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ0VWRU5UX0xJTksnLCB7XG4gICAgICAgIHhTY2FsZUZhY3RvcjogMSxcbiAgICAgICAgeVNjYWxlRmFjdG9yOiAxLFxuICAgICAgICBjb250YWluZXJXaWR0aDogZXZlbnQud2lkdGgsXG4gICAgICAgIGNvbnRhaW5lckhlaWdodDogZXZlbnQuaGVpZ2h0LFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIG14OiAwLjU3LFxuICAgICAgICAgIG15OiAwLjI2M1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdmFyIGZpbGwgPSBpc1Rocm93aW5nID8gZ2V0U3Ryb2tlQ29sb3IoZXZlbnQsIGRlZmF1bHRTdHJva2VDb2xvcikgOiAnbm9uZSc7XG5cbiAgICAgIHJldHVybiBkcmF3UGF0aChwYXJlbnRHZngsIHBhdGhEYXRhLCB7XG4gICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICBmaWxsOiBmaWxsLFxuICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGV2ZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpXG4gICAgICB9KTtcbiAgICB9LFxuICAgICdicG1uOkVycm9yRXZlbnREZWZpbml0aW9uJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBldmVudCwgaXNUaHJvd2luZykge1xuICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aE1hcC5nZXRTY2FsZWRQYXRoKCdFVkVOVF9FUlJPUicsIHtcbiAgICAgICAgeFNjYWxlRmFjdG9yOiAxLjEsXG4gICAgICAgIHlTY2FsZUZhY3RvcjogMS4xLFxuICAgICAgICBjb250YWluZXJXaWR0aDogZXZlbnQud2lkdGgsXG4gICAgICAgIGNvbnRhaW5lckhlaWdodDogZXZlbnQuaGVpZ2h0LFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIG14OiAwLjIsXG4gICAgICAgICAgbXk6IDAuNzIyXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgZmlsbCA9IGlzVGhyb3dpbmcgPyBnZXRTdHJva2VDb2xvcihldmVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKSA6ICdub25lJztcblxuICAgICAgcmV0dXJuIGRyYXdQYXRoKHBhcmVudEdmeCwgcGF0aERhdGEsIHtcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgIGZpbGw6IGZpbGwsXG4gICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZXZlbnQsIGRlZmF1bHRTdHJva2VDb2xvcilcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgJ2JwbW46Q2FuY2VsRXZlbnREZWZpbml0aW9uJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBldmVudCwgaXNUaHJvd2luZykge1xuICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aE1hcC5nZXRTY2FsZWRQYXRoKCdFVkVOVF9DQU5DRUxfNDUnLCB7XG4gICAgICAgIHhTY2FsZUZhY3RvcjogMS4wLFxuICAgICAgICB5U2NhbGVGYWN0b3I6IDEuMCxcbiAgICAgICAgY29udGFpbmVyV2lkdGg6IGV2ZW50LndpZHRoLFxuICAgICAgICBjb250YWluZXJIZWlnaHQ6IGV2ZW50LmhlaWdodCxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICBteDogMC42MzgsXG4gICAgICAgICAgbXk6IC0wLjA1NVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdmFyIGZpbGwgPSBpc1Rocm93aW5nID8gZ2V0U3Ryb2tlQ29sb3IoZXZlbnQsIGRlZmF1bHRTdHJva2VDb2xvcikgOiAnbm9uZSc7XG5cbiAgICAgIHZhciBwYXRoID0gZHJhd1BhdGgocGFyZW50R2Z4LCBwYXRoRGF0YSwge1xuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihldmVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKVxuICAgICAgfSk7XG5cbiAgICAgIHJvdGF0ZShwYXRoLCA0NSk7XG5cbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH0sXG4gICAgJ2JwbW46Q29tcGVuc2F0ZUV2ZW50RGVmaW5pdGlvbic6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZXZlbnQsIGlzVGhyb3dpbmcpIHtcbiAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGhNYXAuZ2V0U2NhbGVkUGF0aCgnRVZFTlRfQ09NUEVOU0FUSU9OJywge1xuICAgICAgICB4U2NhbGVGYWN0b3I6IDEsXG4gICAgICAgIHlTY2FsZUZhY3RvcjogMSxcbiAgICAgICAgY29udGFpbmVyV2lkdGg6IGV2ZW50LndpZHRoLFxuICAgICAgICBjb250YWluZXJIZWlnaHQ6IGV2ZW50LmhlaWdodCxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICBteDogMC4yMixcbiAgICAgICAgICBteTogMC41XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgZmlsbCA9IGlzVGhyb3dpbmcgPyBnZXRTdHJva2VDb2xvcihldmVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKSA6ICdub25lJztcblxuICAgICAgcmV0dXJuIGRyYXdQYXRoKHBhcmVudEdmeCwgcGF0aERhdGEsIHtcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgIGZpbGw6IGZpbGwsXG4gICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZXZlbnQsIGRlZmF1bHRTdHJva2VDb2xvcilcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgJ2JwbW46U2lnbmFsRXZlbnREZWZpbml0aW9uJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBldmVudCwgaXNUaHJvd2luZykge1xuICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aE1hcC5nZXRTY2FsZWRQYXRoKCdFVkVOVF9TSUdOQUwnLCB7XG4gICAgICAgIHhTY2FsZUZhY3RvcjogMC45LFxuICAgICAgICB5U2NhbGVGYWN0b3I6IDAuOSxcbiAgICAgICAgY29udGFpbmVyV2lkdGg6IGV2ZW50LndpZHRoLFxuICAgICAgICBjb250YWluZXJIZWlnaHQ6IGV2ZW50LmhlaWdodCxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICBteDogMC41LFxuICAgICAgICAgIG15OiAwLjJcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBmaWxsID0gaXNUaHJvd2luZyA/IGdldFN0cm9rZUNvbG9yKGV2ZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpIDogJ25vbmUnO1xuXG4gICAgICByZXR1cm4gZHJhd1BhdGgocGFyZW50R2Z4LCBwYXRoRGF0YSwge1xuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihldmVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKVxuICAgICAgfSk7XG4gICAgfSxcbiAgICAnYnBtbjpNdWx0aXBsZUV2ZW50RGVmaW5pdGlvbic6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZXZlbnQsIGlzVGhyb3dpbmcpIHtcbiAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGhNYXAuZ2V0U2NhbGVkUGF0aCgnRVZFTlRfTVVMVElQTEUnLCB7XG4gICAgICAgIHhTY2FsZUZhY3RvcjogMS4xLFxuICAgICAgICB5U2NhbGVGYWN0b3I6IDEuMSxcbiAgICAgICAgY29udGFpbmVyV2lkdGg6IGV2ZW50LndpZHRoLFxuICAgICAgICBjb250YWluZXJIZWlnaHQ6IGV2ZW50LmhlaWdodCxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICBteDogMC4yMjIsXG4gICAgICAgICAgbXk6IDAuMzZcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBmaWxsID0gaXNUaHJvd2luZyA/IGdldFN0cm9rZUNvbG9yKGV2ZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpIDogJ25vbmUnO1xuXG4gICAgICByZXR1cm4gZHJhd1BhdGgocGFyZW50R2Z4LCBwYXRoRGF0YSwge1xuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgZmlsbDogZmlsbFxuICAgICAgfSk7XG4gICAgfSxcbiAgICAnYnBtbjpQYXJhbGxlbE11bHRpcGxlRXZlbnREZWZpbml0aW9uJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBldmVudCkge1xuICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aE1hcC5nZXRTY2FsZWRQYXRoKCdFVkVOVF9QQVJBTExFTF9NVUxUSVBMRScsIHtcbiAgICAgICAgeFNjYWxlRmFjdG9yOiAxLjIsXG4gICAgICAgIHlTY2FsZUZhY3RvcjogMS4yLFxuICAgICAgICBjb250YWluZXJXaWR0aDogZXZlbnQud2lkdGgsXG4gICAgICAgIGNvbnRhaW5lckhlaWdodDogZXZlbnQuaGVpZ2h0LFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIG14OiAwLjQ1OCxcbiAgICAgICAgICBteTogMC4xOTRcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBkcmF3UGF0aChwYXJlbnRHZngsIHBhdGhEYXRhLCB7XG4gICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICBmaWxsOiBnZXRTdHJva2VDb2xvcihldmVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKSxcbiAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihldmVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKVxuICAgICAgfSk7XG4gICAgfSxcbiAgICAnYnBtbjpFbmRFdmVudCc6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCkge1xuICAgICAgdmFyIGNpcmNsZSA9IHJlbmRlcmVyKCdicG1uOkV2ZW50JykocGFyZW50R2Z4LCBlbGVtZW50LCB7XG4gICAgICAgIHN0cm9rZVdpZHRoOiA0LFxuICAgICAgICBmaWxsOiBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvciksXG4gICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKVxuICAgICAgfSk7XG5cbiAgICAgIHJlbmRlckV2ZW50Q29udGVudChlbGVtZW50LCBwYXJlbnRHZngsIHRydWUpO1xuXG4gICAgICByZXR1cm4gY2lyY2xlO1xuICAgIH0sXG4gICAgJ2JwbW46VGVybWluYXRlRXZlbnREZWZpbml0aW9uJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50KSB7XG4gICAgICB2YXIgY2lyY2xlID0gZHJhd0NpcmNsZShwYXJlbnRHZngsIGVsZW1lbnQud2lkdGgsIGVsZW1lbnQuaGVpZ2h0LCA4LCB7XG4gICAgICAgIHN0cm9rZVdpZHRoOiA0LFxuICAgICAgICBmaWxsOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpLFxuICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvcilcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gY2lyY2xlO1xuICAgIH0sXG4gICAgJ2JwbW46SW50ZXJtZWRpYXRlRXZlbnQnOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQpIHtcbiAgICAgIHZhciBvdXRlciA9IHJlbmRlcmVyKCdicG1uOkV2ZW50JykocGFyZW50R2Z4LCBlbGVtZW50LCB7XG4gICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICBmaWxsOiBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvciksXG4gICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKVxuICAgICAgfSk7XG5cbiAgICAgIC8qIGlubmVyICovXG4gICAgICBkcmF3Q2lyY2xlKHBhcmVudEdmeCwgZWxlbWVudC53aWR0aCwgZWxlbWVudC5oZWlnaHQsIElOTkVSX09VVEVSX0RJU1QsIHtcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgIGZpbGw6IGdldEZpbGxDb2xvcihlbGVtZW50LCAnbm9uZScpLFxuICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvcilcbiAgICAgIH0pO1xuXG4gICAgICByZW5kZXJFdmVudENvbnRlbnQoZWxlbWVudCwgcGFyZW50R2Z4KTtcblxuICAgICAgcmV0dXJuIG91dGVyO1xuICAgIH0sXG4gICAgJ2JwbW46SW50ZXJtZWRpYXRlQ2F0Y2hFdmVudCc6IGFzKCdicG1uOkludGVybWVkaWF0ZUV2ZW50JyksXG4gICAgJ2JwbW46SW50ZXJtZWRpYXRlVGhyb3dFdmVudCc6IGFzKCdicG1uOkludGVybWVkaWF0ZUV2ZW50JyksXG5cbiAgICAnYnBtbjpBY3Rpdml0eSc6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMpIHtcblxuICAgICAgYXR0cnMgPSBhdHRycyB8fCB7fTtcblxuICAgICAgaWYgKCEoJ2ZpbGxPcGFjaXR5JyBpbiBhdHRycykpIHtcbiAgICAgICAgYXR0cnMuZmlsbE9wYWNpdHkgPSBERUZBVUxUX0ZJTExfT1BBQ0lUWTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRyYXdSZWN0KHBhcmVudEdmeCwgZWxlbWVudC53aWR0aCwgZWxlbWVudC5oZWlnaHQsIFRBU0tfQk9SREVSX1JBRElVUywgYXR0cnMpO1xuICAgIH0sXG5cbiAgICAnYnBtbjpUYXNrJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50KSB7XG4gICAgICB2YXIgYXR0cnMgPSB7XG4gICAgICAgIGZpbGw6IGdldEZpbGxDb2xvcihlbGVtZW50LCBkZWZhdWx0RmlsbENvbG9yKSxcbiAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpXG4gICAgICB9O1xuXG4gICAgICB2YXIgcmVjdCA9IHJlbmRlcmVyKCdicG1uOkFjdGl2aXR5JykocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycyk7XG5cbiAgICAgIHJlbmRlckVtYmVkZGVkTGFiZWwocGFyZW50R2Z4LCBlbGVtZW50LCAnY2VudGVyLW1pZGRsZScpO1xuICAgICAgYXR0YWNoVGFza01hcmtlcnMocGFyZW50R2Z4LCBlbGVtZW50KTtcblxuICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfSxcbiAgICAnYnBtbjpTZXJ2aWNlVGFzayc6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCkge1xuICAgICAgdmFyIHRhc2sgPSByZW5kZXJlcignYnBtbjpUYXNrJykocGFyZW50R2Z4LCBlbGVtZW50KTtcblxuICAgICAgdmFyIHBhdGhEYXRhQkcgPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ1RBU0tfVFlQRV9TRVJWSUNFJywge1xuICAgICAgICBhYnNwb3M6IHtcbiAgICAgICAgICB4OiAxMixcbiAgICAgICAgICB5OiAxOFxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLyogc2VydmljZSBiZyAqLyBkcmF3UGF0aChwYXJlbnRHZngsIHBhdGhEYXRhQkcsIHtcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgIGZpbGw6IGdldEZpbGxDb2xvcihlbGVtZW50LCBkZWZhdWx0RmlsbENvbG9yKSxcbiAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpXG4gICAgICB9KTtcblxuICAgICAgdmFyIGZpbGxQYXRoRGF0YSA9IHBhdGhNYXAuZ2V0U2NhbGVkUGF0aCgnVEFTS19UWVBFX1NFUlZJQ0VfRklMTCcsIHtcbiAgICAgICAgYWJzcG9zOiB7XG4gICAgICAgICAgeDogMTcuMixcbiAgICAgICAgICB5OiAxOFxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLyogc2VydmljZSBmaWxsICovIGRyYXdQYXRoKHBhcmVudEdmeCwgZmlsbFBhdGhEYXRhLCB7XG4gICAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgICAgICBmaWxsOiBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvcilcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgcGF0aERhdGEgPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ1RBU0tfVFlQRV9TRVJWSUNFJywge1xuICAgICAgICBhYnNwb3M6IHtcbiAgICAgICAgICB4OiAxNyxcbiAgICAgICAgICB5OiAyMlxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLyogc2VydmljZSAqLyBkcmF3UGF0aChwYXJlbnRHZngsIHBhdGhEYXRhLCB7XG4gICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICBmaWxsOiBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvciksXG4gICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0YXNrO1xuICAgIH0sXG4gICAgJ2JwbW46VXNlclRhc2snOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQpIHtcbiAgICAgIHZhciB0YXNrID0gcmVuZGVyZXIoJ2JwbW46VGFzaycpKHBhcmVudEdmeCwgZWxlbWVudCk7XG5cbiAgICAgIHZhciB4ID0gMTU7XG4gICAgICB2YXIgeSA9IDEyO1xuXG4gICAgICB2YXIgcGF0aERhdGEgPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ1RBU0tfVFlQRV9VU0VSXzEnLCB7XG4gICAgICAgIGFic3Bvczoge1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLyogdXNlciBwYXRoICovIGRyYXdQYXRoKHBhcmVudEdmeCwgcGF0aERhdGEsIHtcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDAuNSxcbiAgICAgICAgZmlsbDogZ2V0RmlsbENvbG9yKGVsZW1lbnQsIGRlZmF1bHRGaWxsQ29sb3IpLFxuICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvcilcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgcGF0aERhdGEyID0gcGF0aE1hcC5nZXRTY2FsZWRQYXRoKCdUQVNLX1RZUEVfVVNFUl8yJywge1xuICAgICAgICBhYnNwb3M6IHtcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHlcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8qIHVzZXIyIHBhdGggKi8gZHJhd1BhdGgocGFyZW50R2Z4LCBwYXRoRGF0YTIsIHtcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDAuNSxcbiAgICAgICAgZmlsbDogZ2V0RmlsbENvbG9yKGVsZW1lbnQsIGRlZmF1bHRGaWxsQ29sb3IpLFxuICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvcilcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgcGF0aERhdGEzID0gcGF0aE1hcC5nZXRTY2FsZWRQYXRoKCdUQVNLX1RZUEVfVVNFUl8zJywge1xuICAgICAgICBhYnNwb3M6IHtcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHlcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8qIHVzZXIzIHBhdGggKi8gZHJhd1BhdGgocGFyZW50R2Z4LCBwYXRoRGF0YTMsIHtcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDAuNSxcbiAgICAgICAgZmlsbDogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKSxcbiAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRhc2s7XG4gICAgfSxcbiAgICAnYnBtbjpNYW51YWxUYXNrJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50KSB7XG4gICAgICB2YXIgdGFzayA9IHJlbmRlcmVyKCdicG1uOlRhc2snKShwYXJlbnRHZngsIGVsZW1lbnQpO1xuXG4gICAgICB2YXIgcGF0aERhdGEgPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ1RBU0tfVFlQRV9NQU5VQUwnLCB7XG4gICAgICAgIGFic3Bvczoge1xuICAgICAgICAgIHg6IDE3LFxuICAgICAgICAgIHk6IDE1XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvKiBtYW51YWwgcGF0aCAqLyBkcmF3UGF0aChwYXJlbnRHZngsIHBhdGhEYXRhLCB7XG4gICAgICAgIHN0cm9rZVdpZHRoOiAwLjUsIC8vIDAuMjUsXG4gICAgICAgIGZpbGw6IGdldEZpbGxDb2xvcihlbGVtZW50LCBkZWZhdWx0RmlsbENvbG9yKSxcbiAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRhc2s7XG4gICAgfSxcbiAgICAnYnBtbjpTZW5kVGFzayc6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCkge1xuICAgICAgdmFyIHRhc2sgPSByZW5kZXJlcignYnBtbjpUYXNrJykocGFyZW50R2Z4LCBlbGVtZW50KTtcblxuICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aE1hcC5nZXRTY2FsZWRQYXRoKCdUQVNLX1RZUEVfU0VORCcsIHtcbiAgICAgICAgeFNjYWxlRmFjdG9yOiAxLFxuICAgICAgICB5U2NhbGVGYWN0b3I6IDEsXG4gICAgICAgIGNvbnRhaW5lcldpZHRoOiAyMSxcbiAgICAgICAgY29udGFpbmVySGVpZ2h0OiAxNCxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICBteDogMC4yODUsXG4gICAgICAgICAgbXk6IDAuMzU3XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvKiBzZW5kIHBhdGggKi8gZHJhd1BhdGgocGFyZW50R2Z4LCBwYXRoRGF0YSwge1xuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgZmlsbDogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKSxcbiAgICAgICAgc3Ryb2tlOiBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvcilcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGFzaztcbiAgICB9LFxuICAgICdicG1uOlJlY2VpdmVUYXNrJyA6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCkge1xuICAgICAgdmFyIHNlbWFudGljID0gZ2V0U2VtYW50aWMoZWxlbWVudCk7XG5cbiAgICAgIHZhciB0YXNrID0gcmVuZGVyZXIoJ2JwbW46VGFzaycpKHBhcmVudEdmeCwgZWxlbWVudCk7XG4gICAgICB2YXIgcGF0aERhdGE7XG5cbiAgICAgIGlmIChzZW1hbnRpYy5pbnN0YW50aWF0ZSkge1xuICAgICAgICBkcmF3Q2lyY2xlKHBhcmVudEdmeCwgMjgsIDI4LCAyMCAqIDAuMjIsIHsgc3Ryb2tlV2lkdGg6IDEgfSk7XG5cbiAgICAgICAgcGF0aERhdGEgPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ1RBU0tfVFlQRV9JTlNUQU5USUFUSU5HX1NFTkQnLCB7XG4gICAgICAgICAgYWJzcG9zOiB7XG4gICAgICAgICAgICB4OiA3Ljc3LFxuICAgICAgICAgICAgeTogOS41MlxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHBhdGhEYXRhID0gcGF0aE1hcC5nZXRTY2FsZWRQYXRoKCdUQVNLX1RZUEVfU0VORCcsIHtcbiAgICAgICAgICB4U2NhbGVGYWN0b3I6IDAuOSxcbiAgICAgICAgICB5U2NhbGVGYWN0b3I6IDAuOSxcbiAgICAgICAgICBjb250YWluZXJXaWR0aDogMjEsXG4gICAgICAgICAgY29udGFpbmVySGVpZ2h0OiAxNCxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgbXg6IDAuMyxcbiAgICAgICAgICAgIG15OiAwLjRcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKiByZWNlaXZlIHBhdGggKi8gZHJhd1BhdGgocGFyZW50R2Z4LCBwYXRoRGF0YSwge1xuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgZmlsbDogZ2V0RmlsbENvbG9yKGVsZW1lbnQsIGRlZmF1bHRGaWxsQ29sb3IpLFxuICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvcilcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGFzaztcbiAgICB9LFxuICAgICdicG1uOlNjcmlwdFRhc2snOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQpIHtcbiAgICAgIHZhciB0YXNrID0gcmVuZGVyZXIoJ2JwbW46VGFzaycpKHBhcmVudEdmeCwgZWxlbWVudCk7XG5cbiAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGhNYXAuZ2V0U2NhbGVkUGF0aCgnVEFTS19UWVBFX1NDUklQVCcsIHtcbiAgICAgICAgYWJzcG9zOiB7XG4gICAgICAgICAgeDogMTUsXG4gICAgICAgICAgeTogMjBcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8qIHNjcmlwdCBwYXRoICovIGRyYXdQYXRoKHBhcmVudEdmeCwgcGF0aERhdGEsIHtcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0YXNrO1xuICAgIH0sXG4gICAgJ2JwbW46QnVzaW5lc3NSdWxlVGFzayc6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCkge1xuICAgICAgdmFyIHRhc2sgPSByZW5kZXJlcignYnBtbjpUYXNrJykocGFyZW50R2Z4LCBlbGVtZW50KTtcblxuICAgICAgdmFyIGhlYWRlclBhdGhEYXRhID0gcGF0aE1hcC5nZXRTY2FsZWRQYXRoKCdUQVNLX1RZUEVfQlVTSU5FU1NfUlVMRV9IRUFERVInLCB7XG4gICAgICAgIGFic3Bvczoge1xuICAgICAgICAgIHg6IDgsXG4gICAgICAgICAgeTogOFxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdmFyIGJ1c2luZXNzSGVhZGVyUGF0aCA9IGRyYXdQYXRoKHBhcmVudEdmeCwgaGVhZGVyUGF0aERhdGEpO1xuICAgICAgc3ZnQXR0cihidXNpbmVzc0hlYWRlclBhdGgsIHtcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgIGZpbGw6IGdldEZpbGxDb2xvcihlbGVtZW50LCAnI2FhYWFhYScpLFxuICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvcilcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgaGVhZGVyRGF0YSA9IHBhdGhNYXAuZ2V0U2NhbGVkUGF0aCgnVEFTS19UWVBFX0JVU0lORVNTX1JVTEVfTUFJTicsIHtcbiAgICAgICAgYWJzcG9zOiB7XG4gICAgICAgICAgeDogOCxcbiAgICAgICAgICB5OiA4XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgYnVzaW5lc3NQYXRoID0gZHJhd1BhdGgocGFyZW50R2Z4LCBoZWFkZXJEYXRhKTtcbiAgICAgIHN2Z0F0dHIoYnVzaW5lc3NQYXRoLCB7XG4gICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvcilcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGFzaztcbiAgICB9LFxuICAgICdicG1uOlN1YlByb2Nlc3MnOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICBhdHRycyA9IGFzc2lnbih7XG4gICAgICAgIGZpbGw6IGdldEZpbGxDb2xvcihlbGVtZW50LCBkZWZhdWx0RmlsbENvbG9yKSxcbiAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpXG4gICAgICB9LCBhdHRycyk7XG5cbiAgICAgIHZhciByZWN0ID0gcmVuZGVyZXIoJ2JwbW46QWN0aXZpdHknKShwYXJlbnRHZngsIGVsZW1lbnQsIGF0dHJzKTtcblxuICAgICAgdmFyIGV4cGFuZGVkID0gaXNFeHBhbmRlZChlbGVtZW50KTtcblxuICAgICAgaWYgKGlzRXZlbnRTdWJQcm9jZXNzKGVsZW1lbnQpKSB7XG4gICAgICAgIHN2Z0F0dHIocmVjdCwge1xuICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogJzEsMidcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJlbmRlckVtYmVkZGVkTGFiZWwocGFyZW50R2Z4LCBlbGVtZW50LCBleHBhbmRlZCA/ICdjZW50ZXItdG9wJyA6ICdjZW50ZXItbWlkZGxlJyk7XG5cbiAgICAgIGlmIChleHBhbmRlZCkge1xuICAgICAgICBhdHRhY2hUYXNrTWFya2VycyhwYXJlbnRHZngsIGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0YWNoVGFza01hcmtlcnMocGFyZW50R2Z4LCBlbGVtZW50LCBbJ1N1YlByb2Nlc3NNYXJrZXInXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWN0O1xuICAgIH0sXG4gICAgJ2JwbW46QWRIb2NTdWJQcm9jZXNzJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50KSB7XG4gICAgICByZXR1cm4gcmVuZGVyZXIoJ2JwbW46U3ViUHJvY2VzcycpKHBhcmVudEdmeCwgZWxlbWVudCk7XG4gICAgfSxcbiAgICAnYnBtbjpUcmFuc2FjdGlvbic6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCkge1xuICAgICAgdmFyIG91dGVyID0gcmVuZGVyZXIoJ2JwbW46U3ViUHJvY2VzcycpKHBhcmVudEdmeCwgZWxlbWVudCk7XG5cbiAgICAgIHZhciBpbm5lckF0dHJzID0gc3R5bGVzLnN0eWxlKFsgJ25vLWZpbGwnLCAnbm8tZXZlbnRzJyBdLCB7XG4gICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKVxuICAgICAgfSk7XG5cbiAgICAgIC8qIGlubmVyIHBhdGggKi8gZHJhd1JlY3QocGFyZW50R2Z4LCBlbGVtZW50LndpZHRoLCBlbGVtZW50LmhlaWdodCwgVEFTS19CT1JERVJfUkFESVVTIC0gMiwgSU5ORVJfT1VURVJfRElTVCwgaW5uZXJBdHRycyk7XG5cbiAgICAgIHJldHVybiBvdXRlcjtcbiAgICB9LFxuICAgICdicG1uOkNhbGxBY3Rpdml0eSc6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHJlbmRlcmVyKCdicG1uOlN1YlByb2Nlc3MnKShwYXJlbnRHZngsIGVsZW1lbnQsIHtcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDVcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgJ2JwbW46UGFydGljaXBhbnQnOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQpIHtcblxuICAgICAgdmFyIGF0dHJzID0ge1xuICAgICAgICBmaWxsT3BhY2l0eTogREVGQVVMVF9GSUxMX09QQUNJVFksXG4gICAgICAgIGZpbGw6IGdldEZpbGxDb2xvcihlbGVtZW50LCBkZWZhdWx0RmlsbENvbG9yKSxcbiAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpXG4gICAgICB9O1xuXG4gICAgICB2YXIgbGFuZSA9IHJlbmRlcmVyKCdicG1uOkxhbmUnKShwYXJlbnRHZngsIGVsZW1lbnQsIGF0dHJzKTtcblxuICAgICAgdmFyIGV4cGFuZGVkUG9vbCA9IGlzRXhwYW5kZWQoZWxlbWVudCk7XG5cbiAgICAgIGlmIChleHBhbmRlZFBvb2wpIHtcbiAgICAgICAgZHJhd0xpbmUocGFyZW50R2Z4LCBbXG4gICAgICAgICAgeyB4OiAzMCwgeTogMCB9LFxuICAgICAgICAgIHsgeDogMzAsIHk6IGVsZW1lbnQuaGVpZ2h0IH1cbiAgICAgICAgXSwge1xuICAgICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHRleHQgPSBnZXRTZW1hbnRpYyhlbGVtZW50KS5uYW1lO1xuICAgICAgICByZW5kZXJMYW5lTGFiZWwocGFyZW50R2Z4LCB0ZXh0LCBlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gQ29sbGFwc2VkIHBvb2wgZHJhdyB0ZXh0IGlubGluZVxuICAgICAgICB2YXIgdGV4dDIgPSBnZXRTZW1hbnRpYyhlbGVtZW50KS5uYW1lO1xuICAgICAgICByZW5kZXJMYWJlbChwYXJlbnRHZngsIHRleHQyLCB7XG4gICAgICAgICAgYm94OiBlbGVtZW50LCBhbGlnbjogJ2NlbnRlci1taWRkbGUnLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBmaWxsOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcnRpY2lwYW50TXVsdGlwbGljaXR5ID0gISEoZ2V0U2VtYW50aWMoZWxlbWVudCkucGFydGljaXBhbnRNdWx0aXBsaWNpdHkpO1xuXG4gICAgICBpZiAocGFydGljaXBhbnRNdWx0aXBsaWNpdHkpIHtcbiAgICAgICAgcmVuZGVyZXIoJ1BhcnRpY2lwYW50TXVsdGlwbGljaXR5TWFya2VyJykocGFyZW50R2Z4LCBlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxhbmU7XG4gICAgfSxcbiAgICAnYnBtbjpMYW5lJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycykge1xuICAgICAgdmFyIHJlY3QgPSBkcmF3UmVjdChwYXJlbnRHZngsIGVsZW1lbnQud2lkdGgsIGVsZW1lbnQuaGVpZ2h0LCAwLCBhc3NpZ24oe1xuICAgICAgICBmaWxsOiBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvciksXG4gICAgICAgIGZpbGxPcGFjaXR5OiBISUdIX0ZJTExfT1BBQ0lUWSxcbiAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpXG4gICAgICB9LCBhdHRycykpO1xuXG4gICAgICB2YXIgc2VtYW50aWMgPSBnZXRTZW1hbnRpYyhlbGVtZW50KTtcblxuICAgICAgaWYgKHNlbWFudGljLiR0eXBlID09PSAnYnBtbjpMYW5lJykge1xuICAgICAgICB2YXIgdGV4dCA9IHNlbWFudGljLm5hbWU7XG4gICAgICAgIHJlbmRlckxhbmVMYWJlbChwYXJlbnRHZngsIHRleHQsIGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVjdDtcbiAgICB9LFxuICAgICdicG1uOkluY2x1c2l2ZUdhdGV3YXknOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQpIHtcbiAgICAgIHZhciBkaWFtb25kID0gcmVuZGVyZXIoJ2JwbW46R2F0ZXdheScpKHBhcmVudEdmeCwgZWxlbWVudCk7XG5cbiAgICAgIC8qIGNpcmNsZSBwYXRoICovXG4gICAgICBkcmF3Q2lyY2xlKHBhcmVudEdmeCwgZWxlbWVudC53aWR0aCwgZWxlbWVudC5oZWlnaHQsIGVsZW1lbnQuaGVpZ2h0ICogMC4yNCwge1xuICAgICAgICBzdHJva2VXaWR0aDogMi41LFxuICAgICAgICBmaWxsOiBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvciksXG4gICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBkaWFtb25kO1xuICAgIH0sXG4gICAgJ2JwbW46RXhjbHVzaXZlR2F0ZXdheSc6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCkge1xuICAgICAgdmFyIGRpYW1vbmQgPSByZW5kZXJlcignYnBtbjpHYXRld2F5JykocGFyZW50R2Z4LCBlbGVtZW50KTtcblxuICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aE1hcC5nZXRTY2FsZWRQYXRoKCdHQVRFV0FZX0VYQ0xVU0lWRScsIHtcbiAgICAgICAgeFNjYWxlRmFjdG9yOiAwLjQsXG4gICAgICAgIHlTY2FsZUZhY3RvcjogMC40LFxuICAgICAgICBjb250YWluZXJXaWR0aDogZWxlbWVudC53aWR0aCxcbiAgICAgICAgY29udGFpbmVySGVpZ2h0OiBlbGVtZW50LmhlaWdodCxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICBteDogMC4zMixcbiAgICAgICAgICBteTogMC4zXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoKGdldERpKGVsZW1lbnQpLmlzTWFya2VyVmlzaWJsZSkpIHtcbiAgICAgICAgZHJhd1BhdGgocGFyZW50R2Z4LCBwYXRoRGF0YSwge1xuICAgICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICAgIGZpbGw6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvciksXG4gICAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGlhbW9uZDtcbiAgICB9LFxuICAgICdicG1uOkNvbXBsZXhHYXRld2F5JzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50KSB7XG4gICAgICB2YXIgZGlhbW9uZCA9IHJlbmRlcmVyKCdicG1uOkdhdGV3YXknKShwYXJlbnRHZngsIGVsZW1lbnQpO1xuXG4gICAgICB2YXIgcGF0aERhdGEgPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ0dBVEVXQVlfQ09NUExFWCcsIHtcbiAgICAgICAgeFNjYWxlRmFjdG9yOiAwLjUsXG4gICAgICAgIHlTY2FsZUZhY3RvcjowLjUsXG4gICAgICAgIGNvbnRhaW5lcldpZHRoOiBlbGVtZW50LndpZHRoLFxuICAgICAgICBjb250YWluZXJIZWlnaHQ6IGVsZW1lbnQuaGVpZ2h0LFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIG14OiAwLjQ2LFxuICAgICAgICAgIG15OiAwLjI2XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvKiBjb21wbGV4IHBhdGggKi8gZHJhd1BhdGgocGFyZW50R2Z4LCBwYXRoRGF0YSwge1xuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgZmlsbDogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKSxcbiAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGRpYW1vbmQ7XG4gICAgfSxcbiAgICAnYnBtbjpQYXJhbGxlbEdhdGV3YXknOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQpIHtcbiAgICAgIHZhciBkaWFtb25kID0gcmVuZGVyZXIoJ2JwbW46R2F0ZXdheScpKHBhcmVudEdmeCwgZWxlbWVudCk7XG5cbiAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGhNYXAuZ2V0U2NhbGVkUGF0aCgnR0FURVdBWV9QQVJBTExFTCcsIHtcbiAgICAgICAgeFNjYWxlRmFjdG9yOiAwLjYsXG4gICAgICAgIHlTY2FsZUZhY3RvcjowLjYsXG4gICAgICAgIGNvbnRhaW5lcldpZHRoOiBlbGVtZW50LndpZHRoLFxuICAgICAgICBjb250YWluZXJIZWlnaHQ6IGVsZW1lbnQuaGVpZ2h0LFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIG14OiAwLjQ2LFxuICAgICAgICAgIG15OiAwLjJcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8qIHBhcmFsbGVsIHBhdGggKi8gZHJhd1BhdGgocGFyZW50R2Z4LCBwYXRoRGF0YSwge1xuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgZmlsbDogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKSxcbiAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGRpYW1vbmQ7XG4gICAgfSxcbiAgICAnYnBtbjpFdmVudEJhc2VkR2F0ZXdheSc6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCkge1xuXG4gICAgICB2YXIgc2VtYW50aWMgPSBnZXRTZW1hbnRpYyhlbGVtZW50KTtcblxuICAgICAgdmFyIGRpYW1vbmQgPSByZW5kZXJlcignYnBtbjpHYXRld2F5JykocGFyZW50R2Z4LCBlbGVtZW50KTtcblxuICAgICAgLyogb3V0ZXIgY2lyY2xlIHBhdGggKi8gZHJhd0NpcmNsZShwYXJlbnRHZngsIGVsZW1lbnQud2lkdGgsIGVsZW1lbnQuaGVpZ2h0LCBlbGVtZW50LmhlaWdodCAqIDAuMjAsIHtcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpXG4gICAgICB9KTtcblxuICAgICAgdmFyIHR5cGUgPSBzZW1hbnRpYy5ldmVudEdhdGV3YXlUeXBlO1xuICAgICAgdmFyIGluc3RhbnRpYXRlID0gISFzZW1hbnRpYy5pbnN0YW50aWF0ZTtcblxuICAgICAgZnVuY3Rpb24gZHJhd0V2ZW50KCkge1xuXG4gICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGhNYXAuZ2V0U2NhbGVkUGF0aCgnR0FURVdBWV9FVkVOVF9CQVNFRCcsIHtcbiAgICAgICAgICB4U2NhbGVGYWN0b3I6IDAuMTgsXG4gICAgICAgICAgeVNjYWxlRmFjdG9yOiAwLjE4LFxuICAgICAgICAgIGNvbnRhaW5lcldpZHRoOiBlbGVtZW50LndpZHRoLFxuICAgICAgICAgIGNvbnRhaW5lckhlaWdodDogZWxlbWVudC5oZWlnaHQsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIG14OiAwLjM2LFxuICAgICAgICAgICAgbXk6IDAuNDRcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBhdHRycyA9IHtcbiAgICAgICAgICBzdHJva2VXaWR0aDogMixcbiAgICAgICAgICBmaWxsOiBnZXRGaWxsQ29sb3IoZWxlbWVudCwgJ25vbmUnKSxcbiAgICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvcilcbiAgICAgICAgfTtcblxuICAgICAgICAvKiBldmVudCBwYXRoICovIGRyYXdQYXRoKHBhcmVudEdmeCwgcGF0aERhdGEsIGF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09ICdQYXJhbGxlbCcpIHtcblxuICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ0dBVEVXQVlfUEFSQUxMRUwnLCB7XG4gICAgICAgICAgeFNjYWxlRmFjdG9yOiAwLjQsXG4gICAgICAgICAgeVNjYWxlRmFjdG9yOjAuNCxcbiAgICAgICAgICBjb250YWluZXJXaWR0aDogZWxlbWVudC53aWR0aCxcbiAgICAgICAgICBjb250YWluZXJIZWlnaHQ6IGVsZW1lbnQuaGVpZ2h0LFxuICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICBteDogMC40NzQsXG4gICAgICAgICAgICBteTogMC4yOTZcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBwYXJhbGxlbFBhdGggPSBkcmF3UGF0aChwYXJlbnRHZngsIHBhdGhEYXRhKTtcbiAgICAgICAgc3ZnQXR0cihwYXJhbGxlbFBhdGgsIHtcbiAgICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgICBmaWxsOiAnbm9uZSdcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdFeGNsdXNpdmUnKSB7XG5cbiAgICAgICAgaWYgKCFpbnN0YW50aWF0ZSkge1xuICAgICAgICAgIHZhciBpbm5lckNpcmNsZSA9IGRyYXdDaXJjbGUocGFyZW50R2Z4LCBlbGVtZW50LndpZHRoLCBlbGVtZW50LmhlaWdodCwgZWxlbWVudC5oZWlnaHQgKiAwLjI2KTtcbiAgICAgICAgICBzdmdBdHRyKGlubmVyQ2lyY2xlLCB7XG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZHJhd0V2ZW50KCk7XG4gICAgICB9XG5cblxuICAgICAgcmV0dXJuIGRpYW1vbmQ7XG4gICAgfSxcbiAgICAnYnBtbjpHYXRld2F5JzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50KSB7XG4gICAgICB2YXIgYXR0cnMgPSB7XG4gICAgICAgIGZpbGw6IGdldEZpbGxDb2xvcihlbGVtZW50LCBkZWZhdWx0RmlsbENvbG9yKSxcbiAgICAgICAgZmlsbE9wYWNpdHk6IERFRkFVTFRfRklMTF9PUEFDSVRZLFxuICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvcilcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBkcmF3RGlhbW9uZChwYXJlbnRHZngsIGVsZW1lbnQud2lkdGgsIGVsZW1lbnQuaGVpZ2h0LCBhdHRycyk7XG4gICAgfSxcbiAgICAnYnBtbjpTZXF1ZW5jZUZsb3cnOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQpIHtcbiAgICAgIHZhciBwYXRoRGF0YSA9IGNyZWF0ZVBhdGhGcm9tQ29ubmVjdGlvbihlbGVtZW50KTtcblxuICAgICAgdmFyIGZpbGwgPSBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvciksXG4gICAgICAgICAgc3Ryb2tlID0gZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKTtcblxuICAgICAgdmFyIGF0dHJzID0ge1xuICAgICAgICBzdHJva2VMaW5lam9pbjogJ3JvdW5kJyxcbiAgICAgICAgbWFya2VyRW5kOiBtYXJrZXIoJ3NlcXVlbmNlZmxvdy1lbmQnLCBmaWxsLCBzdHJva2UpLFxuICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvcilcbiAgICAgIH07XG5cbiAgICAgIHZhciBwYXRoID0gZHJhd1BhdGgocGFyZW50R2Z4LCBwYXRoRGF0YSwgYXR0cnMpO1xuXG4gICAgICB2YXIgc2VxdWVuY2VGbG93ID0gZ2V0U2VtYW50aWMoZWxlbWVudCk7XG5cbiAgICAgIHZhciBzb3VyY2U7XG5cbiAgICAgIGlmIChlbGVtZW50LnNvdXJjZSkge1xuICAgICAgICBzb3VyY2UgPSBlbGVtZW50LnNvdXJjZS5idXNpbmVzc09iamVjdDtcblxuICAgICAgICAvLyBjb25kaXRpb25hbCBmbG93IG1hcmtlclxuICAgICAgICBpZiAoc2VxdWVuY2VGbG93LmNvbmRpdGlvbkV4cHJlc3Npb24gJiYgc291cmNlLiRpbnN0YW5jZU9mKCdicG1uOkFjdGl2aXR5JykpIHtcbiAgICAgICAgICBzdmdBdHRyKHBhdGgsIHtcbiAgICAgICAgICAgIG1hcmtlclN0YXJ0OiBtYXJrZXIoJ2NvbmRpdGlvbmFsLWZsb3ctbWFya2VyJywgZmlsbCwgc3Ryb2tlKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVmYXVsdCBtYXJrZXJcbiAgICAgICAgaWYgKHNvdXJjZS5kZWZhdWx0ICYmIChzb3VyY2UuJGluc3RhbmNlT2YoJ2JwbW46R2F0ZXdheScpIHx8IHNvdXJjZS4kaW5zdGFuY2VPZignYnBtbjpBY3Rpdml0eScpKSAmJlxuICAgICAgICAgICAgc291cmNlLmRlZmF1bHQgPT09IHNlcXVlbmNlRmxvdykge1xuICAgICAgICAgIHN2Z0F0dHIocGF0aCwge1xuICAgICAgICAgICAgbWFya2VyU3RhcnQ6IG1hcmtlcignY29uZGl0aW9uYWwtZGVmYXVsdC1mbG93LW1hcmtlcicsIGZpbGwsIHN0cm9rZSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9LFxuICAgICdicG1uOkFzc29jaWF0aW9uJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycykge1xuXG4gICAgICB2YXIgc2VtYW50aWMgPSBnZXRTZW1hbnRpYyhlbGVtZW50KTtcblxuICAgICAgdmFyIGZpbGwgPSBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvciksXG4gICAgICAgICAgc3Ryb2tlID0gZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKTtcblxuICAgICAgYXR0cnMgPSBhc3NpZ24oe1xuICAgICAgICBzdHJva2VEYXNoYXJyYXk6ICcwLjUsIDUnLFxuICAgICAgICBzdHJva2VMaW5lY2FwOiAncm91bmQnLFxuICAgICAgICBzdHJva2VMaW5lam9pbjogJ3JvdW5kJyxcbiAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpXG4gICAgICB9LCBhdHRycyB8fCB7fSk7XG5cbiAgICAgIGlmIChzZW1hbnRpYy5hc3NvY2lhdGlvbkRpcmVjdGlvbiA9PT0gJ09uZScgfHxcbiAgICAgICAgICBzZW1hbnRpYy5hc3NvY2lhdGlvbkRpcmVjdGlvbiA9PT0gJ0JvdGgnKSB7XG4gICAgICAgIGF0dHJzLm1hcmtlckVuZCA9IG1hcmtlcignYXNzb2NpYXRpb24tZW5kJywgZmlsbCwgc3Ryb2tlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbWFudGljLmFzc29jaWF0aW9uRGlyZWN0aW9uID09PSAnQm90aCcpIHtcbiAgICAgICAgYXR0cnMubWFya2VyU3RhcnQgPSBtYXJrZXIoJ2Fzc29jaWF0aW9uLXN0YXJ0JywgZmlsbCwgc3Ryb2tlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRyYXdMaW5lKHBhcmVudEdmeCwgZWxlbWVudC53YXlwb2ludHMsIGF0dHJzKTtcbiAgICB9LFxuICAgICdicG1uOkRhdGFJbnB1dEFzc29jaWF0aW9uJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50KSB7XG4gICAgICB2YXIgZmlsbCA9IGdldEZpbGxDb2xvcihlbGVtZW50LCBkZWZhdWx0RmlsbENvbG9yKSxcbiAgICAgICAgICBzdHJva2UgPSBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpO1xuXG4gICAgICByZXR1cm4gcmVuZGVyZXIoJ2JwbW46QXNzb2NpYXRpb24nKShwYXJlbnRHZngsIGVsZW1lbnQsIHtcbiAgICAgICAgbWFya2VyRW5kOiBtYXJrZXIoJ2Fzc29jaWF0aW9uLWVuZCcsIGZpbGwsIHN0cm9rZSlcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgJ2JwbW46RGF0YU91dHB1dEFzc29jaWF0aW9uJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50KSB7XG4gICAgICB2YXIgZmlsbCA9IGdldEZpbGxDb2xvcihlbGVtZW50LCBkZWZhdWx0RmlsbENvbG9yKSxcbiAgICAgICAgICBzdHJva2UgPSBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpO1xuXG4gICAgICByZXR1cm4gcmVuZGVyZXIoJ2JwbW46QXNzb2NpYXRpb24nKShwYXJlbnRHZngsIGVsZW1lbnQsIHtcbiAgICAgICAgbWFya2VyRW5kOiBtYXJrZXIoJ2Fzc29jaWF0aW9uLWVuZCcsIGZpbGwsIHN0cm9rZSlcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgJ2JwbW46TWVzc2FnZUZsb3cnOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQpIHtcblxuICAgICAgdmFyIHNlbWFudGljID0gZ2V0U2VtYW50aWMoZWxlbWVudCksXG4gICAgICAgICAgZGkgPSBnZXREaShlbGVtZW50KTtcblxuICAgICAgdmFyIGZpbGwgPSBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvciksXG4gICAgICAgICAgc3Ryb2tlID0gZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKTtcblxuICAgICAgdmFyIHBhdGhEYXRhID0gY3JlYXRlUGF0aEZyb21Db25uZWN0aW9uKGVsZW1lbnQpO1xuXG4gICAgICB2YXIgYXR0cnMgPSB7XG4gICAgICAgIG1hcmtlckVuZDogbWFya2VyKCdtZXNzYWdlZmxvdy1lbmQnLCBmaWxsLCBzdHJva2UpLFxuICAgICAgICBtYXJrZXJTdGFydDogbWFya2VyKCdtZXNzYWdlZmxvdy1zdGFydCcsIGZpbGwsIHN0cm9rZSksXG4gICAgICAgIHN0cm9rZURhc2hhcnJheTogJzEwLCAxMicsXG4gICAgICAgIHN0cm9rZUxpbmVjYXA6ICdyb3VuZCcsXG4gICAgICAgIHN0cm9rZUxpbmVqb2luOiAncm91bmQnLFxuICAgICAgICBzdHJva2VXaWR0aDogJzEuNXB4JyxcbiAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpXG4gICAgICB9O1xuXG4gICAgICB2YXIgcGF0aCA9IGRyYXdQYXRoKHBhcmVudEdmeCwgcGF0aERhdGEsIGF0dHJzKTtcblxuICAgICAgaWYgKHNlbWFudGljLm1lc3NhZ2VSZWYpIHtcbiAgICAgICAgdmFyIG1pZFBvaW50ID0gcGF0aC5nZXRQb2ludEF0TGVuZ3RoKHBhdGguZ2V0VG90YWxMZW5ndGgoKSAvIDIpO1xuXG4gICAgICAgIHZhciBtYXJrZXJQYXRoRGF0YSA9IHBhdGhNYXAuZ2V0U2NhbGVkUGF0aCgnTUVTU0FHRV9GTE9XX01BUktFUicsIHtcbiAgICAgICAgICBhYnNwb3M6IHtcbiAgICAgICAgICAgIHg6IG1pZFBvaW50LngsXG4gICAgICAgICAgICB5OiBtaWRQb2ludC55XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgbWVzc2FnZUF0dHJzID0geyBzdHJva2VXaWR0aDogMSB9O1xuXG4gICAgICAgIGlmIChkaS5tZXNzYWdlVmlzaWJsZUtpbmQgPT09ICdpbml0aWF0aW5nJykge1xuICAgICAgICAgIG1lc3NhZ2VBdHRycy5maWxsID0gJ3doaXRlJztcbiAgICAgICAgICBtZXNzYWdlQXR0cnMuc3Ryb2tlID0gJ2JsYWNrJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZXNzYWdlQXR0cnMuZmlsbCA9ICcjODg4JztcbiAgICAgICAgICBtZXNzYWdlQXR0cnMuc3Ryb2tlID0gJ3doaXRlJztcbiAgICAgICAgfVxuXG4gICAgICAgIGRyYXdQYXRoKHBhcmVudEdmeCwgbWFya2VyUGF0aERhdGEsIG1lc3NhZ2VBdHRycyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH0sXG4gICAgJ2JwbW46RGF0YU9iamVjdCc6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCkge1xuICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aE1hcC5nZXRTY2FsZWRQYXRoKCdEQVRBX09CSkVDVF9QQVRIJywge1xuICAgICAgICB4U2NhbGVGYWN0b3I6IDEsXG4gICAgICAgIHlTY2FsZUZhY3RvcjogMSxcbiAgICAgICAgY29udGFpbmVyV2lkdGg6IGVsZW1lbnQud2lkdGgsXG4gICAgICAgIGNvbnRhaW5lckhlaWdodDogZWxlbWVudC5oZWlnaHQsXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgbXg6IDAuNDc0LFxuICAgICAgICAgIG15OiAwLjI5NlxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdmFyIGVsZW1lbnRPYmplY3QgPSBkcmF3UGF0aChwYXJlbnRHZngsIHBhdGhEYXRhLCB7XG4gICAgICAgIGZpbGw6IGdldEZpbGxDb2xvcihlbGVtZW50LCBkZWZhdWx0RmlsbENvbG9yKSxcbiAgICAgICAgZmlsbE9wYWNpdHk6IERFRkFVTFRfRklMTF9PUEFDSVRZLFxuICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvcilcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgc2VtYW50aWMgPSBnZXRTZW1hbnRpYyhlbGVtZW50KTtcblxuICAgICAgaWYgKGlzQ29sbGVjdGlvbihzZW1hbnRpYykpIHtcbiAgICAgICAgcmVuZGVyRGF0YUl0ZW1Db2xsZWN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGVtZW50T2JqZWN0O1xuICAgIH0sXG4gICAgJ2JwbW46RGF0YU9iamVjdFJlZmVyZW5jZSc6IGFzKCdicG1uOkRhdGFPYmplY3QnKSxcbiAgICAnYnBtbjpEYXRhSW5wdXQnOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQpIHtcblxuICAgICAgdmFyIGFycm93UGF0aERhdGEgPSBwYXRoTWFwLmdldFJhd1BhdGgoJ0RBVEFfQVJST1cnKTtcblxuICAgICAgLy8gcGFnZVxuICAgICAgdmFyIGVsZW1lbnRPYmplY3QgPSByZW5kZXJlcignYnBtbjpEYXRhT2JqZWN0JykocGFyZW50R2Z4LCBlbGVtZW50KTtcblxuICAgICAgLyogaW5wdXQgYXJyb3cgcGF0aCAqLyBkcmF3UGF0aChwYXJlbnRHZngsIGFycm93UGF0aERhdGEsIHsgc3Ryb2tlV2lkdGg6IDEgfSk7XG5cbiAgICAgIHJldHVybiBlbGVtZW50T2JqZWN0O1xuICAgIH0sXG4gICAgJ2JwbW46RGF0YU91dHB1dCc6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCkge1xuICAgICAgdmFyIGFycm93UGF0aERhdGEgPSBwYXRoTWFwLmdldFJhd1BhdGgoJ0RBVEFfQVJST1cnKTtcblxuICAgICAgLy8gcGFnZVxuICAgICAgdmFyIGVsZW1lbnRPYmplY3QgPSByZW5kZXJlcignYnBtbjpEYXRhT2JqZWN0JykocGFyZW50R2Z4LCBlbGVtZW50KTtcblxuICAgICAgLyogb3V0cHV0IGFycm93IHBhdGggKi8gZHJhd1BhdGgocGFyZW50R2Z4LCBhcnJvd1BhdGhEYXRhLCB7XG4gICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICBmaWxsOiAnYmxhY2snXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGVsZW1lbnRPYmplY3Q7XG4gICAgfSxcbiAgICAnYnBtbjpEYXRhU3RvcmVSZWZlcmVuY2UnOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQpIHtcbiAgICAgIHZhciBEQVRBX1NUT1JFX1BBVEggPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ0RBVEFfU1RPUkUnLCB7XG4gICAgICAgIHhTY2FsZUZhY3RvcjogMSxcbiAgICAgICAgeVNjYWxlRmFjdG9yOiAxLFxuICAgICAgICBjb250YWluZXJXaWR0aDogZWxlbWVudC53aWR0aCxcbiAgICAgICAgY29udGFpbmVySGVpZ2h0OiBlbGVtZW50LmhlaWdodCxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICBteDogMCxcbiAgICAgICAgICBteTogMC4xMzNcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBlbGVtZW50U3RvcmUgPSBkcmF3UGF0aChwYXJlbnRHZngsIERBVEFfU1RPUkVfUEFUSCwge1xuICAgICAgICBzdHJva2VXaWR0aDogMixcbiAgICAgICAgZmlsbDogZ2V0RmlsbENvbG9yKGVsZW1lbnQsIGRlZmF1bHRGaWxsQ29sb3IpLFxuICAgICAgICBmaWxsT3BhY2l0eTogREVGQVVMVF9GSUxMX09QQUNJVFksXG4gICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBlbGVtZW50U3RvcmU7XG4gICAgfSxcbiAgICAnYnBtbjpCb3VuZGFyeUV2ZW50JzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50KSB7XG5cbiAgICAgIHZhciBzZW1hbnRpYyA9IGdldFNlbWFudGljKGVsZW1lbnQpLFxuICAgICAgICAgIGNhbmNlbCA9IHNlbWFudGljLmNhbmNlbEFjdGl2aXR5O1xuXG4gICAgICB2YXIgYXR0cnMgPSB7XG4gICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICBmaWxsOiBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvciksXG4gICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKVxuICAgICAgfTtcblxuICAgICAgaWYgKCFjYW5jZWwpIHtcbiAgICAgICAgYXR0cnMuc3Ryb2tlRGFzaGFycmF5ID0gJzYnO1xuICAgICAgICBhdHRycy5zdHJva2VMaW5lY2FwID0gJ3JvdW5kJztcbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgZmlsbE9wYWNpdHlcbiAgICAgIHZhciBvdXRlckF0dHJzID0gYXNzaWduKHt9LCBhdHRycywge1xuICAgICAgICBmaWxsT3BhY2l0eTogMVxuICAgICAgfSk7XG5cbiAgICAgIC8vIGFwcGx5IG5vLWZpbGxcbiAgICAgIHZhciBpbm5lckF0dHJzID0gYXNzaWduKHt9LCBhdHRycywge1xuICAgICAgICBmaWxsOiAnbm9uZSdcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgb3V0ZXIgPSByZW5kZXJlcignYnBtbjpFdmVudCcpKHBhcmVudEdmeCwgZWxlbWVudCwgb3V0ZXJBdHRycyk7XG5cbiAgICAgIC8qIGlubmVyIHBhdGggKi8gZHJhd0NpcmNsZShwYXJlbnRHZngsIGVsZW1lbnQud2lkdGgsIGVsZW1lbnQuaGVpZ2h0LCBJTk5FUl9PVVRFUl9ESVNULCBpbm5lckF0dHJzKTtcblxuICAgICAgcmVuZGVyRXZlbnRDb250ZW50KGVsZW1lbnQsIHBhcmVudEdmeCk7XG5cbiAgICAgIHJldHVybiBvdXRlcjtcbiAgICB9LFxuICAgICdicG1uOkdyb3VwJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50KSB7XG5cbiAgICAgIHZhciBncm91cCA9IGRyYXdSZWN0KHBhcmVudEdmeCwgZWxlbWVudC53aWR0aCwgZWxlbWVudC5oZWlnaHQsIFRBU0tfQk9SREVSX1JBRElVUywge1xuICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvciksXG4gICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICBzdHJva2VEYXNoYXJyYXk6ICc4LDMsMSwzJyxcbiAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZSdcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfSxcbiAgICAnbGFiZWwnOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiByZW5kZXJFeHRlcm5hbExhYmVsKHBhcmVudEdmeCwgZWxlbWVudCk7XG4gICAgfSxcbiAgICAnYnBtbjpUZXh0QW5ub3RhdGlvbic6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCkge1xuICAgICAgdmFyIHN0eWxlID0ge1xuICAgICAgICAnZmlsbCc6ICdub25lJyxcbiAgICAgICAgJ3N0cm9rZSc6ICdub25lJ1xuICAgICAgfTtcblxuICAgICAgdmFyIHRleHRFbGVtZW50ID0gZHJhd1JlY3QocGFyZW50R2Z4LCBlbGVtZW50LndpZHRoLCBlbGVtZW50LmhlaWdodCwgMCwgMCwgc3R5bGUpO1xuXG4gICAgICB2YXIgdGV4dFBhdGhEYXRhID0gcGF0aE1hcC5nZXRTY2FsZWRQYXRoKCdURVhUX0FOTk9UQVRJT04nLCB7XG4gICAgICAgIHhTY2FsZUZhY3RvcjogMSxcbiAgICAgICAgeVNjYWxlRmFjdG9yOiAxLFxuICAgICAgICBjb250YWluZXJXaWR0aDogZWxlbWVudC53aWR0aCxcbiAgICAgICAgY29udGFpbmVySGVpZ2h0OiBlbGVtZW50LmhlaWdodCxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICBteDogMC4wLFxuICAgICAgICAgIG15OiAwLjBcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGRyYXdQYXRoKHBhcmVudEdmeCwgdGV4dFBhdGhEYXRhLCB7XG4gICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKVxuICAgICAgfSk7XG5cbiAgICAgIHZhciB0ZXh0ID0gZ2V0U2VtYW50aWMoZWxlbWVudCkudGV4dCB8fCAnJztcbiAgICAgIHJlbmRlckxhYmVsKHBhcmVudEdmeCwgdGV4dCwge1xuICAgICAgICBib3g6IGVsZW1lbnQsXG4gICAgICAgIGFsaWduOiAnbGVmdC10b3AnLFxuICAgICAgICBwYWRkaW5nOiA1LFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGZpbGw6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvcilcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0ZXh0RWxlbWVudDtcbiAgICB9LFxuICAgICdQYXJ0aWNpcGFudE11bHRpcGxpY2l0eU1hcmtlcic6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCkge1xuICAgICAgdmFyIG1hcmtlclBhdGggPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ01BUktFUl9QQVJBTExFTCcsIHtcbiAgICAgICAgeFNjYWxlRmFjdG9yOiAxLFxuICAgICAgICB5U2NhbGVGYWN0b3I6IDEsXG4gICAgICAgIGNvbnRhaW5lcldpZHRoOiBlbGVtZW50LndpZHRoLFxuICAgICAgICBjb250YWluZXJIZWlnaHQ6IGVsZW1lbnQuaGVpZ2h0LFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIG14OiAoKGVsZW1lbnQud2lkdGggLyAyKSAvIGVsZW1lbnQud2lkdGgpLFxuICAgICAgICAgIG15OiAoZWxlbWVudC5oZWlnaHQgLSAxNSkgLyBlbGVtZW50LmhlaWdodFxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZHJhd01hcmtlcigncGFydGljaXBhbnQtbXVsdGlwbGljaXR5JywgcGFyZW50R2Z4LCBtYXJrZXJQYXRoLCB7XG4gICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICBmaWxsOiBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvciksXG4gICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKVxuICAgICAgfSk7XG4gICAgfSxcbiAgICAnU3ViUHJvY2Vzc01hcmtlcic6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCkge1xuICAgICAgdmFyIG1hcmtlclJlY3QgPSBkcmF3UmVjdChwYXJlbnRHZngsIDE0LCAxNCwgMCwge1xuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgZmlsbDogZ2V0RmlsbENvbG9yKGVsZW1lbnQsIGRlZmF1bHRGaWxsQ29sb3IpLFxuICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvcilcbiAgICAgIH0pO1xuXG4gICAgICAvLyBQcm9jZXNzIG1hcmtlciBpcyBwbGFjZWQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgYm94XG4gICAgICAvLyB0aGVyZWZvcmUgZml4ZWQgdmFsdWVzIGNhbiBiZSB1c2VkIGhlcmVcbiAgICAgIHRyYW5zbGF0ZShtYXJrZXJSZWN0LCBlbGVtZW50LndpZHRoIC8gMiAtIDcuNSwgZWxlbWVudC5oZWlnaHQgLSAyMCk7XG5cbiAgICAgIHZhciBtYXJrZXJQYXRoID0gcGF0aE1hcC5nZXRTY2FsZWRQYXRoKCdNQVJLRVJfU1VCX1BST0NFU1MnLCB7XG4gICAgICAgIHhTY2FsZUZhY3RvcjogMS41LFxuICAgICAgICB5U2NhbGVGYWN0b3I6IDEuNSxcbiAgICAgICAgY29udGFpbmVyV2lkdGg6IGVsZW1lbnQud2lkdGgsXG4gICAgICAgIGNvbnRhaW5lckhlaWdodDogZWxlbWVudC5oZWlnaHQsXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgbXg6IChlbGVtZW50LndpZHRoIC8gMiAtIDcuNSkgLyBlbGVtZW50LndpZHRoLFxuICAgICAgICAgIG15OiAoZWxlbWVudC5oZWlnaHQgLSAyMCkgLyBlbGVtZW50LmhlaWdodFxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZHJhd01hcmtlcignc3ViLXByb2Nlc3MnLCBwYXJlbnRHZngsIG1hcmtlclBhdGgsIHtcbiAgICAgICAgZmlsbDogZ2V0RmlsbENvbG9yKGVsZW1lbnQsIGRlZmF1bHRGaWxsQ29sb3IpLFxuICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvcilcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgJ1BhcmFsbGVsTWFya2VyJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50LCBwb3NpdGlvbikge1xuICAgICAgdmFyIG1hcmtlclBhdGggPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ01BUktFUl9QQVJBTExFTCcsIHtcbiAgICAgICAgeFNjYWxlRmFjdG9yOiAxLFxuICAgICAgICB5U2NhbGVGYWN0b3I6IDEsXG4gICAgICAgIGNvbnRhaW5lcldpZHRoOiBlbGVtZW50LndpZHRoLFxuICAgICAgICBjb250YWluZXJIZWlnaHQ6IGVsZW1lbnQuaGVpZ2h0LFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIG14OiAoKGVsZW1lbnQud2lkdGggLyAyICsgcG9zaXRpb24ucGFyYWxsZWwpIC8gZWxlbWVudC53aWR0aCksXG4gICAgICAgICAgbXk6IChlbGVtZW50LmhlaWdodCAtIDIwKSAvIGVsZW1lbnQuaGVpZ2h0XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBkcmF3TWFya2VyKCdwYXJhbGxlbCcsIHBhcmVudEdmeCwgbWFya2VyUGF0aCwge1xuICAgICAgICBmaWxsOiBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvciksXG4gICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKVxuICAgICAgfSk7XG4gICAgfSxcbiAgICAnU2VxdWVudGlhbE1hcmtlcic6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCwgcG9zaXRpb24pIHtcbiAgICAgIHZhciBtYXJrZXJQYXRoID0gcGF0aE1hcC5nZXRTY2FsZWRQYXRoKCdNQVJLRVJfU0VRVUVOVElBTCcsIHtcbiAgICAgICAgeFNjYWxlRmFjdG9yOiAxLFxuICAgICAgICB5U2NhbGVGYWN0b3I6IDEsXG4gICAgICAgIGNvbnRhaW5lcldpZHRoOiBlbGVtZW50LndpZHRoLFxuICAgICAgICBjb250YWluZXJIZWlnaHQ6IGVsZW1lbnQuaGVpZ2h0LFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIG14OiAoKGVsZW1lbnQud2lkdGggLyAyICsgcG9zaXRpb24uc2VxKSAvIGVsZW1lbnQud2lkdGgpLFxuICAgICAgICAgIG15OiAoZWxlbWVudC5oZWlnaHQgLSAxOSkgLyBlbGVtZW50LmhlaWdodFxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZHJhd01hcmtlcignc2VxdWVudGlhbCcsIHBhcmVudEdmeCwgbWFya2VyUGF0aCwge1xuICAgICAgICBmaWxsOiBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvciksXG4gICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKVxuICAgICAgfSk7XG4gICAgfSxcbiAgICAnQ29tcGVuc2F0aW9uTWFya2VyJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50LCBwb3NpdGlvbikge1xuICAgICAgdmFyIG1hcmtlck1hdGggPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ01BUktFUl9DT01QRU5TQVRJT04nLCB7XG4gICAgICAgIHhTY2FsZUZhY3RvcjogMSxcbiAgICAgICAgeVNjYWxlRmFjdG9yOiAxLFxuICAgICAgICBjb250YWluZXJXaWR0aDogZWxlbWVudC53aWR0aCxcbiAgICAgICAgY29udGFpbmVySGVpZ2h0OiBlbGVtZW50LmhlaWdodCxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICBteDogKChlbGVtZW50LndpZHRoIC8gMiArIHBvc2l0aW9uLmNvbXBlbnNhdGlvbikgLyBlbGVtZW50LndpZHRoKSxcbiAgICAgICAgICBteTogKGVsZW1lbnQuaGVpZ2h0IC0gMTMpIC8gZWxlbWVudC5oZWlnaHRcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGRyYXdNYXJrZXIoJ2NvbXBlbnNhdGlvbicsIHBhcmVudEdmeCwgbWFya2VyTWF0aCwge1xuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgZmlsbDogZ2V0RmlsbENvbG9yKGVsZW1lbnQsIGRlZmF1bHRGaWxsQ29sb3IpLFxuICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvcilcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgJ0xvb3BNYXJrZXInOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgICB2YXIgbWFya2VyUGF0aCA9IHBhdGhNYXAuZ2V0U2NhbGVkUGF0aCgnTUFSS0VSX0xPT1AnLCB7XG4gICAgICAgIHhTY2FsZUZhY3RvcjogMSxcbiAgICAgICAgeVNjYWxlRmFjdG9yOiAxLFxuICAgICAgICBjb250YWluZXJXaWR0aDogZWxlbWVudC53aWR0aCxcbiAgICAgICAgY29udGFpbmVySGVpZ2h0OiBlbGVtZW50LmhlaWdodCxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICBteDogKChlbGVtZW50LndpZHRoIC8gMiArIHBvc2l0aW9uLmxvb3ApIC8gZWxlbWVudC53aWR0aCksXG4gICAgICAgICAgbXk6IChlbGVtZW50LmhlaWdodCAtIDcpIC8gZWxlbWVudC5oZWlnaHRcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGRyYXdNYXJrZXIoJ2xvb3AnLCBwYXJlbnRHZngsIG1hcmtlclBhdGgsIHtcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgIGZpbGw6IGdldEZpbGxDb2xvcihlbGVtZW50LCBkZWZhdWx0RmlsbENvbG9yKSxcbiAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpLFxuICAgICAgICBzdHJva2VMaW5lY2FwOiAncm91bmQnLFxuICAgICAgICBzdHJva2VNaXRlcmxpbWl0OiAwLjVcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgJ0FkaG9jTWFya2VyJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50LCBwb3NpdGlvbikge1xuICAgICAgdmFyIG1hcmtlclBhdGggPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ01BUktFUl9BREhPQycsIHtcbiAgICAgICAgeFNjYWxlRmFjdG9yOiAxLFxuICAgICAgICB5U2NhbGVGYWN0b3I6IDEsXG4gICAgICAgIGNvbnRhaW5lcldpZHRoOiBlbGVtZW50LndpZHRoLFxuICAgICAgICBjb250YWluZXJIZWlnaHQ6IGVsZW1lbnQuaGVpZ2h0LFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIG14OiAoKGVsZW1lbnQud2lkdGggLyAyICsgcG9zaXRpb24uYWRob2MpIC8gZWxlbWVudC53aWR0aCksXG4gICAgICAgICAgbXk6IChlbGVtZW50LmhlaWdodCAtIDE1KSAvIGVsZW1lbnQuaGVpZ2h0XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBkcmF3TWFya2VyKCdhZGhvYycsIHBhcmVudEdmeCwgbWFya2VyUGF0aCwge1xuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgZmlsbDogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKSxcbiAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gYXR0YWNoVGFza01hcmtlcnMocGFyZW50R2Z4LCBlbGVtZW50LCB0YXNrTWFya2Vycykge1xuICAgIHZhciBvYmogPSBnZXRTZW1hbnRpYyhlbGVtZW50KTtcblxuICAgIHZhciBzdWJwcm9jZXNzID0gdGFza01hcmtlcnMgJiYgdGFza01hcmtlcnMuaW5kZXhPZignU3ViUHJvY2Vzc01hcmtlcicpICE9PSAtMTtcbiAgICB2YXIgcG9zaXRpb247XG5cbiAgICBpZiAoc3VicHJvY2Vzcykge1xuICAgICAgcG9zaXRpb24gPSB7XG4gICAgICAgIHNlcTogLTIxLFxuICAgICAgICBwYXJhbGxlbDogLTIyLFxuICAgICAgICBjb21wZW5zYXRpb246IC00MixcbiAgICAgICAgbG9vcDogLTE4LFxuICAgICAgICBhZGhvYzogMTBcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvc2l0aW9uID0ge1xuICAgICAgICBzZXE6IC0zLFxuICAgICAgICBwYXJhbGxlbDogLTYsXG4gICAgICAgIGNvbXBlbnNhdGlvbjogLTI3LFxuICAgICAgICBsb29wOiAwLFxuICAgICAgICBhZGhvYzogMTBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZm9yRWFjaCh0YXNrTWFya2VycywgZnVuY3Rpb24obWFya2VyKSB7XG4gICAgICByZW5kZXJlcihtYXJrZXIpKHBhcmVudEdmeCwgZWxlbWVudCwgcG9zaXRpb24pO1xuICAgIH0pO1xuXG4gICAgaWYgKG9iai5pc0ZvckNvbXBlbnNhdGlvbikge1xuICAgICAgcmVuZGVyZXIoJ0NvbXBlbnNhdGlvbk1hcmtlcicpKHBhcmVudEdmeCwgZWxlbWVudCwgcG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmIChvYmouJHR5cGUgPT09ICdicG1uOkFkSG9jU3ViUHJvY2VzcycpIHtcbiAgICAgIHJlbmRlcmVyKCdBZGhvY01hcmtlcicpKHBhcmVudEdmeCwgZWxlbWVudCwgcG9zaXRpb24pO1xuICAgIH1cblxuICAgIHZhciBsb29wQ2hhcmFjdGVyaXN0aWNzID0gb2JqLmxvb3BDaGFyYWN0ZXJpc3RpY3MsXG4gICAgICAgIGlzU2VxdWVudGlhbCA9IGxvb3BDaGFyYWN0ZXJpc3RpY3MgJiYgbG9vcENoYXJhY3RlcmlzdGljcy5pc1NlcXVlbnRpYWw7XG5cbiAgICBpZiAobG9vcENoYXJhY3RlcmlzdGljcykge1xuXG4gICAgICBpZiAoaXNTZXF1ZW50aWFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVuZGVyZXIoJ0xvb3BNYXJrZXInKShwYXJlbnRHZngsIGVsZW1lbnQsIHBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzU2VxdWVudGlhbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmVuZGVyZXIoJ1BhcmFsbGVsTWFya2VyJykocGFyZW50R2Z4LCBlbGVtZW50LCBwb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1NlcXVlbnRpYWwgPT09IHRydWUpIHtcbiAgICAgICAgcmVuZGVyZXIoJ1NlcXVlbnRpYWxNYXJrZXInKShwYXJlbnRHZngsIGVsZW1lbnQsIHBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJEYXRhSXRlbUNvbGxlY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50KSB7XG5cbiAgICB2YXIgeVBvc2l0aW9uID0gKGVsZW1lbnQuaGVpZ2h0IC0gMTYpIC8gZWxlbWVudC5oZWlnaHQ7XG5cbiAgICB2YXIgcGF0aERhdGEgPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ0RBVEFfT0JKRUNUX0NPTExFQ1RJT05fUEFUSCcsIHtcbiAgICAgIHhTY2FsZUZhY3RvcjogMSxcbiAgICAgIHlTY2FsZUZhY3RvcjogMSxcbiAgICAgIGNvbnRhaW5lcldpZHRoOiBlbGVtZW50LndpZHRoLFxuICAgICAgY29udGFpbmVySGVpZ2h0OiBlbGVtZW50LmhlaWdodCxcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIG14OiAwLjQ1MSxcbiAgICAgICAgbXk6IHlQb3NpdGlvblxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyogY29sbGVjdGlvbiBwYXRoICovIGRyYXdQYXRoKHBhcmVudEdmeCwgcGF0aERhdGEsIHtcbiAgICAgIHN0cm9rZVdpZHRoOiAyXG4gICAgfSk7XG4gIH1cblxuXG4gIC8vIGV4dGVuc2lvbiBBUEksIHVzZSBhdCB5b3VyIG93biByaXNrXG4gIHRoaXMuX2RyYXdQYXRoID0gZHJhd1BhdGg7XG5cbn1cblxuXG5pbmhlcml0cyhCcG1uUmVuZGVyZXIsIEJhc2VSZW5kZXJlcik7XG5cbkJwbW5SZW5kZXJlci4kaW5qZWN0ID0gW1xuICAnY29uZmlnLmJwbW5SZW5kZXJlcicsXG4gICdldmVudEJ1cycsXG4gICdzdHlsZXMnLFxuICAncGF0aE1hcCcsXG4gICdjYW52YXMnLFxuICAndGV4dFJlbmRlcmVyJ1xuXTtcblxuXG5CcG1uUmVuZGVyZXIucHJvdG90eXBlLmNhblJlbmRlciA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGlzKGVsZW1lbnQsICdicG1uOkJhc2VFbGVtZW50Jyk7XG59O1xuXG5CcG1uUmVuZGVyZXIucHJvdG90eXBlLmRyYXdTaGFwZSA9IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCkge1xuICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgdmFyIGggPSB0aGlzLmhhbmRsZXJzW3R5cGVdO1xuXG4gIC8qIGpzaGludCAtVzA0MCAqL1xuICByZXR1cm4gaChwYXJlbnRHZngsIGVsZW1lbnQpO1xufTtcblxuQnBtblJlbmRlcmVyLnByb3RvdHlwZS5kcmF3Q29ubmVjdGlvbiA9IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCkge1xuICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgdmFyIGggPSB0aGlzLmhhbmRsZXJzW3R5cGVdO1xuXG4gIC8qIGpzaGludCAtVzA0MCAqL1xuICByZXR1cm4gaChwYXJlbnRHZngsIGVsZW1lbnQpO1xufTtcblxuQnBtblJlbmRlcmVyLnByb3RvdHlwZS5nZXRTaGFwZVBhdGggPSBmdW5jdGlvbihlbGVtZW50KSB7XG5cbiAgaWYgKGlzKGVsZW1lbnQsICdicG1uOkV2ZW50JykpIHtcbiAgICByZXR1cm4gZ2V0Q2lyY2xlUGF0aChlbGVtZW50KTtcbiAgfVxuXG4gIGlmIChpcyhlbGVtZW50LCAnYnBtbjpBY3Rpdml0eScpKSB7XG4gICAgcmV0dXJuIGdldFJvdW5kUmVjdFBhdGgoZWxlbWVudCwgVEFTS19CT1JERVJfUkFESVVTKTtcbiAgfVxuXG4gIGlmIChpcyhlbGVtZW50LCAnYnBtbjpHYXRld2F5JykpIHtcbiAgICByZXR1cm4gZ2V0RGlhbW9uZFBhdGgoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZ2V0UmVjdFBhdGgoZWxlbWVudCk7XG59O1xuIiwiLyoqXG4gKiBNYXAgY29udGFpbmluZyBTVkcgcGF0aHMgbmVlZGVkIGJ5IEJwbW5SZW5kZXJlci5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQYXRoTWFwKCkge1xuXG4gIC8qKlxuICAgKiBDb250YWlucyBhIG1hcCBvZiBwYXRoIGVsZW1lbnRzXG4gICAqXG4gICAqIDxoMT5QYXRoIGRlZmluaXRpb248L2gxPlxuICAgKiBBIHBhcmFtZXRlcml6ZWQgcGF0aCBpcyBkZWZpbmVkIGxpa2UgdGhpczpcbiAgICogPHByZT5cbiAgICogJ0dBVEVXQVlfUEFSQUxMRUwnOiB7XG4gICAqICAgZDogJ20ge214fSx7bXl9IHtlLngwfSwwIDAse2UueDF9IHtlLngxfSwwIDAse2UueTB9IC17ZS54MX0sMCAwLHtlLnkxfSAnICtcbiAgICAgICAgICAnLXtlLngwfSwwIDAsLXtlLnkxfSAte2UueDF9LDAgMCwte2UueTB9IHtlLngxfSwwIHonLFxuICAgKiAgIGhlaWdodDogMTcuNSxcbiAgICogICB3aWR0aDogIDE3LjUsXG4gICAqICAgaGVpZ2h0RWxlbWVudHM6IFsyLjUsIDcuNV0sXG4gICAqICAgd2lkdGhFbGVtZW50czogWzIuNSwgNy41XVxuICAgKiB9XG4gICAqIDwvcHJlPlxuICAgKiA8cD5JdCdzIGltcG9ydGFudCB0byBzcGVjaWZ5IGEgY29ycmVjdCA8Yj5oZWlnaHQgYW5kIHdpZHRoPC9iPiBmb3IgdGhlIHBhdGggYXMgdGhlIHNjYWxpbmdcbiAgICogaXMgYmFzZWQgb24gdGhlIHJhdGlvIGJldHdlZW4gdGhlIHNwZWNpZmllZCBoZWlnaHQgYW5kIHdpZHRoIGluIHRoaXMgb2JqZWN0IGFuZCB0aGVcbiAgICogaGVpZ2h0IGFuZCB3aWR0aCB0aGF0IGlzIHNldCBhcyBzY2FsZSB0YXJnZXQgKE5vdGUgeCx5IGNvb3JkaW5hdGVzIHdpbGwgYmUgc2NhbGVkIHdpdGhcbiAgICogaW5kaXZpZHVhbCByYXRpb3MpLjwvcD5cbiAgICogPHA+VGhlICc8Yj5oZWlnaHRFbGVtZW50czwvYj4nIGFuZCAnPGI+d2lkdGhFbGVtZW50czwvYj4nIGFycmF5IG11c3QgY29udGFpbiB0aGUgdmFsdWVzIHRoYXQgd2lsbCBiZSBzY2FsZWQuXG4gICAqIFRoZSBzY2FsaW5nIGlzIGJhc2VkIG9uIHRoZSBjb21wdXRlZCByYXRpb3MuXG4gICAqIENvb3JkaW5hdGVzIG9uIHRoZSB5IGF4aXMgc2hvdWxkIGJlIGluIHRoZSA8Yj5oZWlnaHRFbGVtZW50PC9iPidzIGFycmF5LCB0aGV5IHdpbGwgYmUgc2NhbGVkIHVzaW5nXG4gICAqIHRoZSBjb21wdXRlZCByYXRpbyBjb2VmZmljaWVudC5cbiAgICogSW4gdGhlIHBhcmFtZXRlcml6ZWQgcGF0aCB0aGUgc2NhbGVkIHZhbHVlcyBjYW4gYmUgYWNjZXNzZWQgdGhyb3VnaCB0aGUgJ2UnIG9iamVjdCBpbiB7fSBicmFja2V0cy5cbiAgICogICA8dWw+XG4gICAqICAgIDxsaT5UaGUgdmFsdWVzIGZvciB0aGUgeSBheGlzIGNhbiBiZSBhY2Nlc3NlZCBpbiB0aGUgcGF0aCBzdHJpbmcgdXNpbmcge2UueTB9LCB7ZS55MX0sIC4uLi48L2xpPlxuICAgKiAgICA8bGk+VGhlIHZhbHVlcyBmb3IgdGhlIHggYXhpcyBjYW4gYmUgYWNjZXNzZWQgaW4gdGhlIHBhdGggc3RyaW5nIHVzaW5nIHtlLngwfSwge2UueDF9LCAuLi4uPC9saT5cbiAgICogICA8L3VsPlxuICAgKiAgIFRoZSBudW1iZXJzIHgwLCB4MSByZXNwZWN0aXZlbHkgeTAsIHkxLCAuLi4gbWFwIHRvIHRoZSBjb3JyZXNwb25kaW5nIGFycmF5IGluZGV4LlxuICAgKiA8L3A+XG4gICAqL1xuICB0aGlzLnBhdGhNYXAgPSB7XG4gICAgJ0VWRU5UX01FU1NBR0UnOiB7XG4gICAgICBkOiAnbSB7bXh9LHtteX0gbCAwLHtlLnkxfSBsIHtlLngxfSwwIGwgMCwte2UueTF9IHogbCB7ZS54MH0se2UueTB9IGwge2UueDB9LC17ZS55MH0nLFxuICAgICAgaGVpZ2h0OiAzNixcbiAgICAgIHdpZHRoOiAgMzYsXG4gICAgICBoZWlnaHRFbGVtZW50czogWzYsIDE0XSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFsxMC41LCAyMV1cbiAgICB9LFxuICAgICdFVkVOVF9TSUdOQUwnOiB7XG4gICAgICBkOiAnTSB7bXh9LHtteX0gbCB7ZS54MH0se2UueTB9IGwgLXtlLngxfSwwIFonLFxuICAgICAgaGVpZ2h0OiAzNixcbiAgICAgIHdpZHRoOiAzNixcbiAgICAgIGhlaWdodEVsZW1lbnRzOiBbMThdLFxuICAgICAgd2lkdGhFbGVtZW50czogWzEwLCAyMF1cbiAgICB9LFxuICAgICdFVkVOVF9FU0NBTEFUSU9OJzoge1xuICAgICAgZDogJ00ge214fSx7bXl9IGwge2UueDB9LHtlLnkwfSBsIC17ZS54MH0sLXtlLnkxfSBsIC17ZS54MH0se2UueTF9IFonLFxuICAgICAgaGVpZ2h0OiAzNixcbiAgICAgIHdpZHRoOiAzNixcbiAgICAgIGhlaWdodEVsZW1lbnRzOiBbMjAsIDddLFxuICAgICAgd2lkdGhFbGVtZW50czogWzhdXG4gICAgfSxcbiAgICAnRVZFTlRfQ09ORElUSU9OQUwnOiB7XG4gICAgICBkOiAnTSB7ZS54MH0se2UueTB9IGwge2UueDF9LDAgbCAwLHtlLnkyfSBsIC17ZS54MX0sMCBaICcgK1xuICAgICAgICAgJ00ge2UueDJ9LHtlLnkzfSBsIHtlLngwfSwwICcgK1xuICAgICAgICAgJ00ge2UueDJ9LHtlLnk0fSBsIHtlLngwfSwwICcgK1xuICAgICAgICAgJ00ge2UueDJ9LHtlLnk1fSBsIHtlLngwfSwwICcgK1xuICAgICAgICAgJ00ge2UueDJ9LHtlLnk2fSBsIHtlLngwfSwwICcgK1xuICAgICAgICAgJ00ge2UueDJ9LHtlLnk3fSBsIHtlLngwfSwwICcgK1xuICAgICAgICAgJ00ge2UueDJ9LHtlLnk4fSBsIHtlLngwfSwwICcsXG4gICAgICBoZWlnaHQ6IDM2LFxuICAgICAgd2lkdGg6ICAzNixcbiAgICAgIGhlaWdodEVsZW1lbnRzOiBbOC41LCAxNC41LCAxOCwgMTEuNSwgMTQuNSwgMTcuNSwgMjAuNSwgMjMuNSwgMjYuNV0sXG4gICAgICB3aWR0aEVsZW1lbnRzOiAgWzEwLjUsIDE0LjUsIDEyLjVdXG4gICAgfSxcbiAgICAnRVZFTlRfTElOSyc6IHtcbiAgICAgIGQ6ICdtIHtteH0se215fSAwLHtlLnkwfSAte2UueDF9LDAgMCx7ZS55MX0ge2UueDF9LDAgMCx7ZS55MH0ge2UueDB9LC17ZS55Mn0gLXtlLngwfSwte2UueTJ9IHonLFxuICAgICAgaGVpZ2h0OiAzNixcbiAgICAgIHdpZHRoOiAzNixcbiAgICAgIGhlaWdodEVsZW1lbnRzOiBbNC40Mzc1LCA2Ljc1LCA3LjgxMjVdLFxuICAgICAgd2lkdGhFbGVtZW50czogWzkuODQzNzUsIDEzLjVdXG4gICAgfSxcbiAgICAnRVZFTlRfRVJST1InOiB7XG4gICAgICBkOiAnbSB7bXh9LHtteX0ge2UueDB9LC17ZS55MH0ge2UueDF9LC17ZS55MX0ge2UueDJ9LHtlLnkyfSB7ZS54M30sLXtlLnkzfSAte2UueDR9LHtlLnk0fSAte2UueDV9LC17ZS55NX0geicsXG4gICAgICBoZWlnaHQ6IDM2LFxuICAgICAgd2lkdGg6IDM2LFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFswLjAyMywgOC43MzcsIDguMTUxLCAxNi41NjQsIDEwLjU5MSwgOC43MTRdLFxuICAgICAgd2lkdGhFbGVtZW50czogWzAuMDg1LCA2LjY3MiwgNi45NywgNC4yNzMsIDUuMzM3LCA2LjYzNl1cbiAgICB9LFxuICAgICdFVkVOVF9DQU5DRUxfNDUnOiB7XG4gICAgICBkOiAnbSB7bXh9LHtteX0gLXtlLngxfSwwIDAse2UueDB9IHtlLngxfSwwIDAse2UueTF9IHtlLngwfSwwICcgK1xuICAgICAgICAnMCwte2UueTF9IHtlLngxfSwwIDAsLXtlLnkwfSAte2UueDF9LDAgMCwte2UueTF9IC17ZS54MH0sMCB6JyxcbiAgICAgIGhlaWdodDogMzYsXG4gICAgICB3aWR0aDogMzYsXG4gICAgICBoZWlnaHRFbGVtZW50czogWzQuNzUsIDguNV0sXG4gICAgICB3aWR0aEVsZW1lbnRzOiBbNC43NSwgOC41XVxuICAgIH0sXG4gICAgJ0VWRU5UX0NPTVBFTlNBVElPTic6IHtcbiAgICAgIGQ6ICdtIHtteH0se215fSB7ZS54MH0sLXtlLnkwfSAwLHtlLnkxfSB6IG0ge2UueDF9LC17ZS55Mn0ge2UueDJ9LC17ZS55M30gMCx7ZS55MX0gLXtlLngyfSwte2UueTN9IHonLFxuICAgICAgaGVpZ2h0OiAzNixcbiAgICAgIHdpZHRoOiAzNixcbiAgICAgIGhlaWdodEVsZW1lbnRzOiBbNi41LCAxMywgMC40LCA2LjFdLFxuICAgICAgd2lkdGhFbGVtZW50czogWzksIDkuMywgOC43XVxuICAgIH0sXG4gICAgJ0VWRU5UX1RJTUVSX1dIJzoge1xuICAgICAgZDogJ00ge214fSx7bXl9IGwge2UueDB9LC17ZS55MH0gbSAte2UueDB9LHtlLnkwfSBsIHtlLngxfSx7ZS55MX0gJyxcbiAgICAgIGhlaWdodDogMzYsXG4gICAgICB3aWR0aDogIDM2LFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFsxMCwgMl0sXG4gICAgICB3aWR0aEVsZW1lbnRzOiBbMywgN11cbiAgICB9LFxuICAgICdFVkVOVF9USU1FUl9MSU5FJzoge1xuICAgICAgZDogICdNIHtteH0se215fSAnICtcbiAgICAgICAgICAnbSB7ZS54MH0se2UueTB9IGwgLXtlLngxfSx7ZS55MX0gJyxcbiAgICAgIGhlaWdodDogMzYsXG4gICAgICB3aWR0aDogIDM2LFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFsxMCwgM10sXG4gICAgICB3aWR0aEVsZW1lbnRzOiBbMCwgMF1cbiAgICB9LFxuICAgICdFVkVOVF9NVUxUSVBMRSc6IHtcbiAgICAgIGQ6J20ge214fSx7bXl9IHtlLngxfSwte2UueTB9IHtlLngxfSx7ZS55MH0gLXtlLngwfSx7ZS55MX0gLXtlLngyfSwwIHonLFxuICAgICAgaGVpZ2h0OiAzNixcbiAgICAgIHdpZHRoOiAgMzYsXG4gICAgICBoZWlnaHRFbGVtZW50czogWzYuMjgwOTksIDEyLjU2MTk5XSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFszLjE0MDUsIDkuNDIxNDksIDEyLjU2MTk4XVxuICAgIH0sXG4gICAgJ0VWRU5UX1BBUkFMTEVMX01VTFRJUExFJzoge1xuICAgICAgZDonbSB7bXh9LHtteX0ge2UueDB9LDAgMCx7ZS55MX0ge2UueDF9LDAgMCx7ZS55MH0gLXtlLngxfSwwIDAse2UueTF9ICcgK1xuICAgICAgICAnLXtlLngwfSwwIDAsLXtlLnkxfSAte2UueDF9LDAgMCwte2UueTB9IHtlLngxfSwwIHonLFxuICAgICAgaGVpZ2h0OiAzNixcbiAgICAgIHdpZHRoOiAgMzYsXG4gICAgICBoZWlnaHRFbGVtZW50czogWzIuNTYyMjgsIDcuNjg2ODNdLFxuICAgICAgd2lkdGhFbGVtZW50czogWzIuNTYyMjgsIDcuNjg2ODNdXG4gICAgfSxcbiAgICAnR0FURVdBWV9FWENMVVNJVkUnOiB7XG4gICAgICBkOidtIHtteH0se215fSB7ZS54MH0se2UueTB9IHtlLngxfSx7ZS55MH0ge2UueDJ9LDAge2UueDR9LHtlLnkyfSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3tlLng0fSx7ZS55MX0ge2UueDJ9LDAge2UueDF9LHtlLnkzfSB7ZS54MH0se2UueTN9ICcgK1xuICAgICAgICAgICAgICAgICAgICAne2UueDN9LDAge2UueDV9LHtlLnkxfSB7ZS54NX0se2UueTJ9IHtlLngzfSwwIHonLFxuICAgICAgaGVpZ2h0OiAxNy41LFxuICAgICAgd2lkdGg6ICAxNy41LFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFs4LjUsIDYuNTMxMiwgLTYuNTMxMiwgLTguNV0sXG4gICAgICB3aWR0aEVsZW1lbnRzOiAgWzYuNSwgLTYuNSwgMywgLTMsIDUsIC01XVxuICAgIH0sXG4gICAgJ0dBVEVXQVlfUEFSQUxMRUwnOiB7XG4gICAgICBkOidtIHtteH0se215fSAwLHtlLnkxfSAte2UueDF9LDAgMCx7ZS55MH0ge2UueDF9LDAgMCx7ZS55MX0ge2UueDB9LDAgJyArXG4gICAgICAgICcwLC17ZS55MX0ge2UueDF9LDAgMCwte2UueTB9IC17ZS54MX0sMCAwLC17ZS55MX0gLXtlLngwfSwwIHonLFxuICAgICAgaGVpZ2h0OiAzMCxcbiAgICAgIHdpZHRoOiAgMzAsXG4gICAgICBoZWlnaHRFbGVtZW50czogWzUsIDEyLjVdLFxuICAgICAgd2lkdGhFbGVtZW50czogWzUsIDEyLjVdXG4gICAgfSxcbiAgICAnR0FURVdBWV9FVkVOVF9CQVNFRCc6IHtcbiAgICAgIGQ6J20ge214fSx7bXl9IHtlLngwfSx7ZS55MH0ge2UueDB9LHtlLnkxfSB7ZS54MX0se2UueTJ9IHtlLngyfSwwIHonLFxuICAgICAgaGVpZ2h0OiAxMSxcbiAgICAgIHdpZHRoOiAgMTEsXG4gICAgICBoZWlnaHRFbGVtZW50czogWy02LCA2LCAxMiwgLTEyXSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFs5LCAtMywgLTEyXVxuICAgIH0sXG4gICAgJ0dBVEVXQVlfQ09NUExFWCc6IHtcbiAgICAgIGQ6J20ge214fSx7bXl9IDAse2UueTB9IC17ZS54MH0sLXtlLnkxfSAte2UueDF9LHtlLnkyfSB7ZS54MH0se2UueTF9IC17ZS54Mn0sMCAwLHtlLnkzfSAnICtcbiAgICAgICAgJ3tlLngyfSwwICAte2UueDB9LHtlLnkxfSBsIHtlLngxfSx7ZS55Mn0ge2UueDB9LC17ZS55MX0gMCx7ZS55MH0ge2UueDN9LDAgMCwte2UueTB9IHtlLngwfSx7ZS55MX0gJyArXG4gICAgICAgICd7ZS54MX0sLXtlLnkyfSAte2UueDB9LC17ZS55MX0ge2UueDJ9LDAgMCwte2UueTN9IC17ZS54Mn0sMCB7ZS54MH0sLXtlLnkxfSAte2UueDF9LC17ZS55Mn0gJyArXG4gICAgICAgICcte2UueDB9LHtlLnkxfSAwLC17ZS55MH0gLXtlLngzfSwwIHonLFxuICAgICAgaGVpZ2h0OiAxNy4xMjUsXG4gICAgICB3aWR0aDogIDE3LjEyNSxcbiAgICAgIGhlaWdodEVsZW1lbnRzOiBbNC44NzUsIDMuNDM3NSwgMi4xMjUsIDNdLFxuICAgICAgd2lkdGhFbGVtZW50czogWzMuNDM3NSwgMi4xMjUsIDQuODc1LCAzXVxuICAgIH0sXG4gICAgJ0RBVEFfT0JKRUNUX1BBVEgnOiB7XG4gICAgICBkOidtIDAsMCB7ZS54MX0sMCB7ZS54MH0se2UueTB9IDAse2UueTF9IC17ZS54Mn0sMCAwLC17ZS55Mn0ge2UueDF9LDAgMCx7ZS55MH0ge2UueDB9LDAnLFxuICAgICAgaGVpZ2h0OiA2MSxcbiAgICAgIHdpZHRoOiAgNTEsXG4gICAgICBoZWlnaHRFbGVtZW50czogWzEwLCA1MCwgNjBdLFxuICAgICAgd2lkdGhFbGVtZW50czogWzEwLCA0MCwgNTAsIDYwXVxuICAgIH0sXG4gICAgJ0RBVEFfT0JKRUNUX0NPTExFQ1RJT05fUEFUSCc6IHtcbiAgICAgIGQ6J20ge214fSwge215fSAnICtcbiAgICAgICAgJ20gIDAgMTUgIGwgMCAtMTUgJyArXG4gICAgICAgICdtICA0IDE1ICBsIDAgLTE1ICcgK1xuICAgICAgICAnbSAgNCAxNSAgbCAwIC0xNSAnLFxuICAgICAgaGVpZ2h0OiA2MSxcbiAgICAgIHdpZHRoOiAgNTEsXG4gICAgICBoZWlnaHRFbGVtZW50czogWzEyXSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFsxLCA2LCAxMiwgMTVdXG4gICAgfSxcbiAgICAnREFUQV9BUlJPVyc6IHtcbiAgICAgIGQ6J20gNSw5IDksMCAwLC0zIDUsNSAtNSw1IDAsLTMgLTksMCB6JyxcbiAgICAgIGhlaWdodDogNjEsXG4gICAgICB3aWR0aDogIDUxLFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFtdLFxuICAgICAgd2lkdGhFbGVtZW50czogW11cbiAgICB9LFxuICAgICdEQVRBX1NUT1JFJzoge1xuICAgICAgZDonbSAge214fSx7bXl9ICcgK1xuICAgICAgICAnbCAgMCx7ZS55Mn0gJyArXG4gICAgICAgICdjICB7ZS54MH0se2UueTF9IHtlLngxfSx7ZS55MX0gIHtlLngyfSwwICcgK1xuICAgICAgICAnbCAgMCwte2UueTJ9ICcgK1xuICAgICAgICAnYyAte2UueDB9LC17ZS55MX0gLXtlLngxfSwte2UueTF9IC17ZS54Mn0sMCcgK1xuICAgICAgICAnYyAge2UueDB9LHtlLnkxfSB7ZS54MX0se2UueTF9ICB7ZS54Mn0sMCAnICtcbiAgICAgICAgJ20gIC17ZS54Mn0se2UueTB9JyArXG4gICAgICAgICdjICB7ZS54MH0se2UueTF9IHtlLngxfSx7ZS55MX0ge2UueDJ9LDAnICtcbiAgICAgICAgJ20gIC17ZS54Mn0se2UueTB9JyArXG4gICAgICAgICdjICB7ZS54MH0se2UueTF9IHtlLngxfSx7ZS55MX0gIHtlLngyfSwwJyxcbiAgICAgIGhlaWdodDogNjEsXG4gICAgICB3aWR0aDogIDYxLFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFs3LCAxMCwgNDVdLFxuICAgICAgd2lkdGhFbGVtZW50czogIFsyLCA1OCwgNjBdXG4gICAgfSxcbiAgICAnVEVYVF9BTk5PVEFUSU9OJzoge1xuICAgICAgZDogJ20ge214fSwge215fSBtIDEwLDAgbCAtMTAsMCBsIDAse2UueTB9IGwgMTAsMCcsXG4gICAgICBoZWlnaHQ6IDMwLFxuICAgICAgd2lkdGg6IDEwLFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFszMF0sXG4gICAgICB3aWR0aEVsZW1lbnRzOiBbMTBdXG4gICAgfSxcbiAgICAnTUFSS0VSX1NVQl9QUk9DRVNTJzoge1xuICAgICAgZDogJ217bXh9LHtteX0gbSA3LDIgbCAwLDEwIG0gLTUsLTUgbCAxMCwwJyxcbiAgICAgIGhlaWdodDogMTAsXG4gICAgICB3aWR0aDogMTAsXG4gICAgICBoZWlnaHRFbGVtZW50czogW10sXG4gICAgICB3aWR0aEVsZW1lbnRzOiBbXVxuICAgIH0sXG4gICAgJ01BUktFUl9QQVJBTExFTCc6IHtcbiAgICAgIGQ6ICdte214fSx7bXl9IG0gMywyIGwgMCwxMCBtIDMsLTEwIGwgMCwxMCBtIDMsLTEwIGwgMCwxMCcsXG4gICAgICBoZWlnaHQ6IDEwLFxuICAgICAgd2lkdGg6IDEwLFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFtdLFxuICAgICAgd2lkdGhFbGVtZW50czogW11cbiAgICB9LFxuICAgICdNQVJLRVJfU0VRVUVOVElBTCc6IHtcbiAgICAgIGQ6ICdte214fSx7bXl9IG0gMCwzIGwgMTAsMCBtIC0xMCwzIGwgMTAsMCBtIC0xMCwzIGwgMTAsMCcsXG4gICAgICBoZWlnaHQ6IDEwLFxuICAgICAgd2lkdGg6IDEwLFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFtdLFxuICAgICAgd2lkdGhFbGVtZW50czogW11cbiAgICB9LFxuICAgICdNQVJLRVJfQ09NUEVOU0FUSU9OJzoge1xuICAgICAgZDogJ20ge214fSx7bXl9IDcsLTUgMCwxMCB6IG0gNy4xLC0wLjMgNi45LC00LjcgMCwxMCAtNi45LC00LjcgeicsXG4gICAgICBoZWlnaHQ6IDEwLFxuICAgICAgd2lkdGg6IDIxLFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFtdLFxuICAgICAgd2lkdGhFbGVtZW50czogW11cbiAgICB9LFxuICAgICdNQVJLRVJfTE9PUCc6IHtcbiAgICAgIGQ6ICdtIHtteH0se215fSBjIDMuNTI2OTc5LDAgNi4zODYxNjEsLTIuODI5ODU4IDYuMzg2MTYxLC02LjMyMDY2MSAwLC0zLjQ5MDgwNiAtMi44NTkxODIsLTYuMzIwNjYxICcgK1xuICAgICAgICAnLTYuMzg2MTYxLC02LjMyMDY2MSAtMy41MjY5NzgsMCAtNi4zODYxNiwyLjgyOTg1NSAtNi4zODYxNiw2LjMyMDY2MSAwLDEuNzQ1NDAyICcgK1xuICAgICAgICAnMC43MTQ3OTcsMy4zMjU1NjcgMS44NzA0NjMsNC40NjkzODEgMC41Nzc4MzQsMC41NzE5MDggMS4yNjU4ODUsMS4wMzQ3MjggMi4wMjk5MTYsMS4zNTQ1NyAnICtcbiAgICAgICAgJ2wgLTAuNzE4MTYzLC0zLjkwOTc5MyBtIDAuNzE4MTYzLDMuOTA5NzkzIC0zLjg4NTIxMSwwLjgwMjkwMicsXG4gICAgICBoZWlnaHQ6IDEzLjksXG4gICAgICB3aWR0aDogMTMuNyxcbiAgICAgIGhlaWdodEVsZW1lbnRzOiBbXSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFtdXG4gICAgfSxcbiAgICAnTUFSS0VSX0FESE9DJzoge1xuICAgICAgZDogJ20ge214fSx7bXl9IG0gMC44NDQ2MSwyLjY0NDExIGMgMS4wNTUzMywtMS4yMzc4MDk5NiAyLjY0MzM3LC0yLjA3ODgyIDQuMjk2NTMsLTEuOTc5OTc5OTYgMi4wNTE2MywwLjA4MDUgJyArXG4gICAgICAgICczLjg1NTc5LDEuMTU4MDMgNS43NjA4MiwxLjc5MTA3IDEuMDYzODUsMC4zNDEzOTk5NiAyLjI0NDU0LDAuMTQzOCAzLjE4NzU5LC0wLjQzNzY3IDAuNjE3NDMsLTAuMzM2NDIgJyArXG4gICAgICAgICcxLjI3NzUsLTAuNjQwNzggMS43NTQyLC0xLjE3NTExIDAsMC41NjAyMyAwLDEuMTIwNDYgMCwxLjY4MDcgLTAuOTg3MDYsMC45NjIzNzk5NiAtMi4yOTc5MiwxLjYyMzkzOTk2ICcgK1xuICAgICAgICAnLTMuNjkxOCwxLjY2MTgxOTk2IC0xLjI0NDU5LDAuMDkyNyAtMi40NjY3MSwtMC4yNDkxIC0zLjU5NTA1LC0wLjc0ODEyIC0xLjM1Nzg5LC0wLjU1OTY1ICcgK1xuICAgICAgICAnLTIuNzUxMzMsLTEuMzM0MzY5OTYgLTQuMjcwMjcsLTEuMTgxMjE5OTYgLTEuMzc3NDEsMC4xNDYwMSAtMi40MTg0MiwxLjEzNjg1OTk2IC0zLjQ0Mjg4LDEuOTY3ODI5OTYgeicsXG4gICAgICBoZWlnaHQ6IDQsXG4gICAgICB3aWR0aDogMTUsXG4gICAgICBoZWlnaHRFbGVtZW50czogW10sXG4gICAgICB3aWR0aEVsZW1lbnRzOiBbXVxuICAgIH0sXG4gICAgJ1RBU0tfVFlQRV9TRU5EJzoge1xuICAgICAgZDogJ20ge214fSx7bXl9IGwgMCx7ZS55MX0gbCB7ZS54MX0sMCBsIDAsLXtlLnkxfSB6IGwge2UueDB9LHtlLnkwfSBsIHtlLngwfSwte2UueTB9JyxcbiAgICAgIGhlaWdodDogMTQsXG4gICAgICB3aWR0aDogIDIxLFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFs2LCAxNF0sXG4gICAgICB3aWR0aEVsZW1lbnRzOiBbMTAuNSwgMjFdXG4gICAgfSxcbiAgICAnVEFTS19UWVBFX1NDUklQVCc6IHtcbiAgICAgIGQ6ICdtIHtteH0se215fSBjIDkuOTY2NTUzLC02LjI3Mjc2IC04LjAwMDkyNiwtNy45MTkzMiAyLjk2ODk2OCwtMTQuOTM4IGwgLTguODAyNzI4LDAgJyArXG4gICAgICAgICdjIC0xMC45Njk4OTQsNy4wMTg2OCA2Ljk5NzU4NSw4LjY2NTI0IC0yLjk2ODk2NywxNC45MzggeiAnICtcbiAgICAgICAgJ20gLTcsLTEyIGwgNSwwICcgK1xuICAgICAgICAnbSAtNC41LDMgbCA0LjUsMCAnICtcbiAgICAgICAgJ20gLTMsMyBsIDUsMCcgK1xuICAgICAgICAnbSAtNCwzIGwgNSwwJyxcbiAgICAgIGhlaWdodDogMTUsXG4gICAgICB3aWR0aDogIDEyLjYsXG4gICAgICBoZWlnaHRFbGVtZW50czogWzYsIDE0XSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFsxMC41LCAyMV1cbiAgICB9LFxuICAgICdUQVNLX1RZUEVfVVNFUl8xJzoge1xuICAgICAgZDogJ20ge214fSx7bXl9IGMgMC45MDksLTAuODQ1IDEuNTk0LC0yLjA0OSAxLjU5NCwtMy4zODUgMCwtMi41NTQgLTEuODA1LC00LjYyMTk5OTk5ICcgK1xuICAgICAgICAnLTQuMzU3LC00LjYyMTk5OTk5IC0yLjU1MTk5OTk4LDAgLTQuMjg3OTk5OTgsMi4wNjc5OTk5OSAtNC4yODc5OTk5OCw0LjYyMTk5OTk5IDAsMS4zNDggJyArXG4gICAgICAgICcwLjk3NCwyLjU2MiAxLjg5NTk5OTk4LDMuNDA1IC0wLjUyODk5OTk4LDAuMTg3IC01LjY2OSwyLjA5NyAtNS43OTQsNC43NTYwMDA1IHYgNi43MTggJyArXG4gICAgICAgICdoIDE3IHYgLTYuNzE4IGMgMCwtMi4yOTgwMDA1IC01LjUyNzk5OTYsLTQuNTk1MDAwNSAtNi4wNTA5OTk2LC00Ljc3NjAwMDUgeicgK1xuICAgICAgICAnbSAtOCw2IGwgMCw1LjUgbSAxMSwwIGwgMCwtNSdcbiAgICB9LFxuICAgICdUQVNLX1RZUEVfVVNFUl8yJzoge1xuICAgICAgZDogJ20ge214fSx7bXl9IG0gMi4xNjIsMS4wMDkgYyAwLDIuNDQ3MDAwNSAtMi4xNTgsNC40MzEwMDA1IC00LjgyMSw0LjQzMTAwMDUgJyArXG4gICAgICAgICctMi42NjQ5OTk5OCwwIC00LjgyMiwtMS45ODEgLTQuODIyLC00LjQzMTAwMDUgJ1xuICAgIH0sXG4gICAgJ1RBU0tfVFlQRV9VU0VSXzMnOiB7XG4gICAgICBkOiAnbSB7bXh9LHtteX0gbSAtNi45LC0zLjgwIGMgMCwwIDIuMjUwOTk5OTgsLTIuMzU4IDQuMjczOTk5OTgsLTEuMTc3IDIuMDI0LDEuMTgxIDQuMjIxLDEuNTM3ICcgK1xuICAgICAgICAnNC4xMjQsMC45NjUgLTAuMDk4LC0wLjU3IC0wLjExNywtMy43OTA5OTk5OSAtNC4xOTEsLTQuMTM1OTk5OTkgLTMuNTc0OTk5OTgsMC4wMDEgJyArXG4gICAgICAgICctNC4yMDc5OTk5OCwzLjM2Njk5OTk5IC00LjIwNjk5OTk4LDQuMzQ3OTk5OTkgeidcbiAgICB9LFxuICAgICdUQVNLX1RZUEVfTUFOVUFMJzoge1xuICAgICAgZDogJ20ge214fSx7bXl9IGMgMC4yMzQsLTAuMDEgNS42MDQsMC4wMDggOC4wMjksMC4wMDQgMC44MDgsMCAxLjI3MSwtMC4xNzIgMS40MTcsLTAuNzUyIDAuMjI3LC0wLjg5OCAnICtcbiAgICAgICAgJy0wLjMzNCwtMS4zMTQgLTEuMzM4LC0xLjMxNiAtMi40NjcsLTAuMDEgLTcuODg2LC0wLjAwNCAtOC4xMDgsLTAuMDA0IC0wLjAxNCwtMC4wNzkgMC4wMTYsLTAuNTMzIDAsLTAuNjEgJyArXG4gICAgICAgICcwLjE5NSwtMC4wNDIgOC41MDcsMC4wMDYgOS42MTYsMC4wMDIgMC44NzcsLTAuMDA3IDEuMzUsLTAuNDM4IDEuMzUzLC0xLjIwOCAwLjAwMywtMC43NjggLTAuNDc5LC0xLjA5ICcgK1xuICAgICAgICAnLTEuMzUsLTEuMDkxIC0yLjk2OCwtMC4wMDIgLTkuNjE5LC0wLjAxMyAtOS42MTksLTAuMDEzIHYgLTAuNTkxIGMgMCwwIDUuMDUyLC0wLjAxNiA3LjIyNSwtMC4wMTYgJyArXG4gICAgICAgICcwLjg4OCwtMC4wMDIgMS4zNTQsLTAuNDE2IDEuMzUxLC0xLjE5MyAtMC4wMDYsLTAuNzYxIC0wLjQ5MiwtMS4xOTYgLTEuMzYxLC0xLjE5NiAtMy40NzMsLTAuMDA1ICcgK1xuICAgICAgICAnLTEwLjg2LC0wLjAwMyAtMTEuMDgyOTk5NSwtMC4wMDMgLTAuMDIyLC0wLjA0NyAtMC4wNDUsLTAuMDk0IC0wLjA2OSwtMC4xMzkgMC4zOTM5OTk1LC0wLjMxOSAnICtcbiAgICAgICAgJzIuMDQwOTk5NSwtMS42MjYgMi40MTQ5OTk1LC0yLjAxNyAwLjQ2OSwtMC40ODcwMDA1IDAuNTE5LC0xLjE2NTAwMDUgMC4xNjIsLTEuNjA0MDAwNSAtMC40MTQsLTAuNTExICcgK1xuICAgICAgICAnLTAuOTczLC0wLjUgLTEuNDgsLTAuMjM2IC0xLjQ2MDk5OTUsMC43NjQgLTYuNTk5OTk5NSwzLjY0MzAwMDUgLTcuNzMyOTk5NSw0LjI3MTAwMDUgLTAuOSwwLjQ5OSAnICtcbiAgICAgICAgJy0xLjUxNiwxLjI1MyAtMS44ODIsMi4xOSAtMC4zNzAwMDAwMiwwLjk1IC0wLjE3LDIuMDEgLTAuMTY2LDIuOTc5IDAuMDA0LDAuNzE4IC0wLjI3MzAwMDAyLDEuMzQ1ICcgK1xuICAgICAgICAnLTAuMDU1LDIuMDYzIDAuNjI5LDIuMDg3IDIuNDI1LDMuMzEyIDQuODU5LDMuMzE4IDQuNjE3OTk5NSwwLjAxNCA5LjIzNzk5OTUsLTAuMTM5IDEzLjg1Njk5OTUsLTAuMTU4ICcgK1xuICAgICAgICAnMC43NTUsLTAuMDA0IDEuMTcxLC0wLjMwMSAxLjE4MiwtMS4wMzMgMC4wMTIsLTAuNzU0IC0wLjQyMywtMC45NjkgLTEuMTgzLC0wLjk3MyAtMS43NzgsLTAuMDEgJyArXG4gICAgICAgICctNS44MjQsLTAuMDA0IC02LjA0LC0wLjAwNCAxMGUtNCwtMC4wODQgMC4wMDMsLTAuNTg2IDEwZS00LC0wLjY3IHonXG4gICAgfSxcbiAgICAnVEFTS19UWVBFX0lOU1RBTlRJQVRJTkdfU0VORCc6IHtcbiAgICAgIGQ6ICdtIHtteH0se215fSBsIDAsOC40IGwgMTIuNiwwIGwgMCwtOC40IHogbCA2LjMsMy42IGwgNi4zLC0zLjYnXG4gICAgfSxcbiAgICAnVEFTS19UWVBFX1NFUlZJQ0UnOiB7XG4gICAgICBkOiAnbSB7bXh9LHtteX0gdiAtMS43MTMzNSBjIDAuMzUyMzI2LC0wLjA3MDUgMC43MDM5MzIsLTAuMTc4MzggMS4wNDc2MjgsLTAuMzIxMzMgJyArXG4gICAgICAgICcwLjM0NDQxNiwtMC4xNDQ2NSAwLjY2NTgyMiwtMC4zMjEzMyAwLjk2NjM3NywtMC41MjE0NSBsIDEuMTk0MzEsMS4xODAwNSAxLjU2NzQ4NywtMS41NzY4OCAnICtcbiAgICAgICAgJy0xLjE5NTAyOCwtMS4xODAxNCBjIDAuNDAzMzc2LC0wLjYxMzk0IDAuNjgzMDc5LC0xLjI5OTA4IDAuODI1NDQ3LC0yLjAxODI0IGwgMS42MjIxMzMsLTAuMDEgJyArXG4gICAgICAgICd2IC0yLjIxOTYgbCAtMS42MzY1MTQsMC4wMSBjIC0wLjA3MzMzLC0wLjM1MTUzIC0wLjE3ODMxOSwtMC43MDAyNCAtMC4zMjM1NjQsLTEuMDQzNzIgJyArXG4gICAgICAgICctMC4xNDUyNDQsLTAuMzQ0MDYgLTAuMzIxNDA3LC0wLjY2NDQgLTAuNTIyNzM1LC0wLjk2MjE3IGwgMS4xMzEwMzUsLTEuMTM2MzEgLTEuNTgzMzA1LC0xLjU2MjkzICcgK1xuICAgICAgICAnLTEuMTI5NTk4LDEuMTM1ODkgYyAtMC42MTQwNTIsLTAuNDAxMDggLTEuMzAyODgzLC0wLjY4MDkzIC0yLjAyMjYzMywtMC44MjI0NyBsIDAuMDA5MywtMS42MTg1MiAnICtcbiAgICAgICAgJ2ggLTIuMjQxMTczIGwgMC4wMDQyLDEuNjMxMjQgYyAtMC4zNTM3NjMsMC4wNzM2IC0wLjcwNTM2OSwwLjE3OTc3IC0xLjA0OTc4NSwwLjMyMzcxIC0wLjM0NDQxNSwwLjE0NDM3ICcgK1xuICAgICAgICAnLTAuNjY1MTAyLDAuMzIwOTIgLTAuOTYzNTAwNiwwLjUyMDQ2IGwgLTEuMTY5ODYyOCwtMS4xNTgyMyAtMS41NjY3NjkxLDEuNTc5MiAxLjE2ODQyNjUsMS4xNTY2OSAnICtcbiAgICAgICAgJ2MgLTAuNDAyNjU3MywwLjYxMjgzIC0wLjY4MzA4LDEuMjk3OTcgLTAuODI0NzI4NywyLjAxNzEzIGwgLTEuNjU4ODA0MSwwLjAwMyB2IDIuMjIxNzQgJyArXG4gICAgICAgICdsIDEuNjcyNDY0OCwtMC4wMDYgYyAwLjA3MzMyNywwLjM1MDc3IDAuMTc5NzU5OCwwLjcwMjQzIDAuMzI0Mjg1MSwxLjA0NDcyIDAuMTQ1MjQyOCwwLjM0NDQ4ICcgK1xuICAgICAgICAnMC4zMjE0MDY0LDAuNjY0NCAwLjUyMjczMzksMC45NjA2NiBsIC0xLjE5OTM0MzEsMS4xOTcyMyAxLjU4NDAyNTYsMS41NjAxMSAxLjE5NjQ2NjgsLTEuMTkzNDggJyArXG4gICAgICAgICdjIDAuNjE0MDUxNywwLjQwMzQ2IDEuMzAyODgyNywwLjY4MjMyIDIuMDIzMzUxNywwLjgyMzMxIGwgNy4xOWUtNCwxLjY5ODkyIGggMi4yMjY4NDggeiAnICtcbiAgICAgICAgJ20gMC4yMjE0NjIsLTMuOTk1NyBjIC0xLjc4ODk0OCwwLjc1MDIgLTMuODU3NiwtMC4wOTI4IC00LjYwOTcwNTUsLTEuODc0MzggLTAuNzUyMTA2NSwtMS43ODMyMSAnICtcbiAgICAgICAgJzAuMDkwNTk4LC0zLjg0NjI3IDEuODgwMjY0NSwtNC41OTYwNCAxLjc4ODIzLC0wLjc0OTM2IDMuODU2ODgxLDAuMDkyOSA0LjYwODk4NywxLjg3NDM3ICcgK1xuICAgICAgICAnMC43NTIxMDYsMS43ODE2NSAtMC4wOTA2LDMuODQ2MTIgLTEuODc5NTQ2LDQuNTk2MDUgeidcbiAgICB9LFxuICAgICdUQVNLX1RZUEVfU0VSVklDRV9GSUxMJzoge1xuICAgICAgZDogJ20ge214fSx7bXl9IGMgLTEuNzg4OTQ4LDAuNzUwMiAtMy44NTc2LC0wLjA5MjggLTQuNjA5NzA1NSwtMS44NzQzOCAtMC43NTIxMDY1LC0xLjc4MzIxICcgK1xuICAgICAgICAnMC4wOTA1OTgsLTMuODQ2MjcgMS44ODAyNjQ1LC00LjU5NjA0IDEuNzg4MjMsLTAuNzQ5MzYgMy44NTY4ODEsMC4wOTI5IDQuNjA4OTg3LDEuODc0MzcgJyArXG4gICAgICAgICcwLjc1MjEwNiwxLjc4MTY1IC0wLjA5MDYsMy44NDYxMiAtMS44Nzk1NDYsNC41OTYwNSB6J1xuICAgIH0sXG4gICAgJ1RBU0tfVFlQRV9CVVNJTkVTU19SVUxFX0hFQURFUic6IHtcbiAgICAgIGQ6ICdtIHtteH0se215fSAwLDQgMjAsMCAwLC00IHonXG4gICAgfSxcbiAgICAnVEFTS19UWVBFX0JVU0lORVNTX1JVTEVfTUFJTic6IHtcbiAgICAgIGQ6ICdtIHtteH0se215fSAwLDEyIDIwLDAgMCwtMTIgeicgK1xuICAgICAgICAnbSAwLDggbCAyMCwwICcgK1xuICAgICAgICAnbSAtMTMsLTQgbCAwLDgnXG4gICAgfSxcbiAgICAnTUVTU0FHRV9GTE9XX01BUktFUic6IHtcbiAgICAgIGQ6ICdtIHtteH0se215fSBtIC0xMC41ICwtNyBsIDAsMTQgbCAyMSwwIGwgMCwtMTQgeiBsIDEwLjUsNiBsIDEwLjUsLTYnXG4gICAgfVxuICB9O1xuXG4gIHRoaXMuZ2V0UmF3UGF0aCA9IGZ1bmN0aW9uIGdldFJhd1BhdGgocGF0aElkKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0aE1hcFtwYXRoSWRdLmQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNjYWxlcyB0aGUgcGF0aCB0byB0aGUgZ2l2ZW4gaGVpZ2h0IGFuZCB3aWR0aC5cbiAgICogPGgxPlVzZSBjYXNlPC9oMT5cbiAgICogPHA+VXNlIGNhc2UgaXMgdG8gc2NhbGUgdGhlIGNvbnRlbnQgb2YgZWxlbWVudHMgKGV2ZW50LCBnYXRld2F5cykgYmFzZWRcbiAgICogb24gdGhlIGVsZW1lbnQgYm91bmRpbmcgYm94J3Mgc2l6ZS5cbiAgICogPC9wPlxuICAgKiA8aDE+V2h5IG5vdCB0cmFuc2Zvcm08L2gxPlxuICAgKiA8cD5TY2FsaW5nIGEgcGF0aCB3aXRoIHRyYW5zZm9ybSgpIHdpbGwgYWxzbyBzY2FsZSB0aGUgc3Ryb2tlIGFuZCBJRSBkb2VzIG5vdCBzdXBwb3J0XG4gICAqIHRoZSBvcHRpb24gJ25vbi1zY2FsaW5nLXN0cm9rZScgdG8gcHJldmVudCB0aGlzLlxuICAgKiBBbHNvIHRoZXJlIGFyZSB1c2UgY2FzZXMgd2hlcmUgb25seSBzb21lIHBhcnRzIG9mIGEgcGF0aCBzaG91bGQgYmVcbiAgICogc2NhbGVkLjwvcD5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhJZCBUaGUgSUQgb2YgdGhlIHBhdGguXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbSA8cD5cbiAgICogICBFeGFtcGxlIHBhcmFtIG9iamVjdCBzY2FsZXMgdGhlIHBhdGggdG8gNjAlIHNpemUgb2YgdGhlIGNvbnRhaW5lciAoZGF0YS53aWR0aCwgZGF0YS5oZWlnaHQpLlxuICAgKiAgIDxwcmU+XG4gICAqICAge1xuICAgKiAgICAgeFNjYWxlRmFjdG9yOiAwLjYsXG4gICAqICAgICB5U2NhbGVGYWN0b3I6MC42LFxuICAgKiAgICAgY29udGFpbmVyV2lkdGg6IGRhdGEud2lkdGgsXG4gICAqICAgICBjb250YWluZXJIZWlnaHQ6IGRhdGEuaGVpZ2h0LFxuICAgKiAgICAgcG9zaXRpb246IHtcbiAgICogICAgICAgbXg6IDAuNDYsXG4gICAqICAgICAgIG15OiAwLjIsXG4gICAqICAgICB9XG4gICAqICAgfVxuICAgKiAgIDwvcHJlPlxuICAgKiAgIDx1bD5cbiAgICogICAgPGxpPnRhcmdldHBhdGh3aWR0aCA9IHhTY2FsZUZhY3RvciAqIGNvbnRhaW5lcldpZHRoPC9saT5cbiAgICogICAgPGxpPnRhcmdldHBhdGhoZWlnaHQgPSB5U2NhbGVGYWN0b3IgKiBjb250YWluZXJIZWlnaHQ8L2xpPlxuICAgKiAgICA8bGk+UG9zaXRpb24gaXMgdXNlZCB0byBzZXQgdGhlIHN0YXJ0aW5nIGNvb3JkaW5hdGUgb2YgdGhlIHBhdGguIE0gaXMgY29tcHV0ZWQ6XG4gICAgKiAgICA8dWw+XG4gICAgKiAgICAgIDxsaT5wb3NpdGlvbi54ICogY29udGFpbmVyV2lkdGg8L2xpPlxuICAgICogICAgICA8bGk+cG9zaXRpb24ueSAqIGNvbnRhaW5lckhlaWdodDwvbGk+XG4gICAgKiAgICA8L3VsPlxuICAgICogICAgQ2VudGVyIG9mIHRoZSBjb250YWluZXIgPHByZT4gcG9zaXRpb246IHtcbiAgICogICAgICAgbXg6IDAuNSxcbiAgICogICAgICAgbXk6IDAuNSxcbiAgICogICAgIH08L3ByZT5cbiAgICogICAgIFVwcGVyIGxlZnQgY29ybmVyIG9mIHRoZSBjb250YWluZXJcbiAgICogICAgIDxwcmU+IHBvc2l0aW9uOiB7XG4gICAqICAgICAgIG14OiAwLjAsXG4gICAqICAgICAgIG15OiAwLjAsXG4gICAqICAgICB9PC9wcmU+XG4gICAqICAgIDwvbGk+XG4gICAqICAgPC91bD5cbiAgICogPC9wPlxuICAgKlxuICAgKi9cbiAgdGhpcy5nZXRTY2FsZWRQYXRoID0gZnVuY3Rpb24gZ2V0U2NhbGVkUGF0aChwYXRoSWQsIHBhcmFtKSB7XG4gICAgdmFyIHJhd1BhdGggPSB0aGlzLnBhdGhNYXBbcGF0aElkXTtcblxuICAgIC8vIHBvc2l0aW9uaW5nXG4gICAgLy8gY29tcHV0ZSB0aGUgc3RhcnQgcG9pbnQgb2YgdGhlIHBhdGhcbiAgICB2YXIgbXgsIG15O1xuXG4gICAgaWYgKHBhcmFtLmFic3Bvcykge1xuICAgICAgbXggPSBwYXJhbS5hYnNwb3MueDtcbiAgICAgIG15ID0gcGFyYW0uYWJzcG9zLnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG14ID0gcGFyYW0uY29udGFpbmVyV2lkdGggKiBwYXJhbS5wb3NpdGlvbi5teDtcbiAgICAgIG15ID0gcGFyYW0uY29udGFpbmVySGVpZ2h0ICogcGFyYW0ucG9zaXRpb24ubXk7XG4gICAgfVxuXG4gICAgdmFyIGNvb3JkaW5hdGVzID0ge307IC8vIG1hcCBmb3IgdGhlIHNjYWxlZCBjb29yZGluYXRlc1xuICAgIGlmIChwYXJhbS5wb3NpdGlvbikge1xuXG4gICAgICAvLyBwYXRoXG4gICAgICB2YXIgaGVpZ2h0UmF0aW8gPSAocGFyYW0uY29udGFpbmVySGVpZ2h0IC8gcmF3UGF0aC5oZWlnaHQpICogcGFyYW0ueVNjYWxlRmFjdG9yO1xuICAgICAgdmFyIHdpZHRoUmF0aW8gPSAocGFyYW0uY29udGFpbmVyV2lkdGggLyByYXdQYXRoLndpZHRoKSAqIHBhcmFtLnhTY2FsZUZhY3RvcjtcblxuXG4gICAgICAvLyBBcHBseSBoZWlnaHQgcmF0aW9cbiAgICAgIGZvciAodmFyIGhlaWdodEluZGV4ID0gMDsgaGVpZ2h0SW5kZXggPCByYXdQYXRoLmhlaWdodEVsZW1lbnRzLmxlbmd0aDsgaGVpZ2h0SW5kZXgrKykge1xuICAgICAgICBjb29yZGluYXRlc1sneScgKyBoZWlnaHRJbmRleF0gPSByYXdQYXRoLmhlaWdodEVsZW1lbnRzW2hlaWdodEluZGV4XSAqIGhlaWdodFJhdGlvO1xuICAgICAgfVxuXG4gICAgICAvLyBBcHBseSB3aWR0aCByYXRpb1xuICAgICAgZm9yICh2YXIgd2lkdGhJbmRleCA9IDA7IHdpZHRoSW5kZXggPCByYXdQYXRoLndpZHRoRWxlbWVudHMubGVuZ3RoOyB3aWR0aEluZGV4KyspIHtcbiAgICAgICAgY29vcmRpbmF0ZXNbJ3gnICsgd2lkdGhJbmRleF0gPSByYXdQYXRoLndpZHRoRWxlbWVudHNbd2lkdGhJbmRleF0gKiB3aWR0aFJhdGlvO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFwcGx5IHZhbHVlIHRvIHJhdyBwYXRoXG4gICAgdmFyIHBhdGggPSBmb3JtYXQoXG4gICAgICByYXdQYXRoLmQsIHtcbiAgICAgICAgbXg6IG14LFxuICAgICAgICBteTogbXksXG4gICAgICAgIGU6IGNvb3JkaW5hdGVzXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gcGF0aDtcbiAgfTtcbn1cblxuLy8gaGVscGVycyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vIGNvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9hZG9iZS13ZWJwbGF0Zm9ybS9TbmFwLnN2Zy9ibG9iL21hc3Rlci9zcmMvc3ZnLmpzXG52YXIgdG9rZW5SZWdleCA9IC9cXHsoW159XSspXFx9L2csXG4gICAgb2JqTm90YXRpb25SZWdleCA9IC8oPzooPzpefFxcLikoLis/KSg/PVxcW3xcXC58JHxcXCgpfFxcWygnfFwiKSguKz8pXFwyXFxdKShcXChcXCkpPy9nOyAvLyBtYXRjaGVzIC54eHh4eCBvciBbXCJ4eHh4eFwiXSB0byBydW4gb3ZlciBvYmplY3QgcHJvcGVydGllc1xuXG5mdW5jdGlvbiByZXBsYWNlcihhbGwsIGtleSwgb2JqKSB7XG4gIHZhciByZXMgPSBvYmo7XG4gIGtleS5yZXBsYWNlKG9iak5vdGF0aW9uUmVnZXgsIGZ1bmN0aW9uKGFsbCwgbmFtZSwgcXVvdGUsIHF1b3RlZE5hbWUsIGlzRnVuYykge1xuICAgIG5hbWUgPSBuYW1lIHx8IHF1b3RlZE5hbWU7XG4gICAgaWYgKHJlcykge1xuICAgICAgaWYgKG5hbWUgaW4gcmVzKSB7XG4gICAgICAgIHJlcyA9IHJlc1tuYW1lXTtcbiAgICAgIH1cbiAgICAgIHR5cGVvZiByZXMgPT0gJ2Z1bmN0aW9uJyAmJiBpc0Z1bmMgJiYgKHJlcyA9IHJlcygpKTtcbiAgICB9XG4gIH0pO1xuICByZXMgPSAocmVzID09IG51bGwgfHwgcmVzID09IG9iaiA/IGFsbCA6IHJlcykgKyAnJztcblxuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBmb3JtYXQoc3RyLCBvYmopIHtcbiAgcmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UodG9rZW5SZWdleCwgZnVuY3Rpb24oYWxsLCBrZXkpIHtcbiAgICByZXR1cm4gcmVwbGFjZXIoYWxsLCBrZXksIG9iaik7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQgVGV4dFV0aWwgZnJvbSAnZGlhZ3JhbS1qcy9saWIvdXRpbC9UZXh0JztcblxudmFyIERFRkFVTFRfRk9OVF9TSVpFID0gMTI7XG52YXIgTElORV9IRUlHSFRfUkFUSU8gPSAxLjI7XG5cbnZhciBNSU5fVEVYVF9BTk5PVEFUSU9OX0hFSUdIVCA9IDMwO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFRleHRSZW5kZXJlcihjb25maWcpIHtcblxuICB2YXIgZGVmYXVsdFN0eWxlID0gYXNzaWduKHtcbiAgICBmb250RmFtaWx5OiAnQXJpYWwsIHNhbnMtc2VyaWYnLFxuICAgIGZvbnRTaXplOiBERUZBVUxUX0ZPTlRfU0laRSxcbiAgICBmb250V2VpZ2h0OiAnbm9ybWFsJyxcbiAgICBsaW5lSGVpZ2h0OiBMSU5FX0hFSUdIVF9SQVRJT1xuICB9LCBjb25maWcgJiYgY29uZmlnLmRlZmF1bHRTdHlsZSB8fCB7fSk7XG5cbiAgdmFyIGZvbnRTaXplID0gcGFyc2VJbnQoZGVmYXVsdFN0eWxlLmZvbnRTaXplLCAxMCkgLSAxO1xuXG4gIHZhciBleHRlcm5hbFN0eWxlID0gYXNzaWduKHt9LCBkZWZhdWx0U3R5bGUsIHtcbiAgICBmb250U2l6ZTogZm9udFNpemVcbiAgfSwgY29uZmlnICYmIGNvbmZpZy5leHRlcm5hbFN0eWxlIHx8IHt9KTtcblxuICB2YXIgdGV4dFV0aWwgPSBuZXcgVGV4dFV0aWwoe1xuICAgIHN0eWxlOiBkZWZhdWx0U3R5bGVcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmV3IGJvdW5kcyBvZiBhbiBleHRlcm5hbGx5IHJlbmRlcmVkLFxuICAgKiBsYXlvdXRlZCBsYWJlbC5cbiAgICpcbiAgICogQHBhcmFtICB7Qm91bmRzfSBib3VuZHNcbiAgICogQHBhcmFtICB7U3RyaW5nfSB0ZXh0XG4gICAqXG4gICAqIEByZXR1cm4ge0JvdW5kc31cbiAgICovXG4gIHRoaXMuZ2V0RXh0ZXJuYWxMYWJlbEJvdW5kcyA9IGZ1bmN0aW9uKGJvdW5kcywgdGV4dCkge1xuXG4gICAgdmFyIGxheW91dGVkRGltZW5zaW9ucyA9IHRleHRVdGlsLmdldERpbWVuc2lvbnModGV4dCwge1xuICAgICAgYm94OiB7XG4gICAgICAgIHdpZHRoOiA5MCxcbiAgICAgICAgaGVpZ2h0OiAzMCxcbiAgICAgICAgeDogYm91bmRzLndpZHRoIC8gMiArIGJvdW5kcy54LFxuICAgICAgICB5OiBib3VuZHMuaGVpZ2h0IC8gMiArIGJvdW5kcy55XG4gICAgICB9LFxuICAgICAgc3R5bGU6IGV4dGVybmFsU3R5bGVcbiAgICB9KTtcblxuICAgIC8vIHJlc2l6ZSBsYWJlbCBzaGFwZSB0byBmaXQgbGFiZWwgdGV4dFxuICAgIHJldHVybiB7XG4gICAgICB4OiBNYXRoLnJvdW5kKGJvdW5kcy54ICsgYm91bmRzLndpZHRoIC8gMiAtIGxheW91dGVkRGltZW5zaW9ucy53aWR0aCAvIDIpLFxuICAgICAgeTogTWF0aC5yb3VuZChib3VuZHMueSksXG4gICAgICB3aWR0aDogTWF0aC5jZWlsKGxheW91dGVkRGltZW5zaW9ucy53aWR0aCksXG4gICAgICBoZWlnaHQ6IE1hdGguY2VpbChsYXlvdXRlZERpbWVuc2lvbnMuaGVpZ2h0KVxuICAgIH07XG5cbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBuZXcgYm91bmRzIG9mIHRleHQgYW5ub3RhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7Qm91bmRzfSBib3VuZHNcbiAgICogQHBhcmFtICB7U3RyaW5nfSB0ZXh0XG4gICAqXG4gICAqIEByZXR1cm4ge0JvdW5kc31cbiAgICovXG4gIHRoaXMuZ2V0VGV4dEFubm90YXRpb25Cb3VuZHMgPSBmdW5jdGlvbihib3VuZHMsIHRleHQpIHtcblxuICAgIHZhciBsYXlvdXRlZERpbWVuc2lvbnMgPSB0ZXh0VXRpbC5nZXREaW1lbnNpb25zKHRleHQsIHtcbiAgICAgIGJveDogYm91bmRzLFxuICAgICAgc3R5bGU6IGRlZmF1bHRTdHlsZSxcbiAgICAgIGFsaWduOiAnbGVmdC10b3AnLFxuICAgICAgcGFkZGluZzogNVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGJvdW5kcy54LFxuICAgICAgeTogYm91bmRzLnksXG4gICAgICB3aWR0aDogYm91bmRzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBNYXRoLm1heChNSU5fVEVYVF9BTk5PVEFUSU9OX0hFSUdIVCwgTWF0aC5yb3VuZChsYXlvdXRlZERpbWVuc2lvbnMuaGVpZ2h0KSlcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBsYXlvdXRlZCB0ZXh0IGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICpcbiAgICogQHJldHVybiB7U1ZHRWxlbWVudH0gcmVuZGVyZWQgdGV4dFxuICAgKi9cbiAgdGhpcy5jcmVhdGVUZXh0ID0gZnVuY3Rpb24odGV4dCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0ZXh0VXRpbC5jcmVhdGVUZXh0KHRleHQsIG9wdGlvbnMgfHwge30pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgZGVmYXVsdCB0ZXh0IHN0eWxlLlxuICAgKi9cbiAgdGhpcy5nZXREZWZhdWx0U3R5bGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdFN0eWxlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGV4dGVybmFsIHRleHQgc3R5bGUuXG4gICAqL1xuICB0aGlzLmdldEV4dGVybmFsU3R5bGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZXh0ZXJuYWxTdHlsZTtcbiAgfTtcblxufVxuXG5UZXh0UmVuZGVyZXIuJGluamVjdCA9IFtcbiAgJ2NvbmZpZy50ZXh0UmVuZGVyZXInXG5dOyIsImltcG9ydCBCcG1uUmVuZGVyZXIgZnJvbSAnLi9CcG1uUmVuZGVyZXInO1xuaW1wb3J0IFRleHRSZW5kZXJlciBmcm9tICcuL1RleHRSZW5kZXJlcic7XG5cbmltcG9ydCBQYXRoTWFwIGZyb20gJy4vUGF0aE1hcCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19pbml0X186IFsgJ2JwbW5SZW5kZXJlcicgXSxcbiAgYnBtblJlbmRlcmVyOiBbICd0eXBlJywgQnBtblJlbmRlcmVyIF0sXG4gIHRleHRSZW5kZXJlcjogWyAndHlwZScsIFRleHRSZW5kZXJlciBdLFxuICBwYXRoTWFwOiBbICd0eXBlJywgUGF0aE1hcCBdXG59O1xuIiwiaW1wb3J0IHsgaXMgfSBmcm9tICcuLi8uLi91dGlsL01vZGVsVXRpbCc7XG5cbmZ1bmN0aW9uIGdldExhYmVsQXR0cihzZW1hbnRpYykge1xuICBpZiAoXG4gICAgaXMoc2VtYW50aWMsICdicG1uOkZsb3dFbGVtZW50JykgfHxcbiAgICBpcyhzZW1hbnRpYywgJ2JwbW46UGFydGljaXBhbnQnKSB8fFxuICAgIGlzKHNlbWFudGljLCAnYnBtbjpMYW5lJykgfHxcbiAgICBpcyhzZW1hbnRpYywgJ2JwbW46U2VxdWVuY2VGbG93JykgfHxcbiAgICBpcyhzZW1hbnRpYywgJ2JwbW46TWVzc2FnZUZsb3cnKSB8fFxuICAgIGlzKHNlbWFudGljLCAnYnBtbjpEYXRhSW5wdXQnKSB8fFxuICAgIGlzKHNlbWFudGljLCAnYnBtbjpEYXRhT3V0cHV0JylcbiAgKSB7XG4gICAgcmV0dXJuICduYW1lJztcbiAgfVxuXG4gIGlmIChpcyhzZW1hbnRpYywgJ2JwbW46VGV4dEFubm90YXRpb24nKSkge1xuICAgIHJldHVybiAndGV4dCc7XG4gIH1cblxuICBpZiAoaXMoc2VtYW50aWMsICdicG1uOkdyb3VwJykpIHtcbiAgICByZXR1cm4gJ2NhdGVnb3J5VmFsdWVSZWYnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldENhdGVnb3J5VmFsdWUoc2VtYW50aWMpIHtcbiAgdmFyIGNhdGVnb3J5VmFsdWVSZWYgPSBzZW1hbnRpY1snY2F0ZWdvcnlWYWx1ZVJlZiddO1xuXG4gIGlmICghY2F0ZWdvcnlWYWx1ZVJlZikge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG5cbiAgcmV0dXJuIGNhdGVnb3J5VmFsdWVSZWYudmFsdWUgfHwgJyc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMYWJlbChlbGVtZW50KSB7XG4gIHZhciBzZW1hbnRpYyA9IGVsZW1lbnQuYnVzaW5lc3NPYmplY3QsXG4gICAgICBhdHRyID0gZ2V0TGFiZWxBdHRyKHNlbWFudGljKTtcblxuICBpZiAoYXR0cikge1xuXG4gICAgaWYgKGF0dHIgPT09ICdjYXRlZ29yeVZhbHVlUmVmJykge1xuXG4gICAgICByZXR1cm4gZ2V0Q2F0ZWdvcnlWYWx1ZShzZW1hbnRpYyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbWFudGljW2F0dHJdIHx8ICcnO1xuICB9XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHNldExhYmVsKGVsZW1lbnQsIHRleHQsIGlzRXh0ZXJuYWwpIHtcbiAgdmFyIHNlbWFudGljID0gZWxlbWVudC5idXNpbmVzc09iamVjdCxcbiAgICAgIGF0dHIgPSBnZXRMYWJlbEF0dHIoc2VtYW50aWMpO1xuXG4gIGlmIChhdHRyKSB7XG5cbiAgICBpZiAoYXR0ciA9PT0gJ2NhdGVnb3J5VmFsdWVSZWYnKSB7XG4gICAgICBzZW1hbnRpY1snY2F0ZWdvcnlWYWx1ZVJlZiddLnZhbHVlID0gdGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VtYW50aWNbYXR0cl0gPSB0ZXh0O1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59IiwiaW1wb3J0IHtcbiAgYXNzaWduXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHsgaXMgfSBmcm9tICcuLi91dGlsL01vZGVsVXRpbCc7XG5cbmltcG9ydCB7XG4gIGlzTGFiZWxFeHRlcm5hbCxcbiAgZ2V0RXh0ZXJuYWxMYWJlbEJvdW5kc1xufSBmcm9tICcuLi91dGlsL0xhYmVsVXRpbCc7XG5cbmltcG9ydCB7XG4gIGdldE1pZFxufSBmcm9tICdkaWFncmFtLWpzL2xpYi9sYXlvdXQvTGF5b3V0VXRpbCc7XG5cbmltcG9ydCB7XG4gIGlzRXhwYW5kZWRcbn0gZnJvbSAnLi4vdXRpbC9EaVV0aWwnO1xuXG5pbXBvcnQge1xuICBnZXRMYWJlbFxufSBmcm9tICcuLi9mZWF0dXJlcy9sYWJlbC1lZGl0aW5nL0xhYmVsVXRpbCc7XG5cbmltcG9ydCB7XG4gIGVsZW1lbnRUb1N0cmluZ1xufSBmcm9tICcuL1V0aWwnO1xuXG5cbmZ1bmN0aW9uIGVsZW1lbnREYXRhKHNlbWFudGljLCBhdHRycykge1xuICByZXR1cm4gYXNzaWduKHtcbiAgICBpZDogc2VtYW50aWMuaWQsXG4gICAgdHlwZTogc2VtYW50aWMuJHR5cGUsXG4gICAgYnVzaW5lc3NPYmplY3Q6IHNlbWFudGljXG4gIH0sIGF0dHJzKTtcbn1cblxuZnVuY3Rpb24gZ2V0V2F5cG9pbnRzKGJvLCBzb3VyY2UsIHRhcmdldCkge1xuXG4gIHZhciB3YXlwb2ludHMgPSBiby5kaS53YXlwb2ludDtcblxuICBpZiAoIXdheXBvaW50cyB8fCB3YXlwb2ludHMubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiBbIGdldE1pZChzb3VyY2UpLCBnZXRNaWQodGFyZ2V0KSBdO1xuICB9XG5cbiAgcmV0dXJuIHdheXBvaW50cy5tYXAoZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiB7IHg6IHAueCwgeTogcC55IH07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBub3RZZXREcmF3bih0cmFuc2xhdGUsIHNlbWFudGljLCByZWZTZW1hbnRpYywgcHJvcGVydHkpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcih0cmFuc2xhdGUoJ2VsZW1lbnQge2VsZW1lbnR9IHJlZmVyZW5jZWQgYnkge3JlZmVyZW5jZWR9I3twcm9wZXJ0eX0gbm90IHlldCBkcmF3bicsIHtcbiAgICBlbGVtZW50OiBlbGVtZW50VG9TdHJpbmcocmVmU2VtYW50aWMpLFxuICAgIHJlZmVyZW5jZWQ6IGVsZW1lbnRUb1N0cmluZyhzZW1hbnRpYyksXG4gICAgcHJvcGVydHk6IHByb3BlcnR5XG4gIH0pKTtcbn1cblxuXG4vKipcbiAqIEFuIGltcG9ydGVyIHRoYXQgYWRkcyBicG1uIGVsZW1lbnRzIHRvIHRoZSBjYW52YXNcbiAqXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICogQHBhcmFtIHtFbGVtZW50RmFjdG9yeX0gZWxlbWVudEZhY3RvcnlcbiAqIEBwYXJhbSB7RWxlbWVudFJlZ2lzdHJ5fSBlbGVtZW50UmVnaXN0cnlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zbGF0ZVxuICogQHBhcmFtIHtUZXh0UmVuZGVyZXJ9IHRleHRSZW5kZXJlclxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCcG1uSW1wb3J0ZXIoXG4gICAgZXZlbnRCdXMsIGNhbnZhcywgZWxlbWVudEZhY3RvcnksXG4gICAgZWxlbWVudFJlZ2lzdHJ5LCB0cmFuc2xhdGUsIHRleHRSZW5kZXJlcikge1xuXG4gIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG4gIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbiAgdGhpcy5fZWxlbWVudEZhY3RvcnkgPSBlbGVtZW50RmFjdG9yeTtcbiAgdGhpcy5fZWxlbWVudFJlZ2lzdHJ5ID0gZWxlbWVudFJlZ2lzdHJ5O1xuICB0aGlzLl90cmFuc2xhdGUgPSB0cmFuc2xhdGU7XG4gIHRoaXMuX3RleHRSZW5kZXJlciA9IHRleHRSZW5kZXJlcjtcbn1cblxuQnBtbkltcG9ydGVyLiRpbmplY3QgPSBbXG4gICdldmVudEJ1cycsXG4gICdjYW52YXMnLFxuICAnZWxlbWVudEZhY3RvcnknLFxuICAnZWxlbWVudFJlZ2lzdHJ5JyxcbiAgJ3RyYW5zbGF0ZScsXG4gICd0ZXh0UmVuZGVyZXInXG5dO1xuXG5cbi8qKlxuICogQWRkIGJwbW4gZWxlbWVudCAoc2VtYW50aWMpIHRvIHRoZSBjYW52YXMgb250byB0aGVcbiAqIHNwZWNpZmllZCBwYXJlbnQgc2hhcGUuXG4gKi9cbkJwbW5JbXBvcnRlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oc2VtYW50aWMsIHBhcmVudEVsZW1lbnQpIHtcblxuICB2YXIgZGkgPSBzZW1hbnRpYy5kaSxcbiAgICAgIGVsZW1lbnQsXG4gICAgICB0cmFuc2xhdGUgPSB0aGlzLl90cmFuc2xhdGUsXG4gICAgICBoaWRkZW47XG5cbiAgdmFyIHBhcmVudEluZGV4O1xuXG4gIC8vIFJPT1QgRUxFTUVOVFxuICAvLyBoYW5kbGUgdGhlIHNwZWNpYWwgY2FzZSB0aGF0IHdlIGRlYWwgd2l0aCBhXG4gIC8vIGludmlzaWJsZSByb290IGVsZW1lbnQgKHByb2Nlc3Mgb3IgY29sbGFib3JhdGlvbilcbiAgaWYgKGlzKGRpLCAnYnBtbmRpOkJQTU5QbGFuZScpKSB7XG5cbiAgICAvLyBhZGQgYSB2aXJ0dWFsIGVsZW1lbnQgKG5vdCBiZWluZyBkcmF3bilcbiAgICBlbGVtZW50ID0gdGhpcy5fZWxlbWVudEZhY3RvcnkuY3JlYXRlUm9vdChlbGVtZW50RGF0YShzZW1hbnRpYykpO1xuXG4gICAgdGhpcy5fY2FudmFzLnNldFJvb3RFbGVtZW50KGVsZW1lbnQpO1xuICB9XG5cbiAgLy8gU0hBUEVcbiAgZWxzZSBpZiAoaXMoZGksICdicG1uZGk6QlBNTlNoYXBlJykpIHtcblxuICAgIHZhciBjb2xsYXBzZWQgPSAhaXNFeHBhbmRlZChzZW1hbnRpYyksXG4gICAgICAgIGlzRnJhbWUgPSBpc0ZyYW1lRWxlbWVudChzZW1hbnRpYyk7XG4gICAgaGlkZGVuID0gcGFyZW50RWxlbWVudCAmJiAocGFyZW50RWxlbWVudC5oaWRkZW4gfHwgcGFyZW50RWxlbWVudC5jb2xsYXBzZWQpO1xuXG4gICAgdmFyIGJvdW5kcyA9IHNlbWFudGljLmRpLmJvdW5kcztcblxuICAgIGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50RmFjdG9yeS5jcmVhdGVTaGFwZShlbGVtZW50RGF0YShzZW1hbnRpYywge1xuICAgICAgY29sbGFwc2VkOiBjb2xsYXBzZWQsXG4gICAgICBoaWRkZW46IGhpZGRlbixcbiAgICAgIHg6IE1hdGgucm91bmQoYm91bmRzLngpLFxuICAgICAgeTogTWF0aC5yb3VuZChib3VuZHMueSksXG4gICAgICB3aWR0aDogTWF0aC5yb3VuZChib3VuZHMud2lkdGgpLFxuICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKGJvdW5kcy5oZWlnaHQpLFxuICAgICAgaXNGcmFtZTogaXNGcmFtZVxuICAgIH0pKTtcblxuICAgIGlmIChpcyhzZW1hbnRpYywgJ2JwbW46Qm91bmRhcnlFdmVudCcpKSB7XG4gICAgICB0aGlzLl9hdHRhY2hCb3VuZGFyeShzZW1hbnRpYywgZWxlbWVudCk7XG4gICAgfVxuXG4gICAgLy8gaW5zZXJ0IGxhbmVzIGJlaGluZCBvdGhlciBmbG93IG5vZGVzIChjZi4gIzcyNylcbiAgICBpZiAoaXMoc2VtYW50aWMsICdicG1uOkxhbmUnKSkge1xuICAgICAgcGFyZW50SW5kZXggPSAwO1xuICAgIH1cblxuICAgIGlmIChpcyhzZW1hbnRpYywgJ2JwbW46RGF0YVN0b3JlUmVmZXJlbmNlJykpIHtcblxuICAgICAgLy8gY2hlY2sgd2hldGhlciBkYXRhIHN0b3JlIGlzIGluc2lkZSBvdXIgb3V0c2lkZSBvZiBpdHMgc2VtYW50aWMgcGFyZW50XG4gICAgICBpZiAoIWlzUG9pbnRJbnNpZGVCQm94KHBhcmVudEVsZW1lbnQsIGdldE1pZChib3VuZHMpKSkge1xuICAgICAgICBwYXJlbnRFbGVtZW50ID0gdGhpcy5fY2FudmFzLmdldFJvb3RFbGVtZW50KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fY2FudmFzLmFkZFNoYXBlKGVsZW1lbnQsIHBhcmVudEVsZW1lbnQsIHBhcmVudEluZGV4KTtcbiAgfVxuXG4gIC8vIENPTk5FQ1RJT05cbiAgZWxzZSBpZiAoaXMoZGksICdicG1uZGk6QlBNTkVkZ2UnKSkge1xuXG4gICAgdmFyIHNvdXJjZSA9IHRoaXMuX2dldFNvdXJjZShzZW1hbnRpYyksXG4gICAgICAgIHRhcmdldCA9IHRoaXMuX2dldFRhcmdldChzZW1hbnRpYyk7XG5cbiAgICBoaWRkZW4gPSBwYXJlbnRFbGVtZW50ICYmIChwYXJlbnRFbGVtZW50LmhpZGRlbiB8fCBwYXJlbnRFbGVtZW50LmNvbGxhcHNlZCk7XG5cbiAgICBlbGVtZW50ID0gdGhpcy5fZWxlbWVudEZhY3RvcnkuY3JlYXRlQ29ubmVjdGlvbihlbGVtZW50RGF0YShzZW1hbnRpYywge1xuICAgICAgaGlkZGVuOiBoaWRkZW4sXG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgd2F5cG9pbnRzOiBnZXRXYXlwb2ludHMoc2VtYW50aWMsIHNvdXJjZSwgdGFyZ2V0KVxuICAgIH0pKTtcblxuICAgIGlmIChpcyhzZW1hbnRpYywgJ2JwbW46RGF0YUFzc29jaWF0aW9uJykpIHtcblxuICAgICAgLy8gcmVuZGVyIGFsd2F5cyBvbiB0b3A7IHRoaXMgZW5zdXJlcyBEYXRhQXNzb2NpYXRpb25zXG4gICAgICAvLyBhcmUgcmVuZGVyZWQgY29ycmVjdGx5IGFjcm9zcyBkaWZmZXJlbnQgXCJoYWNrc1wiIHBlb3BsZVxuICAgICAgLy8gbG92ZSB0byBtb2RlbCBzdWNoIGFzIGNyb3NzIHBhcnRpY2lwYW50IC8gc3ViIHByb2Nlc3NcbiAgICAgIC8vIGFzc29jaWF0aW9uc1xuICAgICAgcGFyZW50RWxlbWVudCA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gaW5zZXJ0IHNlcXVlbmNlIGZsb3dzIGJlaGluZCBvdGhlciBmbG93IG5vZGVzIChjZi4gIzcyNylcbiAgICBpZiAoaXMoc2VtYW50aWMsICdicG1uOlNlcXVlbmNlRmxvdycpKSB7XG4gICAgICBwYXJlbnRJbmRleCA9IDA7XG4gICAgfVxuXG4gICAgdGhpcy5fY2FudmFzLmFkZENvbm5lY3Rpb24oZWxlbWVudCwgcGFyZW50RWxlbWVudCwgcGFyZW50SW5kZXgpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcih0cmFuc2xhdGUoJ3Vua25vd24gZGkge2RpfSBmb3IgZWxlbWVudCB7c2VtYW50aWN9Jywge1xuICAgICAgZGk6IGVsZW1lbnRUb1N0cmluZyhkaSksXG4gICAgICBzZW1hbnRpYzogZWxlbWVudFRvU3RyaW5nKHNlbWFudGljKVxuICAgIH0pKTtcbiAgfVxuXG4gIC8vIChvcHRpb25hbCkgTEFCRUxcbiAgaWYgKGlzTGFiZWxFeHRlcm5hbChzZW1hbnRpYykgJiYgZ2V0TGFiZWwoZWxlbWVudCkpIHtcbiAgICB0aGlzLmFkZExhYmVsKHNlbWFudGljLCBlbGVtZW50KTtcbiAgfVxuXG5cbiAgdGhpcy5fZXZlbnRCdXMuZmlyZSgnYnBtbkVsZW1lbnQuYWRkZWQnLCB7IGVsZW1lbnQ6IGVsZW1lbnQgfSk7XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG5cbi8qKlxuICogQXR0YWNoIHRoZSBib3VuZGFyeSBlbGVtZW50IHRvIHRoZSBnaXZlbiBob3N0XG4gKlxuICogQHBhcmFtIHtNb2RkbGVFbGVtZW50fSBib3VuZGFyeVNlbWFudGljXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5CYXNlfSBib3VuZGFyeUVsZW1lbnRcbiAqL1xuQnBtbkltcG9ydGVyLnByb3RvdHlwZS5fYXR0YWNoQm91bmRhcnkgPSBmdW5jdGlvbihib3VuZGFyeVNlbWFudGljLCBib3VuZGFyeUVsZW1lbnQpIHtcbiAgdmFyIHRyYW5zbGF0ZSA9IHRoaXMuX3RyYW5zbGF0ZTtcbiAgdmFyIGhvc3RTZW1hbnRpYyA9IGJvdW5kYXJ5U2VtYW50aWMuYXR0YWNoZWRUb1JlZjtcblxuICBpZiAoIWhvc3RTZW1hbnRpYykge1xuICAgIHRocm93IG5ldyBFcnJvcih0cmFuc2xhdGUoJ21pc3Npbmcge3NlbWFudGljfSNhdHRhY2hlZFRvUmVmJywge1xuICAgICAgc2VtYW50aWM6IGVsZW1lbnRUb1N0cmluZyhib3VuZGFyeVNlbWFudGljKVxuICAgIH0pKTtcbiAgfVxuXG4gIHZhciBob3N0ID0gdGhpcy5fZWxlbWVudFJlZ2lzdHJ5LmdldChob3N0U2VtYW50aWMuaWQpLFxuICAgICAgYXR0YWNoZXJzID0gaG9zdCAmJiBob3N0LmF0dGFjaGVycztcblxuICBpZiAoIWhvc3QpIHtcbiAgICB0aHJvdyBub3RZZXREcmF3bih0cmFuc2xhdGUsIGJvdW5kYXJ5U2VtYW50aWMsIGhvc3RTZW1hbnRpYywgJ2F0dGFjaGVkVG9SZWYnKTtcbiAgfVxuXG4gIC8vIHdpcmUgZWxlbWVudC5ob3N0IDw+IGhvc3QuYXR0YWNoZXJzXG4gIGJvdW5kYXJ5RWxlbWVudC5ob3N0ID0gaG9zdDtcblxuICBpZiAoIWF0dGFjaGVycykge1xuICAgIGhvc3QuYXR0YWNoZXJzID0gYXR0YWNoZXJzID0gW107XG4gIH1cblxuICBpZiAoYXR0YWNoZXJzLmluZGV4T2YoYm91bmRhcnlFbGVtZW50KSA9PT0gLTEpIHtcbiAgICBhdHRhY2hlcnMucHVzaChib3VuZGFyeUVsZW1lbnQpO1xuICB9XG59O1xuXG5cbi8qKlxuICogYWRkIGxhYmVsIGZvciBhbiBlbGVtZW50XG4gKi9cbkJwbW5JbXBvcnRlci5wcm90b3R5cGUuYWRkTGFiZWwgPSBmdW5jdGlvbihzZW1hbnRpYywgZWxlbWVudCkge1xuICB2YXIgYm91bmRzLFxuICAgICAgdGV4dCxcbiAgICAgIGxhYmVsO1xuXG4gIGJvdW5kcyA9IGdldEV4dGVybmFsTGFiZWxCb3VuZHMoc2VtYW50aWMsIGVsZW1lbnQpO1xuXG4gIHRleHQgPSBnZXRMYWJlbChlbGVtZW50KTtcblxuICBpZiAodGV4dCkge1xuXG4gICAgLy8gZ2V0IGNvcnJlY3RlZCBib3VuZHMgZnJvbSBhY3R1YWwgbGF5b3V0ZWQgdGV4dFxuICAgIGJvdW5kcyA9IHRoaXMuX3RleHRSZW5kZXJlci5nZXRFeHRlcm5hbExhYmVsQm91bmRzKGJvdW5kcywgdGV4dCk7XG4gIH1cblxuICBsYWJlbCA9IHRoaXMuX2VsZW1lbnRGYWN0b3J5LmNyZWF0ZUxhYmVsKGVsZW1lbnREYXRhKHNlbWFudGljLCB7XG4gICAgaWQ6IHNlbWFudGljLmlkICsgJ19sYWJlbCcsXG4gICAgbGFiZWxUYXJnZXQ6IGVsZW1lbnQsXG4gICAgdHlwZTogJ2xhYmVsJyxcbiAgICBoaWRkZW46IGVsZW1lbnQuaGlkZGVuIHx8ICFnZXRMYWJlbChlbGVtZW50KSxcbiAgICB4OiBNYXRoLnJvdW5kKGJvdW5kcy54KSxcbiAgICB5OiBNYXRoLnJvdW5kKGJvdW5kcy55KSxcbiAgICB3aWR0aDogTWF0aC5yb3VuZChib3VuZHMud2lkdGgpLFxuICAgIGhlaWdodDogTWF0aC5yb3VuZChib3VuZHMuaGVpZ2h0KVxuICB9KSk7XG5cbiAgcmV0dXJuIHRoaXMuX2NhbnZhcy5hZGRTaGFwZShsYWJlbCwgZWxlbWVudC5wYXJlbnQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGRyYXduIGNvbm5lY3Rpb24gZW5kIGJhc2VkIG9uIHRoZSBnaXZlbiBzaWRlLlxuICpcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgZW5kIGlzIG5vdCB5ZXQgZHJhd25cbiAqL1xuQnBtbkltcG9ydGVyLnByb3RvdHlwZS5fZ2V0RW5kID0gZnVuY3Rpb24oc2VtYW50aWMsIHNpZGUpIHtcblxuICB2YXIgZWxlbWVudCxcbiAgICAgIHJlZlNlbWFudGljLFxuICAgICAgdHlwZSA9IHNlbWFudGljLiR0eXBlLFxuICAgICAgdHJhbnNsYXRlID0gdGhpcy5fdHJhbnNsYXRlO1xuXG4gIHJlZlNlbWFudGljID0gc2VtYW50aWNbc2lkZSArICdSZWYnXTtcblxuICAvLyBoYW5kbGUgbXlzdGVyaW91cyBpc01hbnkgRGF0YUFzc29jaWF0aW9uI3NvdXJjZVJlZlxuICBpZiAoc2lkZSA9PT0gJ3NvdXJjZScgJiYgdHlwZSA9PT0gJ2JwbW46RGF0YUlucHV0QXNzb2NpYXRpb24nKSB7XG4gICAgcmVmU2VtYW50aWMgPSByZWZTZW1hbnRpYyAmJiByZWZTZW1hbnRpY1swXTtcbiAgfVxuXG4gIC8vIGZpeCBzb3VyY2UgLyB0YXJnZXQgZm9yIERhdGFJbnB1dEFzc29jaWF0aW9uIC8gRGF0YU91dHB1dEFzc29jaWF0aW9uXG4gIGlmIChzaWRlID09PSAnc291cmNlJyAmJiB0eXBlID09PSAnYnBtbjpEYXRhT3V0cHV0QXNzb2NpYXRpb24nIHx8XG4gICAgICBzaWRlID09PSAndGFyZ2V0JyAmJiB0eXBlID09PSAnYnBtbjpEYXRhSW5wdXRBc3NvY2lhdGlvbicpIHtcblxuICAgIHJlZlNlbWFudGljID0gc2VtYW50aWMuJHBhcmVudDtcbiAgfVxuXG4gIGVsZW1lbnQgPSByZWZTZW1hbnRpYyAmJiB0aGlzLl9nZXRFbGVtZW50KHJlZlNlbWFudGljKTtcblxuICBpZiAoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgaWYgKHJlZlNlbWFudGljKSB7XG4gICAgdGhyb3cgbm90WWV0RHJhd24odHJhbnNsYXRlLCBzZW1hbnRpYywgcmVmU2VtYW50aWMsIHNpZGUgKyAnUmVmJyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHRyYW5zbGF0ZSgne3NlbWFudGljfSN7c2lkZX0gUmVmIG5vdCBzcGVjaWZpZWQnLCB7XG4gICAgICBzZW1hbnRpYzogZWxlbWVudFRvU3RyaW5nKHNlbWFudGljKSxcbiAgICAgIHNpZGU6IHNpZGVcbiAgICB9KSk7XG4gIH1cbn07XG5cbkJwbW5JbXBvcnRlci5wcm90b3R5cGUuX2dldFNvdXJjZSA9IGZ1bmN0aW9uKHNlbWFudGljKSB7XG4gIHJldHVybiB0aGlzLl9nZXRFbmQoc2VtYW50aWMsICdzb3VyY2UnKTtcbn07XG5cbkJwbW5JbXBvcnRlci5wcm90b3R5cGUuX2dldFRhcmdldCA9IGZ1bmN0aW9uKHNlbWFudGljKSB7XG4gIHJldHVybiB0aGlzLl9nZXRFbmQoc2VtYW50aWMsICd0YXJnZXQnKTtcbn07XG5cblxuQnBtbkltcG9ydGVyLnByb3RvdHlwZS5fZ2V0RWxlbWVudCA9IGZ1bmN0aW9uKHNlbWFudGljKSB7XG4gIHJldHVybiB0aGlzLl9lbGVtZW50UmVnaXN0cnkuZ2V0KHNlbWFudGljLmlkKTtcbn07XG5cblxuLy8gaGVscGVycyAvLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBpc1BvaW50SW5zaWRlQkJveChiYm94LCBwb2ludCkge1xuICB2YXIgeCA9IHBvaW50LngsXG4gICAgICB5ID0gcG9pbnQueTtcblxuICByZXR1cm4geCA+PSBiYm94LnggJiZcbiAgICB4IDw9IGJib3gueCArIGJib3gud2lkdGggJiZcbiAgICB5ID49IGJib3gueSAmJlxuICAgIHkgPD0gYmJveC55ICsgYmJveC5oZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIGlzRnJhbWVFbGVtZW50KHNlbWFudGljKSB7XG4gIHJldHVybiBpcyhzZW1hbnRpYywgJ2JwbW46R3JvdXAnKTtcbn0iLCJpbXBvcnQge1xuICBmaWx0ZXIsXG4gIGZpbmQsXG4gIGZvckVhY2hcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQgUmVmcyBmcm9tICdvYmplY3QtcmVmcyc7XG5cbmltcG9ydCB7XG4gIGVsZW1lbnRUb1N0cmluZ1xufSBmcm9tICcuL1V0aWwnO1xuXG52YXIgZGlSZWZzID0gbmV3IFJlZnMoXG4gIHsgbmFtZTogJ2JwbW5FbGVtZW50JywgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICB7IG5hbWU6ICdkaScsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9XG4pO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbiBlbGVtZW50IGhhcyB0aGUgZ2l2ZW4gbWV0YS1tb2RlbCB0eXBlXG4gKlxuICogQHBhcmFtICB7TW9kZGxlRWxlbWVudH0gIGVsZW1lbnRcbiAqIEBwYXJhbSAge1N0cmluZ30gICAgICAgICB0eXBlXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXMoZWxlbWVudCwgdHlwZSkge1xuICByZXR1cm4gZWxlbWVudC4kaW5zdGFuY2VPZih0eXBlKTtcbn1cblxuXG4vKipcbiAqIEZpbmQgYSBzdWl0YWJsZSBkaXNwbGF5IGNhbmRpZGF0ZSBmb3IgZGVmaW5pdGlvbnMgd2hlcmUgdGhlIERJIGRvZXMgbm90XG4gKiBjb3JyZWN0bHkgc3BlY2lmeSBvbmUuXG4gKi9cbmZ1bmN0aW9uIGZpbmREaXNwbGF5Q2FuZGlkYXRlKGRlZmluaXRpb25zKSB7XG4gIHJldHVybiBmaW5kKGRlZmluaXRpb25zLnJvb3RFbGVtZW50cywgZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiBpcyhlLCAnYnBtbjpQcm9jZXNzJykgfHwgaXMoZSwgJ2JwbW46Q29sbGFib3JhdGlvbicpO1xuICB9KTtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCcG1uVHJlZVdhbGtlcihoYW5kbGVyLCB0cmFuc2xhdGUpIHtcblxuICAvLyBsaXN0IG9mIGNvbnRhaW5lcnMgYWxyZWFkeSB3YWxrZWRcbiAgdmFyIGhhbmRsZWRFbGVtZW50cyA9IHt9O1xuXG4gIC8vIGxpc3Qgb2YgZWxlbWVudHMgdG8gaGFuZGxlIGRlZmVycmVkIHRvIGVuc3VyZVxuICAvLyBwcmVyZXF1aXNpdGVzIGFyZSBkcmF3blxuICB2YXIgZGVmZXJyZWQgPSBbXTtcblxuICAvLyBIZWxwZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICBmdW5jdGlvbiBjb250ZXh0dWFsKGZuLCBjdHgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgZm4oZSwgY3R4KTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlZChlbGVtZW50KSB7XG4gICAgaGFuZGxlZEVsZW1lbnRzW2VsZW1lbnQuaWRdID0gZWxlbWVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSGFuZGxlZChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGhhbmRsZWRFbGVtZW50c1tlbGVtZW50LmlkXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZpc2l0KGVsZW1lbnQsIGN0eCkge1xuXG4gICAgdmFyIGdmeCA9IGVsZW1lbnQuZ2Z4O1xuXG4gICAgLy8gYXZvaWQgbXVsdGlwbGUgcmVuZGVyaW5nIG9mIGVsZW1lbnRzXG4gICAgaWYgKGdmeCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICB0cmFuc2xhdGUoJ2FscmVhZHkgcmVuZGVyZWQge2VsZW1lbnR9JywgeyBlbGVtZW50OiBlbGVtZW50VG9TdHJpbmcoZWxlbWVudCkgfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gY2FsbCBoYW5kbGVyXG4gICAgcmV0dXJuIGhhbmRsZXIuZWxlbWVudChlbGVtZW50LCBjdHgpO1xuICB9XG5cbiAgZnVuY3Rpb24gdmlzaXRSb290KGVsZW1lbnQsIGRpYWdyYW0pIHtcbiAgICByZXR1cm4gaGFuZGxlci5yb290KGVsZW1lbnQsIGRpYWdyYW0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdmlzaXRJZkRpKGVsZW1lbnQsIGN0eCkge1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBnZnggPSBlbGVtZW50LmRpICYmIHZpc2l0KGVsZW1lbnQsIGN0eCk7XG5cbiAgICAgIGhhbmRsZWQoZWxlbWVudCk7XG5cbiAgICAgIHJldHVybiBnZng7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nRXJyb3IoZS5tZXNzYWdlLCB7IGVsZW1lbnQ6IGVsZW1lbnQsIGVycm9yOiBlIH0pO1xuXG4gICAgICBjb25zb2xlLmVycm9yKHRyYW5zbGF0ZSgnZmFpbGVkIHRvIGltcG9ydCB7ZWxlbWVudH0nLCB7IGVsZW1lbnQ6IGVsZW1lbnRUb1N0cmluZyhlbGVtZW50KSB9KSk7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGxvZ0Vycm9yKG1lc3NhZ2UsIGNvbnRleHQpIHtcbiAgICBoYW5kbGVyLmVycm9yKG1lc3NhZ2UsIGNvbnRleHQpO1xuICB9XG5cbiAgLy8gREkgaGFuZGxpbmcgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyRGkoZGkpIHtcbiAgICB2YXIgYnBtbkVsZW1lbnQgPSBkaS5icG1uRWxlbWVudDtcblxuICAgIGlmIChicG1uRWxlbWVudCkge1xuICAgICAgaWYgKGJwbW5FbGVtZW50LmRpKSB7XG4gICAgICAgIGxvZ0Vycm9yKFxuICAgICAgICAgIHRyYW5zbGF0ZSgnbXVsdGlwbGUgREkgZWxlbWVudHMgZGVmaW5lZCBmb3Ige2VsZW1lbnR9Jywge1xuICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudFRvU3RyaW5nKGJwbW5FbGVtZW50KVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHsgZWxlbWVudDogYnBtbkVsZW1lbnQgfVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlSZWZzLmJpbmQoYnBtbkVsZW1lbnQsICdkaScpO1xuICAgICAgICBicG1uRWxlbWVudC5kaSA9IGRpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2dFcnJvcihcbiAgICAgICAgdHJhbnNsYXRlKCdubyBicG1uRWxlbWVudCByZWZlcmVuY2VkIGluIHtlbGVtZW50fScsIHtcbiAgICAgICAgICBlbGVtZW50OiBlbGVtZW50VG9TdHJpbmcoZGkpXG4gICAgICAgIH0pLFxuICAgICAgICB7IGVsZW1lbnQ6IGRpIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlRGlhZ3JhbShkaWFncmFtKSB7XG4gICAgaGFuZGxlUGxhbmUoZGlhZ3JhbS5wbGFuZSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVQbGFuZShwbGFuZSkge1xuICAgIHJlZ2lzdGVyRGkocGxhbmUpO1xuXG4gICAgZm9yRWFjaChwbGFuZS5wbGFuZUVsZW1lbnQsIGhhbmRsZVBsYW5lRWxlbWVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVQbGFuZUVsZW1lbnQocGxhbmVFbGVtZW50KSB7XG4gICAgcmVnaXN0ZXJEaShwbGFuZUVsZW1lbnQpO1xuICB9XG5cblxuICAvLyBTZW1hbnRpYyBoYW5kbGluZyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgLyoqXG4gICAqIEhhbmRsZSBkZWZpbml0aW9ucyBhbmQgcmV0dXJuIHRoZSByZW5kZXJlZCBkaWFncmFtIChpZiBhbnkpXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudH0gZGVmaW5pdGlvbnMgdG8gd2FsayBhbmQgaW1wb3J0XG4gICAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudH0gW2RpYWdyYW1dIHNwZWNpZmljIGRpYWdyYW0gdG8gaW1wb3J0IGFuZCBkaXNwbGF5XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBpZiBubyBkaWFncmFtIHRvIGRpc3BsYXkgY291bGQgYmUgZm91bmRcbiAgICovXG4gIGZ1bmN0aW9uIGhhbmRsZURlZmluaXRpb25zKGRlZmluaXRpb25zLCBkaWFncmFtKSB7XG5cbiAgICAvLyBtYWtlIHN1cmUgd2Ugd2FsayB0aGUgY29ycmVjdCBicG1uRWxlbWVudFxuXG4gICAgdmFyIGRpYWdyYW1zID0gZGVmaW5pdGlvbnMuZGlhZ3JhbXM7XG5cbiAgICBpZiAoZGlhZ3JhbSAmJiBkaWFncmFtcy5pbmRleE9mKGRpYWdyYW0pID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHRyYW5zbGF0ZSgnZGlhZ3JhbSBub3QgcGFydCBvZiBicG1uOkRlZmluaXRpb25zJykpO1xuICAgIH1cblxuICAgIGlmICghZGlhZ3JhbSAmJiBkaWFncmFtcyAmJiBkaWFncmFtcy5sZW5ndGgpIHtcbiAgICAgIGRpYWdyYW0gPSBkaWFncmFtc1swXTtcbiAgICB9XG5cbiAgICAvLyBubyBkaWFncmFtIC0+IG5vdGhpbmcgdG8gaW1wb3J0XG4gICAgaWYgKCFkaWFncmFtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodHJhbnNsYXRlKCdubyBkaWFncmFtIHRvIGRpc3BsYXknKSk7XG4gICAgfVxuXG4gICAgLy8gbG9hZCBESSBmcm9tIHNlbGVjdGVkIGRpYWdyYW0gb25seVxuICAgIGhhbmRsZURpYWdyYW0oZGlhZ3JhbSk7XG5cblxuICAgIHZhciBwbGFuZSA9IGRpYWdyYW0ucGxhbmU7XG5cbiAgICBpZiAoIXBsYW5lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodHJhbnNsYXRlKFxuICAgICAgICAnbm8gcGxhbmUgZm9yIHtlbGVtZW50fScsXG4gICAgICAgIHsgZWxlbWVudDogZWxlbWVudFRvU3RyaW5nKGRpYWdyYW0pIH1cbiAgICAgICkpO1xuICAgIH1cblxuICAgIHZhciByb290RWxlbWVudCA9IHBsYW5lLmJwbW5FbGVtZW50O1xuXG4gICAgLy8gZW5zdXJlIHdlIGRlZmF1bHQgdG8gYSBzdWl0YWJsZSBkaXNwbGF5IGNhbmRpZGF0ZSAocHJvY2VzcyBvciBjb2xsYWJvcmF0aW9uKSxcbiAgICAvLyBldmVuIGlmIG5vbiBpcyBzcGVjaWZpZWQgaW4gRElcbiAgICBpZiAoIXJvb3RFbGVtZW50KSB7XG4gICAgICByb290RWxlbWVudCA9IGZpbmREaXNwbGF5Q2FuZGlkYXRlKGRlZmluaXRpb25zKTtcblxuICAgICAgaWYgKCFyb290RWxlbWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodHJhbnNsYXRlKCdubyBwcm9jZXNzIG9yIGNvbGxhYm9yYXRpb24gdG8gZGlzcGxheScpKTtcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgbG9nRXJyb3IoXG4gICAgICAgICAgdHJhbnNsYXRlKCdjb3JyZWN0aW5nIG1pc3NpbmcgYnBtbkVsZW1lbnQgb24ge3BsYW5lfSB0byB7cm9vdEVsZW1lbnR9Jywge1xuICAgICAgICAgICAgcGxhbmU6IGVsZW1lbnRUb1N0cmluZyhwbGFuZSksXG4gICAgICAgICAgICByb290RWxlbWVudDogZWxlbWVudFRvU3RyaW5nKHJvb3RFbGVtZW50KVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gY29ycmVjdCBESSBvbiB0aGUgZmx5XG4gICAgICAgIHBsYW5lLmJwbW5FbGVtZW50ID0gcm9vdEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVyRGkocGxhbmUpO1xuICAgICAgfVxuICAgIH1cblxuXG4gICAgdmFyIGN0eCA9IHZpc2l0Um9vdChyb290RWxlbWVudCwgcGxhbmUpO1xuXG4gICAgaWYgKGlzKHJvb3RFbGVtZW50LCAnYnBtbjpQcm9jZXNzJykpIHtcbiAgICAgIGhhbmRsZVByb2Nlc3Mocm9vdEVsZW1lbnQsIGN0eCk7XG4gICAgfSBlbHNlIGlmIChpcyhyb290RWxlbWVudCwgJ2JwbW46Q29sbGFib3JhdGlvbicpKSB7XG4gICAgICBoYW5kbGVDb2xsYWJvcmF0aW9uKHJvb3RFbGVtZW50LCBjdHgpO1xuXG4gICAgICAvLyBmb3JjZSBkcmF3aW5nIG9mIGV2ZXJ5dGhpbmcgbm90IHlldCBkcmF3biB0aGF0IGlzIHBhcnQgb2YgdGhlIHRhcmdldCBESVxuICAgICAgaGFuZGxlVW5oYW5kbGVkUHJvY2Vzc2VzKGRlZmluaXRpb25zLnJvb3RFbGVtZW50cywgY3R4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICB0cmFuc2xhdGUoJ3Vuc3VwcG9ydGVkIGJwbW5FbGVtZW50IGZvciB7cGxhbmV9OiB7cm9vdEVsZW1lbnR9Jywge1xuICAgICAgICAgIHBsYW5lOiBlbGVtZW50VG9TdHJpbmcocGxhbmUpLFxuICAgICAgICAgIHJvb3RFbGVtZW50OiBlbGVtZW50VG9TdHJpbmcocm9vdEVsZW1lbnQpXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBhbGwgZGVmZXJyZWQgZWxlbWVudHNcbiAgICBoYW5kbGVEZWZlcnJlZChkZWZlcnJlZCk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVEZWZlcnJlZCgpIHtcblxuICAgIHZhciBmbjtcblxuICAgIC8vIGRyYWluIGRlZmVycmVkIHVudGlsIGVtcHR5XG4gICAgd2hpbGUgKGRlZmVycmVkLmxlbmd0aCkge1xuICAgICAgZm4gPSBkZWZlcnJlZC5zaGlmdCgpO1xuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVByb2Nlc3MocHJvY2VzcywgY29udGV4dCkge1xuICAgIGhhbmRsZUZsb3dFbGVtZW50c0NvbnRhaW5lcihwcm9jZXNzLCBjb250ZXh0KTtcbiAgICBoYW5kbGVJb1NwZWNpZmljYXRpb24ocHJvY2Vzcy5pb1NwZWNpZmljYXRpb24sIGNvbnRleHQpO1xuXG4gICAgaGFuZGxlQXJ0aWZhY3RzKHByb2Nlc3MuYXJ0aWZhY3RzLCBjb250ZXh0KTtcblxuICAgIC8vIGxvZyBwcm9jZXNzIGhhbmRsZWRcbiAgICBoYW5kbGVkKHByb2Nlc3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlVW5oYW5kbGVkUHJvY2Vzc2VzKHJvb3RFbGVtZW50cywgY3R4KSB7XG5cbiAgICAvLyB3YWxrIHRocm91Z2ggYWxsIHByb2Nlc3NlcyB0aGF0IGhhdmUgbm90IHlldCBiZWVuIGRyYXduIGFuZCBkcmF3IHRoZW1cbiAgICAvLyBpZiB0aGV5IGNvbnRhaW4gbGFuZXMgd2l0aCBESSBpbmZvcm1hdGlvbi5cbiAgICAvLyB3ZSBkbyB0aGlzIHRvIHBhc3MgdGhlIGZyZWUtZmxvYXRpbmcgbGFuZSB0ZXN0IGNhc2VzIGluIHRoZSBNSVdHIHRlc3Qgc3VpdGVcbiAgICB2YXIgcHJvY2Vzc2VzID0gZmlsdGVyKHJvb3RFbGVtZW50cywgZnVuY3Rpb24oZSkge1xuICAgICAgcmV0dXJuICFpc0hhbmRsZWQoZSkgJiYgaXMoZSwgJ2JwbW46UHJvY2VzcycpICYmIGUubGFuZVNldHM7XG4gICAgfSk7XG5cbiAgICBwcm9jZXNzZXMuZm9yRWFjaChjb250ZXh0dWFsKGhhbmRsZVByb2Nlc3MsIGN0eCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZUZsb3cobWVzc2FnZUZsb3csIGNvbnRleHQpIHtcbiAgICB2aXNpdElmRGkobWVzc2FnZUZsb3csIGNvbnRleHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZUZsb3dzKG1lc3NhZ2VGbG93cywgY29udGV4dCkge1xuICAgIGZvckVhY2gobWVzc2FnZUZsb3dzLCBjb250ZXh0dWFsKGhhbmRsZU1lc3NhZ2VGbG93LCBjb250ZXh0KSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVEYXRhQXNzb2NpYXRpb24oYXNzb2NpYXRpb24sIGNvbnRleHQpIHtcbiAgICB2aXNpdElmRGkoYXNzb2NpYXRpb24sIGNvbnRleHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlRGF0YUlucHV0KGRhdGFJbnB1dCwgY29udGV4dCkge1xuICAgIHZpc2l0SWZEaShkYXRhSW5wdXQsIGNvbnRleHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlRGF0YU91dHB1dChkYXRhT3V0cHV0LCBjb250ZXh0KSB7XG4gICAgdmlzaXRJZkRpKGRhdGFPdXRwdXQsIGNvbnRleHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQXJ0aWZhY3QoYXJ0aWZhY3QsIGNvbnRleHQpIHtcblxuICAgIC8vIGJwbW46VGV4dEFubm90YXRpb25cbiAgICAvLyBicG1uOkdyb3VwXG4gICAgLy8gYnBtbjpBc3NvY2lhdGlvblxuXG4gICAgdmlzaXRJZkRpKGFydGlmYWN0LCBjb250ZXh0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUFydGlmYWN0cyhhcnRpZmFjdHMsIGNvbnRleHQpIHtcblxuICAgIGZvckVhY2goYXJ0aWZhY3RzLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoaXMoZSwgJ2JwbW46QXNzb2NpYXRpb24nKSkge1xuICAgICAgICBkZWZlcnJlZC5wdXNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGhhbmRsZUFydGlmYWN0KGUsIGNvbnRleHQpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZUFydGlmYWN0KGUsIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlSW9TcGVjaWZpY2F0aW9uKGlvU3BlY2lmaWNhdGlvbiwgY29udGV4dCkge1xuXG4gICAgaWYgKCFpb1NwZWNpZmljYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3JFYWNoKGlvU3BlY2lmaWNhdGlvbi5kYXRhSW5wdXRzLCBjb250ZXh0dWFsKGhhbmRsZURhdGFJbnB1dCwgY29udGV4dCkpO1xuICAgIGZvckVhY2goaW9TcGVjaWZpY2F0aW9uLmRhdGFPdXRwdXRzLCBjb250ZXh0dWFsKGhhbmRsZURhdGFPdXRwdXQsIGNvbnRleHQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVN1YlByb2Nlc3Moc3ViUHJvY2VzcywgY29udGV4dCkge1xuICAgIGhhbmRsZUZsb3dFbGVtZW50c0NvbnRhaW5lcihzdWJQcm9jZXNzLCBjb250ZXh0KTtcbiAgICBoYW5kbGVBcnRpZmFjdHMoc3ViUHJvY2Vzcy5hcnRpZmFjdHMsIGNvbnRleHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlRmxvd05vZGUoZmxvd05vZGUsIGNvbnRleHQpIHtcbiAgICB2YXIgY2hpbGRDdHggPSB2aXNpdElmRGkoZmxvd05vZGUsIGNvbnRleHQpO1xuXG4gICAgaWYgKGlzKGZsb3dOb2RlLCAnYnBtbjpTdWJQcm9jZXNzJykpIHtcbiAgICAgIGhhbmRsZVN1YlByb2Nlc3MoZmxvd05vZGUsIGNoaWxkQ3R4IHx8IGNvbnRleHQpO1xuICAgIH1cblxuICAgIGlmIChpcyhmbG93Tm9kZSwgJ2JwbW46QWN0aXZpdHknKSkge1xuICAgICAgaGFuZGxlSW9TcGVjaWZpY2F0aW9uKGZsb3dOb2RlLmlvU3BlY2lmaWNhdGlvbiwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgLy8gZGVmZXIgaGFuZGxpbmcgb2YgYXNzb2NpYXRpb25zXG4gICAgLy8gYWZmZWN0ZWQgdHlwZXM6XG4gICAgLy9cbiAgICAvLyAgICogYnBtbjpBY3Rpdml0eVxuICAgIC8vICAgKiBicG1uOlRocm93RXZlbnRcbiAgICAvLyAgICogYnBtbjpDYXRjaEV2ZW50XG4gICAgLy9cbiAgICBkZWZlcnJlZC5wdXNoKGZ1bmN0aW9uKCkge1xuICAgICAgZm9yRWFjaChmbG93Tm9kZS5kYXRhSW5wdXRBc3NvY2lhdGlvbnMsIGNvbnRleHR1YWwoaGFuZGxlRGF0YUFzc29jaWF0aW9uLCBjb250ZXh0KSk7XG4gICAgICBmb3JFYWNoKGZsb3dOb2RlLmRhdGFPdXRwdXRBc3NvY2lhdGlvbnMsIGNvbnRleHR1YWwoaGFuZGxlRGF0YUFzc29jaWF0aW9uLCBjb250ZXh0KSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTZXF1ZW5jZUZsb3coc2VxdWVuY2VGbG93LCBjb250ZXh0KSB7XG4gICAgdmlzaXRJZkRpKHNlcXVlbmNlRmxvdywgY29udGV4dCk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVEYXRhRWxlbWVudChkYXRhT2JqZWN0LCBjb250ZXh0KSB7XG4gICAgdmlzaXRJZkRpKGRhdGFPYmplY3QsIGNvbnRleHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTGFuZShsYW5lLCBjb250ZXh0KSB7XG5cbiAgICBkZWZlcnJlZC5wdXNoKGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgbmV3Q29udGV4dCA9IHZpc2l0SWZEaShsYW5lLCBjb250ZXh0KTtcblxuICAgICAgaWYgKGxhbmUuY2hpbGRMYW5lU2V0KSB7XG4gICAgICAgIGhhbmRsZUxhbmVTZXQobGFuZS5jaGlsZExhbmVTZXQsIG5ld0NvbnRleHQgfHwgY29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHdpcmVGbG93Tm9kZVJlZnMobGFuZSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVMYW5lU2V0KGxhbmVTZXQsIGNvbnRleHQpIHtcbiAgICBmb3JFYWNoKGxhbmVTZXQubGFuZXMsIGNvbnRleHR1YWwoaGFuZGxlTGFuZSwgY29udGV4dCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTGFuZVNldHMobGFuZVNldHMsIGNvbnRleHQpIHtcbiAgICBmb3JFYWNoKGxhbmVTZXRzLCBjb250ZXh0dWFsKGhhbmRsZUxhbmVTZXQsIGNvbnRleHQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUZsb3dFbGVtZW50c0NvbnRhaW5lcihjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICBoYW5kbGVGbG93RWxlbWVudHMoY29udGFpbmVyLmZsb3dFbGVtZW50cywgY29udGV4dCk7XG5cbiAgICBpZiAoY29udGFpbmVyLmxhbmVTZXRzKSB7XG4gICAgICBoYW5kbGVMYW5lU2V0cyhjb250YWluZXIubGFuZVNldHMsIGNvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUZsb3dFbGVtZW50cyhmbG93RWxlbWVudHMsIGNvbnRleHQpIHtcbiAgICBmb3JFYWNoKGZsb3dFbGVtZW50cywgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGlzKGUsICdicG1uOlNlcXVlbmNlRmxvdycpKSB7XG4gICAgICAgIGRlZmVycmVkLnB1c2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaGFuZGxlU2VxdWVuY2VGbG93KGUsIGNvbnRleHQpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoaXMoZSwgJ2JwbW46Qm91bmRhcnlFdmVudCcpKSB7XG4gICAgICAgIGRlZmVycmVkLnVuc2hpZnQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaGFuZGxlRmxvd05vZGUoZSwgY29udGV4dCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpcyhlLCAnYnBtbjpGbG93Tm9kZScpKSB7XG4gICAgICAgIGhhbmRsZUZsb3dOb2RlKGUsIGNvbnRleHQpO1xuICAgICAgfSBlbHNlIGlmIChpcyhlLCAnYnBtbjpEYXRhT2JqZWN0JykpIHtcblxuICAgICAgICAvLyBTS0lQIChhc3N1bWUgY29ycmVjdCByZWZlcmVuY2luZyB2aWEgRGF0YU9iamVjdFJlZmVyZW5jZSlcbiAgICAgIH0gZWxzZSBpZiAoaXMoZSwgJ2JwbW46RGF0YVN0b3JlUmVmZXJlbmNlJykpIHtcbiAgICAgICAgaGFuZGxlRGF0YUVsZW1lbnQoZSwgY29udGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKGlzKGUsICdicG1uOkRhdGFPYmplY3RSZWZlcmVuY2UnKSkge1xuICAgICAgICBoYW5kbGVEYXRhRWxlbWVudChlLCBjb250ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ0Vycm9yKFxuICAgICAgICAgIHRyYW5zbGF0ZSgndW5yZWNvZ25pemVkIGZsb3dFbGVtZW50IHtlbGVtZW50fSBpbiBjb250ZXh0IHtjb250ZXh0fScsIHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnRUb1N0cmluZyhlKSxcbiAgICAgICAgICAgIGNvbnRleHQ6IChjb250ZXh0ID8gZWxlbWVudFRvU3RyaW5nKGNvbnRleHQuYnVzaW5lc3NPYmplY3QpIDogJ251bGwnKVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHsgZWxlbWVudDogZSwgY29udGV4dDogY29udGV4dCB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVQYXJ0aWNpcGFudChwYXJ0aWNpcGFudCwgY29udGV4dCkge1xuICAgIHZhciBuZXdDdHggPSB2aXNpdElmRGkocGFydGljaXBhbnQsIGNvbnRleHQpO1xuXG4gICAgdmFyIHByb2Nlc3MgPSBwYXJ0aWNpcGFudC5wcm9jZXNzUmVmO1xuICAgIGlmIChwcm9jZXNzKSB7XG4gICAgICBoYW5kbGVQcm9jZXNzKHByb2Nlc3MsIG5ld0N0eCB8fCBjb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDb2xsYWJvcmF0aW9uKGNvbGxhYm9yYXRpb24pIHtcblxuICAgIGZvckVhY2goY29sbGFib3JhdGlvbi5wYXJ0aWNpcGFudHMsIGNvbnRleHR1YWwoaGFuZGxlUGFydGljaXBhbnQpKTtcblxuICAgIGhhbmRsZUFydGlmYWN0cyhjb2xsYWJvcmF0aW9uLmFydGlmYWN0cyk7XG5cbiAgICAvLyBoYW5kbGUgbWVzc2FnZSBmbG93cyBsYXRlc3QgaW4gdGhlIHByb2Nlc3NcbiAgICBkZWZlcnJlZC5wdXNoKGZ1bmN0aW9uKCkge1xuICAgICAgaGFuZGxlTWVzc2FnZUZsb3dzKGNvbGxhYm9yYXRpb24ubWVzc2FnZUZsb3dzKTtcbiAgICB9KTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gd2lyZUZsb3dOb2RlUmVmcyhsYW5lKSB7XG5cbiAgICAvLyB3aXJlIHRoZSB2aXJ0dWFsIGZsb3dOb2RlUmVmcyA8LT4gcmVsYXRpb25zaGlwXG4gICAgZm9yRWFjaChsYW5lLmZsb3dOb2RlUmVmLCBmdW5jdGlvbihmbG93Tm9kZSkge1xuICAgICAgdmFyIGxhbmVzID0gZmxvd05vZGUuZ2V0KCdsYW5lcycpO1xuXG4gICAgICBpZiAobGFuZXMpIHtcbiAgICAgICAgbGFuZXMucHVzaChsYW5lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIEFQSSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgcmV0dXJuIHtcbiAgICBoYW5kbGVEZWZlcnJlZDogaGFuZGxlRGVmZXJyZWQsXG4gICAgaGFuZGxlRGVmaW5pdGlvbnM6IGhhbmRsZURlZmluaXRpb25zLFxuICAgIGhhbmRsZVN1YlByb2Nlc3M6IGhhbmRsZVN1YlByb2Nlc3MsXG4gICAgcmVnaXN0ZXJEaTogcmVnaXN0ZXJEaVxuICB9O1xufSIsImltcG9ydCBCcG1uVHJlZVdhbGtlciBmcm9tICcuL0JwbW5UcmVlV2Fsa2VyJztcblxuaW1wb3J0IHtcbiAgaXNGdW5jdGlvblxufSBmcm9tICdtaW4tZGFzaCc7XG5cbi8qKlxuICogSW1wb3J0IHRoZSBkZWZpbml0aW9ucyBpbnRvIGEgZGlhZ3JhbS5cbiAqXG4gKiBFcnJvcnMgYW5kIHdhcm5pbmdzIGFyZSByZXBvcnRlZCB0aHJvdWdoIHRoZSBzcGVjaWZpZWQgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtICB7ZGpzLkRpYWdyYW19IGRpYWdyYW1cbiAqIEBwYXJhbSAge01vZGRsZUVsZW1lbnQ8RGVmaW5pdGlvbnM+fSBkZWZpbml0aW9uc1xuICogQHBhcmFtICB7TW9kZGxlRWxlbWVudDxCUE1ORGlhZ3JhbT59IFticG1uRGlhZ3JhbV0gdGhlIGRpYWdyYW0gdG8gYmUgcmVuZGVyZWRcbiAqIChpZiBub3QgcHJvdmlkZWQsIHRoZSBmaXJzdCBvbmUgd2lsbCBiZSByZW5kZXJlZClcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBkb25lIHRoZSBjYWxsYmFjaywgaW52b2tlZCB3aXRoIChlcnIsIFsgd2FybmluZyBdKSBvbmNlIHRoZSBpbXBvcnQgaXMgZG9uZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW1wb3J0QnBtbkRpYWdyYW0oZGlhZ3JhbSwgZGVmaW5pdGlvbnMsIGJwbW5EaWFncmFtLCBkb25lKSB7XG5cbiAgaWYgKGlzRnVuY3Rpb24oYnBtbkRpYWdyYW0pKSB7XG4gICAgZG9uZSA9IGJwbW5EaWFncmFtO1xuICAgIGJwbW5EaWFncmFtID0gbnVsbDtcbiAgfVxuXG4gIHZhciBpbXBvcnRlcixcbiAgICAgIGV2ZW50QnVzLFxuICAgICAgdHJhbnNsYXRlO1xuXG4gIHZhciBlcnJvcixcbiAgICAgIHdhcm5pbmdzID0gW107XG5cbiAgLyoqXG4gICAqIFdhbGsgdGhlIGRpYWdyYW0gc2VtYW50aWNhbGx5LCBpbXBvcnRpbmcgKD1kcmF3aW5nKVxuICAgKiBhbGwgZWxlbWVudHMgeW91IGVuY291bnRlci5cbiAgICpcbiAgICogQHBhcmFtIHtNb2RkbGVFbGVtZW50PERlZmluaXRpb25zPn0gZGVmaW5pdGlvbnNcbiAgICogQHBhcmFtIHtNb2RkbGVFbGVtZW50PEJQTU5EaWFncmFtPn0gYnBtbkRpYWdyYW1cbiAgICovXG4gIGZ1bmN0aW9uIHJlbmRlcihkZWZpbml0aW9ucywgYnBtbkRpYWdyYW0pIHtcblxuICAgIHZhciB2aXNpdG9yID0ge1xuXG4gICAgICByb290OiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBpbXBvcnRlci5hZGQoZWxlbWVudCk7XG4gICAgICB9LFxuXG4gICAgICBlbGVtZW50OiBmdW5jdGlvbihlbGVtZW50LCBwYXJlbnRTaGFwZSkge1xuICAgICAgICByZXR1cm4gaW1wb3J0ZXIuYWRkKGVsZW1lbnQsIHBhcmVudFNoYXBlKTtcbiAgICAgIH0sXG5cbiAgICAgIGVycm9yOiBmdW5jdGlvbihtZXNzYWdlLCBjb250ZXh0KSB7XG4gICAgICAgIHdhcm5pbmdzLnB1c2goeyBtZXNzYWdlOiBtZXNzYWdlLCBjb250ZXh0OiBjb250ZXh0IH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgd2Fsa2VyID0gbmV3IEJwbW5UcmVlV2Fsa2VyKHZpc2l0b3IsIHRyYW5zbGF0ZSk7XG5cbiAgICAvLyB0cmF2ZXJzZSBCUE1OIDIuMCBkb2N1bWVudCBtb2RlbCxcbiAgICAvLyBzdGFydGluZyBhdCBkZWZpbml0aW9uc1xuICAgIHdhbGtlci5oYW5kbGVEZWZpbml0aW9ucyhkZWZpbml0aW9ucywgYnBtbkRpYWdyYW0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpbXBvcnRlciA9IGRpYWdyYW0uZ2V0KCdicG1uSW1wb3J0ZXInKTtcbiAgICBldmVudEJ1cyA9IGRpYWdyYW0uZ2V0KCdldmVudEJ1cycpO1xuICAgIHRyYW5zbGF0ZSA9IGRpYWdyYW0uZ2V0KCd0cmFuc2xhdGUnKTtcblxuICAgIGV2ZW50QnVzLmZpcmUoJ2ltcG9ydC5yZW5kZXIuc3RhcnQnLCB7IGRlZmluaXRpb25zOiBkZWZpbml0aW9ucyB9KTtcblxuICAgIHJlbmRlcihkZWZpbml0aW9ucywgYnBtbkRpYWdyYW0pO1xuXG4gICAgZXZlbnRCdXMuZmlyZSgnaW1wb3J0LnJlbmRlci5jb21wbGV0ZScsIHtcbiAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgIHdhcm5pbmdzOiB3YXJuaW5nc1xuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3IgPSBlO1xuICB9XG5cbiAgZG9uZShlcnJvciwgd2FybmluZ3MpO1xufSIsImV4cG9ydCBmdW5jdGlvbiBlbGVtZW50VG9TdHJpbmcoZSkge1xuICBpZiAoIWUpIHtcbiAgICByZXR1cm4gJzxudWxsPic7XG4gIH1cblxuICByZXR1cm4gJzwnICsgZS4kdHlwZSArIChlLmlkID8gJyBpZD1cIicgKyBlLmlkIDogJycpICsgJ1wiIC8+Jztcbn0iLCJpbXBvcnQgdHJhbnNsYXRlIGZyb20gJ2RpYWdyYW0tanMvbGliL2kxOG4vdHJhbnNsYXRlJztcblxuaW1wb3J0IEJwbW5JbXBvcnRlciBmcm9tICcuL0JwbW5JbXBvcnRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19kZXBlbmRzX186IFtcbiAgICB0cmFuc2xhdGVcbiAgXSxcbiAgYnBtbkltcG9ydGVyOiBbICd0eXBlJywgQnBtbkltcG9ydGVyIF1cbn07IiwiaW1wb3J0IHtcbiAgaXMsXG4gIGdldEJ1c2luZXNzT2JqZWN0XG59IGZyb20gJy4vTW9kZWxVdGlsJztcblxuaW1wb3J0IHtcbiAgZm9yRWFjaFxufSBmcm9tICdtaW4tZGFzaCc7XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRXhwYW5kZWQoZWxlbWVudCkge1xuXG4gIGlmIChpcyhlbGVtZW50LCAnYnBtbjpDYWxsQWN0aXZpdHknKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChpcyhlbGVtZW50LCAnYnBtbjpTdWJQcm9jZXNzJykpIHtcbiAgICByZXR1cm4gISFnZXRCdXNpbmVzc09iamVjdChlbGVtZW50KS5kaS5pc0V4cGFuZGVkO1xuICB9XG5cbiAgaWYgKGlzKGVsZW1lbnQsICdicG1uOlBhcnRpY2lwYW50JykpIHtcbiAgICByZXR1cm4gISFnZXRCdXNpbmVzc09iamVjdChlbGVtZW50KS5wcm9jZXNzUmVmO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ludGVycnVwdGluZyhlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50ICYmIGdldEJ1c2luZXNzT2JqZWN0KGVsZW1lbnQpLmlzSW50ZXJydXB0aW5nICE9PSBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRXZlbnRTdWJQcm9jZXNzKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQgJiYgISFnZXRCdXNpbmVzc09iamVjdChlbGVtZW50KS50cmlnZ2VyZWRCeUV2ZW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzRXZlbnREZWZpbml0aW9uKGVsZW1lbnQsIGV2ZW50VHlwZSkge1xuICB2YXIgYm8gPSBnZXRCdXNpbmVzc09iamVjdChlbGVtZW50KSxcbiAgICAgIGhhc0V2ZW50RGVmaW5pdGlvbiA9IGZhbHNlO1xuXG4gIGlmIChiby5ldmVudERlZmluaXRpb25zKSB7XG4gICAgZm9yRWFjaChiby5ldmVudERlZmluaXRpb25zLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgaWYgKGlzKGV2ZW50LCBldmVudFR5cGUpKSB7XG4gICAgICAgIGhhc0V2ZW50RGVmaW5pdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gaGFzRXZlbnREZWZpbml0aW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzRXJyb3JFdmVudERlZmluaXRpb24oZWxlbWVudCkge1xuICByZXR1cm4gaGFzRXZlbnREZWZpbml0aW9uKGVsZW1lbnQsICdicG1uOkVycm9yRXZlbnREZWZpbml0aW9uJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNFc2NhbGF0aW9uRXZlbnREZWZpbml0aW9uKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGhhc0V2ZW50RGVmaW5pdGlvbihlbGVtZW50LCAnYnBtbjpFc2NhbGF0aW9uRXZlbnREZWZpbml0aW9uJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNDb21wZW5zYXRlRXZlbnREZWZpbml0aW9uKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGhhc0V2ZW50RGVmaW5pdGlvbihlbGVtZW50LCAnYnBtbjpDb21wZW5zYXRlRXZlbnREZWZpbml0aW9uJyk7XG59XG4iLCJpbXBvcnQge1xuICBhc3NpZ25cbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQgeyBpcyB9IGZyb20gJy4vTW9kZWxVdGlsJztcblxuXG5leHBvcnQgdmFyIERFRkFVTFRfTEFCRUxfU0laRSA9IHtcbiAgd2lkdGg6IDkwLFxuICBoZWlnaHQ6IDIwXG59O1xuXG5leHBvcnQgdmFyIEZMT1dfTEFCRUxfSU5ERU5UID0gMTU7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNlbWFudGljIGhhcyBhbiBleHRlcm5hbCBsYWJlbFxuICpcbiAqIEBwYXJhbSB7QnBtbkVsZW1lbnR9IHNlbWFudGljXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGhhcyBsYWJlbFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNMYWJlbEV4dGVybmFsKHNlbWFudGljKSB7XG4gIHJldHVybiBpcyhzZW1hbnRpYywgJ2JwbW46RXZlbnQnKSB8fFxuICAgICAgICAgaXMoc2VtYW50aWMsICdicG1uOkdhdGV3YXknKSB8fFxuICAgICAgICAgaXMoc2VtYW50aWMsICdicG1uOkRhdGFTdG9yZVJlZmVyZW5jZScpIHx8XG4gICAgICAgICBpcyhzZW1hbnRpYywgJ2JwbW46RGF0YU9iamVjdFJlZmVyZW5jZScpIHx8XG4gICAgICAgICBpcyhzZW1hbnRpYywgJ2JwbW46RGF0YUlucHV0JykgfHxcbiAgICAgICAgIGlzKHNlbWFudGljLCAnYnBtbjpEYXRhT3V0cHV0JykgfHxcbiAgICAgICAgIGlzKHNlbWFudGljLCAnYnBtbjpTZXF1ZW5jZUZsb3cnKSB8fFxuICAgICAgICAgaXMoc2VtYW50aWMsICdicG1uOk1lc3NhZ2VGbG93JykgfHxcbiAgICAgICAgIGlzKHNlbWFudGljLCAnYnBtbjpHcm91cCcpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBoYXMgYW4gZXh0ZXJuYWwgbGFiZWxcbiAqXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5zaGFwZX0gZWxlbWVudFxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBoYXMgbGFiZWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc0V4dGVybmFsTGFiZWwoZWxlbWVudCkge1xuICByZXR1cm4gaXNMYWJlbChlbGVtZW50LmxhYmVsKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHBvc2l0aW9uIGZvciBzZXF1ZW5jZSBmbG93IGxhYmVsc1xuICpcbiAqIEBwYXJhbSAge0FycmF5PFBvaW50Pn0gd2F5cG9pbnRzXG4gKiBAcmV0dXJuIHtQb2ludH0gdGhlIGxhYmVsIHBvc2l0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGbG93TGFiZWxQb3NpdGlvbih3YXlwb2ludHMpIHtcblxuICAvLyBnZXQgdGhlIHdheXBvaW50cyBtaWRcbiAgdmFyIG1pZCA9IHdheXBvaW50cy5sZW5ndGggLyAyIC0gMTtcblxuICB2YXIgZmlyc3QgPSB3YXlwb2ludHNbTWF0aC5mbG9vcihtaWQpXTtcbiAgdmFyIHNlY29uZCA9IHdheXBvaW50c1tNYXRoLmNlaWwobWlkICsgMC4wMSldO1xuXG4gIC8vIGdldCBwb3NpdGlvblxuICB2YXIgcG9zaXRpb24gPSBnZXRXYXlwb2ludHNNaWQod2F5cG9pbnRzKTtcblxuICAvLyBjYWxjdWxhdGUgYW5nbGVcbiAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuKChzZWNvbmQueSAtIGZpcnN0LnkpIC8gKHNlY29uZC54IC0gZmlyc3QueCkpO1xuXG4gIHZhciB4ID0gcG9zaXRpb24ueCxcbiAgICAgIHkgPSBwb3NpdGlvbi55O1xuXG4gIGlmIChNYXRoLmFicyhhbmdsZSkgPCBNYXRoLlBJIC8gMikge1xuICAgIHkgLT0gRkxPV19MQUJFTF9JTkRFTlQ7XG4gIH0gZWxzZSB7XG4gICAgeCArPSBGTE9XX0xBQkVMX0lOREVOVDtcbiAgfVxuXG4gIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgbWlkZGxlIG9mIGEgbnVtYmVyIG9mIHdheXBvaW50c1xuICpcbiAqIEBwYXJhbSAge0FycmF5PFBvaW50Pn0gd2F5cG9pbnRzXG4gKiBAcmV0dXJuIHtQb2ludH0gdGhlIG1pZCBwb2ludFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2F5cG9pbnRzTWlkKHdheXBvaW50cykge1xuXG4gIHZhciBtaWQgPSB3YXlwb2ludHMubGVuZ3RoIC8gMiAtIDE7XG5cbiAgdmFyIGZpcnN0ID0gd2F5cG9pbnRzW01hdGguZmxvb3IobWlkKV07XG4gIHZhciBzZWNvbmQgPSB3YXlwb2ludHNbTWF0aC5jZWlsKG1pZCArIDAuMDEpXTtcblxuICByZXR1cm4ge1xuICAgIHg6IGZpcnN0LnggKyAoc2Vjb25kLnggLSBmaXJzdC54KSAvIDIsXG4gICAgeTogZmlyc3QueSArIChzZWNvbmQueSAtIGZpcnN0LnkpIC8gMlxuICB9O1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFeHRlcm5hbExhYmVsTWlkKGVsZW1lbnQpIHtcblxuICBpZiAoZWxlbWVudC53YXlwb2ludHMpIHtcbiAgICByZXR1cm4gZ2V0Rmxvd0xhYmVsUG9zaXRpb24oZWxlbWVudC53YXlwb2ludHMpO1xuICB9IGVsc2UgaWYgKGlzKGVsZW1lbnQsICdicG1uOkdyb3VwJykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogZWxlbWVudC54ICsgZWxlbWVudC53aWR0aCAvIDIsXG4gICAgICB5OiBlbGVtZW50LnkgKyBERUZBVUxUX0xBQkVMX1NJWkUuaGVpZ2h0IC8gMlxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGVsZW1lbnQueCArIGVsZW1lbnQud2lkdGggLyAyLFxuICAgICAgeTogZWxlbWVudC55ICsgZWxlbWVudC5oZWlnaHQgKyBERUZBVUxUX0xBQkVMX1NJWkUuaGVpZ2h0IC8gMlxuICAgIH07XG4gIH1cbn1cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGJvdW5kcyBvZiBhbiBlbGVtZW50cyBsYWJlbCwgcGFyc2VkIGZyb20gdGhlIGVsZW1lbnRzIERJIG9yXG4gKiBnZW5lcmF0ZWQgZnJvbSBpdHMgYm91bmRzLlxuICpcbiAqIEBwYXJhbSB7QnBtbkVsZW1lbnR9IHNlbWFudGljXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5CYXNlfSBlbGVtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFeHRlcm5hbExhYmVsQm91bmRzKHNlbWFudGljLCBlbGVtZW50KSB7XG5cbiAgdmFyIG1pZCxcbiAgICAgIHNpemUsXG4gICAgICBib3VuZHMsXG4gICAgICBkaSA9IHNlbWFudGljLmRpLFxuICAgICAgbGFiZWwgPSBkaS5sYWJlbDtcblxuICBpZiAobGFiZWwgJiYgbGFiZWwuYm91bmRzKSB7XG4gICAgYm91bmRzID0gbGFiZWwuYm91bmRzO1xuXG4gICAgc2l6ZSA9IHtcbiAgICAgIHdpZHRoOiBNYXRoLm1heChERUZBVUxUX0xBQkVMX1NJWkUud2lkdGgsIGJvdW5kcy53aWR0aCksXG4gICAgICBoZWlnaHQ6IGJvdW5kcy5oZWlnaHRcbiAgICB9O1xuXG4gICAgbWlkID0ge1xuICAgICAgeDogYm91bmRzLnggKyBib3VuZHMud2lkdGggLyAyLFxuICAgICAgeTogYm91bmRzLnkgKyBib3VuZHMuaGVpZ2h0IC8gMlxuICAgIH07XG4gIH0gZWxzZSB7XG5cbiAgICBtaWQgPSBnZXRFeHRlcm5hbExhYmVsTWlkKGVsZW1lbnQpO1xuXG4gICAgc2l6ZSA9IERFRkFVTFRfTEFCRUxfU0laRTtcbiAgfVxuXG4gIHJldHVybiBhc3NpZ24oe1xuICAgIHg6IG1pZC54IC0gc2l6ZS53aWR0aCAvIDIsXG4gICAgeTogbWlkLnkgLSBzaXplLmhlaWdodCAvIDJcbiAgfSwgc2l6ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0xhYmVsKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQgJiYgISFlbGVtZW50LmxhYmVsVGFyZ2V0O1xufVxuIiwiLyoqXG4gKiBJcyBhbiBlbGVtZW50IG9mIHRoZSBnaXZlbiBCUE1OIHR5cGU/XG4gKlxuICogQHBhcmFtICB7ZGpzLm1vZGVsLkJhc2V8TW9kZGxlRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzKGVsZW1lbnQsIHR5cGUpIHtcbiAgdmFyIGJvID0gZ2V0QnVzaW5lc3NPYmplY3QoZWxlbWVudCk7XG5cbiAgcmV0dXJuIGJvICYmICh0eXBlb2YgYm8uJGluc3RhbmNlT2YgPT09ICdmdW5jdGlvbicpICYmIGJvLiRpbnN0YW5jZU9mKHR5cGUpO1xufVxuXG5cbi8qKlxuICogUmV0dXJuIHRoZSBidXNpbmVzcyBvYmplY3QgZm9yIGEgZ2l2ZW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gIHtkanMubW9kZWwuQmFzZXxNb2RkbGVFbGVtZW50fSBlbGVtZW50XG4gKlxuICogQHJldHVybiB7TW9kZGxlRWxlbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJ1c2luZXNzT2JqZWN0KGVsZW1lbnQpIHtcbiAgcmV0dXJuIChlbGVtZW50ICYmIGVsZW1lbnQuYnVzaW5lc3NPYmplY3QpIHx8IGVsZW1lbnQ7XG59IiwiLyoqXG4gKiBUaGlzIGZpbGUgbXVzdCBub3QgYmUgY2hhbmdlZCBvciBleGNoYW5nZWQuXG4gKlxuICogQHNlZSBodHRwOi8vYnBtbi5pby9saWNlbnNlIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG5cbmltcG9ydCB7XG4gIGRvbWlmeSxcbiAgZGVsZWdhdGUgYXMgZG9tRGVsZWdhdGVcbn0gZnJvbSAnbWluLWRvbSc7XG5cblxuLy8gaW5saW5lZCAuLi8uLi9yZXNvdXJjZXMvbG9nby5zdmdcbnZhciBCUE1OSU9fTE9HT19TVkcgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCA5NjAgOTYwXCI+PHBhdGggZmlsbD1cIiNmZmZcIiBkPVwiTTk2MCA2MHY4MzljMCAzMy0yNyA2MS02MCA2MUg2MGMtMzMgMC02MC0yNy02MC02MFY2MEMwIDI3IDI3IDAgNjAgMGg4MzljMzQgMCA2MSAyNyA2MSA2MHpcIi8+PHBhdGggZmlsbD1cIiM1MmI0MTVcIiBkPVwiTTIxNyA1NDhhMjA1IDIwNSAwIDAgMC0xNDQgNTggMjAyIDIwMiAwIDAgMC00IDI4NiAyMDIgMjAyIDAgMCAwIDI4NSAzIDIwMCAyMDAgMCAwIDAgNDgtMjE5IDIwMyAyMDMgMCAwIDAtMTg1LTEyOHpNNzUyIDZhMjA2IDIwNiAwIDAgMC0xOTIgMjg1IDIwNiAyMDYgMCAwIDAgMjY5IDExMSAyMDcgMjA3IDAgMCAwIDExMS0yNjBBMjA0IDIwNCAwIDAgMCA3NTIgNnpNNjIgMEE2MiA2MiAwIDAgMCAwIDYydjM5OGw2MCA0NmEyNTkgMjU5IDAgMCAxIDg5LTM2YzUtMjggMTAtNTcgMTQtODVsOTkgMiAxMiA4NWEyNDYgMjQ2IDAgMCAxIDg4IDM4bDcwLTUyIDY5IDcxLTUyIDY4YzE3IDMwIDI5IDU4IDM1IDkwbDg2IDE0LTIgMTAwLTg2IDEyYTI0MCAyNDAgMCAwIDEtMzggODlsNDMgNThoNDEzYzM3IDAgNjAtMjcgNjAtNjFWNDA3YTIyMCAyMjAgMCAwIDEtNDQgNDBsMjEgODUtOTMgMzktNDUtNzZhMjU4IDI1OCAwIDAgMS05OCAxbC00NSA3Ni05NC0zOSAyMi04NWEyOTggMjk4IDAgMCAxLTcwLTY5bC04NiAyMi0zOC05NCA3Ni00NWEyNTggMjU4IDAgMCAxLTEtOThsLTc2LTQ1IDQwLTk0IDg1IDIyYTI3MSAyNzEgMCAwIDEgNDEtNDd6XCIvPjwvc3ZnPic7XG5cbnZhciBCUE1OSU9fTE9HT19VUkwgPSAnZGF0YTppbWFnZS9zdmcreG1sLCcgKyBlbmNvZGVVUklDb21wb25lbnQoQlBNTklPX0xPR09fU1ZHKTtcblxuZXhwb3J0IHZhciBCUE1OSU9fSU1HID0gJzxpbWcgd2lkdGg9XCI1MlwiIGhlaWdodD1cIjUyXCIgc3JjPVwiJyArIEJQTU5JT19MT0dPX1VSTCArICdcIiAvPic7XG5cbmZ1bmN0aW9uIGNzcyhhdHRycykge1xuICByZXR1cm4gYXR0cnMuam9pbignOycpO1xufVxuXG52YXIgTElHSFRCT1hfU1RZTEVTID0gY3NzKFtcbiAgJ3otaW5kZXg6IDEwMDEnLFxuICAncG9zaXRpb246IGZpeGVkJyxcbiAgJ3RvcDogMCcsXG4gICdsZWZ0OiAwJyxcbiAgJ3JpZ2h0OiAwJyxcbiAgJ2JvdHRvbTogMCdcbl0pO1xuXG52YXIgQkFDS0RST1BfU1RZTEVTID0gY3NzKFtcbiAgJ3dpZHRoOiAxMDAlJyxcbiAgJ2hlaWdodDogMTAwJScsXG4gICdiYWNrZ3JvdW5kOiByZ2JhKDAsMCwwLDAuMiknXG5dKTtcblxudmFyIE5PVElDRV9TVFlMRVMgPSBjc3MoW1xuICAncG9zaXRpb246IGFic29sdXRlJyxcbiAgJ2xlZnQ6IDUwJScsXG4gICd0b3A6IDQwJScsXG4gICdtYXJnaW46IDAgLTEzMHB4JyxcbiAgJ3dpZHRoOiAyNjBweCcsXG4gICdwYWRkaW5nOiAxMHB4JyxcbiAgJ2JhY2tncm91bmQ6IHdoaXRlJyxcbiAgJ2JvcmRlcjogc29saWQgMXB4ICNBQUEnLFxuICAnYm9yZGVyLXJhZGl1czogM3B4JyxcbiAgJ2ZvbnQtZmFtaWx5OiBIZWx2ZXRpY2EsIEFyaWFsLCBzYW5zLXNlcmlmJyxcbiAgJ2ZvbnQtc2l6ZTogMTRweCcsXG4gICdsaW5lLWhlaWdodDogMS4yZW0nXG5dKTtcblxudmFyIExJR0hUQk9YX01BUktVUCA9XG4gICc8ZGl2IGNsYXNzPVwiYmpzLXBvd2VyZWQtYnktbGlnaHRib3hcIiBzdHlsZT1cIicgKyBMSUdIVEJPWF9TVFlMRVMgKyAnXCI+JyArXG4gICAgJzxkaXYgY2xhc3M9XCJiYWNrZHJvcFwiIHN0eWxlPVwiJyArIEJBQ0tEUk9QX1NUWUxFUyArICdcIj48L2Rpdj4nICtcbiAgICAnPGRpdiBjbGFzcz1cIm5vdGljZVwiIHN0eWxlPVwiJyArIE5PVElDRV9TVFlMRVMgKyAnXCI+JyArXG4gICAgICAnPGEgaHJlZj1cImh0dHA6Ly9icG1uLmlvXCIgdGFyZ2V0PVwiX2JsYW5rXCIgc3R5bGU9XCJmbG9hdDogbGVmdDsgbWFyZ2luLXJpZ2h0OiAxMHB4XCI+JyArXG4gICAgICAgIEJQTU5JT19JTUcgK1xuICAgICAgJzwvYT4nICtcbiAgICAgICdXZWItYmFzZWQgdG9vbGluZyBmb3IgQlBNTiwgRE1OIGFuZCBDTU1OIGRpYWdyYW1zICcgK1xuICAgICAgJ3Bvd2VyZWQgYnkgPGEgaHJlZj1cImh0dHA6Ly9icG1uLmlvXCIgdGFyZ2V0PVwiX2JsYW5rXCI+YnBtbi5pbzwvYT4uJyArXG4gICAgJzwvZGl2PicgK1xuICAnPC9kaXY+JztcblxuXG52YXIgbGlnaHRib3g7XG5cbmV4cG9ydCBmdW5jdGlvbiBvcGVuKCkge1xuXG4gIGlmICghbGlnaHRib3gpIHtcbiAgICBsaWdodGJveCA9IGRvbWlmeShMSUdIVEJPWF9NQVJLVVApO1xuXG4gICAgZG9tRGVsZWdhdGUuYmluZChsaWdodGJveCwgJy5iYWNrZHJvcCcsICdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGxpZ2h0Ym94KTtcbiAgICB9KTtcbiAgfVxuXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGlnaHRib3gpO1xufSIsImltcG9ydCB7IGlzU3RyaW5nLCBpc0Z1bmN0aW9uLCBhc3NpZ24gfSBmcm9tICdtaW4tZGFzaCc7XG5pbXBvcnQgeyBNb2RkbGUgfSBmcm9tICdtb2RkbGUnO1xuaW1wb3J0IHsgUmVhZGVyLCBXcml0ZXIgfSBmcm9tICdtb2RkbGUteG1sJztcblxuLyoqXG4gKiBBIHN1YiBjbGFzcyBvZiB7QGxpbmsgTW9kZGxlfSB3aXRoIHN1cHBvcnQgZm9yIGltcG9ydCBhbmQgZXhwb3J0IG9mIEJQTU4gMi4wIHhtbCBmaWxlcy5cbiAqXG4gKiBAY2xhc3MgQnBtbk1vZGRsZVxuICogQGV4dGVuZHMgTW9kZGxlXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IHBhY2thZ2VzIHRvIHVzZSBmb3IgaW5zdGFudGlhdGluZyB0aGUgbW9kZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gYWRkaXRpb25hbCBvcHRpb25zIHRvIHBhc3Mgb3ZlclxuICovXG5mdW5jdGlvbiBCcG1uTW9kZGxlKHBhY2thZ2VzLCBvcHRpb25zKSB7XG4gIE1vZGRsZS5jYWxsKHRoaXMsIHBhY2thZ2VzLCBvcHRpb25zKTtcbn1cblxuQnBtbk1vZGRsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE1vZGRsZS5wcm90b3R5cGUpO1xuXG5cbi8qKlxuICogSW5zdGFudGlhdGVzIGEgQlBNTiBtb2RlbCB0cmVlIGZyb20gYSBnaXZlbiB4bWwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSAgIHhtbFN0clxuICogQHBhcmFtIHtTdHJpbmd9ICAgW3R5cGVOYW1lPSdicG1uOkRlZmluaXRpb25zJ10gbmFtZSBvZiB0aGUgcm9vdCBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gICBbb3B0aW9uc10gIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgdW5kZXJseWluZyByZWFkZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmUgICAgICAgY2FsbGJhY2sgdGhhdCBpcyBpbnZva2VkIHdpdGggKGVyciwgcmVzdWx0LCBwYXJzZUNvbnRleHQpXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uY2UgdGhlIGltcG9ydCBjb21wbGV0ZXNcbiAqL1xuQnBtbk1vZGRsZS5wcm90b3R5cGUuZnJvbVhNTCA9IGZ1bmN0aW9uKHhtbFN0ciwgdHlwZU5hbWUsIG9wdGlvbnMsIGRvbmUpIHtcblxuICBpZiAoIWlzU3RyaW5nKHR5cGVOYW1lKSkge1xuICAgIGRvbmUgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB0eXBlTmFtZTtcbiAgICB0eXBlTmFtZSA9ICdicG1uOkRlZmluaXRpb25zJztcbiAgfVxuXG4gIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgZG9uZSA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIHJlYWRlciA9IG5ldyBSZWFkZXIoYXNzaWduKHsgbW9kZWw6IHRoaXMsIGxheDogdHJ1ZSB9LCBvcHRpb25zKSk7XG4gIHZhciByb290SGFuZGxlciA9IHJlYWRlci5oYW5kbGVyKHR5cGVOYW1lKTtcblxuICByZWFkZXIuZnJvbVhNTCh4bWxTdHIsIHJvb3RIYW5kbGVyLCBkb25lKTtcbn07XG5cblxuLyoqXG4gKiBTZXJpYWxpemVzIGEgQlBNTiAyLjAgb2JqZWN0IHRyZWUgdG8gWE1MLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSAgIGVsZW1lbnQgICAgdGhlIHJvb3QgZWxlbWVudCwgdHlwaWNhbGx5IGFuIGluc3RhbmNlIG9mIGBicG1uOkRlZmluaXRpb25zYFxuICogQHBhcmFtIHtPYmplY3R9ICAgW29wdGlvbnNdICB0byBwYXNzIHRvIHRoZSB1bmRlcmx5aW5nIHdyaXRlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZSAgICAgICBjYWxsYmFjayBpbnZva2VkIHdpdGggKGVyciwgeG1sU3RyKSBvbmNlIHRoZSBpbXBvcnQgY29tcGxldGVzXG4gKi9cbkJwbW5Nb2RkbGUucHJvdG90eXBlLnRvWE1MID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucywgZG9uZSkge1xuXG4gIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgZG9uZSA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIHdyaXRlciA9IG5ldyBXcml0ZXIob3B0aW9ucyk7XG5cbiAgdmFyIHJlc3VsdDtcbiAgdmFyIGVycjtcblxuICB0cnkge1xuICAgIHJlc3VsdCA9IHdyaXRlci50b1hNTChlbGVtZW50KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVyciA9IGU7XG4gIH1cblxuICByZXR1cm4gZG9uZShlcnIsIHJlc3VsdCk7XG59O1xuXG52YXIgbmFtZSA9IFwiQlBNTjIwXCI7XG52YXIgdXJpID0gXCJodHRwOi8vd3d3Lm9tZy5vcmcvc3BlYy9CUE1OLzIwMTAwNTI0L01PREVMXCI7XG52YXIgcHJlZml4ID0gXCJicG1uXCI7XG52YXIgYXNzb2NpYXRpb25zID0gW1xuXTtcbnZhciB0eXBlcyA9IFtcblx0e1xuXHRcdG5hbWU6IFwiSW50ZXJmYWNlXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJSb290RWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwib3BlcmF0aW9uc1wiLFxuXHRcdFx0XHR0eXBlOiBcIk9wZXJhdGlvblwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaW1wbGVtZW50YXRpb25SZWZcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJPcGVyYXRpb25cIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkJhc2VFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpbk1lc3NhZ2VSZWZcIixcblx0XHRcdFx0dHlwZTogXCJNZXNzYWdlXCIsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm91dE1lc3NhZ2VSZWZcIixcblx0XHRcdFx0dHlwZTogXCJNZXNzYWdlXCIsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImVycm9yUmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiRXJyb3JcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpbXBsZW1lbnRhdGlvblJlZlwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkVuZFBvaW50XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJSb290RWxlbWVudFwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJBdWRpdGluZ1wiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiR2xvYmFsVGFza1wiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiQ2FsbGFibGVFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJyZXNvdXJjZXNcIixcblx0XHRcdFx0dHlwZTogXCJSZXNvdXJjZVJvbGVcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJNb25pdG9yaW5nXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJQZXJmb3JtZXJcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIlJlc291cmNlUm9sZVwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJQcm9jZXNzXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJGbG93RWxlbWVudHNDb250YWluZXJcIixcblx0XHRcdFwiQ2FsbGFibGVFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJwcm9jZXNzVHlwZVwiLFxuXHRcdFx0XHR0eXBlOiBcIlByb2Nlc3NUeXBlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpc0Nsb3NlZFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImF1ZGl0aW5nXCIsXG5cdFx0XHRcdHR5cGU6IFwiQXVkaXRpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJtb25pdG9yaW5nXCIsXG5cdFx0XHRcdHR5cGU6IFwiTW9uaXRvcmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInByb3BlcnRpZXNcIixcblx0XHRcdFx0dHlwZTogXCJQcm9wZXJ0eVwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibGFuZVNldHNcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRyZXBsYWNlczogXCJGbG93RWxlbWVudHNDb250YWluZXIjbGFuZVNldHNcIixcblx0XHRcdFx0dHlwZTogXCJMYW5lU2V0XCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZmxvd0VsZW1lbnRzXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZSxcblx0XHRcdFx0cmVwbGFjZXM6IFwiRmxvd0VsZW1lbnRzQ29udGFpbmVyI2Zsb3dFbGVtZW50c1wiLFxuXHRcdFx0XHR0eXBlOiBcIkZsb3dFbGVtZW50XCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiYXJ0aWZhY3RzXCIsXG5cdFx0XHRcdHR5cGU6IFwiQXJ0aWZhY3RcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInJlc291cmNlc1wiLFxuXHRcdFx0XHR0eXBlOiBcIlJlc291cmNlUm9sZVwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY29ycmVsYXRpb25TdWJzY3JpcHRpb25zXCIsXG5cdFx0XHRcdHR5cGU6IFwiQ29ycmVsYXRpb25TdWJzY3JpcHRpb25cIixcblx0XHRcdFx0aXNNYW55OiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInN1cHBvcnRzXCIsXG5cdFx0XHRcdHR5cGU6IFwiUHJvY2Vzc1wiLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImRlZmluaXRpb25hbENvbGxhYm9yYXRpb25SZWZcIixcblx0XHRcdFx0dHlwZTogXCJDb2xsYWJvcmF0aW9uXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaXNFeGVjdXRhYmxlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJCb29sZWFuXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkxhbmVTZXRcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkJhc2VFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJsYW5lc1wiLFxuXHRcdFx0XHR0eXBlOiBcIkxhbmVcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJMYW5lXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwicGFydGl0aW9uRWxlbWVudFJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkJhc2VFbGVtZW50XCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwicGFydGl0aW9uRWxlbWVudFwiLFxuXHRcdFx0XHR0eXBlOiBcIkJhc2VFbGVtZW50XCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZmxvd05vZGVSZWZcIixcblx0XHRcdFx0dHlwZTogXCJGbG93Tm9kZVwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImNoaWxkTGFuZVNldFwiLFxuXHRcdFx0XHR0eXBlOiBcIkxhbmVTZXRcIixcblx0XHRcdFx0eG1sOiB7XG5cdFx0XHRcdFx0c2VyaWFsaXplOiBcInhzaTp0eXBlXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiR2xvYmFsTWFudWFsVGFza1wiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiR2xvYmFsVGFza1wiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJNYW51YWxUYXNrXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJUYXNrXCJcblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlVzZXJUYXNrXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJUYXNrXCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJyZW5kZXJpbmdzXCIsXG5cdFx0XHRcdHR5cGU6IFwiUmVuZGVyaW5nXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpbXBsZW1lbnRhdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlJlbmRlcmluZ1wiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiSHVtYW5QZXJmb3JtZXJcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIlBlcmZvcm1lclwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJQb3RlbnRpYWxPd25lclwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiSHVtYW5QZXJmb3JtZXJcIlxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiR2xvYmFsVXNlclRhc2tcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkdsb2JhbFRhc2tcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImltcGxlbWVudGF0aW9uXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJyZW5kZXJpbmdzXCIsXG5cdFx0XHRcdHR5cGU6IFwiUmVuZGVyaW5nXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiR2F0ZXdheVwiLFxuXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJGbG93Tm9kZVwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZ2F0ZXdheURpcmVjdGlvblwiLFxuXHRcdFx0XHR0eXBlOiBcIkdhdGV3YXlEaXJlY3Rpb25cIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiVW5zcGVjaWZpZWRcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJFdmVudEJhc2VkR2F0ZXdheVwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiR2F0ZXdheVwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaW5zdGFudGlhdGVcIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImV2ZW50R2F0ZXdheVR5cGVcIixcblx0XHRcdFx0dHlwZTogXCJFdmVudEJhc2VkR2F0ZXdheVR5cGVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRcImRlZmF1bHRcIjogXCJFeGNsdXNpdmVcIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQ29tcGxleEdhdGV3YXlcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkdhdGV3YXlcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImFjdGl2YXRpb25Db25kaXRpb25cIixcblx0XHRcdFx0dHlwZTogXCJFeHByZXNzaW9uXCIsXG5cdFx0XHRcdHhtbDoge1xuXHRcdFx0XHRcdHNlcmlhbGl6ZTogXCJ4c2k6dHlwZVwiXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZGVmYXVsdFwiLFxuXHRcdFx0XHR0eXBlOiBcIlNlcXVlbmNlRmxvd1wiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJFeGNsdXNpdmVHYXRld2F5XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJHYXRld2F5XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJkZWZhdWx0XCIsXG5cdFx0XHRcdHR5cGU6IFwiU2VxdWVuY2VGbG93XCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkluY2x1c2l2ZUdhdGV3YXlcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkdhdGV3YXlcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImRlZmF1bHRcIixcblx0XHRcdFx0dHlwZTogXCJTZXF1ZW5jZUZsb3dcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiUGFyYWxsZWxHYXRld2F5XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJHYXRld2F5XCJcblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlJvb3RFbGVtZW50XCIsXG5cdFx0aXNBYnN0cmFjdDogdHJ1ZSxcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkJhc2VFbGVtZW50XCJcblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlJlbGF0aW9uc2hpcFwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInR5cGVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImRpcmVjdGlvblwiLFxuXHRcdFx0XHR0eXBlOiBcIlJlbGF0aW9uc2hpcERpcmVjdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwic291cmNlXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiRWxlbWVudFwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInRhcmdldFwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIkVsZW1lbnRcIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQmFzZUVsZW1lbnRcIixcblx0XHRpc0Fic3RyYWN0OiB0cnVlLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpZFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCIsXG5cdFx0XHRcdGlzSWQ6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZG9jdW1lbnRhdGlvblwiLFxuXHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50YXRpb25cIixcblx0XHRcdFx0aXNNYW55OiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImV4dGVuc2lvbkRlZmluaXRpb25zXCIsXG5cdFx0XHRcdHR5cGU6IFwiRXh0ZW5zaW9uRGVmaW5pdGlvblwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImV4dGVuc2lvbkVsZW1lbnRzXCIsXG5cdFx0XHRcdHR5cGU6IFwiRXh0ZW5zaW9uRWxlbWVudHNcIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiRXh0ZW5zaW9uXCIsXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm11c3RVbmRlcnN0YW5kXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiBmYWxzZSxcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIkJvb2xlYW5cIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJkZWZpbml0aW9uXCIsXG5cdFx0XHRcdHR5cGU6IFwiRXh0ZW5zaW9uRGVmaW5pdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJFeHRlbnNpb25EZWZpbml0aW9uXCIsXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImV4dGVuc2lvbkF0dHJpYnV0ZURlZmluaXRpb25zXCIsXG5cdFx0XHRcdHR5cGU6IFwiRXh0ZW5zaW9uQXR0cmlidXRlRGVmaW5pdGlvblwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkV4dGVuc2lvbkF0dHJpYnV0ZURlZmluaXRpb25cIixcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwidHlwZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaXNSZWZlcmVuY2VcIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImV4dGVuc2lvbkRlZmluaXRpb25cIixcblx0XHRcdFx0dHlwZTogXCJFeHRlbnNpb25EZWZpbml0aW9uXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkV4dGVuc2lvbkVsZW1lbnRzXCIsXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInZhbHVlUmVmXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiRWxlbWVudFwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInZhbHVlc1wiLFxuXHRcdFx0XHR0eXBlOiBcIkVsZW1lbnRcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImV4dGVuc2lvbkF0dHJpYnV0ZURlZmluaXRpb25cIixcblx0XHRcdFx0dHlwZTogXCJFeHRlbnNpb25BdHRyaWJ1dGVEZWZpbml0aW9uXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkRvY3VtZW50YXRpb25cIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkJhc2VFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJ0ZXh0XCIsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCIsXG5cdFx0XHRcdGlzQm9keTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJ0ZXh0Rm9ybWF0XCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiBcInRleHQvcGxhaW5cIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJFdmVudFwiLFxuXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJGbG93Tm9kZVwiLFxuXHRcdFx0XCJJbnRlcmFjdGlvbk5vZGVcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInByb3BlcnRpZXNcIixcblx0XHRcdFx0dHlwZTogXCJQcm9wZXJ0eVwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkludGVybWVkaWF0ZUNhdGNoRXZlbnRcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkNhdGNoRXZlbnRcIlxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiSW50ZXJtZWRpYXRlVGhyb3dFdmVudFwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiVGhyb3dFdmVudFwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJFbmRFdmVudFwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiVGhyb3dFdmVudFwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJTdGFydEV2ZW50XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJDYXRjaEV2ZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpc0ludGVycnVwdGluZ1wiLFxuXHRcdFx0XHRcImRlZmF1bHRcIjogdHJ1ZSxcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIkJvb2xlYW5cIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiVGhyb3dFdmVudFwiLFxuXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJFdmVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZGF0YUlucHV0c1wiLFxuXHRcdFx0XHR0eXBlOiBcIkRhdGFJbnB1dFwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZGF0YUlucHV0QXNzb2NpYXRpb25zXCIsXG5cdFx0XHRcdHR5cGU6IFwiRGF0YUlucHV0QXNzb2NpYXRpb25cIixcblx0XHRcdFx0aXNNYW55OiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImlucHV0U2V0XCIsXG5cdFx0XHRcdHR5cGU6IFwiSW5wdXRTZXRcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJldmVudERlZmluaXRpb25zXCIsXG5cdFx0XHRcdHR5cGU6IFwiRXZlbnREZWZpbml0aW9uXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJldmVudERlZmluaXRpb25SZWZcIixcblx0XHRcdFx0dHlwZTogXCJFdmVudERlZmluaXRpb25cIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQ2F0Y2hFdmVudFwiLFxuXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJFdmVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwicGFyYWxsZWxNdWx0aXBsZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiLFxuXHRcdFx0XHRcImRlZmF1bHRcIjogZmFsc2Vcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZGF0YU91dHB1dHNcIixcblx0XHRcdFx0dHlwZTogXCJEYXRhT3V0cHV0XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJkYXRhT3V0cHV0QXNzb2NpYXRpb25zXCIsXG5cdFx0XHRcdHR5cGU6IFwiRGF0YU91dHB1dEFzc29jaWF0aW9uXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJvdXRwdXRTZXRcIixcblx0XHRcdFx0dHlwZTogXCJPdXRwdXRTZXRcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJldmVudERlZmluaXRpb25zXCIsXG5cdFx0XHRcdHR5cGU6IFwiRXZlbnREZWZpbml0aW9uXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJldmVudERlZmluaXRpb25SZWZcIixcblx0XHRcdFx0dHlwZTogXCJFdmVudERlZmluaXRpb25cIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQm91bmRhcnlFdmVudFwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiQ2F0Y2hFdmVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY2FuY2VsQWN0aXZpdHlcIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IHRydWUsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJCb29sZWFuXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiYXR0YWNoZWRUb1JlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkFjdGl2aXR5XCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkV2ZW50RGVmaW5pdGlvblwiLFxuXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJSb290RWxlbWVudFwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJDYW5jZWxFdmVudERlZmluaXRpb25cIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkV2ZW50RGVmaW5pdGlvblwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJFcnJvckV2ZW50RGVmaW5pdGlvblwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiRXZlbnREZWZpbml0aW9uXCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJlcnJvclJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkVycm9yXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlRlcm1pbmF0ZUV2ZW50RGVmaW5pdGlvblwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiRXZlbnREZWZpbml0aW9uXCJcblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkVzY2FsYXRpb25FdmVudERlZmluaXRpb25cIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkV2ZW50RGVmaW5pdGlvblwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZXNjYWxhdGlvblJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkVzY2FsYXRpb25cIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiRXNjYWxhdGlvblwiLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJzdHJ1Y3R1cmVSZWZcIixcblx0XHRcdFx0dHlwZTogXCJJdGVtRGVmaW5pdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImVzY2FsYXRpb25Db2RlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJSb290RWxlbWVudFwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJDb21wZW5zYXRlRXZlbnREZWZpbml0aW9uXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJFdmVudERlZmluaXRpb25cIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIndhaXRGb3JDb21wbGV0aW9uXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJCb29sZWFuXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImFjdGl2aXR5UmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiQWN0aXZpdHlcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiVGltZXJFdmVudERlZmluaXRpb25cIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkV2ZW50RGVmaW5pdGlvblwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwidGltZURhdGVcIixcblx0XHRcdFx0dHlwZTogXCJFeHByZXNzaW9uXCIsXG5cdFx0XHRcdHhtbDoge1xuXHRcdFx0XHRcdHNlcmlhbGl6ZTogXCJ4c2k6dHlwZVwiXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwidGltZUN5Y2xlXCIsXG5cdFx0XHRcdHR5cGU6IFwiRXhwcmVzc2lvblwiLFxuXHRcdFx0XHR4bWw6IHtcblx0XHRcdFx0XHRzZXJpYWxpemU6IFwieHNpOnR5cGVcIlxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInRpbWVEdXJhdGlvblwiLFxuXHRcdFx0XHR0eXBlOiBcIkV4cHJlc3Npb25cIixcblx0XHRcdFx0eG1sOiB7XG5cdFx0XHRcdFx0c2VyaWFsaXplOiBcInhzaTp0eXBlXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiTGlua0V2ZW50RGVmaW5pdGlvblwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiRXZlbnREZWZpbml0aW9uXCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJ0YXJnZXRcIixcblx0XHRcdFx0dHlwZTogXCJMaW5rRXZlbnREZWZpbml0aW9uXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwic291cmNlXCIsXG5cdFx0XHRcdHR5cGU6IFwiTGlua0V2ZW50RGVmaW5pdGlvblwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJNZXNzYWdlRXZlbnREZWZpbml0aW9uXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJFdmVudERlZmluaXRpb25cIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm1lc3NhZ2VSZWZcIixcblx0XHRcdFx0dHlwZTogXCJNZXNzYWdlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwib3BlcmF0aW9uUmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiT3BlcmF0aW9uXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkNvbmRpdGlvbmFsRXZlbnREZWZpbml0aW9uXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJFdmVudERlZmluaXRpb25cIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImNvbmRpdGlvblwiLFxuXHRcdFx0XHR0eXBlOiBcIkV4cHJlc3Npb25cIixcblx0XHRcdFx0eG1sOiB7XG5cdFx0XHRcdFx0c2VyaWFsaXplOiBcInhzaTp0eXBlXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiU2lnbmFsRXZlbnREZWZpbml0aW9uXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJFdmVudERlZmluaXRpb25cIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInNpZ25hbFJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIlNpZ25hbFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJTaWduYWxcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIlJvb3RFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJzdHJ1Y3R1cmVSZWZcIixcblx0XHRcdFx0dHlwZTogXCJJdGVtRGVmaW5pdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJJbXBsaWNpdFRocm93RXZlbnRcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIlRocm93RXZlbnRcIlxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiRGF0YVN0YXRlXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkl0ZW1Bd2FyZUVsZW1lbnRcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkJhc2VFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpdGVtU3ViamVjdFJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkl0ZW1EZWZpbml0aW9uXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZGF0YVN0YXRlXCIsXG5cdFx0XHRcdHR5cGU6IFwiRGF0YVN0YXRlXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkRhdGFBc3NvY2lhdGlvblwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInNvdXJjZVJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkl0ZW1Bd2FyZUVsZW1lbnRcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJ0YXJnZXRSZWZcIixcblx0XHRcdFx0dHlwZTogXCJJdGVtQXdhcmVFbGVtZW50XCIsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInRyYW5zZm9ybWF0aW9uXCIsXG5cdFx0XHRcdHR5cGU6IFwiRm9ybWFsRXhwcmVzc2lvblwiLFxuXHRcdFx0XHR4bWw6IHtcblx0XHRcdFx0XHRzZXJpYWxpemU6IFwicHJvcGVydHlcIlxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImFzc2lnbm1lbnRcIixcblx0XHRcdFx0dHlwZTogXCJBc3NpZ25tZW50XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiRGF0YUlucHV0XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJJdGVtQXdhcmVFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpc0NvbGxlY3Rpb25cIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImlucHV0U2V0UmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiSW5wdXRTZXRcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImlucHV0U2V0V2l0aE9wdGlvbmFsXCIsXG5cdFx0XHRcdHR5cGU6IFwiSW5wdXRTZXRcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImlucHV0U2V0V2l0aFdoaWxlRXhlY3V0aW5nXCIsXG5cdFx0XHRcdHR5cGU6IFwiSW5wdXRTZXRcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJEYXRhT3V0cHV0XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJJdGVtQXdhcmVFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpc0NvbGxlY3Rpb25cIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm91dHB1dFNldFJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIk91dHB1dFNldFwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzVmlydHVhbDogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwib3V0cHV0U2V0V2l0aE9wdGlvbmFsXCIsXG5cdFx0XHRcdHR5cGU6IFwiT3V0cHV0U2V0XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZSxcblx0XHRcdFx0aXNWaXJ0dWFsOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJvdXRwdXRTZXRXaXRoV2hpbGVFeGVjdXRpbmdcIixcblx0XHRcdFx0dHlwZTogXCJPdXRwdXRTZXRcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJJbnB1dFNldFwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImRhdGFJbnB1dFJlZnNcIixcblx0XHRcdFx0dHlwZTogXCJEYXRhSW5wdXRcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJvcHRpb25hbElucHV0UmVmc1wiLFxuXHRcdFx0XHR0eXBlOiBcIkRhdGFJbnB1dFwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIndoaWxlRXhlY3V0aW5nSW5wdXRSZWZzXCIsXG5cdFx0XHRcdHR5cGU6IFwiRGF0YUlucHV0XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwib3V0cHV0U2V0UmVmc1wiLFxuXHRcdFx0XHR0eXBlOiBcIk91dHB1dFNldFwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJPdXRwdXRTZXRcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkJhc2VFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJkYXRhT3V0cHV0UmVmc1wiLFxuXHRcdFx0XHR0eXBlOiBcIkRhdGFPdXRwdXRcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpbnB1dFNldFJlZnNcIixcblx0XHRcdFx0dHlwZTogXCJJbnB1dFNldFwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm9wdGlvbmFsT3V0cHV0UmVmc1wiLFxuXHRcdFx0XHR0eXBlOiBcIkRhdGFPdXRwdXRcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJ3aGlsZUV4ZWN1dGluZ091dHB1dFJlZnNcIixcblx0XHRcdFx0dHlwZTogXCJEYXRhT3V0cHV0XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlByb3BlcnR5XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJJdGVtQXdhcmVFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiRGF0YUlucHV0QXNzb2NpYXRpb25cIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkRhdGFBc3NvY2lhdGlvblwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJEYXRhT3V0cHV0QXNzb2NpYXRpb25cIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkRhdGFBc3NvY2lhdGlvblwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJJbnB1dE91dHB1dFNwZWNpZmljYXRpb25cIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkJhc2VFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJkYXRhSW5wdXRzXCIsXG5cdFx0XHRcdHR5cGU6IFwiRGF0YUlucHV0XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJkYXRhT3V0cHV0c1wiLFxuXHRcdFx0XHR0eXBlOiBcIkRhdGFPdXRwdXRcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImlucHV0U2V0c1wiLFxuXHRcdFx0XHR0eXBlOiBcIklucHV0U2V0XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJvdXRwdXRTZXRzXCIsXG5cdFx0XHRcdHR5cGU6IFwiT3V0cHV0U2V0XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiRGF0YU9iamVjdFwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiRmxvd0VsZW1lbnRcIixcblx0XHRcdFwiSXRlbUF3YXJlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaXNDb2xsZWN0aW9uXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiBmYWxzZSxcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIkJvb2xlYW5cIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiSW5wdXRPdXRwdXRCaW5kaW5nXCIsXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImlucHV0RGF0YVJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIklucHV0U2V0XCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwib3V0cHV0RGF0YVJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIk91dHB1dFNldFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm9wZXJhdGlvblJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIk9wZXJhdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJBc3NpZ25tZW50XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZnJvbVwiLFxuXHRcdFx0XHR0eXBlOiBcIkV4cHJlc3Npb25cIixcblx0XHRcdFx0eG1sOiB7XG5cdFx0XHRcdFx0c2VyaWFsaXplOiBcInhzaTp0eXBlXCJcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJ0b1wiLFxuXHRcdFx0XHR0eXBlOiBcIkV4cHJlc3Npb25cIixcblx0XHRcdFx0eG1sOiB7XG5cdFx0XHRcdFx0c2VyaWFsaXplOiBcInhzaTp0eXBlXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiRGF0YVN0b3JlXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJSb290RWxlbWVudFwiLFxuXHRcdFx0XCJJdGVtQXdhcmVFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJjYXBhY2l0eVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiSW50ZWdlclwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImlzVW5saW1pdGVkXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiB0cnVlLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJEYXRhU3RvcmVSZWZlcmVuY2VcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkl0ZW1Bd2FyZUVsZW1lbnRcIixcblx0XHRcdFwiRmxvd0VsZW1lbnRcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImRhdGFTdG9yZVJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkRhdGFTdG9yZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJEYXRhT2JqZWN0UmVmZXJlbmNlXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJJdGVtQXdhcmVFbGVtZW50XCIsXG5cdFx0XHRcIkZsb3dFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJkYXRhT2JqZWN0UmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiRGF0YU9iamVjdFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJDb252ZXJzYXRpb25MaW5rXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwic291cmNlUmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiSW50ZXJhY3Rpb25Ob2RlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwidGFyZ2V0UmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiSW50ZXJhY3Rpb25Ob2RlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkNvbnZlcnNhdGlvbkFzc29jaWF0aW9uXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaW5uZXJDb252ZXJzYXRpb25Ob2RlUmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiQ29udmVyc2F0aW9uTm9kZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm91dGVyQ29udmVyc2F0aW9uTm9kZVJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkNvbnZlcnNhdGlvbk5vZGVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQ2FsbENvbnZlcnNhdGlvblwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiQ29udmVyc2F0aW9uTm9kZVwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY2FsbGVkQ29sbGFib3JhdGlvblJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkNvbGxhYm9yYXRpb25cIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJwYXJ0aWNpcGFudEFzc29jaWF0aW9uc1wiLFxuXHRcdFx0XHR0eXBlOiBcIlBhcnRpY2lwYW50QXNzb2NpYXRpb25cIixcblx0XHRcdFx0aXNNYW55OiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJDb252ZXJzYXRpb25cIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkNvbnZlcnNhdGlvbk5vZGVcIlxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiU3ViQ29udmVyc2F0aW9uXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJDb252ZXJzYXRpb25Ob2RlXCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJjb252ZXJzYXRpb25Ob2Rlc1wiLFxuXHRcdFx0XHR0eXBlOiBcIkNvbnZlcnNhdGlvbk5vZGVcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJDb252ZXJzYXRpb25Ob2RlXCIsXG5cdFx0aXNBYnN0cmFjdDogdHJ1ZSxcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkludGVyYWN0aW9uTm9kZVwiLFxuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwicGFydGljaXBhbnRSZWZcIixcblx0XHRcdFx0dHlwZTogXCJQYXJ0aWNpcGFudFwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm1lc3NhZ2VGbG93UmVmc1wiLFxuXHRcdFx0XHR0eXBlOiBcIk1lc3NhZ2VGbG93XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY29ycmVsYXRpb25LZXlzXCIsXG5cdFx0XHRcdHR5cGU6IFwiQ29ycmVsYXRpb25LZXlcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJHbG9iYWxDb252ZXJzYXRpb25cIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkNvbGxhYm9yYXRpb25cIlxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiUGFydG5lckVudGl0eVwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiUm9vdEVsZW1lbnRcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInBhcnRpY2lwYW50UmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiUGFydGljaXBhbnRcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiUGFydG5lclJvbGVcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIlJvb3RFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJwYXJ0aWNpcGFudFJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIlBhcnRpY2lwYW50XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkNvcnJlbGF0aW9uUHJvcGVydHlcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIlJvb3RFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJjb3JyZWxhdGlvblByb3BlcnR5UmV0cmlldmFsRXhwcmVzc2lvblwiLFxuXHRcdFx0XHR0eXBlOiBcIkNvcnJlbGF0aW9uUHJvcGVydHlSZXRyaWV2YWxFeHByZXNzaW9uXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJ0eXBlXCIsXG5cdFx0XHRcdHR5cGU6IFwiSXRlbURlZmluaXRpb25cIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiRXJyb3JcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIlJvb3RFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJzdHJ1Y3R1cmVSZWZcIixcblx0XHRcdFx0dHlwZTogXCJJdGVtRGVmaW5pdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImVycm9yQ29kZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkNvcnJlbGF0aW9uS2V5XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY29ycmVsYXRpb25Qcm9wZXJ0eVJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkNvcnJlbGF0aW9uUHJvcGVydHlcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiRXhwcmVzc2lvblwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuXHRcdF0sXG5cdFx0aXNBYnN0cmFjdDogZmFsc2UsXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImJvZHlcIixcblx0XHRcdFx0aXNCb2R5OiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJGb3JtYWxFeHByZXNzaW9uXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJFeHByZXNzaW9uXCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJsYW5ndWFnZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZXZhbHVhdGVzVG9UeXBlUmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiSXRlbURlZmluaXRpb25cIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiTWVzc2FnZVwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiUm9vdEVsZW1lbnRcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIml0ZW1SZWZcIixcblx0XHRcdFx0dHlwZTogXCJJdGVtRGVmaW5pdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJJdGVtRGVmaW5pdGlvblwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiUm9vdEVsZW1lbnRcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIml0ZW1LaW5kXCIsXG5cdFx0XHRcdHR5cGU6IFwiSXRlbUtpbmRcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInN0cnVjdHVyZVJlZlwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaXNDb2xsZWN0aW9uXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiBmYWxzZSxcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIkJvb2xlYW5cIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpbXBvcnRcIixcblx0XHRcdFx0dHlwZTogXCJJbXBvcnRcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiRmxvd0VsZW1lbnRcIixcblx0XHRpc0Fic3RyYWN0OiB0cnVlLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImF1ZGl0aW5nXCIsXG5cdFx0XHRcdHR5cGU6IFwiQXVkaXRpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJtb25pdG9yaW5nXCIsXG5cdFx0XHRcdHR5cGU6IFwiTW9uaXRvcmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImNhdGVnb3J5VmFsdWVSZWZcIixcblx0XHRcdFx0dHlwZTogXCJDYXRlZ29yeVZhbHVlXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlNlcXVlbmNlRmxvd1wiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiRmxvd0VsZW1lbnRcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImlzSW1tZWRpYXRlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJCb29sZWFuXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY29uZGl0aW9uRXhwcmVzc2lvblwiLFxuXHRcdFx0XHR0eXBlOiBcIkV4cHJlc3Npb25cIixcblx0XHRcdFx0eG1sOiB7XG5cdFx0XHRcdFx0c2VyaWFsaXplOiBcInhzaTp0eXBlXCJcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJzb3VyY2VSZWZcIixcblx0XHRcdFx0dHlwZTogXCJGbG93Tm9kZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInRhcmdldFJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkZsb3dOb2RlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkZsb3dFbGVtZW50c0NvbnRhaW5lclwiLFxuXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibGFuZVNldHNcIixcblx0XHRcdFx0dHlwZTogXCJMYW5lU2V0XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJmbG93RWxlbWVudHNcIixcblx0XHRcdFx0dHlwZTogXCJGbG93RWxlbWVudFwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkNhbGxhYmxlRWxlbWVudFwiLFxuXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJSb290RWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaW9TcGVjaWZpY2F0aW9uXCIsXG5cdFx0XHRcdHR5cGU6IFwiSW5wdXRPdXRwdXRTcGVjaWZpY2F0aW9uXCIsXG5cdFx0XHRcdHhtbDoge1xuXHRcdFx0XHRcdHNlcmlhbGl6ZTogXCJwcm9wZXJ0eVwiXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwic3VwcG9ydGVkSW50ZXJmYWNlUmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiSW50ZXJmYWNlXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaW9CaW5kaW5nXCIsXG5cdFx0XHRcdHR5cGU6IFwiSW5wdXRPdXRwdXRCaW5kaW5nXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZSxcblx0XHRcdFx0eG1sOiB7XG5cdFx0XHRcdFx0c2VyaWFsaXplOiBcInByb3BlcnR5XCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiRmxvd05vZGVcIixcblx0XHRpc0Fic3RyYWN0OiB0cnVlLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiRmxvd0VsZW1lbnRcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImluY29taW5nXCIsXG5cdFx0XHRcdHR5cGU6IFwiU2VxdWVuY2VGbG93XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwib3V0Z29pbmdcIixcblx0XHRcdFx0dHlwZTogXCJTZXF1ZW5jZUZsb3dcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJsYW5lc1wiLFxuXHRcdFx0XHR0eXBlOiBcIkxhbmVcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJDb3JyZWxhdGlvblByb3BlcnR5UmV0cmlldmFsRXhwcmVzc2lvblwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm1lc3NhZ2VQYXRoXCIsXG5cdFx0XHRcdHR5cGU6IFwiRm9ybWFsRXhwcmVzc2lvblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm1lc3NhZ2VSZWZcIixcblx0XHRcdFx0dHlwZTogXCJNZXNzYWdlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkNvcnJlbGF0aW9uUHJvcGVydHlCaW5kaW5nXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZGF0YVBhdGhcIixcblx0XHRcdFx0dHlwZTogXCJGb3JtYWxFeHByZXNzaW9uXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY29ycmVsYXRpb25Qcm9wZXJ0eVJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkNvcnJlbGF0aW9uUHJvcGVydHlcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiUmVzb3VyY2VcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIlJvb3RFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJyZXNvdXJjZVBhcmFtZXRlcnNcIixcblx0XHRcdFx0dHlwZTogXCJSZXNvdXJjZVBhcmFtZXRlclwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlJlc291cmNlUGFyYW1ldGVyXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaXNSZXF1aXJlZFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInR5cGVcIixcblx0XHRcdFx0dHlwZTogXCJJdGVtRGVmaW5pdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJDb3JyZWxhdGlvblN1YnNjcmlwdGlvblwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImNvcnJlbGF0aW9uS2V5UmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiQ29ycmVsYXRpb25LZXlcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJjb3JyZWxhdGlvblByb3BlcnR5QmluZGluZ1wiLFxuXHRcdFx0XHR0eXBlOiBcIkNvcnJlbGF0aW9uUHJvcGVydHlCaW5kaW5nXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiTWVzc2FnZUZsb3dcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkJhc2VFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJzb3VyY2VSZWZcIixcblx0XHRcdFx0dHlwZTogXCJJbnRlcmFjdGlvbk5vZGVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJ0YXJnZXRSZWZcIixcblx0XHRcdFx0dHlwZTogXCJJbnRlcmFjdGlvbk5vZGVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJtZXNzYWdlUmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiTWVzc2FnZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJNZXNzYWdlRmxvd0Fzc29jaWF0aW9uXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaW5uZXJNZXNzYWdlRmxvd1JlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIk1lc3NhZ2VGbG93XCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwib3V0ZXJNZXNzYWdlRmxvd1JlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIk1lc3NhZ2VGbG93XCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkludGVyYWN0aW9uTm9kZVwiLFxuXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImluY29taW5nQ29udmVyc2F0aW9uTGlua3NcIixcblx0XHRcdFx0dHlwZTogXCJDb252ZXJzYXRpb25MaW5rXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZSxcblx0XHRcdFx0aXNWaXJ0dWFsOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJvdXRnb2luZ0NvbnZlcnNhdGlvbkxpbmtzXCIsXG5cdFx0XHRcdHR5cGU6IFwiQ29udmVyc2F0aW9uTGlua1wiLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzVmlydHVhbDogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlBhcnRpY2lwYW50XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJJbnRlcmFjdGlvbk5vZGVcIixcblx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImludGVyZmFjZVJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkludGVyZmFjZVwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInBhcnRpY2lwYW50TXVsdGlwbGljaXR5XCIsXG5cdFx0XHRcdHR5cGU6IFwiUGFydGljaXBhbnRNdWx0aXBsaWNpdHlcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJlbmRQb2ludFJlZnNcIixcblx0XHRcdFx0dHlwZTogXCJFbmRQb2ludFwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInByb2Nlc3NSZWZcIixcblx0XHRcdFx0dHlwZTogXCJQcm9jZXNzXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlBhcnRpY2lwYW50QXNzb2NpYXRpb25cIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkJhc2VFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpbm5lclBhcnRpY2lwYW50UmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiUGFydGljaXBhbnRcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJvdXRlclBhcnRpY2lwYW50UmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiUGFydGljaXBhbnRcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiUGFydGljaXBhbnRNdWx0aXBsaWNpdHlcIixcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibWluaW11bVwiLFxuXHRcdFx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIkludGVnZXJcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJtYXhpbXVtXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiAxLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiSW50ZWdlclwiXG5cdFx0XHR9XG5cdFx0XSxcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkJhc2VFbGVtZW50XCJcblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkNvbGxhYm9yYXRpb25cIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIlJvb3RFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpc0Nsb3NlZFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInBhcnRpY2lwYW50c1wiLFxuXHRcdFx0XHR0eXBlOiBcIlBhcnRpY2lwYW50XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJtZXNzYWdlRmxvd3NcIixcblx0XHRcdFx0dHlwZTogXCJNZXNzYWdlRmxvd1wiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiYXJ0aWZhY3RzXCIsXG5cdFx0XHRcdHR5cGU6IFwiQXJ0aWZhY3RcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImNvbnZlcnNhdGlvbnNcIixcblx0XHRcdFx0dHlwZTogXCJDb252ZXJzYXRpb25Ob2RlXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJjb252ZXJzYXRpb25Bc3NvY2lhdGlvbnNcIixcblx0XHRcdFx0dHlwZTogXCJDb252ZXJzYXRpb25Bc3NvY2lhdGlvblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInBhcnRpY2lwYW50QXNzb2NpYXRpb25zXCIsXG5cdFx0XHRcdHR5cGU6IFwiUGFydGljaXBhbnRBc3NvY2lhdGlvblwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibWVzc2FnZUZsb3dBc3NvY2lhdGlvbnNcIixcblx0XHRcdFx0dHlwZTogXCJNZXNzYWdlRmxvd0Fzc29jaWF0aW9uXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJjb3JyZWxhdGlvbktleXNcIixcblx0XHRcdFx0dHlwZTogXCJDb3JyZWxhdGlvbktleVwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY2hvcmVvZ3JhcGh5UmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiQ2hvcmVvZ3JhcGh5XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY29udmVyc2F0aW9uTGlua3NcIixcblx0XHRcdFx0dHlwZTogXCJDb252ZXJzYXRpb25MaW5rXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQ2hvcmVvZ3JhcGh5QWN0aXZpdHlcIixcblx0XHRpc0Fic3RyYWN0OiB0cnVlLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiRmxvd05vZGVcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInBhcnRpY2lwYW50UmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiUGFydGljaXBhbnRcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpbml0aWF0aW5nUGFydGljaXBhbnRSZWZcIixcblx0XHRcdFx0dHlwZTogXCJQYXJ0aWNpcGFudFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImNvcnJlbGF0aW9uS2V5c1wiLFxuXHRcdFx0XHR0eXBlOiBcIkNvcnJlbGF0aW9uS2V5XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJsb29wVHlwZVwiLFxuXHRcdFx0XHR0eXBlOiBcIkNob3Jlb2dyYXBoeUxvb3BUeXBlXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiBcIk5vbmVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJDYWxsQ2hvcmVvZ3JhcGh5XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJDaG9yZW9ncmFwaHlBY3Rpdml0eVwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY2FsbGVkQ2hvcmVvZ3JhcGh5UmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiQ2hvcmVvZ3JhcGh5XCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwicGFydGljaXBhbnRBc3NvY2lhdGlvbnNcIixcblx0XHRcdFx0dHlwZTogXCJQYXJ0aWNpcGFudEFzc29jaWF0aW9uXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiU3ViQ2hvcmVvZ3JhcGh5XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJDaG9yZW9ncmFwaHlBY3Rpdml0eVwiLFxuXHRcdFx0XCJGbG93RWxlbWVudHNDb250YWluZXJcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImFydGlmYWN0c1wiLFxuXHRcdFx0XHR0eXBlOiBcIkFydGlmYWN0XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQ2hvcmVvZ3JhcGh5VGFza1wiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiQ2hvcmVvZ3JhcGh5QWN0aXZpdHlcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm1lc3NhZ2VGbG93UmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiTWVzc2FnZUZsb3dcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQ2hvcmVvZ3JhcGh5XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJDb2xsYWJvcmF0aW9uXCIsXG5cdFx0XHRcIkZsb3dFbGVtZW50c0NvbnRhaW5lclwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJHbG9iYWxDaG9yZW9ncmFwaHlUYXNrXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJDaG9yZW9ncmFwaHlcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImluaXRpYXRpbmdQYXJ0aWNpcGFudFJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIlBhcnRpY2lwYW50XCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlRleHRBbm5vdGF0aW9uXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJBcnRpZmFjdFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwidGV4dFwiLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInRleHRGb3JtYXRcIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkdyb3VwXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJBcnRpZmFjdFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY2F0ZWdvcnlWYWx1ZVJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkNhdGVnb3J5VmFsdWVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQXNzb2NpYXRpb25cIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkFydGlmYWN0XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJhc3NvY2lhdGlvbkRpcmVjdGlvblwiLFxuXHRcdFx0XHR0eXBlOiBcIkFzc29jaWF0aW9uRGlyZWN0aW9uXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJzb3VyY2VSZWZcIixcblx0XHRcdFx0dHlwZTogXCJCYXNlRWxlbWVudFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInRhcmdldFJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkJhc2VFbGVtZW50XCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkNhdGVnb3J5XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJSb290RWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY2F0ZWdvcnlWYWx1ZVwiLFxuXHRcdFx0XHR0eXBlOiBcIkNhdGVnb3J5VmFsdWVcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJBcnRpZmFjdFwiLFxuXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJDYXRlZ29yeVZhbHVlXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY2F0ZWdvcml6ZWRGbG93RWxlbWVudHNcIixcblx0XHRcdFx0dHlwZTogXCJGbG93RWxlbWVudFwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzVmlydHVhbDogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwidmFsdWVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJBY3Rpdml0eVwiLFxuXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJGbG93Tm9kZVwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaXNGb3JDb21wZW5zYXRpb25cIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImRlZmF1bHRcIixcblx0XHRcdFx0dHlwZTogXCJTZXF1ZW5jZUZsb3dcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpb1NwZWNpZmljYXRpb25cIixcblx0XHRcdFx0dHlwZTogXCJJbnB1dE91dHB1dFNwZWNpZmljYXRpb25cIixcblx0XHRcdFx0eG1sOiB7XG5cdFx0XHRcdFx0c2VyaWFsaXplOiBcInByb3BlcnR5XCJcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJib3VuZGFyeUV2ZW50UmVmc1wiLFxuXHRcdFx0XHR0eXBlOiBcIkJvdW5kYXJ5RXZlbnRcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJwcm9wZXJ0aWVzXCIsXG5cdFx0XHRcdHR5cGU6IFwiUHJvcGVydHlcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImRhdGFJbnB1dEFzc29jaWF0aW9uc1wiLFxuXHRcdFx0XHR0eXBlOiBcIkRhdGFJbnB1dEFzc29jaWF0aW9uXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJkYXRhT3V0cHV0QXNzb2NpYXRpb25zXCIsXG5cdFx0XHRcdHR5cGU6IFwiRGF0YU91dHB1dEFzc29jaWF0aW9uXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJzdGFydFF1YW50aXR5XCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiAxLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiSW50ZWdlclwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInJlc291cmNlc1wiLFxuXHRcdFx0XHR0eXBlOiBcIlJlc291cmNlUm9sZVwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY29tcGxldGlvblF1YW50aXR5XCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiAxLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiSW50ZWdlclwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImxvb3BDaGFyYWN0ZXJpc3RpY3NcIixcblx0XHRcdFx0dHlwZTogXCJMb29wQ2hhcmFjdGVyaXN0aWNzXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlNlcnZpY2VUYXNrXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJUYXNrXCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpbXBsZW1lbnRhdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwib3BlcmF0aW9uUmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiT3BlcmF0aW9uXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlN1YlByb2Nlc3NcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkFjdGl2aXR5XCIsXG5cdFx0XHRcIkZsb3dFbGVtZW50c0NvbnRhaW5lclwiLFxuXHRcdFx0XCJJbnRlcmFjdGlvbk5vZGVcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInRyaWdnZXJlZEJ5RXZlbnRcIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImFydGlmYWN0c1wiLFxuXHRcdFx0XHR0eXBlOiBcIkFydGlmYWN0XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiTG9vcENoYXJhY3RlcmlzdGljc1wiLFxuXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJNdWx0aUluc3RhbmNlTG9vcENoYXJhY3RlcmlzdGljc1wiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiTG9vcENoYXJhY3RlcmlzdGljc1wiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaXNTZXF1ZW50aWFsXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiBmYWxzZSxcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIkJvb2xlYW5cIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJiZWhhdmlvclwiLFxuXHRcdFx0XHR0eXBlOiBcIk11bHRpSW5zdGFuY2VCZWhhdmlvclwiLFxuXHRcdFx0XHRcImRlZmF1bHRcIjogXCJBbGxcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImxvb3BDYXJkaW5hbGl0eVwiLFxuXHRcdFx0XHR0eXBlOiBcIkV4cHJlc3Npb25cIixcblx0XHRcdFx0eG1sOiB7XG5cdFx0XHRcdFx0c2VyaWFsaXplOiBcInhzaTp0eXBlXCJcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJsb29wRGF0YUlucHV0UmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiSXRlbUF3YXJlRWxlbWVudFwiLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJsb29wRGF0YU91dHB1dFJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkl0ZW1Bd2FyZUVsZW1lbnRcIixcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaW5wdXREYXRhSXRlbVwiLFxuXHRcdFx0XHR0eXBlOiBcIkRhdGFJbnB1dFwiLFxuXHRcdFx0XHR4bWw6IHtcblx0XHRcdFx0XHRzZXJpYWxpemU6IFwicHJvcGVydHlcIlxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm91dHB1dERhdGFJdGVtXCIsXG5cdFx0XHRcdHR5cGU6IFwiRGF0YU91dHB1dFwiLFxuXHRcdFx0XHR4bWw6IHtcblx0XHRcdFx0XHRzZXJpYWxpemU6IFwicHJvcGVydHlcIlxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImNvbXBsZXhCZWhhdmlvckRlZmluaXRpb25cIixcblx0XHRcdFx0dHlwZTogXCJDb21wbGV4QmVoYXZpb3JEZWZpbml0aW9uXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJjb21wbGV0aW9uQ29uZGl0aW9uXCIsXG5cdFx0XHRcdHR5cGU6IFwiRXhwcmVzc2lvblwiLFxuXHRcdFx0XHR4bWw6IHtcblx0XHRcdFx0XHRzZXJpYWxpemU6IFwieHNpOnR5cGVcIlxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm9uZUJlaGF2aW9yRXZlbnRSZWZcIixcblx0XHRcdFx0dHlwZTogXCJFdmVudERlZmluaXRpb25cIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJub25lQmVoYXZpb3JFdmVudFJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkV2ZW50RGVmaW5pdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJTdGFuZGFyZExvb3BDaGFyYWN0ZXJpc3RpY3NcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkxvb3BDaGFyYWN0ZXJpc3RpY3NcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInRlc3RCZWZvcmVcIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImxvb3BDb25kaXRpb25cIixcblx0XHRcdFx0dHlwZTogXCJFeHByZXNzaW9uXCIsXG5cdFx0XHRcdHhtbDoge1xuXHRcdFx0XHRcdHNlcmlhbGl6ZTogXCJ4c2k6dHlwZVwiXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibG9vcE1heGltdW1cIixcblx0XHRcdFx0dHlwZTogXCJJbnRlZ2VyXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQ2FsbEFjdGl2aXR5XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJBY3Rpdml0eVwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY2FsbGVkRWxlbWVudFwiLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlRhc2tcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkFjdGl2aXR5XCIsXG5cdFx0XHRcIkludGVyYWN0aW9uTm9kZVwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJTZW5kVGFza1wiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiVGFza1wiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaW1wbGVtZW50YXRpb25cIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm9wZXJhdGlvblJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIk9wZXJhdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm1lc3NhZ2VSZWZcIixcblx0XHRcdFx0dHlwZTogXCJNZXNzYWdlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlJlY2VpdmVUYXNrXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJUYXNrXCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpbXBsZW1lbnRhdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaW5zdGFudGlhdGVcIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm9wZXJhdGlvblJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIk9wZXJhdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm1lc3NhZ2VSZWZcIixcblx0XHRcdFx0dHlwZTogXCJNZXNzYWdlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlNjcmlwdFRhc2tcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIlRhc2tcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInNjcmlwdEZvcm1hdFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwic2NyaXB0XCIsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkJ1c2luZXNzUnVsZVRhc2tcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIlRhc2tcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImltcGxlbWVudGF0aW9uXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQWRIb2NTdWJQcm9jZXNzXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJTdWJQcm9jZXNzXCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJjb21wbGV0aW9uQ29uZGl0aW9uXCIsXG5cdFx0XHRcdHR5cGU6IFwiRXhwcmVzc2lvblwiLFxuXHRcdFx0XHR4bWw6IHtcblx0XHRcdFx0XHRzZXJpYWxpemU6IFwieHNpOnR5cGVcIlxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm9yZGVyaW5nXCIsXG5cdFx0XHRcdHR5cGU6IFwiQWRIb2NPcmRlcmluZ1wiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY2FuY2VsUmVtYWluaW5nSW5zdGFuY2VzXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiB0cnVlLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJUcmFuc2FjdGlvblwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiU3ViUHJvY2Vzc1wiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwicHJvdG9jb2xcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm1ldGhvZFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkdsb2JhbFNjcmlwdFRhc2tcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkdsb2JhbFRhc2tcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInNjcmlwdExhbmd1YWdlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJzY3JpcHRcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJHbG9iYWxCdXNpbmVzc1J1bGVUYXNrXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJHbG9iYWxUYXNrXCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpbXBsZW1lbnRhdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkNvbXBsZXhCZWhhdmlvckRlZmluaXRpb25cIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkJhc2VFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJjb25kaXRpb25cIixcblx0XHRcdFx0dHlwZTogXCJGb3JtYWxFeHByZXNzaW9uXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZXZlbnRcIixcblx0XHRcdFx0dHlwZTogXCJJbXBsaWNpdFRocm93RXZlbnRcIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiUmVzb3VyY2VSb2xlXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwicmVzb3VyY2VSZWZcIixcblx0XHRcdFx0dHlwZTogXCJSZXNvdXJjZVwiLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJyZXNvdXJjZVBhcmFtZXRlckJpbmRpbmdzXCIsXG5cdFx0XHRcdHR5cGU6IFwiUmVzb3VyY2VQYXJhbWV0ZXJCaW5kaW5nXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJyZXNvdXJjZUFzc2lnbm1lbnRFeHByZXNzaW9uXCIsXG5cdFx0XHRcdHR5cGU6IFwiUmVzb3VyY2VBc3NpZ25tZW50RXhwcmVzc2lvblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJSZXNvdXJjZVBhcmFtZXRlckJpbmRpbmdcIixcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZXhwcmVzc2lvblwiLFxuXHRcdFx0XHR0eXBlOiBcIkV4cHJlc3Npb25cIixcblx0XHRcdFx0eG1sOiB7XG5cdFx0XHRcdFx0c2VyaWFsaXplOiBcInhzaTp0eXBlXCJcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJwYXJhbWV0ZXJSZWZcIixcblx0XHRcdFx0dHlwZTogXCJSZXNvdXJjZVBhcmFtZXRlclwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XSxcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkJhc2VFbGVtZW50XCJcblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlJlc291cmNlQXNzaWdubWVudEV4cHJlc3Npb25cIixcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZXhwcmVzc2lvblwiLFxuXHRcdFx0XHR0eXBlOiBcIkV4cHJlc3Npb25cIixcblx0XHRcdFx0eG1sOiB7XG5cdFx0XHRcdFx0c2VyaWFsaXplOiBcInhzaTp0eXBlXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJJbXBvcnRcIixcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaW1wb3J0VHlwZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibG9jYXRpb25cIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm5hbWVzcGFjZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkRlZmluaXRpb25zXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwidGFyZ2V0TmFtZXNwYWNlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJleHByZXNzaW9uTGFuZ3VhZ2VcIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS9YUGF0aFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwidHlwZUxhbmd1YWdlXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpbXBvcnRzXCIsXG5cdFx0XHRcdHR5cGU6IFwiSW1wb3J0XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJleHRlbnNpb25zXCIsXG5cdFx0XHRcdHR5cGU6IFwiRXh0ZW5zaW9uXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJyb290RWxlbWVudHNcIixcblx0XHRcdFx0dHlwZTogXCJSb290RWxlbWVudFwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZGlhZ3JhbXNcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcImJwbW5kaTpCUE1ORGlhZ3JhbVwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImV4cG9ydGVyXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJyZWxhdGlvbnNoaXBzXCIsXG5cdFx0XHRcdHR5cGU6IFwiUmVsYXRpb25zaGlwXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJleHBvcnRlclZlcnNpb25cIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9XG5cdFx0XVxuXHR9XG5dO1xudmFyIGVudW1lcmF0aW9ucyA9IFtcblx0e1xuXHRcdG5hbWU6IFwiUHJvY2Vzc1R5cGVcIixcblx0XHRsaXRlcmFsVmFsdWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiTm9uZVwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIlB1YmxpY1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIlByaXZhdGVcIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiR2F0ZXdheURpcmVjdGlvblwiLFxuXHRcdGxpdGVyYWxWYWx1ZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJVbnNwZWNpZmllZFwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIkNvbnZlcmdpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJEaXZlcmdpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJNaXhlZFwiXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJFdmVudEJhc2VkR2F0ZXdheVR5cGVcIixcblx0XHRsaXRlcmFsVmFsdWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiUGFyYWxsZWxcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJFeGNsdXNpdmVcIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiUmVsYXRpb25zaGlwRGlyZWN0aW9uXCIsXG5cdFx0bGl0ZXJhbFZhbHVlczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIk5vbmVcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJGb3J3YXJkXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiQmFja3dhcmRcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJCb3RoXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkl0ZW1LaW5kXCIsXG5cdFx0bGl0ZXJhbFZhbHVlczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIlBoeXNpY2FsXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiSW5mb3JtYXRpb25cIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQ2hvcmVvZ3JhcGh5TG9vcFR5cGVcIixcblx0XHRsaXRlcmFsVmFsdWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiTm9uZVwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIlN0YW5kYXJkXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiTXVsdGlJbnN0YW5jZVNlcXVlbnRpYWxcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJNdWx0aUluc3RhbmNlUGFyYWxsZWxcIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQXNzb2NpYXRpb25EaXJlY3Rpb25cIixcblx0XHRsaXRlcmFsVmFsdWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiTm9uZVwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIk9uZVwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIkJvdGhcIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiTXVsdGlJbnN0YW5jZUJlaGF2aW9yXCIsXG5cdFx0bGl0ZXJhbFZhbHVlczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIk5vbmVcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJPbmVcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJBbGxcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJDb21wbGV4XCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkFkSG9jT3JkZXJpbmdcIixcblx0XHRsaXRlcmFsVmFsdWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiUGFyYWxsZWxcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJTZXF1ZW50aWFsXCJcblx0XHRcdH1cblx0XHRdXG5cdH1cbl07XG52YXIgeG1sID0ge1xuXHR0YWdBbGlhczogXCJsb3dlckNhc2VcIixcblx0dHlwZVByZWZpeDogXCJ0XCJcbn07XG52YXIgQnBtblBhY2thZ2UgPSB7XG5cdG5hbWU6IG5hbWUsXG5cdHVyaTogdXJpLFxuXHRwcmVmaXg6IHByZWZpeCxcblx0YXNzb2NpYXRpb25zOiBhc3NvY2lhdGlvbnMsXG5cdHR5cGVzOiB0eXBlcyxcblx0ZW51bWVyYXRpb25zOiBlbnVtZXJhdGlvbnMsXG5cdHhtbDogeG1sXG59O1xuXG52YXIgbmFtZSQxID0gXCJCUE1ORElcIjtcbnZhciB1cmkkMSA9IFwiaHR0cDovL3d3dy5vbWcub3JnL3NwZWMvQlBNTi8yMDEwMDUyNC9ESVwiO1xudmFyIHByZWZpeCQxID0gXCJicG1uZGlcIjtcbnZhciB0eXBlcyQxID0gW1xuXHR7XG5cdFx0bmFtZTogXCJCUE1ORGlhZ3JhbVwiLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJwbGFuZVwiLFxuXHRcdFx0XHR0eXBlOiBcIkJQTU5QbGFuZVwiLFxuXHRcdFx0XHRyZWRlZmluZXM6IFwiZGk6RGlhZ3JhbSNyb290RWxlbWVudFwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImxhYmVsU3R5bGVcIixcblx0XHRcdFx0dHlwZTogXCJCUE1OTGFiZWxTdHlsZVwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH1cblx0XHRdLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiZGk6RGlhZ3JhbVwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJCUE1OUGxhbmVcIixcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiYnBtbkVsZW1lbnRcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJicG1uOkJhc2VFbGVtZW50XCIsXG5cdFx0XHRcdHJlZGVmaW5lczogXCJkaTpEaWFncmFtRWxlbWVudCNtb2RlbEVsZW1lbnRcIlxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJkaTpQbGFuZVwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJCUE1OU2hhcGVcIixcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiYnBtbkVsZW1lbnRcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJicG1uOkJhc2VFbGVtZW50XCIsXG5cdFx0XHRcdHJlZGVmaW5lczogXCJkaTpEaWFncmFtRWxlbWVudCNtb2RlbEVsZW1lbnRcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpc0hvcml6b250YWxcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIkJvb2xlYW5cIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpc0V4cGFuZGVkXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJCb29sZWFuXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaXNNYXJrZXJWaXNpYmxlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJCb29sZWFuXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibGFiZWxcIixcblx0XHRcdFx0dHlwZTogXCJCUE1OTGFiZWxcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpc01lc3NhZ2VWaXNpYmxlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJCb29sZWFuXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwicGFydGljaXBhbnRCYW5kS2luZFwiLFxuXHRcdFx0XHR0eXBlOiBcIlBhcnRpY2lwYW50QmFuZEtpbmRcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImNob3Jlb2dyYXBoeUFjdGl2aXR5U2hhcGVcIixcblx0XHRcdFx0dHlwZTogXCJCUE1OU2hhcGVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJkaTpMYWJlbGVkU2hhcGVcIlxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQlBNTkVkZ2VcIixcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibGFiZWxcIixcblx0XHRcdFx0dHlwZTogXCJCUE1OTGFiZWxcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJicG1uRWxlbWVudFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcImJwbW46QmFzZUVsZW1lbnRcIixcblx0XHRcdFx0cmVkZWZpbmVzOiBcImRpOkRpYWdyYW1FbGVtZW50I21vZGVsRWxlbWVudFwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInNvdXJjZUVsZW1lbnRcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJkaTpEaWFncmFtRWxlbWVudFwiLFxuXHRcdFx0XHRyZWRlZmluZXM6IFwiZGk6RWRnZSNzb3VyY2VcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJ0YXJnZXRFbGVtZW50XCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiZGk6RGlhZ3JhbUVsZW1lbnRcIixcblx0XHRcdFx0cmVkZWZpbmVzOiBcImRpOkVkZ2UjdGFyZ2V0XCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibWVzc2FnZVZpc2libGVLaW5kXCIsXG5cdFx0XHRcdHR5cGU6IFwiTWVzc2FnZVZpc2libGVLaW5kXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiaW5pdGlhdGluZ1wiXG5cdFx0XHR9XG5cdFx0XSxcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcImRpOkxhYmVsZWRFZGdlXCJcblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkJQTU5MYWJlbFwiLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJsYWJlbFN0eWxlXCIsXG5cdFx0XHRcdHR5cGU6IFwiQlBNTkxhYmVsU3R5bGVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZSxcblx0XHRcdFx0cmVkZWZpbmVzOiBcImRpOkRpYWdyYW1FbGVtZW50I3N0eWxlXCJcblx0XHRcdH1cblx0XHRdLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiZGk6TGFiZWxcIlxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQlBNTkxhYmVsU3R5bGVcIixcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZm9udFwiLFxuXHRcdFx0XHR0eXBlOiBcImRjOkZvbnRcIlxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJkaTpTdHlsZVwiXG5cdFx0XVxuXHR9XG5dO1xudmFyIGVudW1lcmF0aW9ucyQxID0gW1xuXHR7XG5cdFx0bmFtZTogXCJQYXJ0aWNpcGFudEJhbmRLaW5kXCIsXG5cdFx0bGl0ZXJhbFZhbHVlczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInRvcF9pbml0aWF0aW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibWlkZGxlX2luaXRpYXRpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJib3R0b21faW5pdGlhdGluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInRvcF9ub25faW5pdGlhdGluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm1pZGRsZV9ub25faW5pdGlhdGluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImJvdHRvbV9ub25faW5pdGlhdGluZ1wiXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJNZXNzYWdlVmlzaWJsZUtpbmRcIixcblx0XHRsaXRlcmFsVmFsdWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaW5pdGlhdGluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm5vbl9pbml0aWF0aW5nXCJcblx0XHRcdH1cblx0XHRdXG5cdH1cbl07XG52YXIgYXNzb2NpYXRpb25zJDEgPSBbXG5dO1xudmFyIEJwbW5EaVBhY2thZ2UgPSB7XG5cdG5hbWU6IG5hbWUkMSxcblx0dXJpOiB1cmkkMSxcblx0cHJlZml4OiBwcmVmaXgkMSxcblx0dHlwZXM6IHR5cGVzJDEsXG5cdGVudW1lcmF0aW9uczogZW51bWVyYXRpb25zJDEsXG5cdGFzc29jaWF0aW9uczogYXNzb2NpYXRpb25zJDFcbn07XG5cbnZhciBuYW1lJDIgPSBcIkRDXCI7XG52YXIgdXJpJDIgPSBcImh0dHA6Ly93d3cub21nLm9yZy9zcGVjL0RELzIwMTAwNTI0L0RDXCI7XG52YXIgcHJlZml4JDIgPSBcImRjXCI7XG52YXIgdHlwZXMkMiA9IFtcblx0e1xuXHRcdG5hbWU6IFwiQm9vbGVhblwiXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkludGVnZXJcIlxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJSZWFsXCJcblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiU3RyaW5nXCJcblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiRm9udFwiLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJzaXplXCIsXG5cdFx0XHRcdHR5cGU6IFwiUmVhbFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaXNCb2xkXCIsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaXNJdGFsaWNcIixcblx0XHRcdFx0dHlwZTogXCJCb29sZWFuXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpc1VuZGVybGluZVwiLFxuXHRcdFx0XHR0eXBlOiBcIkJvb2xlYW5cIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImlzU3RyaWtlVGhyb3VnaFwiLFxuXHRcdFx0XHR0eXBlOiBcIkJvb2xlYW5cIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJQb2ludFwiLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJ4XCIsXG5cdFx0XHRcdHR5cGU6IFwiUmVhbFwiLFxuXHRcdFx0XHRcImRlZmF1bHRcIjogXCIwXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJ5XCIsXG5cdFx0XHRcdHR5cGU6IFwiUmVhbFwiLFxuXHRcdFx0XHRcImRlZmF1bHRcIjogXCIwXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQm91bmRzXCIsXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInhcIixcblx0XHRcdFx0dHlwZTogXCJSZWFsXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiBcIjBcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInlcIixcblx0XHRcdFx0dHlwZTogXCJSZWFsXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiBcIjBcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIndpZHRoXCIsXG5cdFx0XHRcdHR5cGU6IFwiUmVhbFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaGVpZ2h0XCIsXG5cdFx0XHRcdHR5cGU6IFwiUmVhbFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH1cbl07XG52YXIgYXNzb2NpYXRpb25zJDIgPSBbXG5dO1xudmFyIERjUGFja2FnZSA9IHtcblx0bmFtZTogbmFtZSQyLFxuXHR1cmk6IHVyaSQyLFxuXHRwcmVmaXg6IHByZWZpeCQyLFxuXHR0eXBlczogdHlwZXMkMixcblx0YXNzb2NpYXRpb25zOiBhc3NvY2lhdGlvbnMkMlxufTtcblxudmFyIG5hbWUkMyA9IFwiRElcIjtcbnZhciB1cmkkMyA9IFwiaHR0cDovL3d3dy5vbWcub3JnL3NwZWMvREQvMjAxMDA1MjQvRElcIjtcbnZhciBwcmVmaXgkMyA9IFwiZGlcIjtcbnZhciB0eXBlcyQzID0gW1xuXHR7XG5cdFx0bmFtZTogXCJEaWFncmFtRWxlbWVudFwiLFxuXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImlkXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNJZDogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJleHRlbnNpb25cIixcblx0XHRcdFx0dHlwZTogXCJFeHRlbnNpb25cIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJvd25pbmdEaWFncmFtXCIsXG5cdFx0XHRcdHR5cGU6IFwiRGlhZ3JhbVwiLFxuXHRcdFx0XHRpc1JlYWRPbmx5OiB0cnVlLFxuXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm93bmluZ0VsZW1lbnRcIixcblx0XHRcdFx0dHlwZTogXCJEaWFncmFtRWxlbWVudFwiLFxuXHRcdFx0XHRpc1JlYWRPbmx5OiB0cnVlLFxuXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm1vZGVsRWxlbWVudFwiLFxuXHRcdFx0XHRpc1JlYWRPbmx5OiB0cnVlLFxuXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIkVsZW1lbnRcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJzdHlsZVwiLFxuXHRcdFx0XHR0eXBlOiBcIlN0eWxlXCIsXG5cdFx0XHRcdGlzUmVhZE9ubHk6IHRydWUsXG5cdFx0XHRcdGlzVmlydHVhbDogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwib3duZWRFbGVtZW50XCIsXG5cdFx0XHRcdHR5cGU6IFwiRGlhZ3JhbUVsZW1lbnRcIixcblx0XHRcdFx0aXNSZWFkT25seTogdHJ1ZSxcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIk5vZGVcIixcblx0XHRpc0Fic3RyYWN0OiB0cnVlLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiRGlhZ3JhbUVsZW1lbnRcIlxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiRWRnZVwiLFxuXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJEaWFncmFtRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwic291cmNlXCIsXG5cdFx0XHRcdHR5cGU6IFwiRGlhZ3JhbUVsZW1lbnRcIixcblx0XHRcdFx0aXNSZWFkT25seTogdHJ1ZSxcblx0XHRcdFx0aXNWaXJ0dWFsOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJ0YXJnZXRcIixcblx0XHRcdFx0dHlwZTogXCJEaWFncmFtRWxlbWVudFwiLFxuXHRcdFx0XHRpc1JlYWRPbmx5OiB0cnVlLFxuXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIndheXBvaW50XCIsXG5cdFx0XHRcdGlzVW5pcXVlOiBmYWxzZSxcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcImRjOlBvaW50XCIsXG5cdFx0XHRcdHhtbDoge1xuXHRcdFx0XHRcdHNlcmlhbGl6ZTogXCJ4c2k6dHlwZVwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkRpYWdyYW1cIixcblx0XHRpc0Fic3RyYWN0OiB0cnVlLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpZFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzSWQ6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwicm9vdEVsZW1lbnRcIixcblx0XHRcdFx0dHlwZTogXCJEaWFncmFtRWxlbWVudFwiLFxuXHRcdFx0XHRpc1JlYWRPbmx5OiB0cnVlLFxuXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZG9jdW1lbnRhdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwicmVzb2x1dGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiUmVhbFwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm93bmVkU3R5bGVcIixcblx0XHRcdFx0dHlwZTogXCJTdHlsZVwiLFxuXHRcdFx0XHRpc1JlYWRPbmx5OiB0cnVlLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzVmlydHVhbDogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiU2hhcGVcIixcblx0XHRpc0Fic3RyYWN0OiB0cnVlLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiTm9kZVwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiYm91bmRzXCIsXG5cdFx0XHRcdHR5cGU6IFwiZGM6Qm91bmRzXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlBsYW5lXCIsXG5cdFx0aXNBYnN0cmFjdDogdHJ1ZSxcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIk5vZGVcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInBsYW5lRWxlbWVudFwiLFxuXHRcdFx0XHR0eXBlOiBcIkRpYWdyYW1FbGVtZW50XCIsXG5cdFx0XHRcdHN1YnNldHRlZFByb3BlcnR5OiBcIkRpYWdyYW1FbGVtZW50LW93bmVkRWxlbWVudFwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkxhYmVsZWRFZGdlXCIsXG5cdFx0aXNBYnN0cmFjdDogdHJ1ZSxcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkVkZ2VcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm93bmVkTGFiZWxcIixcblx0XHRcdFx0dHlwZTogXCJMYWJlbFwiLFxuXHRcdFx0XHRpc1JlYWRPbmx5OiB0cnVlLFxuXHRcdFx0XHRzdWJzZXR0ZWRQcm9wZXJ0eTogXCJEaWFncmFtRWxlbWVudC1vd25lZEVsZW1lbnRcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkxhYmVsZWRTaGFwZVwiLFxuXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJTaGFwZVwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwib3duZWRMYWJlbFwiLFxuXHRcdFx0XHR0eXBlOiBcIkxhYmVsXCIsXG5cdFx0XHRcdGlzUmVhZE9ubHk6IHRydWUsXG5cdFx0XHRcdHN1YnNldHRlZFByb3BlcnR5OiBcIkRpYWdyYW1FbGVtZW50LW93bmVkRWxlbWVudFwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzVmlydHVhbDogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiTGFiZWxcIixcblx0XHRpc0Fic3RyYWN0OiB0cnVlLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiTm9kZVwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiYm91bmRzXCIsXG5cdFx0XHRcdHR5cGU6IFwiZGM6Qm91bmRzXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlN0eWxlXCIsXG5cdFx0aXNBYnN0cmFjdDogdHJ1ZSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaWRcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc0lkOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJFeHRlbnNpb25cIixcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwidmFsdWVzXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJFbGVtZW50XCJcblx0XHRcdH1cblx0XHRdXG5cdH1cbl07XG52YXIgYXNzb2NpYXRpb25zJDMgPSBbXG5dO1xudmFyIHhtbCQxID0ge1xuXHR0YWdBbGlhczogXCJsb3dlckNhc2VcIlxufTtcbnZhciBEaVBhY2thZ2UgPSB7XG5cdG5hbWU6IG5hbWUkMyxcblx0dXJpOiB1cmkkMyxcblx0cHJlZml4OiBwcmVmaXgkMyxcblx0dHlwZXM6IHR5cGVzJDMsXG5cdGFzc29jaWF0aW9uczogYXNzb2NpYXRpb25zJDMsXG5cdHhtbDogeG1sJDFcbn07XG5cbnZhciBuYW1lJDQgPSBcImJwbW4uaW8gY29sb3JzIGZvciBCUE1OXCI7XG52YXIgdXJpJDQgPSBcImh0dHA6Ly9icG1uLmlvL3NjaGVtYS9icG1uL2Jpb2NvbG9yLzEuMFwiO1xudmFyIHByZWZpeCQ0ID0gXCJiaW9jXCI7XG52YXIgdHlwZXMkNCA9IFtcblx0e1xuXHRcdG5hbWU6IFwiQ29sb3JlZFNoYXBlXCIsXG5cdFx0XCJleHRlbmRzXCI6IFtcblx0XHRcdFwiYnBtbmRpOkJQTU5TaGFwZVwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwic3Ryb2tlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJmaWxsXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQ29sb3JlZEVkZ2VcIixcblx0XHRcImV4dGVuZHNcIjogW1xuXHRcdFx0XCJicG1uZGk6QlBNTkVkZ2VcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInN0cm9rZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZmlsbFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH1cblx0XHRdXG5cdH1cbl07XG52YXIgZW51bWVyYXRpb25zJDIgPSBbXG5dO1xudmFyIGFzc29jaWF0aW9ucyQ0ID0gW1xuXTtcbnZhciBCaW9jUGFja2FnZSA9IHtcblx0bmFtZTogbmFtZSQ0LFxuXHR1cmk6IHVyaSQ0LFxuXHRwcmVmaXg6IHByZWZpeCQ0LFxuXHR0eXBlczogdHlwZXMkNCxcblx0ZW51bWVyYXRpb25zOiBlbnVtZXJhdGlvbnMkMixcblx0YXNzb2NpYXRpb25zOiBhc3NvY2lhdGlvbnMkNFxufTtcblxudmFyIHBhY2thZ2VzID0ge1xuICBicG1uOiBCcG1uUGFja2FnZSxcbiAgYnBtbmRpOiBCcG1uRGlQYWNrYWdlLFxuICBkYzogRGNQYWNrYWdlLFxuICBkaTogRGlQYWNrYWdlLFxuICBiaW9jOiBCaW9jUGFja2FnZVxufTtcblxuZnVuY3Rpb24gc2ltcGxlKGFkZGl0aW9uYWxQYWNrYWdlcywgb3B0aW9ucykge1xuICB2YXIgcGtzID0gYXNzaWduKHt9LCBwYWNrYWdlcywgYWRkaXRpb25hbFBhY2thZ2VzKTtcblxuICByZXR1cm4gbmV3IEJwbW5Nb2RkbGUocGtzLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2ltcGxlO1xuIiwiaW1wb3J0IHsgZm9yRWFjaCwgYXNzaWduLCBmaW5kLCBmaWx0ZXIsIGlzU3RyaW5nLCBtYXAgfSBmcm9tICdtaW4tZGFzaCc7XG5pbXBvcnQgeyBQYXJzZXIgfSBmcm9tICdzYXhlbic7XG5pbXBvcnQgeyBjb2VyY2VUeXBlLCBwYXJzZU5hbWVOUywgaXNTaW1wbGVUeXBlLCBNb2RkbGUgfSBmcm9tICdtb2RkbGUnO1xuXG5mdW5jdGlvbiBoYXNMb3dlckNhc2VBbGlhcyhwa2cpIHtcbiAgcmV0dXJuIHBrZy54bWwgJiYgcGtnLnhtbC50YWdBbGlhcyA9PT0gJ2xvd2VyQ2FzZSc7XG59XG5cbnZhciBERUZBVUxUX05TX01BUCA9IHtcbiAgJ3hzaSc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYS1pbnN0YW5jZSdcbn07XG5cbnZhciBYU0lfVFlQRSA9ICd4c2k6dHlwZSc7XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUZvcm1hdChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LnhtbCAmJiBlbGVtZW50LnhtbC5zZXJpYWxpemU7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUFzVHlwZShlbGVtZW50KSB7XG4gIHJldHVybiBzZXJpYWxpemVGb3JtYXQoZWxlbWVudCkgPT09IFhTSV9UWVBFO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVBc1Byb3BlcnR5KGVsZW1lbnQpIHtcbiAgcmV0dXJuIHNlcmlhbGl6ZUZvcm1hdChlbGVtZW50KSA9PT0gJ3Byb3BlcnR5Jztcbn1cblxuZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn1cblxuZnVuY3Rpb24gYWxpYXNUb05hbWUoYWxpYXNOcywgcGtnKSB7XG5cbiAgaWYgKCFoYXNMb3dlckNhc2VBbGlhcyhwa2cpKSB7XG4gICAgcmV0dXJuIGFsaWFzTnMubmFtZTtcbiAgfVxuXG4gIHJldHVybiBhbGlhc05zLnByZWZpeCArICc6JyArIGNhcGl0YWxpemUoYWxpYXNOcy5sb2NhbE5hbWUpO1xufVxuXG5mdW5jdGlvbiBwcmVmaXhlZFRvTmFtZShuYW1lTnMsIHBrZykge1xuXG4gIHZhciBuYW1lID0gbmFtZU5zLm5hbWUsXG4gICAgICBsb2NhbE5hbWUgPSBuYW1lTnMubG9jYWxOYW1lO1xuXG4gIHZhciB0eXBlUHJlZml4ID0gcGtnLnhtbCAmJiBwa2cueG1sLnR5cGVQcmVmaXg7XG5cbiAgaWYgKHR5cGVQcmVmaXggJiYgbG9jYWxOYW1lLmluZGV4T2YodHlwZVByZWZpeCkgPT09IDApIHtcbiAgICByZXR1cm4gbmFtZU5zLnByZWZpeCArICc6JyArIGxvY2FsTmFtZS5zbGljZSh0eXBlUHJlZml4Lmxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplWHNpVHlwZU5hbWUobmFtZSwgbW9kZWwpIHtcblxuICB2YXIgbmFtZU5zID0gcGFyc2VOYW1lTlMobmFtZSk7XG4gIHZhciBwa2cgPSBtb2RlbC5nZXRQYWNrYWdlKG5hbWVOcy5wcmVmaXgpO1xuXG4gIHJldHVybiBwcmVmaXhlZFRvTmFtZShuYW1lTnMsIHBrZyk7XG59XG5cbmZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG1vZGRsZSBkZXNjcmlwdG9yIGZvciBhIGdpdmVuIGluc3RhbmNlIG9yIHR5cGUuXG4gKlxuICogQHBhcmFtICB7TW9kZGxlRWxlbWVudHxGdW5jdGlvbn0gZWxlbWVudFxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIG1vZGRsZSBkZXNjcmlwdG9yXG4gKi9cbmZ1bmN0aW9uIGdldE1vZGRsZURlc2NyaXB0b3IoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC4kZGVzY3JpcHRvcjtcbn1cblxuZnVuY3Rpb24gZGVmZXIoZm4pIHtcbiAgc2V0VGltZW91dChmbiwgMCk7XG59XG5cbi8qKlxuICogQSBwYXJzZSBjb250ZXh0LlxuICpcbiAqIEBjbGFzc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0VsZW1lbnRIYW5kbGVyfSBvcHRpb25zLnJvb3RIYW5kbGVyIHRoZSByb290IGhhbmRsZXIgZm9yIHBhcnNpbmcgYSBkb2N1bWVudFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sYXg9ZmFsc2VdIHdoZXRoZXIgb3Igbm90IHRvIGlnbm9yZSBpbnZhbGlkIGVsZW1lbnRzXG4gKi9cbmZ1bmN0aW9uIENvbnRleHQob3B0aW9ucykge1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkge0VsZW1lbnRIYW5kbGVyfSByb290SGFuZGxlclxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBsYXhcbiAgICovXG5cbiAgYXNzaWduKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuZWxlbWVudHNCeUlkID0ge307XG4gIHRoaXMucmVmZXJlbmNlcyA9IFtdO1xuICB0aGlzLndhcm5pbmdzID0gW107XG5cbiAgLyoqXG4gICAqIEFkZCBhbiB1bnJlc29sdmVkIHJlZmVyZW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlZmVyZW5jZVxuICAgKi9cbiAgdGhpcy5hZGRSZWZlcmVuY2UgPSBmdW5jdGlvbihyZWZlcmVuY2UpIHtcbiAgICB0aGlzLnJlZmVyZW5jZXMucHVzaChyZWZlcmVuY2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBwcm9jZXNzZWQgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtNb2RkbGVFbGVtZW50fSBlbGVtZW50XG4gICAqL1xuICB0aGlzLmFkZEVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG5cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHRocm93IGVycm9yKCdleHBlY3RlZCBlbGVtZW50Jyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRzQnlJZCA9IHRoaXMuZWxlbWVudHNCeUlkO1xuXG4gICAgdmFyIGRlc2NyaXB0b3IgPSBnZXRNb2RkbGVEZXNjcmlwdG9yKGVsZW1lbnQpO1xuXG4gICAgdmFyIGlkUHJvcGVydHkgPSBkZXNjcmlwdG9yLmlkUHJvcGVydHksXG4gICAgICAgIGlkO1xuXG4gICAgaWYgKGlkUHJvcGVydHkpIHtcbiAgICAgIGlkID0gZWxlbWVudC5nZXQoaWRQcm9wZXJ0eS5uYW1lKTtcblxuICAgICAgaWYgKGlkKSB7XG4gICAgICAgIC8vIGZvciBRTmFtZSB2YWxpZGF0aW9uIGFzIHBlciBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMteG1sLyNOVC1OYW1lQ2hhclxuICAgICAgICBpZiAoIS9eKFthLXpdW1xcdy0uXSo6KT9bYS16X11bXFx3LS5dKiQvaS50ZXN0KGlkKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaWxsZWdhbCBJRCA8JyArIGlkICsgJz4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbGVtZW50c0J5SWRbaWRdKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3IoJ2R1cGxpY2F0ZSBJRCA8JyArIGlkICsgJz4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnRzQnlJZFtpZF0gPSBlbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWRkIGFuIGltcG9ydCB3YXJuaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gd2FybmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gd2FybmluZy5tZXNzYWdlXG4gICAqIEBwYXJhbSB7RXJyb3J9IFt3YXJuaW5nLmVycm9yXVxuICAgKi9cbiAgdGhpcy5hZGRXYXJuaW5nID0gZnVuY3Rpb24od2FybmluZykge1xuICAgIHRoaXMud2FybmluZ3MucHVzaCh3YXJuaW5nKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gQmFzZUhhbmRsZXIoKSB7fVxuXG5CYXNlSGFuZGxlci5wcm90b3R5cGUuaGFuZGxlRW5kID0gZnVuY3Rpb24oKSB7fTtcbkJhc2VIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVUZXh0ID0gZnVuY3Rpb24oKSB7fTtcbkJhc2VIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVOb2RlID0gZnVuY3Rpb24oKSB7fTtcblxuXG4vKipcbiAqIEEgc2ltcGxlIHBhc3MgdGhyb3VnaCBoYW5kbGVyIHRoYXQgZG9lcyBub3RoaW5nIGV4Y2VwdCBmb3JcbiAqIGlnbm9yaW5nIGFsbCBpbnB1dCBpdCByZWNlaXZlcy5cbiAqXG4gKiBUaGlzIGlzIHVzZWQgdG8gaWdub3JlIHVua25vd24gZWxlbWVudHMgYW5kXG4gKiBhdHRyaWJ1dGVzLlxuICovXG5mdW5jdGlvbiBOb29wSGFuZGxlcigpIHsgfVxuXG5Ob29wSGFuZGxlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2VIYW5kbGVyLnByb3RvdHlwZSk7XG5cbk5vb3BIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVOb2RlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gQm9keUhhbmRsZXIoKSB7fVxuXG5Cb2R5SGFuZGxlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2VIYW5kbGVyLnByb3RvdHlwZSk7XG5cbkJvZHlIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVUZXh0ID0gZnVuY3Rpb24odGV4dCkge1xuICB0aGlzLmJvZHkgPSAodGhpcy5ib2R5IHx8ICcnKSArIHRleHQ7XG59O1xuXG5mdW5jdGlvbiBSZWZlcmVuY2VIYW5kbGVyKHByb3BlcnR5LCBjb250ZXh0KSB7XG4gIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbn1cblxuUmVmZXJlbmNlSGFuZGxlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJvZHlIYW5kbGVyLnByb3RvdHlwZSk7XG5cblJlZmVyZW5jZUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZU5vZGUgPSBmdW5jdGlvbihub2RlKSB7XG5cbiAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgIHRocm93IGVycm9yKCdleHBlY3RlZCBubyBzdWIgbm9kZXMnKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmVsZW1lbnQgPSB0aGlzLmNyZWF0ZVJlZmVyZW5jZShub2RlKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVmZXJlbmNlSGFuZGxlci5wcm90b3R5cGUuaGFuZGxlRW5kID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZWxlbWVudC5pZCA9IHRoaXMuYm9keTtcbn07XG5cblJlZmVyZW5jZUhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZVJlZmVyZW5jZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9wZXJ0eTogdGhpcy5wcm9wZXJ0eS5ucy5uYW1lLFxuICAgIGlkOiAnJ1xuICB9O1xufTtcblxuZnVuY3Rpb24gVmFsdWVIYW5kbGVyKHByb3BlcnR5RGVzYywgZWxlbWVudCkge1xuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICB0aGlzLnByb3BlcnR5RGVzYyA9IHByb3BlcnR5RGVzYztcbn1cblxuVmFsdWVIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQm9keUhhbmRsZXIucHJvdG90eXBlKTtcblxuVmFsdWVIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVFbmQgPSBmdW5jdGlvbigpIHtcblxuICB2YXIgdmFsdWUgPSB0aGlzLmJvZHkgfHwgJycsXG4gICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgcHJvcGVydHlEZXNjID0gdGhpcy5wcm9wZXJ0eURlc2M7XG5cbiAgdmFsdWUgPSBjb2VyY2VUeXBlKHByb3BlcnR5RGVzYy50eXBlLCB2YWx1ZSk7XG5cbiAgaWYgKHByb3BlcnR5RGVzYy5pc01hbnkpIHtcbiAgICBlbGVtZW50LmdldChwcm9wZXJ0eURlc2MubmFtZSkucHVzaCh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudC5zZXQocHJvcGVydHlEZXNjLm5hbWUsIHZhbHVlKTtcbiAgfVxufTtcblxuXG5mdW5jdGlvbiBCYXNlRWxlbWVudEhhbmRsZXIoKSB7fVxuXG5CYXNlRWxlbWVudEhhbmRsZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCb2R5SGFuZGxlci5wcm90b3R5cGUpO1xuXG5CYXNlRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmhhbmRsZU5vZGUgPSBmdW5jdGlvbihub2RlKSB7XG4gIHZhciBwYXJzZXIgPSB0aGlzLFxuICAgICAgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50ID0gdGhpcy5jcmVhdGVFbGVtZW50KG5vZGUpO1xuXG4gICAgdGhpcy5jb250ZXh0LmFkZEVsZW1lbnQoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgcGFyc2VyID0gdGhpcy5oYW5kbGVDaGlsZChub2RlKTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZXI7XG59O1xuXG4vKipcbiAqIEBjbGFzcyBSZWFkZXIuRWxlbWVudEhhbmRsZXJcbiAqXG4gKi9cbmZ1bmN0aW9uIEVsZW1lbnRIYW5kbGVyKG1vZGVsLCB0eXBlTmFtZSwgY29udGV4dCkge1xuICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gIHRoaXMudHlwZSA9IG1vZGVsLmdldFR5cGUodHlwZU5hbWUpO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xufVxuXG5FbGVtZW50SGFuZGxlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2VFbGVtZW50SGFuZGxlci5wcm90b3R5cGUpO1xuXG5FbGVtZW50SGFuZGxlci5wcm90b3R5cGUuYWRkUmVmZXJlbmNlID0gZnVuY3Rpb24ocmVmZXJlbmNlKSB7XG4gIHRoaXMuY29udGV4dC5hZGRSZWZlcmVuY2UocmVmZXJlbmNlKTtcbn07XG5cbkVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVUZXh0ID0gZnVuY3Rpb24odGV4dCkge1xuXG4gIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgZGVzY3JpcHRvciA9IGdldE1vZGRsZURlc2NyaXB0b3IoZWxlbWVudCksXG4gICAgICBib2R5UHJvcGVydHkgPSBkZXNjcmlwdG9yLmJvZHlQcm9wZXJ0eTtcblxuICBpZiAoIWJvZHlQcm9wZXJ0eSkge1xuICAgIHRocm93IGVycm9yKCd1bmV4cGVjdGVkIGJvZHkgdGV4dCA8JyArIHRleHQgKyAnPicpO1xuICB9XG5cbiAgQm9keUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZVRleHQuY2FsbCh0aGlzLCB0ZXh0KTtcbn07XG5cbkVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVFbmQgPSBmdW5jdGlvbigpIHtcblxuICB2YXIgdmFsdWUgPSB0aGlzLmJvZHksXG4gICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgZGVzY3JpcHRvciA9IGdldE1vZGRsZURlc2NyaXB0b3IoZWxlbWVudCksXG4gICAgICBib2R5UHJvcGVydHkgPSBkZXNjcmlwdG9yLmJvZHlQcm9wZXJ0eTtcblxuICBpZiAoYm9keVByb3BlcnR5ICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGNvZXJjZVR5cGUoYm9keVByb3BlcnR5LnR5cGUsIHZhbHVlKTtcbiAgICBlbGVtZW50LnNldChib2R5UHJvcGVydHkubmFtZSwgdmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGUgbW9kZWwgZnJvbSB0aGUgZ2l2ZW4gbm9kZS5cbiAqXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBub2RlIHRoZSB4bWwgbm9kZVxuICovXG5FbGVtZW50SGFuZGxlci5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBub2RlLmF0dHJpYnV0ZXMsXG4gICAgICBUeXBlID0gdGhpcy50eXBlLFxuICAgICAgZGVzY3JpcHRvciA9IGdldE1vZGRsZURlc2NyaXB0b3IoVHlwZSksXG4gICAgICBjb250ZXh0ID0gdGhpcy5jb250ZXh0LFxuICAgICAgaW5zdGFuY2UgPSBuZXcgVHlwZSh7fSksXG4gICAgICBtb2RlbCA9IHRoaXMubW9kZWwsXG4gICAgICBwcm9wTmFtZU5zO1xuXG4gIGZvckVhY2goYXR0cmlidXRlcywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcblxuICAgIHZhciBwcm9wID0gZGVzY3JpcHRvci5wcm9wZXJ0aWVzQnlOYW1lW25hbWVdLFxuICAgICAgICB2YWx1ZXM7XG5cbiAgICBpZiAocHJvcCAmJiBwcm9wLmlzUmVmZXJlbmNlKSB7XG5cbiAgICAgIGlmICghcHJvcC5pc01hbnkpIHtcbiAgICAgICAgY29udGV4dC5hZGRSZWZlcmVuY2Uoe1xuICAgICAgICAgIGVsZW1lbnQ6IGluc3RhbmNlLFxuICAgICAgICAgIHByb3BlcnR5OiBwcm9wLm5zLm5hbWUsXG4gICAgICAgICAgaWQ6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSURSRUZTOiBwYXJzZSByZWZlcmVuY2VzIGFzIHdoaXRlc3BhY2Utc2VwYXJhdGVkIGxpc3RcbiAgICAgICAgdmFsdWVzID0gdmFsdWUuc3BsaXQoJyAnKTtcblxuICAgICAgICBmb3JFYWNoKHZhbHVlcywgZnVuY3Rpb24odikge1xuICAgICAgICAgIGNvbnRleHQuYWRkUmVmZXJlbmNlKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGluc3RhbmNlLFxuICAgICAgICAgICAgcHJvcGVydHk6IHByb3AubnMubmFtZSxcbiAgICAgICAgICAgIGlkOiB2XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wKSB7XG4gICAgICAgIHZhbHVlID0gY29lcmNlVHlwZShwcm9wLnR5cGUsIHZhbHVlKTtcbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKG5hbWUgIT09ICd4bWxucycpIHtcbiAgICAgICAgcHJvcE5hbWVOcyA9IHBhcnNlTmFtZU5TKG5hbWUsIGRlc2NyaXB0b3IubnMucHJlZml4KTtcblxuICAgICAgICAvLyBjaGVjayB3aGV0aGVyIGF0dHJpYnV0ZSBpcyBkZWZpbmVkIGluIGEgd2VsbC1rbm93biBuYW1lc3BhY2VcbiAgICAgICAgLy8gaWYgdGhhdCBpcyB0aGUgY2FzZSB3ZSBlbWl0IGEgd2FybmluZyB0byBpbmRpY2F0ZSBwb3RlbnRpYWwgbWlzdXNlXG4gICAgICAgIGlmIChtb2RlbC5nZXRQYWNrYWdlKHByb3BOYW1lTnMucHJlZml4KSkge1xuXG4gICAgICAgICAgY29udGV4dC5hZGRXYXJuaW5nKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICd1bmtub3duIGF0dHJpYnV0ZSA8JyArIG5hbWUgKyAnPicsXG4gICAgICAgICAgICBlbGVtZW50OiBpbnN0YW5jZSxcbiAgICAgICAgICAgIHByb3BlcnR5OiBuYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW5zdGFuY2Uuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn07XG5cbkVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5nZXRQcm9wZXJ0eUZvck5vZGUgPSBmdW5jdGlvbihub2RlKSB7XG5cbiAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG4gIHZhciBuYW1lTnMgPSBwYXJzZU5hbWVOUyhuYW1lKTtcblxuICB2YXIgdHlwZSA9IHRoaXMudHlwZSxcbiAgICAgIG1vZGVsID0gdGhpcy5tb2RlbCxcbiAgICAgIGRlc2NyaXB0b3IgPSBnZXRNb2RkbGVEZXNjcmlwdG9yKHR5cGUpO1xuXG4gIHZhciBwcm9wZXJ0eU5hbWUgPSBuYW1lTnMubmFtZSxcbiAgICAgIHByb3BlcnR5ID0gZGVzY3JpcHRvci5wcm9wZXJ0aWVzQnlOYW1lW3Byb3BlcnR5TmFtZV0sXG4gICAgICBlbGVtZW50VHlwZU5hbWUsXG4gICAgICBlbGVtZW50VHlwZTtcblxuICAvLyBzZWFyY2ggZm9yIHByb3BlcnRpZXMgYnkgbmFtZSBmaXJzdFxuXG4gIGlmIChwcm9wZXJ0eSAmJiAhcHJvcGVydHkuaXNBdHRyKSB7XG5cbiAgICBpZiAoc2VyaWFsaXplQXNUeXBlKHByb3BlcnR5KSkge1xuICAgICAgZWxlbWVudFR5cGVOYW1lID0gbm9kZS5hdHRyaWJ1dGVzW1hTSV9UWVBFXTtcblxuICAgICAgLy8geHNpIHR5cGUgaXMgb3B0aW9uYWwsIGlmIGl0IGRvZXMgbm90IGV4aXN0cyB0aGVcbiAgICAgIC8vIGRlZmF1bHQgdHlwZSBpcyBhc3N1bWVkXG4gICAgICBpZiAoZWxlbWVudFR5cGVOYW1lKSB7XG5cbiAgICAgICAgLy8gdGFrZSBwb3NzaWJsZSB0eXBlIHByZWZpeGVzIGZyb20gWE1MXG4gICAgICAgIC8vIGludG8gYWNjb3VudCwgaS5lLjogeHNpOnR5cGU9XCJ0e0FjdHVhbFR5cGV9XCJcbiAgICAgICAgZWxlbWVudFR5cGVOYW1lID0gbm9ybWFsaXplWHNpVHlwZU5hbWUoZWxlbWVudFR5cGVOYW1lLCBtb2RlbCk7XG5cbiAgICAgICAgZWxlbWVudFR5cGUgPSBtb2RlbC5nZXRUeXBlKGVsZW1lbnRUeXBlTmFtZSk7XG5cbiAgICAgICAgcmV0dXJuIGFzc2lnbih7fSwgcHJvcGVydHksIHtcbiAgICAgICAgICBlZmZlY3RpdmVUeXBlOiBnZXRNb2RkbGVEZXNjcmlwdG9yKGVsZW1lbnRUeXBlKS5uYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNlYXJjaCBmb3IgcHJvcGVydGllcyBieSBuYW1lIGZpcnN0XG4gICAgcmV0dXJuIHByb3BlcnR5O1xuICB9XG5cbiAgdmFyIHBrZyA9IG1vZGVsLmdldFBhY2thZ2UobmFtZU5zLnByZWZpeCk7XG5cbiAgaWYgKHBrZykge1xuICAgIGVsZW1lbnRUeXBlTmFtZSA9IGFsaWFzVG9OYW1lKG5hbWVOcywgcGtnKTtcbiAgICBlbGVtZW50VHlwZSA9IG1vZGVsLmdldFR5cGUoZWxlbWVudFR5cGVOYW1lKTtcblxuICAgIC8vIHNlYXJjaCBmb3IgY29sbGVjdGlvbiBtZW1iZXJzIGxhdGVyXG4gICAgcHJvcGVydHkgPSBmaW5kKGRlc2NyaXB0b3IucHJvcGVydGllcywgZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuICFwLmlzVmlydHVhbCAmJiAhcC5pc1JlZmVyZW5jZSAmJiAhcC5pc0F0dHJpYnV0ZSAmJiBlbGVtZW50VHlwZS5oYXNUeXBlKHAudHlwZSk7XG4gICAgfSk7XG5cbiAgICBpZiAocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiBhc3NpZ24oe30sIHByb3BlcnR5LCB7XG4gICAgICAgIGVmZmVjdGl2ZVR5cGU6IGdldE1vZGRsZURlc2NyaXB0b3IoZWxlbWVudFR5cGUpLm5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBwYXJzZSB1bmtub3duIGVsZW1lbnQgKG1heWJlIGV4dGVuc2lvbilcbiAgICBwcm9wZXJ0eSA9IGZpbmQoZGVzY3JpcHRvci5wcm9wZXJ0aWVzLCBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gIXAuaXNSZWZlcmVuY2UgJiYgIXAuaXNBdHRyaWJ1dGUgJiYgcC50eXBlID09PSAnRWxlbWVudCc7XG4gICAgfSk7XG5cbiAgICBpZiAocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBlcnJvcigndW5yZWNvZ25pemVkIGVsZW1lbnQgPCcgKyBuYW1lTnMubmFtZSArICc+Jyk7XG59O1xuXG5FbGVtZW50SGFuZGxlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICdFbGVtZW50RGVzY3JpcHRvclsnICsgZ2V0TW9kZGxlRGVzY3JpcHRvcih0aGlzLnR5cGUpLm5hbWUgKyAnXSc7XG59O1xuXG5FbGVtZW50SGFuZGxlci5wcm90b3R5cGUudmFsdWVIYW5kbGVyID0gZnVuY3Rpb24ocHJvcGVydHlEZXNjLCBlbGVtZW50KSB7XG4gIHJldHVybiBuZXcgVmFsdWVIYW5kbGVyKHByb3BlcnR5RGVzYywgZWxlbWVudCk7XG59O1xuXG5FbGVtZW50SGFuZGxlci5wcm90b3R5cGUucmVmZXJlbmNlSGFuZGxlciA9IGZ1bmN0aW9uKHByb3BlcnR5RGVzYykge1xuICByZXR1cm4gbmV3IFJlZmVyZW5jZUhhbmRsZXIocHJvcGVydHlEZXNjLCB0aGlzLmNvbnRleHQpO1xufTtcblxuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmhhbmRsZXIgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0eXBlID09PSAnRWxlbWVudCcpIHtcbiAgICByZXR1cm4gbmV3IEdlbmVyaWNFbGVtZW50SGFuZGxlcih0aGlzLm1vZGVsLCB0eXBlLCB0aGlzLmNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgRWxlbWVudEhhbmRsZXIodGhpcy5tb2RlbCwgdHlwZSwgdGhpcy5jb250ZXh0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGUgdGhlIGNoaWxkIGVsZW1lbnQgcGFyc2luZ1xuICpcbiAqIEBwYXJhbSAge0VsZW1lbnR9IG5vZGUgdGhlIHhtbCBub2RlXG4gKi9cbkVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVDaGlsZCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdmFyIHByb3BlcnR5RGVzYywgdHlwZSwgZWxlbWVudCwgY2hpbGRIYW5kbGVyO1xuXG4gIHByb3BlcnR5RGVzYyA9IHRoaXMuZ2V0UHJvcGVydHlGb3JOb2RlKG5vZGUpO1xuICBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXG4gIHR5cGUgPSBwcm9wZXJ0eURlc2MuZWZmZWN0aXZlVHlwZSB8fCBwcm9wZXJ0eURlc2MudHlwZTtcblxuICBpZiAoaXNTaW1wbGVUeXBlKHR5cGUpKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVIYW5kbGVyKHByb3BlcnR5RGVzYywgZWxlbWVudCk7XG4gIH1cblxuICBpZiAocHJvcGVydHlEZXNjLmlzUmVmZXJlbmNlKSB7XG4gICAgY2hpbGRIYW5kbGVyID0gdGhpcy5yZWZlcmVuY2VIYW5kbGVyKHByb3BlcnR5RGVzYykuaGFuZGxlTm9kZShub2RlKTtcbiAgfSBlbHNlIHtcbiAgICBjaGlsZEhhbmRsZXIgPSB0aGlzLmhhbmRsZXIodHlwZSkuaGFuZGxlTm9kZShub2RlKTtcbiAgfVxuXG4gIHZhciBuZXdFbGVtZW50ID0gY2hpbGRIYW5kbGVyLmVsZW1lbnQ7XG5cbiAgLy8gY2hpbGQgaGFuZGxlcyBtYXkgZGVjaWRlIHRvIHNraXAgZWxlbWVudHNcbiAgLy8gYnkgbm90IHJldHVybmluZyBhbnl0aGluZ1xuICBpZiAobmV3RWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICBpZiAocHJvcGVydHlEZXNjLmlzTWFueSkge1xuICAgICAgZWxlbWVudC5nZXQocHJvcGVydHlEZXNjLm5hbWUpLnB1c2gobmV3RWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuc2V0KHByb3BlcnR5RGVzYy5uYW1lLCBuZXdFbGVtZW50KTtcbiAgICB9XG5cbiAgICBpZiAocHJvcGVydHlEZXNjLmlzUmVmZXJlbmNlKSB7XG4gICAgICBhc3NpZ24obmV3RWxlbWVudCwge1xuICAgICAgICBlbGVtZW50OiBlbGVtZW50XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5jb250ZXh0LmFkZFJlZmVyZW5jZShuZXdFbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXN0YWJsaXNoIGNoaWxkIC0+IHBhcmVudCByZWxhdGlvbnNoaXBcbiAgICAgIG5ld0VsZW1lbnQuJHBhcmVudCA9IGVsZW1lbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNoaWxkSGFuZGxlcjtcbn07XG5cbi8qKlxuICogQW4gZWxlbWVudCBoYW5kbGVyIHRoYXQgcGVyZm9ybXMgc3BlY2lhbCB2YWxpZGF0aW9uXG4gKiB0byBlbnN1cmUgdGhlIG5vZGUgaXQgZ2V0cyBpbml0aWFsaXplZCB3aXRoIG1hdGNoZXNcbiAqIHRoZSBoYW5kbGVycyB0eXBlIChuYW1lc3BhY2Ugd2lzZSkuXG4gKlxuICogQHBhcmFtIHtNb2RkbGV9IG1vZGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZU5hbWVcbiAqIEBwYXJhbSB7Q29udGV4dH0gY29udGV4dFxuICovXG5mdW5jdGlvbiBSb290RWxlbWVudEhhbmRsZXIobW9kZWwsIHR5cGVOYW1lLCBjb250ZXh0KSB7XG4gIEVsZW1lbnRIYW5kbGVyLmNhbGwodGhpcywgbW9kZWwsIHR5cGVOYW1lLCBjb250ZXh0KTtcbn1cblxuUm9vdEVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRWxlbWVudEhhbmRsZXIucHJvdG90eXBlKTtcblxuUm9vdEVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuXG4gIHZhciBuYW1lID0gbm9kZS5uYW1lLFxuICAgICAgbmFtZU5zID0gcGFyc2VOYW1lTlMobmFtZSksXG4gICAgICBtb2RlbCA9IHRoaXMubW9kZWwsXG4gICAgICB0eXBlID0gdGhpcy50eXBlLFxuICAgICAgcGtnID0gbW9kZWwuZ2V0UGFja2FnZShuYW1lTnMucHJlZml4KSxcbiAgICAgIHR5cGVOYW1lID0gcGtnICYmIGFsaWFzVG9OYW1lKG5hbWVOcywgcGtnKSB8fCBuYW1lO1xuXG4gIC8vIHZlcmlmeSB0aGUgY29ycmVjdCBuYW1lc3BhY2UgaWYgd2UgcGFyc2VcbiAgLy8gdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGhhbmRsZXIgdHJlZVxuICAvL1xuICAvLyB0aGlzIGVuc3VyZXMgd2UgZG9uJ3QgbWlzdGFrZW5seSBpbXBvcnQgd3JvbmcgbmFtZXNwYWNlIGVsZW1lbnRzXG4gIGlmICghdHlwZS5oYXNUeXBlKHR5cGVOYW1lKSkge1xuICAgIHRocm93IGVycm9yKCd1bmV4cGVjdGVkIGVsZW1lbnQgPCcgKyBub2RlLm9yaWdpbmFsTmFtZSArICc+Jyk7XG4gIH1cblxuICByZXR1cm4gRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQuY2FsbCh0aGlzLCBub2RlKTtcbn07XG5cblxuZnVuY3Rpb24gR2VuZXJpY0VsZW1lbnRIYW5kbGVyKG1vZGVsLCB0eXBlTmFtZSwgY29udGV4dCkge1xuICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbkdlbmVyaWNFbGVtZW50SGFuZGxlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2VFbGVtZW50SGFuZGxlci5wcm90b3R5cGUpO1xuXG5HZW5lcmljRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG5cbiAgdmFyIG5hbWUgPSBub2RlLm5hbWUsXG4gICAgICBucyA9IHBhcnNlTmFtZU5TKG5hbWUpLFxuICAgICAgcHJlZml4ID0gbnMucHJlZml4LFxuICAgICAgdXJpID0gbm9kZS5uc1twcmVmaXggKyAnJHVyaSddLFxuICAgICAgYXR0cmlidXRlcyA9IG5vZGUuYXR0cmlidXRlcztcblxuICByZXR1cm4gdGhpcy5tb2RlbC5jcmVhdGVBbnkobmFtZSwgdXJpLCBhdHRyaWJ1dGVzKTtcbn07XG5cbkdlbmVyaWNFbGVtZW50SGFuZGxlci5wcm90b3R5cGUuaGFuZGxlQ2hpbGQgPSBmdW5jdGlvbihub2RlKSB7XG5cbiAgdmFyIGhhbmRsZXIgPSBuZXcgR2VuZXJpY0VsZW1lbnRIYW5kbGVyKHRoaXMubW9kZWwsICdFbGVtZW50JywgdGhpcy5jb250ZXh0KS5oYW5kbGVOb2RlKG5vZGUpLFxuICAgICAgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblxuICB2YXIgbmV3RWxlbWVudCA9IGhhbmRsZXIuZWxlbWVudCxcbiAgICAgIGNoaWxkcmVuO1xuXG4gIGlmIChuZXdFbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjaGlsZHJlbiA9IGVsZW1lbnQuJGNoaWxkcmVuID0gZWxlbWVudC4kY2hpbGRyZW4gfHwgW107XG4gICAgY2hpbGRyZW4ucHVzaChuZXdFbGVtZW50KTtcblxuICAgIC8vIGVzdGFibGlzaCBjaGlsZCAtPiBwYXJlbnQgcmVsYXRpb25zaGlwXG4gICAgbmV3RWxlbWVudC4kcGFyZW50ID0gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiBoYW5kbGVyO1xufTtcblxuR2VuZXJpY0VsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVFbmQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuYm9keSkge1xuICAgIHRoaXMuZWxlbWVudC4kYm9keSA9IHRoaXMuYm9keTtcbiAgfVxufTtcblxuLyoqXG4gKiBBIHJlYWRlciBmb3IgYSBtZXRhLW1vZGVsXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7TW9kZWx9IG9wdGlvbnMubW9kZWwgdXNlZCB0byByZWFkIHhtbCBmaWxlc1xuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmxheCB3aGV0aGVyIHRvIG1ha2UgcGFyc2UgZXJyb3JzIHdhcm5pbmdzXG4gKi9cbmZ1bmN0aW9uIFJlYWRlcihvcHRpb25zKSB7XG5cbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBNb2RkbGUpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgbW9kZWw6IG9wdGlvbnNcbiAgICB9O1xuICB9XG5cbiAgYXNzaWduKHRoaXMsIHsgbGF4OiBmYWxzZSB9LCBvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBYTUwgaW50byBhIG1vZGRsZSBkb2N1bWVudCB0cmVlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB4bWxcbiAqIEBwYXJhbSB7RWxlbWVudEhhbmRsZXJ8T2JqZWN0fSBvcHRpb25zIG9yIHJvb3RIYW5kbGVyXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZG9uZVxuICovXG5SZWFkZXIucHJvdG90eXBlLmZyb21YTUwgPSBmdW5jdGlvbih4bWwsIG9wdGlvbnMsIGRvbmUpIHtcblxuICB2YXIgcm9vdEhhbmRsZXIgPSBvcHRpb25zLnJvb3RIYW5kbGVyO1xuXG4gIGlmIChvcHRpb25zIGluc3RhbmNlb2YgRWxlbWVudEhhbmRsZXIpIHtcbiAgICAvLyByb290IGhhbmRsZXIgcGFzc2VkIHZpYSAoeG1sLCB7IHJvb3RIYW5kbGVyOiBFbGVtZW50SGFuZGxlciB9LCAuLi4pXG4gICAgcm9vdEhhbmRsZXIgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyByb290SGFuZGxlciBwYXNzZWQgdmlhICh4bWwsICdzb21lU3RyaW5nJywgLi4uKVxuICAgICAgcm9vdEhhbmRsZXIgPSB0aGlzLmhhbmRsZXIob3B0aW9ucyk7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygcm9vdEhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyByb290SGFuZGxlciBwYXNzZWQgdmlhICh4bWwsIHsgcm9vdEhhbmRsZXI6ICdzb21lU3RyaW5nJyB9LCAuLi4pXG4gICAgICByb290SGFuZGxlciA9IHRoaXMuaGFuZGxlcihyb290SGFuZGxlcik7XG4gICAgfVxuICB9XG5cbiAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbCxcbiAgICAgIGxheCA9IHRoaXMubGF4O1xuXG4gIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQoYXNzaWduKHt9LCBvcHRpb25zLCB7IHJvb3RIYW5kbGVyOiByb290SGFuZGxlciB9KSksXG4gICAgICBwYXJzZXIgPSBuZXcgUGFyc2VyKHsgcHJveHk6IHRydWUgfSksXG4gICAgICBzdGFjayA9IGNyZWF0ZVN0YWNrKCk7XG5cbiAgcm9vdEhhbmRsZXIuY29udGV4dCA9IGNvbnRleHQ7XG5cbiAgLy8gcHVzaCByb290IGhhbmRsZXJcbiAgc3RhY2sucHVzaChyb290SGFuZGxlcik7XG5cblxuICAvKipcbiAgICogSGFuZGxlIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gIHtFcnJvcn0gZXJyXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBnZXRDb250ZXh0XG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IGxheFxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGhhbmRsZWRcbiAgICovXG4gIGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVyciwgZ2V0Q29udGV4dCwgbGF4KSB7XG5cbiAgICB2YXIgY3R4ID0gZ2V0Q29udGV4dCgpO1xuXG4gICAgdmFyIGxpbmUgPSBjdHgubGluZSxcbiAgICAgICAgY29sdW1uID0gY3R4LmNvbHVtbixcbiAgICAgICAgZGF0YSA9IGN0eC5kYXRhO1xuXG4gICAgLy8gd2UgcmVjZWl2ZSB0aGUgZnVsbCBjb250ZXh0IGRhdGEgaGVyZSxcbiAgICAvLyBmb3IgZWxlbWVudHMgdHJpbSBkb3duIHRoZSBpbmZvcm1hdGlvblxuICAgIC8vIHRvIHRoZSB0YWcgbmFtZSwgb25seVxuICAgIGlmIChkYXRhLmNoYXJBdCgwKSA9PT0gJzwnICYmIGRhdGEuaW5kZXhPZignICcpICE9PSAtMSkge1xuICAgICAgZGF0YSA9IGRhdGEuc2xpY2UoMCwgZGF0YS5pbmRleE9mKCcgJykpICsgJz4nO1xuICAgIH1cblxuICAgIHZhciBtZXNzYWdlID1cbiAgICAgICd1bnBhcnNhYmxlIGNvbnRlbnQgJyArIChkYXRhID8gZGF0YSArICcgJyA6ICcnKSArICdkZXRlY3RlZFxcblxcdCcgK1xuICAgICAgICAnbGluZTogJyArIGxpbmUgKyAnXFxuXFx0JyArXG4gICAgICAgICdjb2x1bW46ICcgKyBjb2x1bW4gKyAnXFxuXFx0JyArXG4gICAgICAgICduZXN0ZWQgZXJyb3I6ICcgKyBlcnIubWVzc2FnZTtcblxuICAgIGlmIChsYXgpIHtcbiAgICAgIGNvbnRleHQuYWRkV2FybmluZyh7XG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgIGVycm9yOiBlcnJcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlV2FybmluZyhlcnIsIGdldENvbnRleHQpIHtcbiAgICAvLyBqdXN0IGxpa2UgaGFuZGxpbmcgZXJyb3JzIGluIDxsYXg9dHJ1ZT4gbW9kZVxuICAgIHJldHVybiBoYW5kbGVFcnJvcihlcnIsIGdldENvbnRleHQsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmUgY29sbGVjdGVkIHJlZmVyZW5jZXMgb24gcGFyc2UgZW5kLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVzb2x2ZVJlZmVyZW5jZXMoKSB7XG5cbiAgICB2YXIgZWxlbWVudHNCeUlkID0gY29udGV4dC5lbGVtZW50c0J5SWQ7XG4gICAgdmFyIHJlZmVyZW5jZXMgPSBjb250ZXh0LnJlZmVyZW5jZXM7XG5cbiAgICB2YXIgaSwgcjtcblxuICAgIGZvciAoaSA9IDA7IChyID0gcmVmZXJlbmNlc1tpXSk7IGkrKykge1xuICAgICAgdmFyIGVsZW1lbnQgPSByLmVsZW1lbnQ7XG4gICAgICB2YXIgcmVmZXJlbmNlID0gZWxlbWVudHNCeUlkW3IuaWRdO1xuICAgICAgdmFyIHByb3BlcnR5ID0gZ2V0TW9kZGxlRGVzY3JpcHRvcihlbGVtZW50KS5wcm9wZXJ0aWVzQnlOYW1lW3IucHJvcGVydHldO1xuXG4gICAgICBpZiAoIXJlZmVyZW5jZSkge1xuICAgICAgICBjb250ZXh0LmFkZFdhcm5pbmcoe1xuICAgICAgICAgIG1lc3NhZ2U6ICd1bnJlc29sdmVkIHJlZmVyZW5jZSA8JyArIHIuaWQgKyAnPicsXG4gICAgICAgICAgZWxlbWVudDogci5lbGVtZW50LFxuICAgICAgICAgIHByb3BlcnR5OiByLnByb3BlcnR5LFxuICAgICAgICAgIHZhbHVlOiByLmlkXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcGVydHkuaXNNYW55KSB7XG4gICAgICAgIHZhciBjb2xsZWN0aW9uID0gZWxlbWVudC5nZXQocHJvcGVydHkubmFtZSksXG4gICAgICAgICAgICBpZHggPSBjb2xsZWN0aW9uLmluZGV4T2Yocik7XG5cbiAgICAgICAgLy8gd2UgcmVwbGFjZSBhbiBleGlzdGluZyBwbGFjZSBob2xkZXIgKGlkeCAhPSAtMSkgb3JcbiAgICAgICAgLy8gYXBwZW5kIHRvIHRoZSBjb2xsZWN0aW9uIGluc3RlYWRcbiAgICAgICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgICBpZHggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVmZXJlbmNlKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHVucmVzb2x2YWJsZSByZWZlcmVuY2VcbiAgICAgICAgICBjb2xsZWN0aW9uLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGFkZCBvciB1cGRhdGUgcmVmZXJlbmNlIGluIGNvbGxlY3Rpb25cbiAgICAgICAgICBjb2xsZWN0aW9uW2lkeF0gPSByZWZlcmVuY2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2V0KHByb3BlcnR5Lm5hbWUsIHJlZmVyZW5jZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ2xvc2UoKSB7XG4gICAgc3RhY2sucG9wKCkuaGFuZGxlRW5kKCk7XG4gIH1cblxuICB2YXIgUFJFQU1CTEVfU1RBUlRfUEFUVEVSTiA9IC9ePFxcP3htbCAvaTtcblxuICB2YXIgRU5DT0RJTkdfUEFUVEVSTiA9IC8gZW5jb2Rpbmc9XCIoW15cIl0rKVwiL2k7XG5cbiAgdmFyIFVURl84X1BBVFRFUk4gPSAvXnV0Zi04JC9pO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZVF1ZXN0aW9uKHF1ZXN0aW9uKSB7XG5cbiAgICBpZiAoIVBSRUFNQkxFX1NUQVJUX1BBVFRFUk4udGVzdChxdWVzdGlvbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2ggPSBFTkNPRElOR19QQVRURVJOLmV4ZWMocXVlc3Rpb24pO1xuICAgIHZhciBlbmNvZGluZyA9IG1hdGNoICYmIG1hdGNoWzFdO1xuXG4gICAgaWYgKCFlbmNvZGluZyB8fCBVVEZfOF9QQVRURVJOLnRlc3QoZW5jb2RpbmcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29udGV4dC5hZGRXYXJuaW5nKHtcbiAgICAgIG1lc3NhZ2U6XG4gICAgICAgICd1bnN1cHBvcnRlZCBkb2N1bWVudCBlbmNvZGluZyA8JyArIGVuY29kaW5nICsgJz4sICcgK1xuICAgICAgICAnZmFsbGluZyBiYWNrIHRvIFVURi04J1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlT3Blbihub2RlLCBnZXRDb250ZXh0KSB7XG4gICAgdmFyIGhhbmRsZXIgPSBzdGFjay5wZWVrKCk7XG5cbiAgICB0cnkge1xuICAgICAgc3RhY2sucHVzaChoYW5kbGVyLmhhbmRsZU5vZGUobm9kZSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuXG4gICAgICBpZiAoaGFuZGxlRXJyb3IoZXJyLCBnZXRDb250ZXh0LCBsYXgpKSB7XG4gICAgICAgIHN0YWNrLnB1c2gobmV3IE5vb3BIYW5kbGVyKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUNEYXRhKHRleHQsIGdldENvbnRleHQpIHtcblxuICAgIHRyeSB7XG4gICAgICBzdGFjay5wZWVrKCkuaGFuZGxlVGV4dCh0ZXh0KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGhhbmRsZVdhcm5pbmcoZXJyLCBnZXRDb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVUZXh0KHRleHQsIGdldENvbnRleHQpIHtcbiAgICAvLyBzdHJpcCB3aGl0ZXNwYWNlIG9ubHkgbm9kZXMsIGkuZS4gYmVmb3JlXG4gICAgLy8gPCFDREFUQVsgLi4uIF0+IHNlY3Rpb25zIGFuZCBpbiBiZXR3ZWVuIHRhZ3NcbiAgICB0ZXh0ID0gdGV4dC50cmltKCk7XG5cbiAgICBpZiAoIXRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBoYW5kbGVDRGF0YSh0ZXh0LCBnZXRDb250ZXh0KTtcbiAgfVxuXG4gIHZhciB1cmlNYXAgPSBtb2RlbC5nZXRQYWNrYWdlcygpLnJlZHVjZShmdW5jdGlvbih1cmlNYXAsIHApIHtcbiAgICB1cmlNYXBbcC51cmldID0gcC5wcmVmaXg7XG5cbiAgICByZXR1cm4gdXJpTWFwO1xuICB9LCB7fSk7XG5cbiAgcGFyc2VyXG4gICAgLm5zKHVyaU1hcClcbiAgICAub24oJ29wZW5UYWcnLCBmdW5jdGlvbihvYmosIGRlY29kZVN0ciwgc2VsZkNsb3NpbmcsIGdldENvbnRleHQpIHtcblxuICAgICAgLy8gZ3JhY2VmdWxseSBoYW5kbGUgdW5wYXJzYWJsZSBhdHRyaWJ1dGVzIChhdHRycz1mYWxzZSlcbiAgICAgIHZhciBhdHRycyA9IG9iai5hdHRycyB8fCB7fTtcblxuICAgICAgdmFyIGRlY29kZWRBdHRycyA9IE9iamVjdC5rZXlzKGF0dHJzKS5yZWR1Y2UoZnVuY3Rpb24oZCwga2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGRlY29kZVN0cihhdHRyc1trZXldKTtcblxuICAgICAgICBkW2tleV0gPSB2YWx1ZTtcblxuICAgICAgICByZXR1cm4gZDtcbiAgICAgIH0sIHt9KTtcblxuICAgICAgdmFyIG5vZGUgPSB7XG4gICAgICAgIG5hbWU6IG9iai5uYW1lLFxuICAgICAgICBvcmlnaW5hbE5hbWU6IG9iai5vcmlnaW5hbE5hbWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IGRlY29kZWRBdHRycyxcbiAgICAgICAgbnM6IG9iai5uc1xuICAgICAgfTtcblxuICAgICAgaGFuZGxlT3Blbihub2RlLCBnZXRDb250ZXh0KTtcbiAgICB9KVxuICAgIC5vbigncXVlc3Rpb24nLCBoYW5kbGVRdWVzdGlvbilcbiAgICAub24oJ2Nsb3NlVGFnJywgaGFuZGxlQ2xvc2UpXG4gICAgLm9uKCdjZGF0YScsIGhhbmRsZUNEYXRhKVxuICAgIC5vbigndGV4dCcsIGZ1bmN0aW9uKHRleHQsIGRlY29kZUVudGl0aWVzLCBnZXRDb250ZXh0KSB7XG4gICAgICBoYW5kbGVUZXh0KGRlY29kZUVudGl0aWVzKHRleHQpLCBnZXRDb250ZXh0KTtcbiAgICB9KVxuICAgIC5vbignZXJyb3InLCBoYW5kbGVFcnJvcilcbiAgICAub24oJ3dhcm4nLCBoYW5kbGVXYXJuaW5nKTtcblxuICAvLyBkZWZlcnJlZCBwYXJzZSBYTUwgdG8gbWFrZSBsb2FkaW5nIHJlYWxseSBhc2NuY2hyb25vdXNcbiAgLy8gdGhpcyBlbnN1cmVzIHRoZSBleGVjdXRpb24gZW52aXJvbm1lbnQgKG5vZGUgb3IgYnJvd3NlcilcbiAgLy8gaXMga2VwdCByZXNwb25zaXZlIGFuZCB0aGF0IGNlcnRhaW4gb3B0aW1pemF0aW9uIHN0cmF0ZWdpZXNcbiAgLy8gY2FuIGtpY2sgaW5cbiAgZGVmZXIoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGVycjtcblxuICAgIHRyeSB7XG4gICAgICBwYXJzZXIucGFyc2UoeG1sKTtcblxuICAgICAgcmVzb2x2ZVJlZmVyZW5jZXMoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnIgPSBlO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0gcm9vdEhhbmRsZXIuZWxlbWVudDtcblxuICAgIC8vIGhhbmRsZSB0aGUgc2l0dWF0aW9uIHRoYXQgd2UgY291bGQgbm90IGV4dHJhY3RcbiAgICAvLyB0aGUgZGVzaXJlZCByb290IGVsZW1lbnQgZnJvbSB0aGUgZG9jdW1lbnRcbiAgICBpZiAoIWVyciAmJiAhZWxlbWVudCkge1xuICAgICAgZXJyID0gZXJyb3IoJ2ZhaWxlZCB0byBwYXJzZSBkb2N1bWVudCBhcyA8JyArIHJvb3RIYW5kbGVyLnR5cGUuJGRlc2NyaXB0b3IubmFtZSArICc+Jyk7XG4gICAgfVxuXG4gICAgZG9uZShlcnIsIGVyciA/IHVuZGVmaW5lZCA6IGVsZW1lbnQsIGNvbnRleHQpO1xuICB9KTtcbn07XG5cblJlYWRlci5wcm90b3R5cGUuaGFuZGxlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBSb290RWxlbWVudEhhbmRsZXIodGhpcy5tb2RlbCwgbmFtZSk7XG59O1xuXG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gY3JlYXRlU3RhY2soKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdGFjaywgJ3BlZWsnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXNbdGhpcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBzdGFjaztcbn1cblxudmFyIFhNTF9QUkVBTUJMRSA9ICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiPz5cXG4nO1xuXG52YXIgRVNDQVBFX0FUVFJfQ0hBUlMgPSAvPHw+fCd8XCJ8JnxcXG5cXHJ8XFxuL2c7XG52YXIgRVNDQVBFX0NIQVJTID0gLzx8PnwmL2c7XG5cblxuZnVuY3Rpb24gTmFtZXNwYWNlcyhwYXJlbnQpIHtcblxuICB2YXIgcHJlZml4TWFwID0ge307XG4gIHZhciB1cmlNYXAgPSB7fTtcbiAgdmFyIHVzZWQgPSB7fTtcblxuICB2YXIgd2VsbGtub3duID0gW107XG4gIHZhciBjdXN0b20gPSBbXTtcblxuICAvLyBBUElcblxuICB0aGlzLmJ5VXJpID0gZnVuY3Rpb24odXJpKSB7XG4gICAgcmV0dXJuIHVyaU1hcFt1cmldIHx8IChcbiAgICAgIHBhcmVudCAmJiBwYXJlbnQuYnlVcmkodXJpKVxuICAgICk7XG4gIH07XG5cbiAgdGhpcy5hZGQgPSBmdW5jdGlvbihucywgaXNXZWxsa25vd24pIHtcblxuICAgIHVyaU1hcFtucy51cmldID0gbnM7XG5cbiAgICBpZiAoaXNXZWxsa25vd24pIHtcbiAgICAgIHdlbGxrbm93bi5wdXNoKG5zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VzdG9tLnB1c2gobnMpO1xuICAgIH1cblxuICAgIHRoaXMubWFwUHJlZml4KG5zLnByZWZpeCwgbnMudXJpKTtcbiAgfTtcblxuICB0aGlzLnVyaUJ5UHJlZml4ID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgcmV0dXJuIHByZWZpeE1hcFtwcmVmaXggfHwgJ3htbG5zJ107XG4gIH07XG5cbiAgdGhpcy5tYXBQcmVmaXggPSBmdW5jdGlvbihwcmVmaXgsIHVyaSkge1xuICAgIHByZWZpeE1hcFtwcmVmaXggfHwgJ3htbG5zJ10gPSB1cmk7XG4gIH07XG5cbiAgdGhpcy5sb2dVc2VkID0gZnVuY3Rpb24obnMpIHtcbiAgICB2YXIgdXJpID0gbnMudXJpO1xuXG4gICAgdXNlZFt1cmldID0gdGhpcy5ieVVyaSh1cmkpO1xuICB9O1xuXG4gIHRoaXMuZ2V0VXNlZCA9IGZ1bmN0aW9uKG5zKSB7XG5cbiAgICBmdW5jdGlvbiBpc1VzZWQobnMpIHtcbiAgICAgIHJldHVybiB1c2VkW25zLnVyaV07XG4gICAgfVxuXG4gICAgdmFyIGFsbE5zID0gW10uY29uY2F0KHdlbGxrbm93biwgY3VzdG9tKTtcblxuICAgIHJldHVybiBhbGxOcy5maWx0ZXIoaXNVc2VkKTtcbiAgfTtcblxufVxuXG5mdW5jdGlvbiBsb3dlcihzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbn1cblxuZnVuY3Rpb24gbmFtZVRvQWxpYXMobmFtZSwgcGtnKSB7XG4gIGlmIChoYXNMb3dlckNhc2VBbGlhcyhwa2cpKSB7XG4gICAgcmV0dXJuIGxvd2VyKG5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gbnNOYW1lKG5zKSB7XG4gIGlmIChpc1N0cmluZyhucykpIHtcbiAgICByZXR1cm4gbnM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChucy5wcmVmaXggPyBucy5wcmVmaXggKyAnOicgOiAnJykgKyBucy5sb2NhbE5hbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TnNBdHRycyhuYW1lc3BhY2VzKSB7XG5cbiAgcmV0dXJuIG1hcChuYW1lc3BhY2VzLmdldFVzZWQoKSwgZnVuY3Rpb24obnMpIHtcbiAgICB2YXIgbmFtZSA9ICd4bWxucycgKyAobnMucHJlZml4ID8gJzonICsgbnMucHJlZml4IDogJycpO1xuICAgIHJldHVybiB7IG5hbWU6IG5hbWUsIHZhbHVlOiBucy51cmkgfTtcbiAgfSk7XG5cbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudE5zKG5zLCBkZXNjcmlwdG9yKSB7XG4gIGlmIChkZXNjcmlwdG9yLmlzR2VuZXJpYykge1xuICAgIHJldHVybiBhc3NpZ24oeyBsb2NhbE5hbWU6IGRlc2NyaXB0b3IubnMubG9jYWxOYW1lIH0sIG5zKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXNzaWduKHsgbG9jYWxOYW1lOiBuYW1lVG9BbGlhcyhkZXNjcmlwdG9yLm5zLmxvY2FsTmFtZSwgZGVzY3JpcHRvci4kcGtnKSB9LCBucyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UHJvcGVydHlOcyhucywgZGVzY3JpcHRvcikge1xuICByZXR1cm4gYXNzaWduKHsgbG9jYWxOYW1lOiBkZXNjcmlwdG9yLm5zLmxvY2FsTmFtZSB9LCBucyk7XG59XG5cbmZ1bmN0aW9uIGdldFNlcmlhbGl6YWJsZVByb3BlcnRpZXMoZWxlbWVudCkge1xuICB2YXIgZGVzY3JpcHRvciA9IGVsZW1lbnQuJGRlc2NyaXB0b3I7XG5cbiAgcmV0dXJuIGZpbHRlcihkZXNjcmlwdG9yLnByb3BlcnRpZXMsIGZ1bmN0aW9uKHApIHtcbiAgICB2YXIgbmFtZSA9IHAubmFtZTtcblxuICAgIGlmIChwLmlzVmlydHVhbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGRvIG5vdCBzZXJpYWxpemUgZGVmYXVsdHNcbiAgICBpZiAoIWVsZW1lbnQuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBlbGVtZW50W25hbWVdO1xuXG4gICAgLy8gZG8gbm90IHNlcmlhbGl6ZSBkZWZhdWx0IGVxdWFsc1xuICAgIGlmICh2YWx1ZSA9PT0gcC5kZWZhdWx0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gZG8gbm90IHNlcmlhbGl6ZSBudWxsIHByb3BlcnRpZXNcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcC5pc01hbnkgPyB2YWx1ZS5sZW5ndGggOiB0cnVlO1xuICB9KTtcbn1cblxudmFyIEVTQ0FQRV9BVFRSX01BUCA9IHtcbiAgJ1xcbic6ICcjMTAnLFxuICAnXFxuXFxyJzogJyMxMCcsXG4gICdcIic6ICcjMzQnLFxuICAnXFwnJzogJyMzOScsXG4gICc8JzogJyM2MCcsXG4gICc+JzogJyM2MicsXG4gICcmJzogJyMzOCdcbn07XG5cbnZhciBFU0NBUEVfTUFQID0ge1xuICAnPCc6ICdsdCcsXG4gICc+JzogJ2d0JyxcbiAgJyYnOiAnYW1wJ1xufTtcblxuZnVuY3Rpb24gZXNjYXBlKHN0ciwgY2hhclBhdHRlcm4sIHJlcGxhY2VNYXApIHtcblxuICAvLyBlbnN1cmUgd2UgYXJlIGhhbmRsaW5nIHN0cmluZ3MgaGVyZVxuICBzdHIgPSBpc1N0cmluZyhzdHIpID8gc3RyIDogJycgKyBzdHI7XG5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNoYXJQYXR0ZXJuLCBmdW5jdGlvbihzKSB7XG4gICAgcmV0dXJuICcmJyArIHJlcGxhY2VNYXBbc10gKyAnOyc7XG4gIH0pO1xufVxuXG4vKipcbiAqIEVzY2FwZSBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gbm90IGNvbnRhaW4gYW55IGJhZCB2YWx1ZXMgKGxpbmUgYnJlYWtzLCAnXCInLCAuLi4pXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIGVzY2FwZVxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgZXNjYXBlZCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZXNjYXBlQXR0cihzdHIpIHtcbiAgcmV0dXJuIGVzY2FwZShzdHIsIEVTQ0FQRV9BVFRSX0NIQVJTLCBFU0NBUEVfQVRUUl9NQVApO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVCb2R5KHN0cikge1xuICByZXR1cm4gZXNjYXBlKHN0ciwgRVNDQVBFX0NIQVJTLCBFU0NBUEVfTUFQKTtcbn1cblxuZnVuY3Rpb24gZmlsdGVyQXR0cmlidXRlcyhwcm9wcykge1xuICByZXR1cm4gZmlsdGVyKHByb3BzLCBmdW5jdGlvbihwKSB7IHJldHVybiBwLmlzQXR0cjsgfSk7XG59XG5cbmZ1bmN0aW9uIGZpbHRlckNvbnRhaW5lZChwcm9wcykge1xuICByZXR1cm4gZmlsdGVyKHByb3BzLCBmdW5jdGlvbihwKSB7IHJldHVybiAhcC5pc0F0dHI7IH0pO1xufVxuXG5cbmZ1bmN0aW9uIFJlZmVyZW5jZVNlcmlhbGl6ZXIodGFnTmFtZSkge1xuICB0aGlzLnRhZ05hbWUgPSB0YWdOYW1lO1xufVxuXG5SZWZlcmVuY2VTZXJpYWxpemVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZWZlcmVuY2VTZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemVUbyA9IGZ1bmN0aW9uKHdyaXRlcikge1xuICB3cml0ZXJcbiAgICAuYXBwZW5kSW5kZW50KClcbiAgICAuYXBwZW5kKCc8JyArIHRoaXMudGFnTmFtZSArICc+JyArIHRoaXMuZWxlbWVudC5pZCArICc8LycgKyB0aGlzLnRhZ05hbWUgKyAnPicpXG4gICAgLmFwcGVuZE5ld0xpbmUoKTtcbn07XG5cbmZ1bmN0aW9uIEJvZHlTZXJpYWxpemVyKCkge31cblxuQm9keVNlcmlhbGl6ZXIucHJvdG90eXBlLnNlcmlhbGl6ZVZhbHVlID1cbkJvZHlTZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemVUbyA9IGZ1bmN0aW9uKHdyaXRlcikge1xuICB3cml0ZXIuYXBwZW5kKFxuICAgIHRoaXMuZXNjYXBlXG4gICAgICA/IGVzY2FwZUJvZHkodGhpcy52YWx1ZSlcbiAgICAgIDogdGhpcy52YWx1ZVxuICApO1xufTtcblxuQm9keVNlcmlhbGl6ZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24ocHJvcCwgdmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuXG4gIGlmIChwcm9wLnR5cGUgPT09ICdTdHJpbmcnICYmIHZhbHVlLnNlYXJjaChFU0NBUEVfQ0hBUlMpICE9PSAtMSkge1xuICAgIHRoaXMuZXNjYXBlID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gVmFsdWVTZXJpYWxpemVyKHRhZ05hbWUpIHtcbiAgdGhpcy50YWdOYW1lID0gdGFnTmFtZTtcbn1cblxuaW5oZXJpdHMoVmFsdWVTZXJpYWxpemVyLCBCb2R5U2VyaWFsaXplcik7XG5cblZhbHVlU2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplVG8gPSBmdW5jdGlvbih3cml0ZXIpIHtcblxuICB3cml0ZXJcbiAgICAuYXBwZW5kSW5kZW50KClcbiAgICAuYXBwZW5kKCc8JyArIHRoaXMudGFnTmFtZSArICc+Jyk7XG5cbiAgdGhpcy5zZXJpYWxpemVWYWx1ZSh3cml0ZXIpO1xuXG4gIHdyaXRlclxuICAgIC5hcHBlbmQoJzwvJyArIHRoaXMudGFnTmFtZSArICc+JylcbiAgICAuYXBwZW5kTmV3TGluZSgpO1xufTtcblxuZnVuY3Rpb24gRWxlbWVudFNlcmlhbGl6ZXIocGFyZW50LCBwcm9wZXJ0eURlc2NyaXB0b3IpIHtcbiAgdGhpcy5ib2R5ID0gW107XG4gIHRoaXMuYXR0cnMgPSBbXTtcblxuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5wcm9wZXJ0eURlc2NyaXB0b3IgPSBwcm9wZXJ0eURlc2NyaXB0b3I7XG59XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcblxuICB2YXIgZWxlbWVudERlc2NyaXB0b3IgPSBlbGVtZW50LiRkZXNjcmlwdG9yLFxuICAgICAgcHJvcGVydHlEZXNjcmlwdG9yID0gdGhpcy5wcm9wZXJ0eURlc2NyaXB0b3I7XG5cbiAgdmFyIG90aGVyQXR0cnMsXG4gICAgICBwcm9wZXJ0aWVzO1xuXG4gIHZhciBpc0dlbmVyaWMgPSBlbGVtZW50RGVzY3JpcHRvci5pc0dlbmVyaWM7XG5cbiAgaWYgKGlzR2VuZXJpYykge1xuICAgIG90aGVyQXR0cnMgPSB0aGlzLnBhcnNlR2VuZXJpYyhlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICBvdGhlckF0dHJzID0gdGhpcy5wYXJzZU5zQXR0cmlidXRlcyhlbGVtZW50KTtcbiAgfVxuXG4gIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IpIHtcbiAgICB0aGlzLm5zID0gdGhpcy5uc1Byb3BlcnR5VGFnTmFtZShwcm9wZXJ0eURlc2NyaXB0b3IpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubnMgPSB0aGlzLm5zVGFnTmFtZShlbGVtZW50RGVzY3JpcHRvcik7XG4gIH1cblxuICAvLyBjb21wdXRlIHRhZyBuYW1lXG4gIHRoaXMudGFnTmFtZSA9IHRoaXMuYWRkVGFnTmFtZSh0aGlzLm5zKTtcblxuICBpZiAoIWlzR2VuZXJpYykge1xuICAgIHByb3BlcnRpZXMgPSBnZXRTZXJpYWxpemFibGVQcm9wZXJ0aWVzKGVsZW1lbnQpO1xuXG4gICAgdGhpcy5wYXJzZUF0dHJpYnV0ZXMoZmlsdGVyQXR0cmlidXRlcyhwcm9wZXJ0aWVzKSk7XG4gICAgdGhpcy5wYXJzZUNvbnRhaW5tZW50cyhmaWx0ZXJDb250YWluZWQocHJvcGVydGllcykpO1xuICB9XG5cbiAgdGhpcy5wYXJzZUdlbmVyaWNBdHRyaWJ1dGVzKGVsZW1lbnQsIG90aGVyQXR0cnMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLm5zVGFnTmFtZSA9IGZ1bmN0aW9uKGRlc2NyaXB0b3IpIHtcbiAgdmFyIGVmZmVjdGl2ZU5zID0gdGhpcy5sb2dOYW1lc3BhY2VVc2VkKGRlc2NyaXB0b3IubnMpO1xuICByZXR1cm4gZ2V0RWxlbWVudE5zKGVmZmVjdGl2ZU5zLCBkZXNjcmlwdG9yKTtcbn07XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5uc1Byb3BlcnR5VGFnTmFtZSA9IGZ1bmN0aW9uKGRlc2NyaXB0b3IpIHtcbiAgdmFyIGVmZmVjdGl2ZU5zID0gdGhpcy5sb2dOYW1lc3BhY2VVc2VkKGRlc2NyaXB0b3IubnMpO1xuICByZXR1cm4gZ2V0UHJvcGVydHlOcyhlZmZlY3RpdmVOcywgZGVzY3JpcHRvcik7XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUuaXNMb2NhbE5zID0gZnVuY3Rpb24obnMpIHtcbiAgcmV0dXJuIG5zLnVyaSA9PT0gdGhpcy5ucy51cmk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYWN0dWFsIG5zIGF0dHJpYnV0ZSBuYW1lIGZvciB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudFxuICogQHBhcmFtIHtCb29sZWFufSBbZWxlbWVudC5pbmhlcml0ZWQ9ZmFsc2VdXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBuc05hbWVcbiAqL1xuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLm5zQXR0cmlidXRlTmFtZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICB2YXIgbnM7XG5cbiAgaWYgKGlzU3RyaW5nKGVsZW1lbnQpKSB7XG4gICAgbnMgPSBwYXJzZU5hbWVOUyhlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICBucyA9IGVsZW1lbnQubnM7XG4gIH1cblxuICAvLyByZXR1cm4ganVzdCBsb2NhbCBuYW1lIGZvciBpbmhlcml0ZWQgYXR0cmlidXRlc1xuICBpZiAoZWxlbWVudC5pbmhlcml0ZWQpIHtcbiAgICByZXR1cm4geyBsb2NhbE5hbWU6IG5zLmxvY2FsTmFtZSB9O1xuICB9XG5cbiAgLy8gcGFyc2UgKyBsb2cgZWZmZWN0aXZlIG5zXG4gIHZhciBlZmZlY3RpdmVOcyA9IHRoaXMubG9nTmFtZXNwYWNlVXNlZChucyk7XG5cbiAgLy8gTE9HIEFDVFVBTCBuYW1lc3BhY2UgdXNlXG4gIHRoaXMuZ2V0TmFtZXNwYWNlcygpLmxvZ1VzZWQoZWZmZWN0aXZlTnMpO1xuXG4gIC8vIHN0cmlwIHByZWZpeCBpZiBzYW1lIG5hbWVzcGFjZSBsaWtlIHBhcmVudFxuICBpZiAodGhpcy5pc0xvY2FsTnMoZWZmZWN0aXZlTnMpKSB7XG4gICAgcmV0dXJuIHsgbG9jYWxOYW1lOiBucy5sb2NhbE5hbWUgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXNzaWduKHsgbG9jYWxOYW1lOiBucy5sb2NhbE5hbWUgfSwgZWZmZWN0aXZlTnMpO1xuICB9XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUucGFyc2VHZW5lcmljID0gZnVuY3Rpb24oZWxlbWVudCkge1xuXG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIGJvZHkgPSB0aGlzLmJvZHk7XG5cbiAgdmFyIGF0dHJpYnV0ZXMgPSBbXTtcblxuICBmb3JFYWNoKGVsZW1lbnQsIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG5cbiAgICB2YXIgbm9uTnNBdHRyO1xuXG4gICAgaWYgKGtleSA9PT0gJyRib2R5Jykge1xuICAgICAgYm9keS5wdXNoKG5ldyBCb2R5U2VyaWFsaXplcigpLmJ1aWxkKHsgdHlwZTogJ1N0cmluZycgfSwgdmFsKSk7XG4gICAgfSBlbHNlXG4gICAgaWYgKGtleSA9PT0gJyRjaGlsZHJlbicpIHtcbiAgICAgIGZvckVhY2godmFsLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICBib2R5LnB1c2gobmV3IEVsZW1lbnRTZXJpYWxpemVyKHNlbGYpLmJ1aWxkKGNoaWxkKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2VcbiAgICBpZiAoa2V5LmluZGV4T2YoJyQnKSAhPT0gMCkge1xuICAgICAgbm9uTnNBdHRyID0gc2VsZi5wYXJzZU5zQXR0cmlidXRlKGVsZW1lbnQsIGtleSwgdmFsKTtcblxuICAgICAgaWYgKG5vbk5zQXR0cikge1xuICAgICAgICBhdHRyaWJ1dGVzLnB1c2goeyBuYW1lOiBrZXksIHZhbHVlOiB2YWwgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gYXR0cmlidXRlcztcbn07XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5wYXJzZU5zQXR0cmlidXRlID0gZnVuY3Rpb24oZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIG1vZGVsID0gZWxlbWVudC4kbW9kZWw7XG5cbiAgdmFyIG5hbWVOcyA9IHBhcnNlTmFtZU5TKG5hbWUpO1xuXG4gIHZhciBucztcblxuICAvLyBwYXJzZSB4bWxuczpmb289XCJodHRwOi8vZm9vLmJhclwiXG4gIGlmIChuYW1lTnMucHJlZml4ID09PSAneG1sbnMnKSB7XG4gICAgbnMgPSB7IHByZWZpeDogbmFtZU5zLmxvY2FsTmFtZSwgdXJpOiB2YWx1ZSB9O1xuICB9XG5cbiAgLy8gcGFyc2UgeG1sbnM9XCJodHRwOi8vZm9vLmJhclwiXG4gIGlmICghbmFtZU5zLnByZWZpeCAmJiBuYW1lTnMubG9jYWxOYW1lID09PSAneG1sbnMnKSB7XG4gICAgbnMgPSB7IHVyaTogdmFsdWUgfTtcbiAgfVxuXG4gIGlmICghbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH07XG4gIH1cblxuICBpZiAobW9kZWwgJiYgbW9kZWwuZ2V0UGFja2FnZSh2YWx1ZSkpIHtcbiAgICAvLyByZWdpc3RlciB3ZWxsIGtub3duIG5hbWVzcGFjZVxuICAgIHRoaXMubG9nTmFtZXNwYWNlKG5zLCB0cnVlLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBsb2cgY3VzdG9tIG5hbWVzcGFjZSBkaXJlY3RseSBhcyB1c2VkXG4gICAgdmFyIGFjdHVhbE5zID0gdGhpcy5sb2dOYW1lc3BhY2VVc2VkKG5zLCB0cnVlKTtcblxuICAgIHRoaXMuZ2V0TmFtZXNwYWNlcygpLmxvZ1VzZWQoYWN0dWFsTnMpO1xuICB9XG59O1xuXG5cbi8qKlxuICogUGFyc2UgbmFtZXNwYWNlcyBhbmQgcmV0dXJuIGEgbGlzdCBvZiBsZWZ0IG92ZXIgZ2VuZXJpYyBhdHRyaWJ1dGVzXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtBcnJheTxPYmplY3Q+fVxuICovXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUucGFyc2VOc0F0dHJpYnV0ZXMgPSBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIGdlbmVyaWNBdHRycyA9IGVsZW1lbnQuJGF0dHJzO1xuXG4gIHZhciBhdHRyaWJ1dGVzID0gW107XG5cbiAgLy8gcGFyc2UgbmFtZXNwYWNlIGF0dHJpYnV0ZXMgZmlyc3RcbiAgLy8gYW5kIGxvZyB0aGVtLiBwdXNoIG5vbiBuYW1lc3BhY2UgYXR0cmlidXRlcyB0byBhIGxpc3RcbiAgLy8gYW5kIHByb2Nlc3MgdGhlbSBsYXRlclxuICBmb3JFYWNoKGdlbmVyaWNBdHRycywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcblxuICAgIHZhciBub25Oc0F0dHIgPSBzZWxmLnBhcnNlTnNBdHRyaWJ1dGUoZWxlbWVudCwgbmFtZSwgdmFsdWUpO1xuXG4gICAgaWYgKG5vbk5zQXR0cikge1xuICAgICAgYXR0cmlidXRlcy5wdXNoKG5vbk5zQXR0cik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gYXR0cmlidXRlcztcbn07XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5wYXJzZUdlbmVyaWNBdHRyaWJ1dGVzID0gZnVuY3Rpb24oZWxlbWVudCwgYXR0cmlidXRlcykge1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmb3JFYWNoKGF0dHJpYnV0ZXMsIGZ1bmN0aW9uKGF0dHIpIHtcblxuICAgIC8vIGRvIG5vdCBzZXJpYWxpemUgeHNpOnR5cGUgYXR0cmlidXRlXG4gICAgLy8gaXQgaXMgc2V0IG1hbnVhbGx5IGJhc2VkIG9uIHRoZSBhY3R1YWwgaW1wbGVtZW50YXRpb24gdHlwZVxuICAgIGlmIChhdHRyLm5hbWUgPT09IFhTSV9UWVBFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHNlbGYuYWRkQXR0cmlidXRlKHNlbGYubnNBdHRyaWJ1dGVOYW1lKGF0dHIubmFtZSksIGF0dHIudmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ21pc3NpbmcgbmFtZXNwYWNlIGluZm9ybWF0aW9uIGZvciAnLFxuICAgICAgICBhdHRyLm5hbWUsICc9JywgYXR0ci52YWx1ZSwgJ29uJywgZWxlbWVudCxcbiAgICAgICAgZSk7XG4gICAgfVxuICB9KTtcbn07XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5wYXJzZUNvbnRhaW5tZW50cyA9IGZ1bmN0aW9uKHByb3BlcnRpZXMpIHtcblxuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICBib2R5ID0gdGhpcy5ib2R5LFxuICAgICAgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblxuICBmb3JFYWNoKHByb3BlcnRpZXMsIGZ1bmN0aW9uKHApIHtcbiAgICB2YXIgdmFsdWUgPSBlbGVtZW50LmdldChwLm5hbWUpLFxuICAgICAgICBpc1JlZmVyZW5jZSA9IHAuaXNSZWZlcmVuY2UsXG4gICAgICAgIGlzTWFueSA9IHAuaXNNYW55O1xuXG4gICAgaWYgKCFpc01hbnkpIHtcbiAgICAgIHZhbHVlID0gWyB2YWx1ZSBdO1xuICAgIH1cblxuICAgIGlmIChwLmlzQm9keSkge1xuICAgICAgYm9keS5wdXNoKG5ldyBCb2R5U2VyaWFsaXplcigpLmJ1aWxkKHAsIHZhbHVlWzBdKSk7XG4gICAgfSBlbHNlXG4gICAgaWYgKGlzU2ltcGxlVHlwZShwLnR5cGUpKSB7XG4gICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbih2KSB7XG4gICAgICAgIGJvZHkucHVzaChuZXcgVmFsdWVTZXJpYWxpemVyKHNlbGYuYWRkVGFnTmFtZShzZWxmLm5zUHJvcGVydHlUYWdOYW1lKHApKSkuYnVpbGQocCwgdikpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlXG4gICAgaWYgKGlzUmVmZXJlbmNlKSB7XG4gICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbih2KSB7XG4gICAgICAgIGJvZHkucHVzaChuZXcgUmVmZXJlbmNlU2VyaWFsaXplcihzZWxmLmFkZFRhZ05hbWUoc2VsZi5uc1Byb3BlcnR5VGFnTmFtZShwKSkpLmJ1aWxkKHYpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhbGxvdyBzZXJpYWxpemF0aW9uIHZpYSB0eXBlXG4gICAgICAvLyByYXRoZXIgdGhhbiBlbGVtZW50IG5hbWVcbiAgICAgIHZhciBhc1R5cGUgPSBzZXJpYWxpemVBc1R5cGUocCksXG4gICAgICAgICAgYXNQcm9wZXJ0eSA9IHNlcmlhbGl6ZUFzUHJvcGVydHkocCk7XG5cbiAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgdmFyIHNlcmlhbGl6ZXI7XG5cbiAgICAgICAgaWYgKGFzVHlwZSkge1xuICAgICAgICAgIHNlcmlhbGl6ZXIgPSBuZXcgVHlwZVNlcmlhbGl6ZXIoc2VsZiwgcCk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICBpZiAoYXNQcm9wZXJ0eSkge1xuICAgICAgICAgIHNlcmlhbGl6ZXIgPSBuZXcgRWxlbWVudFNlcmlhbGl6ZXIoc2VsZiwgcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VyaWFsaXplciA9IG5ldyBFbGVtZW50U2VyaWFsaXplcihzZWxmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJvZHkucHVzaChzZXJpYWxpemVyLmJ1aWxkKHYpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUuZ2V0TmFtZXNwYWNlcyA9IGZ1bmN0aW9uKGxvY2FsKSB7XG5cbiAgdmFyIG5hbWVzcGFjZXMgPSB0aGlzLm5hbWVzcGFjZXMsXG4gICAgICBwYXJlbnQgPSB0aGlzLnBhcmVudCxcbiAgICAgIHBhcmVudE5hbWVzcGFjZXM7XG5cbiAgaWYgKCFuYW1lc3BhY2VzKSB7XG4gICAgcGFyZW50TmFtZXNwYWNlcyA9IHBhcmVudCAmJiBwYXJlbnQuZ2V0TmFtZXNwYWNlcygpO1xuXG4gICAgaWYgKGxvY2FsIHx8ICFwYXJlbnROYW1lc3BhY2VzKSB7XG4gICAgICB0aGlzLm5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzID0gbmV3IE5hbWVzcGFjZXMocGFyZW50TmFtZXNwYWNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWVzcGFjZXMgPSBwYXJlbnROYW1lc3BhY2VzO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lc3BhY2VzO1xufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLmxvZ05hbWVzcGFjZSA9IGZ1bmN0aW9uKG5zLCB3ZWxsa25vd24sIGxvY2FsKSB7XG4gIHZhciBuYW1lc3BhY2VzID0gdGhpcy5nZXROYW1lc3BhY2VzKGxvY2FsKTtcblxuICB2YXIgbnNVcmkgPSBucy51cmksXG4gICAgICBuc1ByZWZpeCA9IG5zLnByZWZpeDtcblxuICB2YXIgZXhpc3RpbmcgPSBuYW1lc3BhY2VzLmJ5VXJpKG5zVXJpKTtcblxuICBpZiAoIWV4aXN0aW5nKSB7XG4gICAgbmFtZXNwYWNlcy5hZGQobnMsIHdlbGxrbm93bik7XG4gIH1cblxuICBuYW1lc3BhY2VzLm1hcFByZWZpeChuc1ByZWZpeCwgbnNVcmkpO1xuXG4gIHJldHVybiBucztcbn07XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5sb2dOYW1lc3BhY2VVc2VkID0gZnVuY3Rpb24obnMsIGxvY2FsKSB7XG4gIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgbW9kZWwgPSBlbGVtZW50LiRtb2RlbCxcbiAgICAgIG5hbWVzcGFjZXMgPSB0aGlzLmdldE5hbWVzcGFjZXMobG9jYWwpO1xuXG4gIC8vIG5zIG1heSBiZVxuICAvL1xuICAvLyAgICogcHJlZml4IG9ubHlcbiAgLy8gICAqIHByZWZpeDp1cmlcbiAgLy8gICAqIGxvY2FsTmFtZSBvbmx5XG5cbiAgdmFyIHByZWZpeCA9IG5zLnByZWZpeCxcbiAgICAgIHVyaSA9IG5zLnVyaSxcbiAgICAgIG5ld1ByZWZpeCwgaWR4LFxuICAgICAgd2VsbGtub3duVXJpO1xuXG4gIC8vIGhhbmRsZSBhbm9ueW1vdXMgbmFtZXNwYWNlcyAoZWxlbWVudEZvcm09dW5xdWFsaWZpZWQpLCBjZi4gIzIzXG4gIGlmICghcHJlZml4ICYmICF1cmkpIHtcbiAgICByZXR1cm4geyBsb2NhbE5hbWU6IG5zLmxvY2FsTmFtZSB9O1xuICB9XG5cbiAgd2VsbGtub3duVXJpID0gREVGQVVMVF9OU19NQVBbcHJlZml4XSB8fCBtb2RlbCAmJiAobW9kZWwuZ2V0UGFja2FnZShwcmVmaXgpIHx8IHt9KS51cmk7XG5cbiAgdXJpID0gdXJpIHx8IHdlbGxrbm93blVyaSB8fCBuYW1lc3BhY2VzLnVyaUJ5UHJlZml4KHByZWZpeCk7XG5cbiAgaWYgKCF1cmkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIG5hbWVzcGFjZSB1cmkgZ2l2ZW4gZm9yIHByZWZpeCA8JyArIHByZWZpeCArICc+Jyk7XG4gIH1cblxuICBucyA9IG5hbWVzcGFjZXMuYnlVcmkodXJpKTtcblxuICBpZiAoIW5zKSB7XG4gICAgbmV3UHJlZml4ID0gcHJlZml4O1xuICAgIGlkeCA9IDE7XG5cbiAgICAvLyBmaW5kIGEgcHJlZml4IHRoYXQgaXMgbm90IG1hcHBlZCB5ZXRcbiAgICB3aGlsZSAobmFtZXNwYWNlcy51cmlCeVByZWZpeChuZXdQcmVmaXgpKSB7XG4gICAgICBuZXdQcmVmaXggPSBwcmVmaXggKyAnXycgKyBpZHgrKztcbiAgICB9XG5cbiAgICBucyA9IHRoaXMubG9nTmFtZXNwYWNlKHsgcHJlZml4OiBuZXdQcmVmaXgsIHVyaTogdXJpIH0sIHdlbGxrbm93blVyaSA9PT0gdXJpKTtcbiAgfVxuXG4gIGlmIChwcmVmaXgpIHtcbiAgICBuYW1lc3BhY2VzLm1hcFByZWZpeChwcmVmaXgsIHVyaSk7XG4gIH1cblxuICByZXR1cm4gbnM7XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUucGFyc2VBdHRyaWJ1dGVzID0gZnVuY3Rpb24ocHJvcGVydGllcykge1xuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXG4gIGZvckVhY2gocHJvcGVydGllcywgZnVuY3Rpb24ocCkge1xuXG4gICAgdmFyIHZhbHVlID0gZWxlbWVudC5nZXQocC5uYW1lKTtcblxuICAgIGlmIChwLmlzUmVmZXJlbmNlKSB7XG5cbiAgICAgIGlmICghcC5pc01hbnkpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5pZDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB2YWx1ZXMucHVzaCh2LmlkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElEUkVGUyBpcyBhIHdoaXRlc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2YgcmVmZXJlbmNlcy5cbiAgICAgICAgdmFsdWUgPSB2YWx1ZXMuam9pbignICcpO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgc2VsZi5hZGRBdHRyaWJ1dGUoc2VsZi5uc0F0dHJpYnV0ZU5hbWUocCksIHZhbHVlKTtcbiAgfSk7XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUuYWRkVGFnTmFtZSA9IGZ1bmN0aW9uKG5zVGFnTmFtZSkge1xuICB2YXIgYWN0dWFsTnMgPSB0aGlzLmxvZ05hbWVzcGFjZVVzZWQobnNUYWdOYW1lKTtcblxuICB0aGlzLmdldE5hbWVzcGFjZXMoKS5sb2dVc2VkKGFjdHVhbE5zKTtcblxuICByZXR1cm4gbnNOYW1lKG5zVGFnTmFtZSk7XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUuYWRkQXR0cmlidXRlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGF0dHJzID0gdGhpcy5hdHRycztcblxuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFsdWUgPSBlc2NhcGVBdHRyKHZhbHVlKTtcbiAgfVxuXG4gIGF0dHJzLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplQXR0cmlidXRlcyA9IGZ1bmN0aW9uKHdyaXRlcikge1xuICB2YXIgYXR0cnMgPSB0aGlzLmF0dHJzLFxuICAgICAgbmFtZXNwYWNlcyA9IHRoaXMubmFtZXNwYWNlcztcblxuICBpZiAobmFtZXNwYWNlcykge1xuICAgIGF0dHJzID0gZ2V0TnNBdHRycyhuYW1lc3BhY2VzKS5jb25jYXQoYXR0cnMpO1xuICB9XG5cbiAgZm9yRWFjaChhdHRycywgZnVuY3Rpb24oYSkge1xuICAgIHdyaXRlclxuICAgICAgLmFwcGVuZCgnICcpXG4gICAgICAuYXBwZW5kKG5zTmFtZShhLm5hbWUpKS5hcHBlbmQoJz1cIicpLmFwcGVuZChhLnZhbHVlKS5hcHBlbmQoJ1wiJyk7XG4gIH0pO1xufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLnNlcmlhbGl6ZVRvID0gZnVuY3Rpb24od3JpdGVyKSB7XG4gIHZhciBmaXJzdEJvZHkgPSB0aGlzLmJvZHlbMF0sXG4gICAgICBpbmRlbnQgPSBmaXJzdEJvZHkgJiYgZmlyc3RCb2R5LmNvbnN0cnVjdG9yICE9PSBCb2R5U2VyaWFsaXplcjtcblxuICB3cml0ZXJcbiAgICAuYXBwZW5kSW5kZW50KClcbiAgICAuYXBwZW5kKCc8JyArIHRoaXMudGFnTmFtZSk7XG5cbiAgdGhpcy5zZXJpYWxpemVBdHRyaWJ1dGVzKHdyaXRlcik7XG5cbiAgd3JpdGVyLmFwcGVuZChmaXJzdEJvZHkgPyAnPicgOiAnIC8+Jyk7XG5cbiAgaWYgKGZpcnN0Qm9keSkge1xuXG4gICAgaWYgKGluZGVudCkge1xuICAgICAgd3JpdGVyXG4gICAgICAgIC5hcHBlbmROZXdMaW5lKClcbiAgICAgICAgLmluZGVudCgpO1xuICAgIH1cblxuICAgIGZvckVhY2godGhpcy5ib2R5LCBmdW5jdGlvbihiKSB7XG4gICAgICBiLnNlcmlhbGl6ZVRvKHdyaXRlcik7XG4gICAgfSk7XG5cbiAgICBpZiAoaW5kZW50KSB7XG4gICAgICB3cml0ZXJcbiAgICAgICAgLnVuaW5kZW50KClcbiAgICAgICAgLmFwcGVuZEluZGVudCgpO1xuICAgIH1cblxuICAgIHdyaXRlci5hcHBlbmQoJzwvJyArIHRoaXMudGFnTmFtZSArICc+Jyk7XG4gIH1cblxuICB3cml0ZXIuYXBwZW5kTmV3TGluZSgpO1xufTtcblxuLyoqXG4gKiBBIHNlcmlhbGl6ZXIgZm9yIHR5cGVzIHRoYXQgaGFuZGxlcyBzZXJpYWxpemF0aW9uIG9mIGRhdGEgdHlwZXNcbiAqL1xuZnVuY3Rpb24gVHlwZVNlcmlhbGl6ZXIocGFyZW50LCBwcm9wZXJ0eURlc2NyaXB0b3IpIHtcbiAgRWxlbWVudFNlcmlhbGl6ZXIuY2FsbCh0aGlzLCBwYXJlbnQsIHByb3BlcnR5RGVzY3JpcHRvcik7XG59XG5cbmluaGVyaXRzKFR5cGVTZXJpYWxpemVyLCBFbGVtZW50U2VyaWFsaXplcik7XG5cblR5cGVTZXJpYWxpemVyLnByb3RvdHlwZS5wYXJzZU5zQXR0cmlidXRlcyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICAvLyBleHRyYWN0ZWQgYXR0cmlidXRlc1xuICB2YXIgYXR0cmlidXRlcyA9IEVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5wYXJzZU5zQXR0cmlidXRlcy5jYWxsKHRoaXMsIGVsZW1lbnQpO1xuXG4gIHZhciBkZXNjcmlwdG9yID0gZWxlbWVudC4kZGVzY3JpcHRvcjtcblxuICAvLyBvbmx5IHNlcmlhbGl6ZSB4c2k6dHlwZSBpZiBuZWNlc3NhcnlcbiAgaWYgKGRlc2NyaXB0b3IubmFtZSA9PT0gdGhpcy5wcm9wZXJ0eURlc2NyaXB0b3IudHlwZSkge1xuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICB9XG5cbiAgdmFyIHR5cGVOcyA9IHRoaXMudHlwZU5zID0gdGhpcy5uc1RhZ05hbWUoZGVzY3JpcHRvcik7XG4gIHRoaXMuZ2V0TmFtZXNwYWNlcygpLmxvZ1VzZWQodGhpcy50eXBlTnMpO1xuXG4gIC8vIGFkZCB4c2k6dHlwZSBhdHRyaWJ1dGUgdG8gcmVwcmVzZW50IHRoZSBlbGVtZW50c1xuICAvLyBhY3R1YWwgdHlwZVxuXG4gIHZhciBwa2cgPSBlbGVtZW50LiRtb2RlbC5nZXRQYWNrYWdlKHR5cGVOcy51cmkpLFxuICAgICAgdHlwZVByZWZpeCA9IChwa2cueG1sICYmIHBrZy54bWwudHlwZVByZWZpeCkgfHwgJyc7XG5cbiAgdGhpcy5hZGRBdHRyaWJ1dGUoXG4gICAgdGhpcy5uc0F0dHJpYnV0ZU5hbWUoWFNJX1RZUEUpLFxuICAgICh0eXBlTnMucHJlZml4ID8gdHlwZU5zLnByZWZpeCArICc6JyA6ICcnKSArIHR5cGVQcmVmaXggKyBkZXNjcmlwdG9yLm5zLmxvY2FsTmFtZVxuICApO1xuXG4gIHJldHVybiBhdHRyaWJ1dGVzO1xufTtcblxuVHlwZVNlcmlhbGl6ZXIucHJvdG90eXBlLmlzTG9jYWxOcyA9IGZ1bmN0aW9uKG5zKSB7XG4gIHJldHVybiBucy51cmkgPT09ICh0aGlzLnR5cGVOcyB8fCB0aGlzLm5zKS51cmk7XG59O1xuXG5mdW5jdGlvbiBTYXZpbmdXcml0ZXIoKSB7XG4gIHRoaXMudmFsdWUgPSAnJztcblxuICB0aGlzLndyaXRlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgdGhpcy52YWx1ZSArPSBzdHI7XG4gIH07XG59XG5cbmZ1bmN0aW9uIEZvcm1hdGluZ1dyaXRlcihvdXQsIGZvcm1hdCkge1xuXG4gIHZhciBpbmRlbnQgPSBbJyddO1xuXG4gIHRoaXMuYXBwZW5kID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgb3V0LndyaXRlKHN0cik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB0aGlzLmFwcGVuZE5ld0xpbmUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICBvdXQud3JpdGUoJ1xcbicpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHRoaXMuYXBwZW5kSW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgb3V0LndyaXRlKGluZGVudC5qb2luKCcgICcpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB0aGlzLmluZGVudCA9IGZ1bmN0aW9uKCkge1xuICAgIGluZGVudC5wdXNoKCcnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB0aGlzLnVuaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgaW5kZW50LnBvcCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG4vKipcbiAqIEEgd3JpdGVyIGZvciBtZXRhLW1vZGVsIGJhY2tlZCBkb2N1bWVudCB0cmVlc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG91dHB1dCBvcHRpb25zIHRvIHBhc3MgaW50byB0aGUgd3JpdGVyXG4gKi9cbmZ1bmN0aW9uIFdyaXRlcihvcHRpb25zKSB7XG5cbiAgb3B0aW9ucyA9IGFzc2lnbih7IGZvcm1hdDogZmFsc2UsIHByZWFtYmxlOiB0cnVlIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIGZ1bmN0aW9uIHRvWE1MKHRyZWUsIHdyaXRlcikge1xuICAgIHZhciBpbnRlcm5hbFdyaXRlciA9IHdyaXRlciB8fCBuZXcgU2F2aW5nV3JpdGVyKCk7XG4gICAgdmFyIGZvcm1hdGluZ1dyaXRlciA9IG5ldyBGb3JtYXRpbmdXcml0ZXIoaW50ZXJuYWxXcml0ZXIsIG9wdGlvbnMuZm9ybWF0KTtcblxuICAgIGlmIChvcHRpb25zLnByZWFtYmxlKSB7XG4gICAgICBmb3JtYXRpbmdXcml0ZXIuYXBwZW5kKFhNTF9QUkVBTUJMRSk7XG4gICAgfVxuXG4gICAgbmV3IEVsZW1lbnRTZXJpYWxpemVyKCkuYnVpbGQodHJlZSkuc2VyaWFsaXplVG8oZm9ybWF0aW5nV3JpdGVyKTtcblxuICAgIGlmICghd3JpdGVyKSB7XG4gICAgICByZXR1cm4gaW50ZXJuYWxXcml0ZXIudmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b1hNTDogdG9YTUxcbiAgfTtcbn1cblxuZXhwb3J0IHsgUmVhZGVyLCBXcml0ZXIgfTtcbiIsInZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgRU5USVRZX1BBVFRFUk4gPSAvJiMoXFxkKyk7fCYjeChbMC05YS1mXSspO3wmKFxcdyspOy9pZztcblxudmFyIEVOVElUWV9NQVBQSU5HID0ge1xuICAnYW1wJzogJyYnLFxuICAnYXBvcyc6ICdcXCcnLFxuICAnZ3QnOiAnPicsXG4gICdsdCc6ICc8JyxcbiAgJ3F1b3QnOiAnXCInXG59O1xuXG4vLyBtYXAgVVBQRVJDQVNFIHZhcmlhbnRzIG9mIHN1cHBvcnRlZCBzcGVjaWFsIGNoYXJzXG5PYmplY3Qua2V5cyhFTlRJVFlfTUFQUElORykuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gIEVOVElUWV9NQVBQSU5HW2sudG9VcHBlckNhc2UoKV0gPSBFTlRJVFlfTUFQUElOR1trXTtcbn0pO1xuXG5cbmZ1bmN0aW9uIHJlcGxhY2VFbnRpdGllcyhfLCBkLCB4LCB6KSB7XG5cbiAgLy8gcmVzZXJ2ZWQgbmFtZXMsIGkuZS4gJm5ic3A7XG4gIGlmICh6KSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoRU5USVRZX01BUFBJTkcsIHopKSB7XG4gICAgICByZXR1cm4gRU5USVRZX01BUFBJTkdbel07XG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gZmFsbCBiYWNrIHRvIG9yaWdpbmFsIHZhbHVlXG4gICAgICByZXR1cm4gJyYnICsgeiArICc7JztcbiAgICB9XG4gIH1cblxuICAvLyBkZWNpbWFsIGVuY29kZWQgY2hhclxuICBpZiAoZCkge1xuICAgIHJldHVybiBmcm9tQ2hhckNvZGUoZCk7XG4gIH1cblxuICAvLyBoZXggZW5jb2RlZCBjaGFyXG4gIHJldHVybiBmcm9tQ2hhckNvZGUocGFyc2VJbnQoeCwgMTYpKTtcbn1cblxuXG4vKipcbiAqIEEgYmFzaWMgZW50aXR5IGRlY29kZXIgdGhhdCBjYW4gZGVjb2RlIGEgbWluaW1hbFxuICogc3ViLXNldCBvZiByZXNlcnZlZCBuYW1lcyAoJmFtcDspIGFzIHdlbGwgYXNcbiAqIGhleCAoJiN4YWFmOykgYW5kIGRlY2ltYWwgKCYjMTIzMTspIGVuY29kZWQgY2hhcmFjdGVycy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBkZWNvZGVkIHN0cmluZ1xuICovXG5mdW5jdGlvbiBkZWNvZGVFbnRpdGllcyhzKSB7XG4gIGlmIChzLmxlbmd0aCA+IDMgJiYgcy5pbmRleE9mKCcmJykgIT09IC0xKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZShFTlRJVFlfUEFUVEVSTiwgcmVwbGFjZUVudGl0aWVzKTtcbiAgfVxuXG4gIHJldHVybiBzO1xufVxuXG52YXIgWFNJX1VSSSA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYS1pbnN0YW5jZSc7XG52YXIgWFNJX1BSRUZJWCA9ICd4c2knO1xudmFyIFhTSV9UWVBFID0gJ3hzaTp0eXBlJztcblxudmFyIE5PTl9XSElURVNQQUNFX09VVFNJREVfUk9PVF9OT0RFID0gJ25vbi13aGl0ZXNwYWNlIG91dHNpZGUgb2Ygcm9vdCBub2RlJztcblxuZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gIHJldHVybiBuZXcgRXJyb3IobXNnKTtcbn1cblxuZnVuY3Rpb24gbWlzc2luZ05hbWVzcGFjZUZvclByZWZpeChwcmVmaXgpIHtcbiAgcmV0dXJuICdtaXNzaW5nIG5hbWVzcGFjZSBmb3IgcHJlZml4IDwnICsgcHJlZml4ICsgJz4nO1xufVxuXG5mdW5jdGlvbiBnZXR0ZXIoZ2V0Rm4pIHtcbiAgcmV0dXJuIHtcbiAgICAnZ2V0JzogZ2V0Rm4sXG4gICAgJ2VudW1lcmFibGUnOiB0cnVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsb25lTnNNYXRyaXgobnNNYXRyaXgpIHtcbiAgdmFyIGNsb25lID0ge30sIGtleTtcbiAgZm9yIChrZXkgaW4gbnNNYXRyaXgpIHtcbiAgICBjbG9uZVtrZXldID0gbnNNYXRyaXhba2V5XTtcbiAgfVxuICByZXR1cm4gY2xvbmU7XG59XG5cbmZ1bmN0aW9uIHVyaVByZWZpeChwcmVmaXgpIHtcbiAgcmV0dXJuIHByZWZpeCArICckdXJpJztcbn1cblxuZnVuY3Rpb24gYnVpbGROc01hdHJpeChuc1VyaVRvUHJlZml4KSB7XG4gIHZhciBuc01hdHJpeCA9IHt9LFxuICAgICAgdXJpLFxuICAgICAgcHJlZml4O1xuXG4gIGZvciAodXJpIGluIG5zVXJpVG9QcmVmaXgpIHtcbiAgICBwcmVmaXggPSBuc1VyaVRvUHJlZml4W3VyaV07XG4gICAgbnNNYXRyaXhbcHJlZml4XSA9IHByZWZpeDtcbiAgICBuc01hdHJpeFt1cmlQcmVmaXgocHJlZml4KV0gPSB1cmk7XG4gIH1cblxuICByZXR1cm4gbnNNYXRyaXg7XG59XG5cbmZ1bmN0aW9uIG5vb3BHZXRDb250ZXh0KCkge1xuICByZXR1cm4geyAnbGluZSc6IDAsICdjb2x1bW4nOiAwIH07XG59XG5cbmZ1bmN0aW9uIHRocm93RnVuYyhlcnIpIHtcbiAgdGhyb3cgZXJyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcGFyc2VyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtICB7IU9iamVjdDxzdHJpbmcsID8+PX0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBQYXJzZXIob3B0aW9ucykge1xuXG4gIGlmICghdGhpcykge1xuICAgIHJldHVybiBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIHByb3h5ID0gb3B0aW9ucyAmJiBvcHRpb25zWydwcm94eSddO1xuXG4gIHZhciBvblRleHQsXG4gICAgICBvbk9wZW5UYWcsXG4gICAgICBvbkNsb3NlVGFnLFxuICAgICAgb25DREFUQSxcbiAgICAgIG9uRXJyb3IgPSB0aHJvd0Z1bmMsXG4gICAgICBvbldhcm5pbmcsXG4gICAgICBvbkNvbW1lbnQsXG4gICAgICBvblF1ZXN0aW9uLFxuICAgICAgb25BdHRlbnRpb247XG5cbiAgdmFyIGdldENvbnRleHQgPSBub29wR2V0Q29udGV4dDtcblxuICAvKipcbiAgICogRG8gd2UgbmVlZCB0byBwYXJzZSB0aGUgY3VycmVudCBlbGVtZW50cyBhdHRyaWJ1dGVzIGZvciBuYW1lc3BhY2VzP1xuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHZhciBtYXliZU5TID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIERvIHdlIHByb2Nlc3MgbmFtZXNwYWNlcyBhdCBhbGw/XG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdmFyIGlzTmFtZXNwYWNlID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFRoZSBjYXVnaHQgZXJyb3IgcmV0dXJuZWQgb24gcGFyc2UgZW5kXG4gICAqXG4gICAqIEB0eXBlIHtFcnJvcn1cbiAgICovXG4gIHZhciByZXR1cm5FcnJvciA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFNob3VsZCB3ZSBzdG9wIHBhcnNpbmc/XG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdmFyIHBhcnNlU3RvcCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBBIG1hcCBvZiB7IHVyaTogcHJlZml4IH0gdXNlZCBieSB0aGUgcGFyc2VyLlxuICAgKlxuICAgKiBUaGlzIG1hcCB3aWxsIGVuc3VyZSB3ZSBjYW4gbm9ybWFsaXplIHByZWZpeGVzIGR1cmluZyBwcm9jZXNzaW5nO1xuICAgKiBmb3IgZWFjaCB1cmksIG9ubHkgb25lIHByZWZpeCB3aWxsIGJlIGV4cG9zZWQgdG8gdGhlIGhhbmRsZXJzLlxuICAgKlxuICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIHN0cmluZz59fVxuICAgKi9cbiAgdmFyIG5zVXJpVG9QcmVmaXg7XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwYXJzZSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfEVycm9yfSBlcnJcbiAgICovXG4gIGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycikge1xuICAgIGlmICghKGVyciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgZXJyID0gZXJyb3IoZXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm5FcnJvciA9IGVycjtcblxuICAgIG9uRXJyb3IoZXJyLCBnZXRDb250ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcGFyc2UgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xFcnJvcn0gZXJyXG4gICAqL1xuICBmdW5jdGlvbiBoYW5kbGVXYXJuaW5nKGVycikge1xuXG4gICAgaWYgKCFvbldhcm5pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgIGVyciA9IGVycm9yKGVycik7XG4gICAgfVxuXG4gICAgb25XYXJuaW5nKGVyciwgZ2V0Q29udGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgcGFyc2UgbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICBuYW1lXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgKlxuICAgKiBAcmV0dXJuIHtQYXJzZXJ9XG4gICAqL1xuICB0aGlzWydvbiddID0gZnVuY3Rpb24obmFtZSwgY2IpIHtcblxuICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IGVycm9yKCdyZXF1aXJlZCBhcmdzIDxuYW1lLCBjYj4nKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdvcGVuVGFnJzogb25PcGVuVGFnID0gY2I7IGJyZWFrO1xuICAgIGNhc2UgJ3RleHQnOiBvblRleHQgPSBjYjsgYnJlYWs7XG4gICAgY2FzZSAnY2xvc2VUYWcnOiBvbkNsb3NlVGFnID0gY2I7IGJyZWFrO1xuICAgIGNhc2UgJ2Vycm9yJzogb25FcnJvciA9IGNiOyBicmVhaztcbiAgICBjYXNlICd3YXJuJzogb25XYXJuaW5nID0gY2I7IGJyZWFrO1xuICAgIGNhc2UgJ2NkYXRhJzogb25DREFUQSA9IGNiOyBicmVhaztcbiAgICBjYXNlICdhdHRlbnRpb24nOiBvbkF0dGVudGlvbiA9IGNiOyBicmVhazsgLy8gPCFYWFhYWCB6enp6PVwiZWVlZVwiPlxuICAgIGNhc2UgJ3F1ZXN0aW9uJzogb25RdWVzdGlvbiA9IGNiOyBicmVhazsgLy8gPD8gLi4uLiAgPz5cbiAgICBjYXNlICdjb21tZW50Jzogb25Db21tZW50ID0gY2I7IGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBlcnJvcigndW5zdXBwb3J0ZWQgZXZlbnQ6ICcgKyBuYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBuYW1lc3BhY2UgdG8gcHJlZml4IG1hcHBpbmcuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHBhcnNlci5ucyh7XG4gICAqICAgJ2h0dHA6Ly9mb28nOiAnZm9vJyxcbiAgICogICAnaHR0cDovL2Jhcic6ICdiYXInXG4gICAqIH0pO1xuICAgKlxuICAgKiBAcGFyYW0gIHshT2JqZWN0PHN0cmluZywgc3RyaW5nPn0gbnNNYXBcbiAgICpcbiAgICogQHJldHVybiB7UGFyc2VyfVxuICAgKi9cbiAgdGhpc1snbnMnXSA9IGZ1bmN0aW9uKG5zTWFwKSB7XG5cbiAgICBpZiAodHlwZW9mIG5zTWFwID09PSAndW5kZWZpbmVkJykge1xuICAgICAgbnNNYXAgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5zTWFwICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgZXJyb3IoJ3JlcXVpcmVkIGFyZ3MgPG5zTWFwPXt9PicpO1xuICAgIH1cblxuICAgIHZhciBfbnNVcmlUb1ByZWZpeCA9IHt9LCBrO1xuXG4gICAgZm9yIChrIGluIG5zTWFwKSB7XG4gICAgICBfbnNVcmlUb1ByZWZpeFtrXSA9IG5zTWFwW2tdO1xuICAgIH1cblxuICAgIC8vIEZPUkNFIGRlZmF1bHQgbWFwcGluZyBmb3Igc2NoZW1hIGluc3RhbmNlXG4gICAgX25zVXJpVG9QcmVmaXhbWFNJX1VSSV0gPSBYU0lfUFJFRklYO1xuXG4gICAgaXNOYW1lc3BhY2UgPSB0cnVlO1xuICAgIG5zVXJpVG9QcmVmaXggPSBfbnNVcmlUb1ByZWZpeDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSB4bWwgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHhtbFxuICAgKlxuICAgKiBAcmV0dXJuIHtFcnJvcn0gcmV0dXJuRXJyb3IsIGlmIG5vdCB0aHJvd25cbiAgICovXG4gIHRoaXNbJ3BhcnNlJ10gPSBmdW5jdGlvbih4bWwpIHtcbiAgICBpZiAodHlwZW9mIHhtbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IGVycm9yKCdyZXF1aXJlZCBhcmdzIDx4bWw9c3RyaW5nPicpO1xuICAgIH1cblxuICAgIHJldHVybkVycm9yID0gbnVsbDtcblxuICAgIHBhcnNlKHhtbCk7XG5cbiAgICBnZXRDb250ZXh0ID0gbm9vcEdldENvbnRleHQ7XG4gICAgcGFyc2VTdG9wID0gZmFsc2U7XG5cbiAgICByZXR1cm4gcmV0dXJuRXJyb3I7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3AgcGFyc2luZy5cbiAgICovXG4gIHRoaXNbJ3N0b3AnXSA9IGZ1bmN0aW9uKCkge1xuICAgIHBhcnNlU3RvcCA9IHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIHN0cmluZywgaW52b2tpbmcgY29uZmlndXJlZCBsaXN0ZW5lcnMgb24gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB4bWxcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlKHhtbCkge1xuICAgIHZhciBuc01hdHJpeFN0YWNrID0gaXNOYW1lc3BhY2UgPyBbXSA6IG51bGwsXG4gICAgICAgIG5zTWF0cml4ID0gaXNOYW1lc3BhY2UgPyBidWlsZE5zTWF0cml4KG5zVXJpVG9QcmVmaXgpIDogbnVsbCxcbiAgICAgICAgX25zTWF0cml4LFxuICAgICAgICBub2RlU3RhY2sgPSBbXSxcbiAgICAgICAgYW5vbnltb3VzTnNDb3VudCA9IDAsXG4gICAgICAgIHRhZ1N0YXJ0ID0gZmFsc2UsXG4gICAgICAgIHRhZ0VuZCA9IGZhbHNlLFxuICAgICAgICBpID0gMCwgaiA9IDAsXG4gICAgICAgIHgsIHksIHEsIHcsIHYsXG4gICAgICAgIHhtbG5zLFxuICAgICAgICBlbGVtZW50TmFtZSxcbiAgICAgICAgX2VsZW1lbnROYW1lLFxuICAgICAgICBlbGVtZW50UHJveHlcbiAgICAgICAgO1xuXG4gICAgdmFyIGF0dHJzU3RyaW5nID0gJycsXG4gICAgICAgIGF0dHJzU3RhcnQgPSAwLFxuICAgICAgICBjYWNoZWRBdHRycyAvLyBmYWxzZSA9IHBhcnNlZCB3aXRoIGVycm9ycywgbnVsbCA9IG5lZWRzIHBhcnNpbmdcbiAgICAgICAgO1xuXG4gICAgLyoqXG4gICAgICogUGFyc2UgYXR0cmlidXRlcyBvbiBkZW1hbmQgYW5kIHJldHVybnMgdGhlIHBhcnNlZCBhdHRyaWJ1dGVzLlxuICAgICAqXG4gICAgICogUmV0dXJuIHNlbWFudGljczogKDEpIGBmYWxzZWAgb24gYXR0cmlidXRlIHBhcnNlIGVycm9yLFxuICAgICAqICgyKSBvYmplY3QgaGFzaCBvbiBleHRyYWN0ZWQgYXR0cnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufE9iamVjdH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBdHRycygpIHtcbiAgICAgIGlmIChjYWNoZWRBdHRycyAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY2FjaGVkQXR0cnM7XG4gICAgICB9XG5cbiAgICAgIHZhciBuc1VyaSxcbiAgICAgICAgICBuc1VyaVByZWZpeCxcbiAgICAgICAgICBuc05hbWUsXG4gICAgICAgICAgZGVmYXVsdEFsaWFzID0gaXNOYW1lc3BhY2UgJiYgbnNNYXRyaXhbJ3htbG5zJ10sXG4gICAgICAgICAgYXR0ckxpc3QgPSBpc05hbWVzcGFjZSAmJiBtYXliZU5TID8gW10gOiBudWxsLFxuICAgICAgICAgIGkgPSBhdHRyc1N0YXJ0LFxuICAgICAgICAgIHMgPSBhdHRyc1N0cmluZyxcbiAgICAgICAgICBsID0gcy5sZW5ndGgsXG4gICAgICAgICAgaGFzTmV3TWF0cml4LFxuICAgICAgICAgIG5ld2FsaWFzLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGFsaWFzLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgYXR0cnMgPSB7fSxcbiAgICAgICAgICBzZWVuQXR0cnMgPSB7fSxcbiAgICAgICAgICBza2lwQXR0cixcbiAgICAgICAgICB3LFxuICAgICAgICAgIGo7XG5cbiAgICAgIHBhcnNlQXR0cjpcbiAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHNraXBBdHRyID0gZmFsc2U7XG4gICAgICAgIHcgPSBzLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgaWYgKHcgPT09IDMyIHx8ICh3IDwgMTQgJiYgdyA+IDgpKSB7IC8vIFdISVRFU1BBQ0U9eyBcXGZcXG5cXHJcXHRcXHZ9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3YWl0IGZvciBub24gd2hpdGVzcGFjZSBjaGFyYWN0ZXJcbiAgICAgICAgaWYgKHcgPCA2NSB8fCB3ID4gMTIyIHx8ICh3ID4gOTAgJiYgdyA8IDk3KSkge1xuICAgICAgICAgIGlmICh3ICE9PSA5NSAmJiB3ICE9PSA1OCkgeyAvLyBjaGFyIDk1XCJfXCIgNThcIjpcIlxuICAgICAgICAgICAgaGFuZGxlV2FybmluZygnaWxsZWdhbCBmaXJzdCBjaGFyIGF0dHJpYnV0ZSBuYW1lJyk7XG4gICAgICAgICAgICBza2lwQXR0ciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFyc2UgYXR0cmlidXRlIG5hbWVcbiAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICB3ID0gcy5jaGFyQ29kZUF0KGopO1xuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdyA+IDk2ICYmIHcgPCAxMjMgfHxcbiAgICAgICAgICAgIHcgPiA2NCAmJiB3IDwgOTEgfHxcbiAgICAgICAgICAgIHcgPiA0NyAmJiB3IDwgNTkgfHxcbiAgICAgICAgICAgIHcgPT09IDQ2IHx8IC8vICcuJ1xuICAgICAgICAgICAgdyA9PT0gNDUgfHwgLy8gJy0nXG4gICAgICAgICAgICB3ID09PSA5NSAvLyAnXydcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgd2hpdGVzcGFjZVxuICAgICAgICAgIGlmICh3ID09PSAzMiB8fCAodyA8IDE0ICYmIHcgPiA4KSkgeyAvLyBXSElURVNQQUNFXG4gICAgICAgICAgICBoYW5kbGVXYXJuaW5nKCdtaXNzaW5nIGF0dHJpYnV0ZSB2YWx1ZScpO1xuICAgICAgICAgICAgaSA9IGo7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlIHBhcnNlQXR0cjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBleHBlY3RlZCBcIj1cIlxuICAgICAgICAgIGlmICh3ID09PSA2MSkgeyAvLyBcIj1cIiA9PSA2MVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaGFuZGxlV2FybmluZygnaWxsZWdhbCBhdHRyaWJ1dGUgbmFtZSBjaGFyJyk7XG4gICAgICAgICAgc2tpcEF0dHIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbmFtZSA9IHMuc3Vic3RyaW5nKGksIGopO1xuXG4gICAgICAgIGlmIChuYW1lID09PSAneG1sbnM6eG1sbnMnKSB7XG4gICAgICAgICAgaGFuZGxlV2FybmluZygnaWxsZWdhbCBkZWNsYXJhdGlvbiBvZiB4bWxucycpO1xuICAgICAgICAgIHNraXBBdHRyID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHcgPSBzLmNoYXJDb2RlQXQoaiArIDEpO1xuXG4gICAgICAgIGlmICh3ID09PSAzNCkgeyAvLyAnXCInXG4gICAgICAgICAgaiA9IHMuaW5kZXhPZignXCInLCBpID0gaiArIDIpO1xuXG4gICAgICAgICAgaWYgKGogPT09IC0xKSB7XG4gICAgICAgICAgICBqID0gcy5pbmRleE9mKCdcXCcnLCBpKTtcblxuICAgICAgICAgICAgaWYgKGogIT09IC0xKSB7XG4gICAgICAgICAgICAgIGhhbmRsZVdhcm5pbmcoJ2F0dHJpYnV0ZSB2YWx1ZSBxdW90ZSBtaXNzbWF0Y2gnKTtcbiAgICAgICAgICAgICAgc2tpcEF0dHIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKHcgPT09IDM5KSB7IC8vIFwiJ1wiXG4gICAgICAgICAgaiA9IHMuaW5kZXhPZignXFwnJywgaSA9IGogKyAyKTtcblxuICAgICAgICAgIGlmIChqID09PSAtMSkge1xuICAgICAgICAgICAgaiA9IHMuaW5kZXhPZignXCInLCBpKTtcblxuICAgICAgICAgICAgaWYgKGogIT09IC0xKSB7XG4gICAgICAgICAgICAgIGhhbmRsZVdhcm5pbmcoJ2F0dHJpYnV0ZSB2YWx1ZSBxdW90ZSBtaXNzbWF0Y2gnKTtcbiAgICAgICAgICAgICAgc2tpcEF0dHIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhbmRsZVdhcm5pbmcoJ21pc3NpbmcgYXR0cmlidXRlIHZhbHVlIHF1b3RlcycpO1xuICAgICAgICAgIHNraXBBdHRyID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIHNraXAgdG8gbmV4dCBzcGFjZVxuICAgICAgICAgIGZvciAoaiA9IGogKyAxOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgICB3ID0gcy5jaGFyQ29kZUF0KGogKyAxKTtcblxuICAgICAgICAgICAgaWYgKHcgPT09IDMyIHx8ICh3IDwgMTQgJiYgdyA+IDgpKSB7IC8vIFdISVRFU1BBQ0VcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaiA9PT0gLTEpIHtcbiAgICAgICAgICBoYW5kbGVXYXJuaW5nKCdtaXNzaW5nIGNsb3NpbmcgcXVvdGVzJyk7XG5cbiAgICAgICAgICBqID0gbDtcbiAgICAgICAgICBza2lwQXR0ciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNraXBBdHRyKSB7XG4gICAgICAgICAgdmFsdWUgPSBzLnN1YnN0cmluZyhpLCBqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgPSBqO1xuXG4gICAgICAgIC8vIGVuc3VyZSBTUEFDRSBmb2xsb3dzIGF0dHJpYnV0ZVxuICAgICAgICAvLyBza2lwIGlsbGVnYWwgY29udGVudCBvdGhlcndpc2VcbiAgICAgICAgLy8gZXhhbXBsZSBhPVwiYlwiY1xuICAgICAgICBmb3IgKDsgaiArIDEgPCBsOyBqKyspIHtcbiAgICAgICAgICB3ID0gcy5jaGFyQ29kZUF0KGogKyAxKTtcblxuICAgICAgICAgIGlmICh3ID09PSAzMiB8fCAodyA8IDE0ICYmIHcgPiA4KSkgeyAvLyBXSElURVNQQUNFXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBGSVJTVCBJTExFR0FMIENIQVJcbiAgICAgICAgICBpZiAoaSA9PT0gaikge1xuICAgICAgICAgICAgaGFuZGxlV2FybmluZygnaWxsZWdhbCBjaGFyYWN0ZXIgYWZ0ZXIgYXR0cmlidXRlIGVuZCcpO1xuICAgICAgICAgICAgc2tpcEF0dHIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkdmFuY2UgY3Vyc29yIHRvIG5leHQgYXR0cmlidXRlXG4gICAgICAgIGkgPSBqICsgMTtcblxuICAgICAgICBpZiAoc2tpcEF0dHIpIHtcbiAgICAgICAgICBjb250aW51ZSBwYXJzZUF0dHI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBhdHRyaWJ1dGUgcmUtZGVjbGFyYXRpb25cbiAgICAgICAgaWYgKG5hbWUgaW4gc2VlbkF0dHJzKSB7XG4gICAgICAgICAgaGFuZGxlV2FybmluZygnYXR0cmlidXRlIDwnICsgbmFtZSArICc+IGFscmVhZHkgZGVmaW5lZCcpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VlbkF0dHJzW25hbWVdID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIWlzTmFtZXNwYWNlKSB7XG4gICAgICAgICAgYXR0cnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyeSB0byBleHRyYWN0IG5hbWVzcGFjZSBpbmZvcm1hdGlvblxuICAgICAgICBpZiAobWF5YmVOUykge1xuICAgICAgICAgIG5ld2FsaWFzID0gKFxuICAgICAgICAgICAgbmFtZSA9PT0gJ3htbG5zJ1xuICAgICAgICAgICAgICA/ICd4bWxucydcbiAgICAgICAgICAgICAgOiAobmFtZS5jaGFyQ29kZUF0KDApID09PSAxMjAgJiYgbmFtZS5zdWJzdHIoMCwgNikgPT09ICd4bWxuczonKVxuICAgICAgICAgICAgICAgID8gbmFtZS5zdWJzdHIoNilcbiAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gaGFuZGxlIHhtbG5zKDphbGlhcykgYXNzaWdubWVudFxuICAgICAgICAgIGlmIChuZXdhbGlhcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbnNVcmkgPSBkZWNvZGVFbnRpdGllcyh2YWx1ZSk7XG4gICAgICAgICAgICBuc1VyaVByZWZpeCA9IHVyaVByZWZpeChuZXdhbGlhcyk7XG5cbiAgICAgICAgICAgIGFsaWFzID0gbnNVcmlUb1ByZWZpeFtuc1VyaV07XG5cbiAgICAgICAgICAgIGlmICghYWxpYXMpIHtcblxuICAgICAgICAgICAgICAvLyBubyBwcmVmaXggZGVmaW5lZCBvciBwcmVmaXggY29sbGlzaW9uXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAobmV3YWxpYXMgPT09ICd4bWxucycpIHx8XG4gICAgICAgICAgICAgICAgKG5zVXJpUHJlZml4IGluIG5zTWF0cml4ICYmIG5zTWF0cml4W25zVXJpUHJlZml4XSAhPT0gbnNVcmkpXG4gICAgICAgICAgICAgICkge1xuXG4gICAgICAgICAgICAgICAgLy8gYWxvY2F0ZSBmcmVlIG5zIHByZWZpeFxuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgIGFsaWFzID0gJ25zJyArIChhbm9ueW1vdXNOc0NvdW50KyspO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHR5cGVvZiBuc01hdHJpeFthbGlhc10gIT09ICd1bmRlZmluZWQnKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbGlhcyA9IG5ld2FsaWFzO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbnNVcmlUb1ByZWZpeFtuc1VyaV0gPSBhbGlhcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5zTWF0cml4W25ld2FsaWFzXSAhPT0gYWxpYXMpIHtcbiAgICAgICAgICAgICAgaWYgKCFoYXNOZXdNYXRyaXgpIHtcbiAgICAgICAgICAgICAgICBuc01hdHJpeCA9IGNsb25lTnNNYXRyaXgobnNNYXRyaXgpO1xuICAgICAgICAgICAgICAgIGhhc05ld01hdHJpeCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBuc01hdHJpeFtuZXdhbGlhc10gPSBhbGlhcztcbiAgICAgICAgICAgICAgaWYgKG5ld2FsaWFzID09PSAneG1sbnMnKSB7XG4gICAgICAgICAgICAgICAgbnNNYXRyaXhbdXJpUHJlZml4KGFsaWFzKV0gPSBuc1VyaTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0QWxpYXMgPSBhbGlhcztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG5zTWF0cml4W25zVXJpUHJlZml4XSA9IG5zVXJpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBleHBvc2UgeG1sbnMoOmFzZCk9XCIuLi5cIiBpbiBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBhdHRyc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gY29sbGVjdCBhdHRyaWJ1dGVzIHVudGlsIGFsbCBuYW1lc3BhY2VcbiAgICAgICAgICAvLyBkZWNsYXJhdGlvbnMgYXJlIHByb2Nlc3NlZFxuICAgICAgICAgIGF0dHJMaXN0LnB1c2gobmFtZSwgdmFsdWUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIH0gLyoqIGVuZCBpZiAobWF5YmVOcykgKi9cblxuICAgICAgICAvLyBoYW5kbGUgYXR0cmlidXRlcyBvbiBlbGVtZW50IHdpdGhvdXRcbiAgICAgICAgLy8gbmFtZXNwYWNlIGRlY2xhcmF0aW9uc1xuICAgICAgICB3ID0gbmFtZS5pbmRleE9mKCc6Jyk7XG4gICAgICAgIGlmICh3ID09PSAtMSkge1xuICAgICAgICAgIGF0dHJzW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3JtYWxpemUgbnMgYXR0cmlidXRlIG5hbWVcbiAgICAgICAgaWYgKCEobnNOYW1lID0gbnNNYXRyaXhbbmFtZS5zdWJzdHJpbmcoMCwgdyldKSkge1xuICAgICAgICAgIGhhbmRsZVdhcm5pbmcobWlzc2luZ05hbWVzcGFjZUZvclByZWZpeChuYW1lLnN1YnN0cmluZygwLCB3KSkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbmFtZSA9IGRlZmF1bHRBbGlhcyA9PT0gbnNOYW1lXG4gICAgICAgICAgPyBuYW1lLnN1YnN0cih3ICsgMSlcbiAgICAgICAgICA6IG5zTmFtZSArIG5hbWUuc3Vic3RyKHcpO1xuXG4gICAgICAgIC8vIGVuZDogbm9ybWFsaXplIG5zIGF0dHJpYnV0ZSBuYW1lXG5cbiAgICAgICAgLy8gbm9ybWFsaXplIHhzaTp0eXBlIG5zIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAgICBpZiAobmFtZSA9PT0gWFNJX1RZUEUpIHtcbiAgICAgICAgICB3ID0gdmFsdWUuaW5kZXhPZignOicpO1xuXG4gICAgICAgICAgaWYgKHcgIT09IC0xKSB7XG4gICAgICAgICAgICBuc05hbWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgdyk7XG5cbiAgICAgICAgICAgIC8vIGhhbmRsZSBkZWZhdWx0IHByZWZpeGVzLCBpLmUuIHhzOlN0cmluZyBncmFjZWZ1bGx5XG4gICAgICAgICAgICBuc05hbWUgPSBuc01hdHJpeFtuc05hbWVdIHx8IG5zTmFtZTtcbiAgICAgICAgICAgIHZhbHVlID0gbnNOYW1lICsgdmFsdWUuc3Vic3RyaW5nKHcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGRlZmF1bHRBbGlhcyArICc6JyArIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuZDogbm9ybWFsaXplIHhzaTp0eXBlIG5zIGF0dHJpYnV0ZSB2YWx1ZVxuXG4gICAgICAgIGF0dHJzW25hbWVdID0gdmFsdWU7XG4gICAgICB9XG5cblxuICAgICAgLy8gaGFuZGxlIGRlZmVycmVkLCBwb3NzaWJseSBuYW1lc3BhY2VkIGF0dHJpYnV0ZXNcbiAgICAgIGlmIChtYXliZU5TKSB7XG5cbiAgICAgICAgLy8gbm9ybWFsaXplIGNhcHR1cmVkIGF0dHJpYnV0ZXNcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGF0dHJMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXG4gICAgICAgICAgbmFtZSA9IGF0dHJMaXN0W2krK107XG4gICAgICAgICAgdmFsdWUgPSBhdHRyTGlzdFtpXTtcblxuICAgICAgICAgIHcgPSBuYW1lLmluZGV4T2YoJzonKTtcblxuICAgICAgICAgIGlmICh3ICE9PSAtMSkge1xuXG4gICAgICAgICAgICAvLyBub3JtYWxpemUgbnMgYXR0cmlidXRlIG5hbWVcbiAgICAgICAgICAgIGlmICghKG5zTmFtZSA9IG5zTWF0cml4W25hbWUuc3Vic3RyaW5nKDAsIHcpXSkpIHtcbiAgICAgICAgICAgICAgaGFuZGxlV2FybmluZyhtaXNzaW5nTmFtZXNwYWNlRm9yUHJlZml4KG5hbWUuc3Vic3RyaW5nKDAsIHcpKSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuYW1lID0gZGVmYXVsdEFsaWFzID09PSBuc05hbWVcbiAgICAgICAgICAgICAgPyBuYW1lLnN1YnN0cih3ICsgMSlcbiAgICAgICAgICAgICAgOiBuc05hbWUgKyBuYW1lLnN1YnN0cih3KTtcblxuICAgICAgICAgICAgLy8gZW5kOiBub3JtYWxpemUgbnMgYXR0cmlidXRlIG5hbWVcblxuICAgICAgICAgICAgLy8gbm9ybWFsaXplIHhzaTp0eXBlIG5zIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFhTSV9UWVBFKSB7XG4gICAgICAgICAgICAgIHcgPSB2YWx1ZS5pbmRleE9mKCc6Jyk7XG5cbiAgICAgICAgICAgICAgaWYgKHcgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbnNOYW1lID0gdmFsdWUuc3Vic3RyaW5nKDAsIHcpO1xuXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIGRlZmF1bHQgcHJlZml4ZXMsIGkuZS4geHM6U3RyaW5nIGdyYWNlZnVsbHlcbiAgICAgICAgICAgICAgICBuc05hbWUgPSBuc01hdHJpeFtuc05hbWVdIHx8IG5zTmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5zTmFtZSArIHZhbHVlLnN1YnN0cmluZyh3KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRlZmF1bHRBbGlhcyArICc6JyArIHZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGVuZDogbm9ybWFsaXplIHhzaTp0eXBlIG5zIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGF0dHJzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbmQ6IG5vcm1hbGl6ZSBjYXB0dXJlZCBhdHRyaWJ1dGVzXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWNoZWRBdHRycyA9IGF0dHJzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3QgdGhlIHBhcnNlIGNvbnRleHQgeyBsaW5lLCBjb2x1bW4sIHBhcnQgfVxuICAgICAqIGZyb20gdGhlIGN1cnJlbnQgcGFyc2VyIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBwYXJzZSBjb250ZXh0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2VDb250ZXh0KCkge1xuICAgICAgdmFyIHNwbGl0c1JlID0gLyhcXHJcXG58XFxyfFxcbikvZztcblxuICAgICAgdmFyIGxpbmUgPSAwO1xuICAgICAgdmFyIGNvbHVtbiA9IDA7XG4gICAgICB2YXIgc3RhcnRPZkxpbmUgPSAwO1xuICAgICAgdmFyIGVuZE9mTGluZSA9IGo7XG4gICAgICB2YXIgbWF0Y2g7XG4gICAgICB2YXIgZGF0YTtcblxuICAgICAgd2hpbGUgKGkgPj0gc3RhcnRPZkxpbmUpIHtcblxuICAgICAgICBtYXRjaCA9IHNwbGl0c1JlLmV4ZWMoeG1sKTtcblxuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbmQgb2YgbGluZSA9IChicmVhayBpZHggKyBicmVhayBjaGFycylcbiAgICAgICAgZW5kT2ZMaW5lID0gbWF0Y2hbMF0ubGVuZ3RoICsgbWF0Y2guaW5kZXg7XG5cbiAgICAgICAgaWYgKGVuZE9mTGluZSA+IGkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkdmFuY2UgdG8gbmV4dCBsaW5lXG4gICAgICAgIGxpbmUgKz0gMTtcblxuICAgICAgICBzdGFydE9mTGluZSA9IGVuZE9mTGluZTtcbiAgICAgIH1cblxuICAgICAgLy8gRU9GIGVycm9yc1xuICAgICAgaWYgKGkgPT0gLTEpIHtcbiAgICAgICAgY29sdW1uID0gZW5kT2ZMaW5lO1xuICAgICAgICBkYXRhID0geG1sLnN1YnN0cmluZyhqKTtcbiAgICAgIH0gZWxzZVxuXG4gICAgICAvLyBzdGFydCBlcnJvcnNcbiAgICAgIGlmIChqID09PSAwKSB7XG4gICAgICAgIGRhdGEgPSB4bWwuc3Vic3RyaW5nKGosIGkpO1xuICAgICAgfVxuXG4gICAgICAvLyBvdGhlciBlcnJvcnNcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb2x1bW4gPSBpIC0gc3RhcnRPZkxpbmU7XG4gICAgICAgIGRhdGEgPSAoaiA9PSAtMSA/IHhtbC5zdWJzdHJpbmcoaSkgOiB4bWwuc3Vic3RyaW5nKGksIGogKyAxKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICdkYXRhJzogZGF0YSxcbiAgICAgICAgJ2xpbmUnOiBsaW5lLFxuICAgICAgICAnY29sdW1uJzogY29sdW1uXG4gICAgICB9O1xuICAgIH1cblxuICAgIGdldENvbnRleHQgPSBnZXRQYXJzZUNvbnRleHQ7XG5cblxuICAgIGlmIChwcm94eSkge1xuICAgICAgZWxlbWVudFByb3h5ID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAnbmFtZSc6IGdldHRlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudE5hbWU7XG4gICAgICAgIH0pLFxuICAgICAgICAnb3JpZ2luYWxOYW1lJzogZ2V0dGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfZWxlbWVudE5hbWU7XG4gICAgICAgIH0pLFxuICAgICAgICAnYXR0cnMnOiBnZXR0ZXIoZ2V0QXR0cnMpLFxuICAgICAgICAnbnMnOiBnZXR0ZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG5zTWF0cml4O1xuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gYWN0dWFsIHBhcnNlIGxvZ2ljXG4gICAgd2hpbGUgKGogIT09IC0xKSB7XG5cbiAgICAgIGlmICh4bWwuY2hhckNvZGVBdChqKSA9PT0gNjApIHsgLy8gXCI8XCJcbiAgICAgICAgaSA9IGo7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpID0geG1sLmluZGV4T2YoJzwnLCBqKTtcbiAgICAgIH1cblxuICAgICAgLy8gcGFyc2UgZW5kXG4gICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgaWYgKG5vZGVTdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoJ3VuZXhwZWN0ZWQgZW5kIG9mIGZpbGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCdtaXNzaW5nIHN0YXJ0IHRhZycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGogPCB4bWwubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHhtbC5zdWJzdHJpbmcoaikudHJpbSgpKSB7XG4gICAgICAgICAgICBoYW5kbGVXYXJuaW5nKE5PTl9XSElURVNQQUNFX09VVFNJREVfUk9PVF9OT0RFKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHBhcnNlIHRleHRcbiAgICAgIGlmIChqICE9PSBpKSB7XG5cbiAgICAgICAgaWYgKG5vZGVTdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAob25UZXh0KSB7XG4gICAgICAgICAgICBvblRleHQoeG1sLnN1YnN0cmluZyhqLCBpKSwgZGVjb2RlRW50aXRpZXMsIGdldENvbnRleHQpO1xuXG4gICAgICAgICAgICBpZiAocGFyc2VTdG9wKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHhtbC5zdWJzdHJpbmcoaiwgaSkudHJpbSgpKSB7XG4gICAgICAgICAgICBoYW5kbGVXYXJuaW5nKE5PTl9XSElURVNQQUNFX09VVFNJREVfUk9PVF9OT0RFKTtcblxuICAgICAgICAgICAgaWYgKHBhcnNlU3RvcCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHcgPSB4bWwuY2hhckNvZGVBdChpKzEpO1xuXG4gICAgICAvLyBwYXJzZSBjb21tZW50cyArIENEQVRBXG4gICAgICBpZiAodyA9PT0gMzMpIHsgLy8gXCIhXCJcbiAgICAgICAgcSA9IHhtbC5jaGFyQ29kZUF0KGkrMik7XG5cbiAgICAgICAgLy8gQ0RBVEEgc2VjdGlvblxuICAgICAgICBpZiAocSA9PT0gOTEgJiYgeG1sLnN1YnN0cihpICsgMywgNikgPT09ICdDREFUQVsnKSB7IC8vIDkxID09IFwiW1wiXG4gICAgICAgICAgaiA9IHhtbC5pbmRleE9mKCddXT4nLCBpKTtcbiAgICAgICAgICBpZiAoaiA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcigndW5jbG9zZWQgY2RhdGEnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob25DREFUQSkge1xuICAgICAgICAgICAgb25DREFUQSh4bWwuc3Vic3RyaW5nKGkgKyA5LCBqKSwgZ2V0Q29udGV4dCk7XG4gICAgICAgICAgICBpZiAocGFyc2VTdG9wKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBqICs9IDM7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb21tZW50XG4gICAgICAgIGlmIChxID09PSA0NSAmJiB4bWwuY2hhckNvZGVBdChpICsgMykgPT09IDQ1KSB7IC8vIDQ1ID09IFwiLVwiXG4gICAgICAgICAgaiA9IHhtbC5pbmRleE9mKCctLT4nLCBpKTtcbiAgICAgICAgICBpZiAoaiA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcigndW5jbG9zZWQgY29tbWVudCcpO1xuICAgICAgICAgIH1cblxuXG4gICAgICAgICAgaWYgKG9uQ29tbWVudCkge1xuICAgICAgICAgICAgb25Db21tZW50KHhtbC5zdWJzdHJpbmcoaSArIDQsIGopLCBkZWNvZGVFbnRpdGllcywgZ2V0Q29udGV4dCk7XG4gICAgICAgICAgICBpZiAocGFyc2VTdG9wKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBqICs9IDM7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcGFyc2UgcXVlc3Rpb24gPD8gLi4uID8+XG4gICAgICBpZiAodyA9PT0gNjMpIHsgLy8gXCI/XCJcbiAgICAgICAgaiA9IHhtbC5pbmRleE9mKCc/PicsIGkpO1xuICAgICAgICBpZiAoaiA9PT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoJ3VuY2xvc2VkIHF1ZXN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob25RdWVzdGlvbikge1xuICAgICAgICAgIG9uUXVlc3Rpb24oeG1sLnN1YnN0cmluZyhpLCBqICsgMiksIGdldENvbnRleHQpO1xuICAgICAgICAgIGlmIChwYXJzZVN0b3ApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBqICs9IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBmaW5kIG1hdGNoaW5nIGNsb3NpbmcgdGFnIGZvciBhdHRlbnRpb24gb3Igc3RhbmRhcmQgdGFnc1xuICAgICAgLy8gZm9yIHRoYXQgd2UgbXVzdCBza2lwIHRocm91Z2ggYXR0cmlidXRlIHZhbHVlc1xuICAgICAgLy8gKGVuY2xvc2VkIGluIHNpbmdsZSBvciBkb3VibGUgcXVvdGVzKVxuICAgICAgZm9yICh4ID0gaSArIDE7IDsgeCsrKSB7XG4gICAgICAgIHYgPSB4bWwuY2hhckNvZGVBdCh4KTtcbiAgICAgICAgaWYgKGlzTmFOKHYpKSB7XG4gICAgICAgICAgaiA9IC0xO1xuICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcigndW5jbG9zZWQgdGFnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBbMTBdIEF0dFZhbHVlIDo6PSAnXCInIChbXjwmXCJdIHwgUmVmZXJlbmNlKSogJ1wiJyB8IFwiJ1wiIChbXjwmJ10gfCBSZWZlcmVuY2UpKiBcIidcIlxuICAgICAgICAvLyBza2lwcyB0aGUgcXVvdGVkIHN0cmluZ1xuICAgICAgICAvLyAoZG91YmxlIHF1b3RlcykgZG9lcyBub3QgYXBwZWFyIGluIGEgbGl0ZXJhbCBlbmNsb3NlZCBieSAoZG91YmxlIHF1b3RlcylcbiAgICAgICAgLy8gKHNpbmdsZSBxdW90ZSkgZG9lcyBub3QgYXBwZWFyIGluIGEgbGl0ZXJhbCBlbmNsb3NlZCBieSAoc2luZ2xlIHF1b3RlKVxuICAgICAgICBpZiAodiA9PT0gMzQpIHsgLy8gICdcIidcbiAgICAgICAgICBxID0geG1sLmluZGV4T2YoJ1wiJywgeCArIDEpO1xuICAgICAgICAgIHggPSBxICE9PSAtMSA/IHEgOiB4O1xuICAgICAgICB9IGVsc2UgaWYgKHYgPT09IDM5KSB7IC8vIFwiJ1wiXG4gICAgICAgICAgcSA9IHhtbC5pbmRleE9mKFwiJ1wiLCB4ICsgMSk7XG4gICAgICAgICAgeCA9IHEgIT09IC0xID8gcSA6IHg7XG4gICAgICAgIH0gZWxzZSBpZiAodiA9PT0gNjIpIHsgLy8gJz4nXG4gICAgICAgICAgaiA9IHg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuXG4gICAgICAvLyBwYXJzZSBhdHRlbnRpb24gPCEgLi4uPlxuICAgICAgLy8gcHJldmlvdXNseSBjb21tZW50IGFuZCBDREFUQSBoYXZlIGFscmVhZHkgYmVlbiBwYXJzZWRcbiAgICAgIGlmICh3ID09PSAzMykgeyAvLyBcIiFcIlxuXG4gICAgICAgIGlmIChvbkF0dGVudGlvbikge1xuICAgICAgICAgIG9uQXR0ZW50aW9uKHhtbC5zdWJzdHJpbmcoaSwgaiArIDEpLCBkZWNvZGVFbnRpdGllcywgZ2V0Q29udGV4dCk7XG4gICAgICAgICAgaWYgKHBhcnNlU3RvcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGogKz0gMTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGRvbid0IHByb2Nlc3MgYXR0cmlidXRlcztcbiAgICAgIC8vIHRoZXJlIGFyZSBub25lXG4gICAgICBjYWNoZWRBdHRycyA9IHt9O1xuXG4gICAgICAvLyBpZiAoeG1sLmNoYXJDb2RlQXQoaSsxKSA9PT0gNDcpIHsgLy8gPC8uLi5cbiAgICAgIGlmICh3ID09PSA0NykgeyAvLyA8Ly4uLlxuICAgICAgICB0YWdTdGFydCA9IGZhbHNlO1xuICAgICAgICB0YWdFbmQgPSB0cnVlO1xuXG4gICAgICAgIGlmICghbm9kZVN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcignbWlzc2luZyBvcGVuIHRhZycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmVyaWZ5IG9wZW4gPC0+IGNsb3NlIHRhZyBtYXRjaFxuICAgICAgICB4ID0gZWxlbWVudE5hbWUgPSBub2RlU3RhY2sucG9wKCk7XG4gICAgICAgIHEgPSBpICsgMiArIHgubGVuZ3RoO1xuXG4gICAgICAgIGlmICh4bWwuc3Vic3RyaW5nKGkgKyAyLCBxKSAhPT0geCkge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcignY2xvc2luZyB0YWcgbWlzbWF0Y2gnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZlcmlmeSBjaGFycyBpbiBjbG9zZSB0YWdcbiAgICAgICAgZm9yICg7IHEgPCBqOyBxKyspIHtcbiAgICAgICAgICB3ID0geG1sLmNoYXJDb2RlQXQocSk7XG5cbiAgICAgICAgICBpZiAodyA9PT0gMzIgfHwgKHcgPiA4ICYmIHcgPCAxNCkpIHsgLy8gXFxmXFxuXFxyXFx0XFx2IHNwYWNlXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoJ2Nsb3NlIHRhZycpO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh4bWwuY2hhckNvZGVBdChqIC0gMSkgPT09IDQ3KSB7IC8vIC4uLi8+XG4gICAgICAgICAgeCA9IGVsZW1lbnROYW1lID0geG1sLnN1YnN0cmluZyhpICsgMSwgaiAtIDEpO1xuXG4gICAgICAgICAgdGFnU3RhcnQgPSB0cnVlO1xuICAgICAgICAgIHRhZ0VuZCA9IHRydWU7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4ID0gZWxlbWVudE5hbWUgPSB4bWwuc3Vic3RyaW5nKGkgKyAxLCBqKTtcblxuICAgICAgICAgIHRhZ1N0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgICB0YWdFbmQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKHcgPiA5NiAmJiB3IDwgMTIzIHx8IHcgPiA2NCAmJiB3IDwgOTEgfHwgdyA9PT0gOTUgfHwgdyA9PT0gNTgpKSB7IC8vIGNoYXIgOTVcIl9cIiA1OFwiOlwiXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCdpbGxlZ2FsIGZpcnN0IGNoYXIgbm9kZU5hbWUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAocSA9IDEsIHkgPSB4Lmxlbmd0aDsgcSA8IHk7IHErKykge1xuICAgICAgICAgIHcgPSB4LmNoYXJDb2RlQXQocSk7XG5cbiAgICAgICAgICBpZiAodyA+IDk2ICYmIHcgPCAxMjMgfHwgdyA+IDY0ICYmIHcgPCA5MSB8fCB3ID4gNDcgJiYgdyA8IDU5IHx8IHcgPT09IDQ1IHx8IHcgPT09IDk1IHx8IHcgPT0gNDYpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh3ID09PSAzMiB8fCAodyA8IDE0ICYmIHcgPiA4KSkgeyAvLyBcXGZcXG5cXHJcXHRcXHYgc3BhY2VcbiAgICAgICAgICAgIGVsZW1lbnROYW1lID0geC5zdWJzdHJpbmcoMCwgcSk7XG5cbiAgICAgICAgICAgIC8vIG1heWJlIHRoZXJlIGFyZSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBjYWNoZWRBdHRycyA9IG51bGw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoJ2ludmFsaWQgbm9kZU5hbWUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGFnRW5kKSB7XG4gICAgICAgICAgbm9kZVN0YWNrLnB1c2goZWxlbWVudE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc05hbWVzcGFjZSkge1xuXG4gICAgICAgIF9uc01hdHJpeCA9IG5zTWF0cml4O1xuXG4gICAgICAgIGlmICh0YWdTdGFydCkge1xuXG4gICAgICAgICAgLy8gcmVtZW1iZXIgb2xkIG5hbWVzcGFjZVxuICAgICAgICAgIC8vIHVubGVzcyB3ZSdyZSBzZWxmLWNsb3NpbmdcbiAgICAgICAgICBpZiAoIXRhZ0VuZCkge1xuICAgICAgICAgICAgbnNNYXRyaXhTdGFjay5wdXNoKF9uc01hdHJpeCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNhY2hlZEF0dHJzID09PSBudWxsKSB7XG5cbiAgICAgICAgICAgIC8vIHF1aWNrIGNoZWNrLCB3aGV0aGVyIHRoZXJlIG1heSBiZSBuYW1lc3BhY2VcbiAgICAgICAgICAgIC8vIGRlY2xhcmF0aW9ucyBvbiB0aGUgbm9kZTsgaWYgdGhhdCBpcyB0aGUgY2FzZVxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBlYWdlcmx5IHBhcnNlIHRoZSBub2RlIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIGlmICgobWF5YmVOUyA9IHguaW5kZXhPZigneG1sbnMnLCBxKSAhPT0gLTEpKSB7XG4gICAgICAgICAgICAgIGF0dHJzU3RhcnQgPSBxO1xuICAgICAgICAgICAgICBhdHRyc1N0cmluZyA9IHg7XG5cbiAgICAgICAgICAgICAgZ2V0QXR0cnMoKTtcblxuICAgICAgICAgICAgICBtYXliZU5TID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX2VsZW1lbnROYW1lID0gZWxlbWVudE5hbWU7XG5cbiAgICAgICAgdyA9IGVsZW1lbnROYW1lLmluZGV4T2YoJzonKTtcbiAgICAgICAgaWYgKHcgIT09IC0xKSB7XG4gICAgICAgICAgeG1sbnMgPSBuc01hdHJpeFtlbGVtZW50TmFtZS5zdWJzdHJpbmcoMCwgdyldO1xuXG4gICAgICAgICAgLy8gcHJlZml4IGdpdmVuOyBuYW1lc3BhY2UgbXVzdCBleGlzdFxuICAgICAgICAgIGlmICgheG1sbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcignbWlzc2luZyBuYW1lc3BhY2Ugb24gPCcgKyBfZWxlbWVudE5hbWUgKyAnPicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsZW1lbnROYW1lID0gZWxlbWVudE5hbWUuc3Vic3RyKHcgKyAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4bWxucyA9IG5zTWF0cml4Wyd4bWxucyddO1xuXG4gICAgICAgICAgLy8gaWYgbm8gZGVmYXVsdCBuYW1lc3BhY2UgaXMgZGVmaW5lZCxcbiAgICAgICAgICAvLyB3ZSdsbCBpbXBvcnQgdGhlIGVsZW1lbnQgYXMgYW5vbnltb3VzLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gaXQgaXMgdXAgdG8gdXNlcnMgdG8gY29ycmVjdCB0aGF0IHRvIHRoZSBkb2N1bWVudCBkZWZpbmVkXG4gICAgICAgICAgLy8gdGFyZ2V0TmFtZXNwYWNlLCBvciB3aGF0ZXZlciB0aGVpciB1bmRlcnNhbmRpbmcgb2YgdGhlXG4gICAgICAgICAgLy8gWE1MIHNwZWMgbWFuZGF0ZXMuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGp1c3QgbmFtZXNwYWNlIHByZWZpeHMgYXMgY29uZmlndXJlZFxuICAgICAgICBpZiAoeG1sbnMpIHtcbiAgICAgICAgICBlbGVtZW50TmFtZSA9IHhtbG5zICsgJzonICsgZWxlbWVudE5hbWU7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBpZiAodGFnU3RhcnQpIHtcbiAgICAgICAgYXR0cnNTdGFydCA9IHE7XG4gICAgICAgIGF0dHJzU3RyaW5nID0geDtcblxuICAgICAgICBpZiAob25PcGVuVGFnKSB7XG4gICAgICAgICAgaWYgKHByb3h5KSB7XG4gICAgICAgICAgICBvbk9wZW5UYWcoZWxlbWVudFByb3h5LCBkZWNvZGVFbnRpdGllcywgdGFnRW5kLCBnZXRDb250ZXh0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb25PcGVuVGFnKGVsZW1lbnROYW1lLCBnZXRBdHRycywgZGVjb2RlRW50aXRpZXMsIHRhZ0VuZCwgZ2V0Q29udGV4dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhcnNlU3RvcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmICh0YWdFbmQpIHtcblxuICAgICAgICBpZiAob25DbG9zZVRhZykge1xuICAgICAgICAgIG9uQ2xvc2VUYWcocHJveHkgPyBlbGVtZW50UHJveHkgOiBlbGVtZW50TmFtZSwgZGVjb2RlRW50aXRpZXMsIHRhZ1N0YXJ0LCBnZXRDb250ZXh0KTtcblxuICAgICAgICAgIGlmIChwYXJzZVN0b3ApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXN0b3JlIG9sZCBuYW1lc3BhY2VcbiAgICAgICAgaWYgKGlzTmFtZXNwYWNlKSB7XG4gICAgICAgICAgaWYgKCF0YWdTdGFydCkge1xuICAgICAgICAgICAgbnNNYXRyaXggPSBuc01hdHJpeFN0YWNrLnBvcCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuc01hdHJpeCA9IF9uc01hdHJpeDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaiArPSAxO1xuICAgIH1cbiAgfSAvKiogZW5kIHBhcnNlICovXG5cbn1cblxuZXhwb3J0IHsgUGFyc2VyLCBkZWNvZGVFbnRpdGllcyBhcyBkZWNvZGUgfTtcbiIsImltcG9ydCB7IGlzU3RyaW5nLCBpc0Z1bmN0aW9uLCBhc3NpZ24gfSBmcm9tICdtaW4tZGFzaCc7XG5pbXBvcnQgeyBNb2RkbGUgfSBmcm9tICdtb2RkbGUnO1xuaW1wb3J0IHsgUmVhZGVyLCBXcml0ZXIgfSBmcm9tICdtb2RkbGUteG1sJztcblxuLyoqXG4gKiBBIHN1YiBjbGFzcyBvZiB7QGxpbmsgTW9kZGxlfSB3aXRoIHN1cHBvcnQgZm9yIGltcG9ydCBhbmQgZXhwb3J0IG9mIEJQTU4gMi4wIHhtbCBmaWxlcy5cbiAqXG4gKiBAY2xhc3MgQnBtbk1vZGRsZVxuICogQGV4dGVuZHMgTW9kZGxlXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IHBhY2thZ2VzIHRvIHVzZSBmb3IgaW5zdGFudGlhdGluZyB0aGUgbW9kZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gYWRkaXRpb25hbCBvcHRpb25zIHRvIHBhc3Mgb3ZlclxuICovXG5mdW5jdGlvbiBCcG1uTW9kZGxlKHBhY2thZ2VzLCBvcHRpb25zKSB7XG4gIE1vZGRsZS5jYWxsKHRoaXMsIHBhY2thZ2VzLCBvcHRpb25zKTtcbn1cblxuQnBtbk1vZGRsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE1vZGRsZS5wcm90b3R5cGUpO1xuXG5cbi8qKlxuICogSW5zdGFudGlhdGVzIGEgQlBNTiBtb2RlbCB0cmVlIGZyb20gYSBnaXZlbiB4bWwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSAgIHhtbFN0clxuICogQHBhcmFtIHtTdHJpbmd9ICAgW3R5cGVOYW1lPSdicG1uOkRlZmluaXRpb25zJ10gbmFtZSBvZiB0aGUgcm9vdCBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gICBbb3B0aW9uc10gIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgdW5kZXJseWluZyByZWFkZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmUgICAgICAgY2FsbGJhY2sgdGhhdCBpcyBpbnZva2VkIHdpdGggKGVyciwgcmVzdWx0LCBwYXJzZUNvbnRleHQpXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uY2UgdGhlIGltcG9ydCBjb21wbGV0ZXNcbiAqL1xuQnBtbk1vZGRsZS5wcm90b3R5cGUuZnJvbVhNTCA9IGZ1bmN0aW9uKHhtbFN0ciwgdHlwZU5hbWUsIG9wdGlvbnMsIGRvbmUpIHtcblxuICBpZiAoIWlzU3RyaW5nKHR5cGVOYW1lKSkge1xuICAgIGRvbmUgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB0eXBlTmFtZTtcbiAgICB0eXBlTmFtZSA9ICdicG1uOkRlZmluaXRpb25zJztcbiAgfVxuXG4gIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgZG9uZSA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIHJlYWRlciA9IG5ldyBSZWFkZXIoYXNzaWduKHsgbW9kZWw6IHRoaXMsIGxheDogdHJ1ZSB9LCBvcHRpb25zKSk7XG4gIHZhciByb290SGFuZGxlciA9IHJlYWRlci5oYW5kbGVyKHR5cGVOYW1lKTtcblxuICByZWFkZXIuZnJvbVhNTCh4bWxTdHIsIHJvb3RIYW5kbGVyLCBkb25lKTtcbn07XG5cblxuLyoqXG4gKiBTZXJpYWxpemVzIGEgQlBNTiAyLjAgb2JqZWN0IHRyZWUgdG8gWE1MLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSAgIGVsZW1lbnQgICAgdGhlIHJvb3QgZWxlbWVudCwgdHlwaWNhbGx5IGFuIGluc3RhbmNlIG9mIGBicG1uOkRlZmluaXRpb25zYFxuICogQHBhcmFtIHtPYmplY3R9ICAgW29wdGlvbnNdICB0byBwYXNzIHRvIHRoZSB1bmRlcmx5aW5nIHdyaXRlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZSAgICAgICBjYWxsYmFjayBpbnZva2VkIHdpdGggKGVyciwgeG1sU3RyKSBvbmNlIHRoZSBpbXBvcnQgY29tcGxldGVzXG4gKi9cbkJwbW5Nb2RkbGUucHJvdG90eXBlLnRvWE1MID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucywgZG9uZSkge1xuXG4gIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgZG9uZSA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIHdyaXRlciA9IG5ldyBXcml0ZXIob3B0aW9ucyk7XG5cbiAgdmFyIHJlc3VsdDtcbiAgdmFyIGVycjtcblxuICB0cnkge1xuICAgIHJlc3VsdCA9IHdyaXRlci50b1hNTChlbGVtZW50KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVyciA9IGU7XG4gIH1cblxuICByZXR1cm4gZG9uZShlcnIsIHJlc3VsdCk7XG59O1xuXG52YXIgbmFtZSA9IFwiQlBNTjIwXCI7XG52YXIgdXJpID0gXCJodHRwOi8vd3d3Lm9tZy5vcmcvc3BlYy9CUE1OLzIwMTAwNTI0L01PREVMXCI7XG52YXIgYXNzb2NpYXRpb25zID0gW1xuXTtcbnZhciB0eXBlcyA9IFtcblx0e1xuXHRcdG5hbWU6IFwiSW50ZXJmYWNlXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJSb290RWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwib3BlcmF0aW9uc1wiLFxuXHRcdFx0XHR0eXBlOiBcIk9wZXJhdGlvblwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaW1wbGVtZW50YXRpb25SZWZcIixcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJPcGVyYXRpb25cIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkJhc2VFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpbk1lc3NhZ2VSZWZcIixcblx0XHRcdFx0dHlwZTogXCJNZXNzYWdlXCIsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm91dE1lc3NhZ2VSZWZcIixcblx0XHRcdFx0dHlwZTogXCJNZXNzYWdlXCIsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImVycm9yUmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiRXJyb3JcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpbXBsZW1lbnRhdGlvblJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkVuZFBvaW50XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJSb290RWxlbWVudFwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJBdWRpdGluZ1wiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiR2xvYmFsVGFza1wiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiQ2FsbGFibGVFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJyZXNvdXJjZXNcIixcblx0XHRcdFx0dHlwZTogXCJSZXNvdXJjZVJvbGVcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJNb25pdG9yaW5nXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJQZXJmb3JtZXJcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIlJlc291cmNlUm9sZVwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJQcm9jZXNzXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJGbG93RWxlbWVudHNDb250YWluZXJcIixcblx0XHRcdFwiQ2FsbGFibGVFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJwcm9jZXNzVHlwZVwiLFxuXHRcdFx0XHR0eXBlOiBcIlByb2Nlc3NUeXBlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpc0Nsb3NlZFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImF1ZGl0aW5nXCIsXG5cdFx0XHRcdHR5cGU6IFwiQXVkaXRpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJtb25pdG9yaW5nXCIsXG5cdFx0XHRcdHR5cGU6IFwiTW9uaXRvcmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInByb3BlcnRpZXNcIixcblx0XHRcdFx0dHlwZTogXCJQcm9wZXJ0eVwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibGFuZVNldHNcIixcblx0XHRcdFx0dHlwZTogXCJMYW5lU2V0XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZSxcblx0XHRcdFx0cmVwbGFjZXM6IFwiRmxvd0VsZW1lbnRzQ29udGFpbmVyI2xhbmVTZXRzXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZmxvd0VsZW1lbnRzXCIsXG5cdFx0XHRcdHR5cGU6IFwiRmxvd0VsZW1lbnRcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRyZXBsYWNlczogXCJGbG93RWxlbWVudHNDb250YWluZXIjZmxvd0VsZW1lbnRzXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiYXJ0aWZhY3RzXCIsXG5cdFx0XHRcdHR5cGU6IFwiQXJ0aWZhY3RcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInJlc291cmNlc1wiLFxuXHRcdFx0XHR0eXBlOiBcIlJlc291cmNlUm9sZVwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY29ycmVsYXRpb25TdWJzY3JpcHRpb25zXCIsXG5cdFx0XHRcdHR5cGU6IFwiQ29ycmVsYXRpb25TdWJzY3JpcHRpb25cIixcblx0XHRcdFx0aXNNYW55OiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInN1cHBvcnRzXCIsXG5cdFx0XHRcdHR5cGU6IFwiUHJvY2Vzc1wiLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImRlZmluaXRpb25hbENvbGxhYm9yYXRpb25SZWZcIixcblx0XHRcdFx0dHlwZTogXCJDb2xsYWJvcmF0aW9uXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaXNFeGVjdXRhYmxlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJCb29sZWFuXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkxhbmVTZXRcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkJhc2VFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJsYW5lc1wiLFxuXHRcdFx0XHR0eXBlOiBcIkxhbmVcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJMYW5lXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwicGFydGl0aW9uRWxlbWVudFJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkJhc2VFbGVtZW50XCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwicGFydGl0aW9uRWxlbWVudFwiLFxuXHRcdFx0XHR0eXBlOiBcIkJhc2VFbGVtZW50XCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZmxvd05vZGVSZWZcIixcblx0XHRcdFx0dHlwZTogXCJGbG93Tm9kZVwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImNoaWxkTGFuZVNldFwiLFxuXHRcdFx0XHR0eXBlOiBcIkxhbmVTZXRcIixcblx0XHRcdFx0eG1sOiB7XG5cdFx0XHRcdFx0c2VyaWFsaXplOiBcInhzaTp0eXBlXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiR2xvYmFsTWFudWFsVGFza1wiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiR2xvYmFsVGFza1wiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJNYW51YWxUYXNrXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJUYXNrXCJcblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlVzZXJUYXNrXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJUYXNrXCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJyZW5kZXJpbmdzXCIsXG5cdFx0XHRcdHR5cGU6IFwiUmVuZGVyaW5nXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpbXBsZW1lbnRhdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlJlbmRlcmluZ1wiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiSHVtYW5QZXJmb3JtZXJcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIlBlcmZvcm1lclwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJQb3RlbnRpYWxPd25lclwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiSHVtYW5QZXJmb3JtZXJcIlxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiR2xvYmFsVXNlclRhc2tcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkdsb2JhbFRhc2tcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImltcGxlbWVudGF0aW9uXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJyZW5kZXJpbmdzXCIsXG5cdFx0XHRcdHR5cGU6IFwiUmVuZGVyaW5nXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiR2F0ZXdheVwiLFxuXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJGbG93Tm9kZVwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZ2F0ZXdheURpcmVjdGlvblwiLFxuXHRcdFx0XHR0eXBlOiBcIkdhdGV3YXlEaXJlY3Rpb25cIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiVW5zcGVjaWZpZWRcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJFdmVudEJhc2VkR2F0ZXdheVwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiR2F0ZXdheVwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaW5zdGFudGlhdGVcIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImV2ZW50R2F0ZXdheVR5cGVcIixcblx0XHRcdFx0dHlwZTogXCJFdmVudEJhc2VkR2F0ZXdheVR5cGVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRcImRlZmF1bHRcIjogXCJFeGNsdXNpdmVcIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQ29tcGxleEdhdGV3YXlcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkdhdGV3YXlcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImFjdGl2YXRpb25Db25kaXRpb25cIixcblx0XHRcdFx0dHlwZTogXCJFeHByZXNzaW9uXCIsXG5cdFx0XHRcdHhtbDoge1xuXHRcdFx0XHRcdHNlcmlhbGl6ZTogXCJ4c2k6dHlwZVwiXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZGVmYXVsdFwiLFxuXHRcdFx0XHR0eXBlOiBcIlNlcXVlbmNlRmxvd1wiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJFeGNsdXNpdmVHYXRld2F5XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJHYXRld2F5XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJkZWZhdWx0XCIsXG5cdFx0XHRcdHR5cGU6IFwiU2VxdWVuY2VGbG93XCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkluY2x1c2l2ZUdhdGV3YXlcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkdhdGV3YXlcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImRlZmF1bHRcIixcblx0XHRcdFx0dHlwZTogXCJTZXF1ZW5jZUZsb3dcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiUGFyYWxsZWxHYXRld2F5XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJHYXRld2F5XCJcblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlJvb3RFbGVtZW50XCIsXG5cdFx0aXNBYnN0cmFjdDogdHJ1ZSxcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkJhc2VFbGVtZW50XCJcblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlJlbGF0aW9uc2hpcFwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInR5cGVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImRpcmVjdGlvblwiLFxuXHRcdFx0XHR0eXBlOiBcIlJlbGF0aW9uc2hpcERpcmVjdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwic291cmNlXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiRWxlbWVudFwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInRhcmdldFwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIkVsZW1lbnRcIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQmFzZUVsZW1lbnRcIixcblx0XHRpc0Fic3RyYWN0OiB0cnVlLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpZFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCIsXG5cdFx0XHRcdGlzSWQ6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZG9jdW1lbnRhdGlvblwiLFxuXHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50YXRpb25cIixcblx0XHRcdFx0aXNNYW55OiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImV4dGVuc2lvbkRlZmluaXRpb25zXCIsXG5cdFx0XHRcdHR5cGU6IFwiRXh0ZW5zaW9uRGVmaW5pdGlvblwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImV4dGVuc2lvbkVsZW1lbnRzXCIsXG5cdFx0XHRcdHR5cGU6IFwiRXh0ZW5zaW9uRWxlbWVudHNcIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiRXh0ZW5zaW9uXCIsXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm11c3RVbmRlcnN0YW5kXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiBmYWxzZSxcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIkJvb2xlYW5cIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJkZWZpbml0aW9uXCIsXG5cdFx0XHRcdHR5cGU6IFwiRXh0ZW5zaW9uRGVmaW5pdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJFeHRlbnNpb25EZWZpbml0aW9uXCIsXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImV4dGVuc2lvbkF0dHJpYnV0ZURlZmluaXRpb25zXCIsXG5cdFx0XHRcdHR5cGU6IFwiRXh0ZW5zaW9uQXR0cmlidXRlRGVmaW5pdGlvblwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkV4dGVuc2lvbkF0dHJpYnV0ZURlZmluaXRpb25cIixcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwidHlwZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaXNSZWZlcmVuY2VcIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImV4dGVuc2lvbkRlZmluaXRpb25cIixcblx0XHRcdFx0dHlwZTogXCJFeHRlbnNpb25EZWZpbml0aW9uXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkV4dGVuc2lvbkVsZW1lbnRzXCIsXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInZhbHVlUmVmXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiRWxlbWVudFwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInZhbHVlc1wiLFxuXHRcdFx0XHR0eXBlOiBcIkVsZW1lbnRcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImV4dGVuc2lvbkF0dHJpYnV0ZURlZmluaXRpb25cIixcblx0XHRcdFx0dHlwZTogXCJFeHRlbnNpb25BdHRyaWJ1dGVEZWZpbml0aW9uXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkRvY3VtZW50YXRpb25cIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkJhc2VFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJ0ZXh0XCIsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCIsXG5cdFx0XHRcdGlzQm9keTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJ0ZXh0Rm9ybWF0XCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiBcInRleHQvcGxhaW5cIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJFdmVudFwiLFxuXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJGbG93Tm9kZVwiLFxuXHRcdFx0XCJJbnRlcmFjdGlvbk5vZGVcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInByb3BlcnRpZXNcIixcblx0XHRcdFx0dHlwZTogXCJQcm9wZXJ0eVwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkludGVybWVkaWF0ZUNhdGNoRXZlbnRcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkNhdGNoRXZlbnRcIlxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiSW50ZXJtZWRpYXRlVGhyb3dFdmVudFwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiVGhyb3dFdmVudFwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJFbmRFdmVudFwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiVGhyb3dFdmVudFwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJTdGFydEV2ZW50XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJDYXRjaEV2ZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpc0ludGVycnVwdGluZ1wiLFxuXHRcdFx0XHRcImRlZmF1bHRcIjogdHJ1ZSxcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIkJvb2xlYW5cIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiVGhyb3dFdmVudFwiLFxuXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJFdmVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZGF0YUlucHV0c1wiLFxuXHRcdFx0XHR0eXBlOiBcIkRhdGFJbnB1dFwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZGF0YUlucHV0QXNzb2NpYXRpb25zXCIsXG5cdFx0XHRcdHR5cGU6IFwiRGF0YUlucHV0QXNzb2NpYXRpb25cIixcblx0XHRcdFx0aXNNYW55OiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImlucHV0U2V0XCIsXG5cdFx0XHRcdHR5cGU6IFwiSW5wdXRTZXRcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJldmVudERlZmluaXRpb25zXCIsXG5cdFx0XHRcdHR5cGU6IFwiRXZlbnREZWZpbml0aW9uXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJldmVudERlZmluaXRpb25SZWZcIixcblx0XHRcdFx0dHlwZTogXCJFdmVudERlZmluaXRpb25cIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQ2F0Y2hFdmVudFwiLFxuXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJFdmVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwicGFyYWxsZWxNdWx0aXBsZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiLFxuXHRcdFx0XHRcImRlZmF1bHRcIjogZmFsc2Vcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZGF0YU91dHB1dHNcIixcblx0XHRcdFx0dHlwZTogXCJEYXRhT3V0cHV0XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJkYXRhT3V0cHV0QXNzb2NpYXRpb25zXCIsXG5cdFx0XHRcdHR5cGU6IFwiRGF0YU91dHB1dEFzc29jaWF0aW9uXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJvdXRwdXRTZXRcIixcblx0XHRcdFx0dHlwZTogXCJPdXRwdXRTZXRcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJldmVudERlZmluaXRpb25zXCIsXG5cdFx0XHRcdHR5cGU6IFwiRXZlbnREZWZpbml0aW9uXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJldmVudERlZmluaXRpb25SZWZcIixcblx0XHRcdFx0dHlwZTogXCJFdmVudERlZmluaXRpb25cIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQm91bmRhcnlFdmVudFwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiQ2F0Y2hFdmVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY2FuY2VsQWN0aXZpdHlcIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IHRydWUsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJCb29sZWFuXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiYXR0YWNoZWRUb1JlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkFjdGl2aXR5XCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkV2ZW50RGVmaW5pdGlvblwiLFxuXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJSb290RWxlbWVudFwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJDYW5jZWxFdmVudERlZmluaXRpb25cIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkV2ZW50RGVmaW5pdGlvblwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJFcnJvckV2ZW50RGVmaW5pdGlvblwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiRXZlbnREZWZpbml0aW9uXCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJlcnJvclJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkVycm9yXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlRlcm1pbmF0ZUV2ZW50RGVmaW5pdGlvblwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiRXZlbnREZWZpbml0aW9uXCJcblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkVzY2FsYXRpb25FdmVudERlZmluaXRpb25cIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkV2ZW50RGVmaW5pdGlvblwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZXNjYWxhdGlvblJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkVzY2FsYXRpb25cIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiRXNjYWxhdGlvblwiLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJzdHJ1Y3R1cmVSZWZcIixcblx0XHRcdFx0dHlwZTogXCJJdGVtRGVmaW5pdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImVzY2FsYXRpb25Db2RlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJSb290RWxlbWVudFwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJDb21wZW5zYXRlRXZlbnREZWZpbml0aW9uXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJFdmVudERlZmluaXRpb25cIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIndhaXRGb3JDb21wbGV0aW9uXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJCb29sZWFuXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImFjdGl2aXR5UmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiQWN0aXZpdHlcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiVGltZXJFdmVudERlZmluaXRpb25cIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkV2ZW50RGVmaW5pdGlvblwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwidGltZURhdGVcIixcblx0XHRcdFx0dHlwZTogXCJFeHByZXNzaW9uXCIsXG5cdFx0XHRcdHhtbDoge1xuXHRcdFx0XHRcdHNlcmlhbGl6ZTogXCJ4c2k6dHlwZVwiXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwidGltZUN5Y2xlXCIsXG5cdFx0XHRcdHR5cGU6IFwiRXhwcmVzc2lvblwiLFxuXHRcdFx0XHR4bWw6IHtcblx0XHRcdFx0XHRzZXJpYWxpemU6IFwieHNpOnR5cGVcIlxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInRpbWVEdXJhdGlvblwiLFxuXHRcdFx0XHR0eXBlOiBcIkV4cHJlc3Npb25cIixcblx0XHRcdFx0eG1sOiB7XG5cdFx0XHRcdFx0c2VyaWFsaXplOiBcInhzaTp0eXBlXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiTGlua0V2ZW50RGVmaW5pdGlvblwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiRXZlbnREZWZpbml0aW9uXCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJ0YXJnZXRcIixcblx0XHRcdFx0dHlwZTogXCJMaW5rRXZlbnREZWZpbml0aW9uXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwic291cmNlXCIsXG5cdFx0XHRcdHR5cGU6IFwiTGlua0V2ZW50RGVmaW5pdGlvblwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJNZXNzYWdlRXZlbnREZWZpbml0aW9uXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJFdmVudERlZmluaXRpb25cIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm1lc3NhZ2VSZWZcIixcblx0XHRcdFx0dHlwZTogXCJNZXNzYWdlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwib3BlcmF0aW9uUmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiT3BlcmF0aW9uXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkNvbmRpdGlvbmFsRXZlbnREZWZpbml0aW9uXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJFdmVudERlZmluaXRpb25cIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImNvbmRpdGlvblwiLFxuXHRcdFx0XHR0eXBlOiBcIkV4cHJlc3Npb25cIixcblx0XHRcdFx0eG1sOiB7XG5cdFx0XHRcdFx0c2VyaWFsaXplOiBcInhzaTp0eXBlXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiU2lnbmFsRXZlbnREZWZpbml0aW9uXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJFdmVudERlZmluaXRpb25cIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInNpZ25hbFJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIlNpZ25hbFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJTaWduYWxcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIlJvb3RFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJzdHJ1Y3R1cmVSZWZcIixcblx0XHRcdFx0dHlwZTogXCJJdGVtRGVmaW5pdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJJbXBsaWNpdFRocm93RXZlbnRcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIlRocm93RXZlbnRcIlxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiRGF0YVN0YXRlXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkl0ZW1Bd2FyZUVsZW1lbnRcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkJhc2VFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpdGVtU3ViamVjdFJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkl0ZW1EZWZpbml0aW9uXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZGF0YVN0YXRlXCIsXG5cdFx0XHRcdHR5cGU6IFwiRGF0YVN0YXRlXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkRhdGFBc3NvY2lhdGlvblwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImFzc2lnbm1lbnRcIixcblx0XHRcdFx0dHlwZTogXCJBc3NpZ25tZW50XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJzb3VyY2VSZWZcIixcblx0XHRcdFx0dHlwZTogXCJJdGVtQXdhcmVFbGVtZW50XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwidGFyZ2V0UmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiSXRlbUF3YXJlRWxlbWVudFwiLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuXHRcdFx0XHR0eXBlOiBcIkZvcm1hbEV4cHJlc3Npb25cIixcblx0XHRcdFx0eG1sOiB7XG5cdFx0XHRcdFx0c2VyaWFsaXplOiBcInByb3BlcnR5XCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiRGF0YUlucHV0XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJJdGVtQXdhcmVFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpc0NvbGxlY3Rpb25cIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImlucHV0U2V0UmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiSW5wdXRTZXRcIixcblx0XHRcdFx0aXNWaXJ0dWFsOiB0cnVlLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImlucHV0U2V0V2l0aE9wdGlvbmFsXCIsXG5cdFx0XHRcdHR5cGU6IFwiSW5wdXRTZXRcIixcblx0XHRcdFx0aXNWaXJ0dWFsOiB0cnVlLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImlucHV0U2V0V2l0aFdoaWxlRXhlY3V0aW5nXCIsXG5cdFx0XHRcdHR5cGU6IFwiSW5wdXRTZXRcIixcblx0XHRcdFx0aXNWaXJ0dWFsOiB0cnVlLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJEYXRhT3V0cHV0XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJJdGVtQXdhcmVFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpc0NvbGxlY3Rpb25cIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm91dHB1dFNldFJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIk91dHB1dFNldFwiLFxuXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWUsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwib3V0cHV0U2V0V2l0aE9wdGlvbmFsXCIsXG5cdFx0XHRcdHR5cGU6IFwiT3V0cHV0U2V0XCIsXG5cdFx0XHRcdGlzVmlydHVhbDogdHJ1ZSxcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJvdXRwdXRTZXRXaXRoV2hpbGVFeGVjdXRpbmdcIixcblx0XHRcdFx0dHlwZTogXCJPdXRwdXRTZXRcIixcblx0XHRcdFx0aXNWaXJ0dWFsOiB0cnVlLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJJbnB1dFNldFwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImRhdGFJbnB1dFJlZnNcIixcblx0XHRcdFx0dHlwZTogXCJEYXRhSW5wdXRcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJvcHRpb25hbElucHV0UmVmc1wiLFxuXHRcdFx0XHR0eXBlOiBcIkRhdGFJbnB1dFwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIndoaWxlRXhlY3V0aW5nSW5wdXRSZWZzXCIsXG5cdFx0XHRcdHR5cGU6IFwiRGF0YUlucHV0XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwib3V0cHV0U2V0UmVmc1wiLFxuXHRcdFx0XHR0eXBlOiBcIk91dHB1dFNldFwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJPdXRwdXRTZXRcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkJhc2VFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJkYXRhT3V0cHV0UmVmc1wiLFxuXHRcdFx0XHR0eXBlOiBcIkRhdGFPdXRwdXRcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpbnB1dFNldFJlZnNcIixcblx0XHRcdFx0dHlwZTogXCJJbnB1dFNldFwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm9wdGlvbmFsT3V0cHV0UmVmc1wiLFxuXHRcdFx0XHR0eXBlOiBcIkRhdGFPdXRwdXRcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJ3aGlsZUV4ZWN1dGluZ091dHB1dFJlZnNcIixcblx0XHRcdFx0dHlwZTogXCJEYXRhT3V0cHV0XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlByb3BlcnR5XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJJdGVtQXdhcmVFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiRGF0YUlucHV0QXNzb2NpYXRpb25cIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkRhdGFBc3NvY2lhdGlvblwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJEYXRhT3V0cHV0QXNzb2NpYXRpb25cIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkRhdGFBc3NvY2lhdGlvblwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJJbnB1dE91dHB1dFNwZWNpZmljYXRpb25cIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkJhc2VFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJkYXRhSW5wdXRzXCIsXG5cdFx0XHRcdHR5cGU6IFwiRGF0YUlucHV0XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJkYXRhT3V0cHV0c1wiLFxuXHRcdFx0XHR0eXBlOiBcIkRhdGFPdXRwdXRcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImlucHV0U2V0c1wiLFxuXHRcdFx0XHR0eXBlOiBcIklucHV0U2V0XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJvdXRwdXRTZXRzXCIsXG5cdFx0XHRcdHR5cGU6IFwiT3V0cHV0U2V0XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiRGF0YU9iamVjdFwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiRmxvd0VsZW1lbnRcIixcblx0XHRcdFwiSXRlbUF3YXJlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaXNDb2xsZWN0aW9uXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiBmYWxzZSxcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIkJvb2xlYW5cIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiSW5wdXRPdXRwdXRCaW5kaW5nXCIsXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImlucHV0RGF0YVJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIklucHV0U2V0XCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwib3V0cHV0RGF0YVJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIk91dHB1dFNldFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm9wZXJhdGlvblJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIk9wZXJhdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJBc3NpZ25tZW50XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZnJvbVwiLFxuXHRcdFx0XHR0eXBlOiBcIkV4cHJlc3Npb25cIixcblx0XHRcdFx0eG1sOiB7XG5cdFx0XHRcdFx0c2VyaWFsaXplOiBcInhzaTp0eXBlXCJcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJ0b1wiLFxuXHRcdFx0XHR0eXBlOiBcIkV4cHJlc3Npb25cIixcblx0XHRcdFx0eG1sOiB7XG5cdFx0XHRcdFx0c2VyaWFsaXplOiBcInhzaTp0eXBlXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiRGF0YVN0b3JlXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJSb290RWxlbWVudFwiLFxuXHRcdFx0XCJJdGVtQXdhcmVFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJjYXBhY2l0eVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiSW50ZWdlclwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImlzVW5saW1pdGVkXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiB0cnVlLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJEYXRhU3RvcmVSZWZlcmVuY2VcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkl0ZW1Bd2FyZUVsZW1lbnRcIixcblx0XHRcdFwiRmxvd0VsZW1lbnRcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImRhdGFTdG9yZVJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkRhdGFTdG9yZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJEYXRhT2JqZWN0UmVmZXJlbmNlXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJJdGVtQXdhcmVFbGVtZW50XCIsXG5cdFx0XHRcIkZsb3dFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJkYXRhT2JqZWN0UmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiRGF0YU9iamVjdFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJDb252ZXJzYXRpb25MaW5rXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwic291cmNlUmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiSW50ZXJhY3Rpb25Ob2RlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwidGFyZ2V0UmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiSW50ZXJhY3Rpb25Ob2RlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkNvbnZlcnNhdGlvbkFzc29jaWF0aW9uXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaW5uZXJDb252ZXJzYXRpb25Ob2RlUmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiQ29udmVyc2F0aW9uTm9kZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm91dGVyQ29udmVyc2F0aW9uTm9kZVJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkNvbnZlcnNhdGlvbk5vZGVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQ2FsbENvbnZlcnNhdGlvblwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiQ29udmVyc2F0aW9uTm9kZVwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY2FsbGVkQ29sbGFib3JhdGlvblJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkNvbGxhYm9yYXRpb25cIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJwYXJ0aWNpcGFudEFzc29jaWF0aW9uc1wiLFxuXHRcdFx0XHR0eXBlOiBcIlBhcnRpY2lwYW50QXNzb2NpYXRpb25cIixcblx0XHRcdFx0aXNNYW55OiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJDb252ZXJzYXRpb25cIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkNvbnZlcnNhdGlvbk5vZGVcIlxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiU3ViQ29udmVyc2F0aW9uXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJDb252ZXJzYXRpb25Ob2RlXCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJjb252ZXJzYXRpb25Ob2Rlc1wiLFxuXHRcdFx0XHR0eXBlOiBcIkNvbnZlcnNhdGlvbk5vZGVcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJDb252ZXJzYXRpb25Ob2RlXCIsXG5cdFx0aXNBYnN0cmFjdDogdHJ1ZSxcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkludGVyYWN0aW9uTm9kZVwiLFxuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwicGFydGljaXBhbnRSZWZcIixcblx0XHRcdFx0dHlwZTogXCJQYXJ0aWNpcGFudFwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm1lc3NhZ2VGbG93UmVmc1wiLFxuXHRcdFx0XHR0eXBlOiBcIk1lc3NhZ2VGbG93XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY29ycmVsYXRpb25LZXlzXCIsXG5cdFx0XHRcdHR5cGU6IFwiQ29ycmVsYXRpb25LZXlcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJHbG9iYWxDb252ZXJzYXRpb25cIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkNvbGxhYm9yYXRpb25cIlxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiUGFydG5lckVudGl0eVwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiUm9vdEVsZW1lbnRcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInBhcnRpY2lwYW50UmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiUGFydGljaXBhbnRcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiUGFydG5lclJvbGVcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIlJvb3RFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJwYXJ0aWNpcGFudFJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIlBhcnRpY2lwYW50XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkNvcnJlbGF0aW9uUHJvcGVydHlcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIlJvb3RFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJjb3JyZWxhdGlvblByb3BlcnR5UmV0cmlldmFsRXhwcmVzc2lvblwiLFxuXHRcdFx0XHR0eXBlOiBcIkNvcnJlbGF0aW9uUHJvcGVydHlSZXRyaWV2YWxFeHByZXNzaW9uXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJ0eXBlXCIsXG5cdFx0XHRcdHR5cGU6IFwiSXRlbURlZmluaXRpb25cIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiRXJyb3JcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIlJvb3RFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJzdHJ1Y3R1cmVSZWZcIixcblx0XHRcdFx0dHlwZTogXCJJdGVtRGVmaW5pdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImVycm9yQ29kZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkNvcnJlbGF0aW9uS2V5XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY29ycmVsYXRpb25Qcm9wZXJ0eVJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkNvcnJlbGF0aW9uUHJvcGVydHlcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiRXhwcmVzc2lvblwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuXHRcdF0sXG5cdFx0aXNBYnN0cmFjdDogZmFsc2UsXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImJvZHlcIixcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIixcblx0XHRcdFx0aXNCb2R5OiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJGb3JtYWxFeHByZXNzaW9uXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJFeHByZXNzaW9uXCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJsYW5ndWFnZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZXZhbHVhdGVzVG9UeXBlUmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiSXRlbURlZmluaXRpb25cIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiTWVzc2FnZVwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiUm9vdEVsZW1lbnRcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIml0ZW1SZWZcIixcblx0XHRcdFx0dHlwZTogXCJJdGVtRGVmaW5pdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJJdGVtRGVmaW5pdGlvblwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiUm9vdEVsZW1lbnRcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIml0ZW1LaW5kXCIsXG5cdFx0XHRcdHR5cGU6IFwiSXRlbUtpbmRcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInN0cnVjdHVyZVJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaXNDb2xsZWN0aW9uXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiBmYWxzZSxcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIkJvb2xlYW5cIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpbXBvcnRcIixcblx0XHRcdFx0dHlwZTogXCJJbXBvcnRcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiRmxvd0VsZW1lbnRcIixcblx0XHRpc0Fic3RyYWN0OiB0cnVlLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImF1ZGl0aW5nXCIsXG5cdFx0XHRcdHR5cGU6IFwiQXVkaXRpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJtb25pdG9yaW5nXCIsXG5cdFx0XHRcdHR5cGU6IFwiTW9uaXRvcmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImNhdGVnb3J5VmFsdWVSZWZcIixcblx0XHRcdFx0dHlwZTogXCJDYXRlZ29yeVZhbHVlXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlNlcXVlbmNlRmxvd1wiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiRmxvd0VsZW1lbnRcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImlzSW1tZWRpYXRlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJCb29sZWFuXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY29uZGl0aW9uRXhwcmVzc2lvblwiLFxuXHRcdFx0XHR0eXBlOiBcIkV4cHJlc3Npb25cIixcblx0XHRcdFx0eG1sOiB7XG5cdFx0XHRcdFx0c2VyaWFsaXplOiBcInhzaTp0eXBlXCJcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJzb3VyY2VSZWZcIixcblx0XHRcdFx0dHlwZTogXCJGbG93Tm9kZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInRhcmdldFJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkZsb3dOb2RlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkZsb3dFbGVtZW50c0NvbnRhaW5lclwiLFxuXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibGFuZVNldHNcIixcblx0XHRcdFx0dHlwZTogXCJMYW5lU2V0XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJmbG93RWxlbWVudHNcIixcblx0XHRcdFx0dHlwZTogXCJGbG93RWxlbWVudFwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkNhbGxhYmxlRWxlbWVudFwiLFxuXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJSb290RWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaW9TcGVjaWZpY2F0aW9uXCIsXG5cdFx0XHRcdHR5cGU6IFwiSW5wdXRPdXRwdXRTcGVjaWZpY2F0aW9uXCIsXG5cdFx0XHRcdHhtbDoge1xuXHRcdFx0XHRcdHNlcmlhbGl6ZTogXCJwcm9wZXJ0eVwiXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwic3VwcG9ydGVkSW50ZXJmYWNlUmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiSW50ZXJmYWNlXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaW9CaW5kaW5nXCIsXG5cdFx0XHRcdHR5cGU6IFwiSW5wdXRPdXRwdXRCaW5kaW5nXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZSxcblx0XHRcdFx0eG1sOiB7XG5cdFx0XHRcdFx0c2VyaWFsaXplOiBcInByb3BlcnR5XCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiRmxvd05vZGVcIixcblx0XHRpc0Fic3RyYWN0OiB0cnVlLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiRmxvd0VsZW1lbnRcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImluY29taW5nXCIsXG5cdFx0XHRcdHR5cGU6IFwiU2VxdWVuY2VGbG93XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwib3V0Z29pbmdcIixcblx0XHRcdFx0dHlwZTogXCJTZXF1ZW5jZUZsb3dcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJsYW5lc1wiLFxuXHRcdFx0XHR0eXBlOiBcIkxhbmVcIixcblx0XHRcdFx0aXNWaXJ0dWFsOiB0cnVlLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJDb3JyZWxhdGlvblByb3BlcnR5UmV0cmlldmFsRXhwcmVzc2lvblwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm1lc3NhZ2VQYXRoXCIsXG5cdFx0XHRcdHR5cGU6IFwiRm9ybWFsRXhwcmVzc2lvblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm1lc3NhZ2VSZWZcIixcblx0XHRcdFx0dHlwZTogXCJNZXNzYWdlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkNvcnJlbGF0aW9uUHJvcGVydHlCaW5kaW5nXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZGF0YVBhdGhcIixcblx0XHRcdFx0dHlwZTogXCJGb3JtYWxFeHByZXNzaW9uXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY29ycmVsYXRpb25Qcm9wZXJ0eVJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkNvcnJlbGF0aW9uUHJvcGVydHlcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiUmVzb3VyY2VcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIlJvb3RFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJyZXNvdXJjZVBhcmFtZXRlcnNcIixcblx0XHRcdFx0dHlwZTogXCJSZXNvdXJjZVBhcmFtZXRlclwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlJlc291cmNlUGFyYW1ldGVyXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaXNSZXF1aXJlZFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInR5cGVcIixcblx0XHRcdFx0dHlwZTogXCJJdGVtRGVmaW5pdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJDb3JyZWxhdGlvblN1YnNjcmlwdGlvblwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImNvcnJlbGF0aW9uS2V5UmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiQ29ycmVsYXRpb25LZXlcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJjb3JyZWxhdGlvblByb3BlcnR5QmluZGluZ1wiLFxuXHRcdFx0XHR0eXBlOiBcIkNvcnJlbGF0aW9uUHJvcGVydHlCaW5kaW5nXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiTWVzc2FnZUZsb3dcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkJhc2VFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJzb3VyY2VSZWZcIixcblx0XHRcdFx0dHlwZTogXCJJbnRlcmFjdGlvbk5vZGVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJ0YXJnZXRSZWZcIixcblx0XHRcdFx0dHlwZTogXCJJbnRlcmFjdGlvbk5vZGVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJtZXNzYWdlUmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiTWVzc2FnZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJNZXNzYWdlRmxvd0Fzc29jaWF0aW9uXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaW5uZXJNZXNzYWdlRmxvd1JlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIk1lc3NhZ2VGbG93XCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwib3V0ZXJNZXNzYWdlRmxvd1JlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIk1lc3NhZ2VGbG93XCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkludGVyYWN0aW9uTm9kZVwiLFxuXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImluY29taW5nQ29udmVyc2F0aW9uTGlua3NcIixcblx0XHRcdFx0dHlwZTogXCJDb252ZXJzYXRpb25MaW5rXCIsXG5cdFx0XHRcdGlzVmlydHVhbDogdHJ1ZSxcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJvdXRnb2luZ0NvbnZlcnNhdGlvbkxpbmtzXCIsXG5cdFx0XHRcdHR5cGU6IFwiQ29udmVyc2F0aW9uTGlua1wiLFxuXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWUsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlBhcnRpY2lwYW50XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJJbnRlcmFjdGlvbk5vZGVcIixcblx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImludGVyZmFjZVJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkludGVyZmFjZVwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInBhcnRpY2lwYW50TXVsdGlwbGljaXR5XCIsXG5cdFx0XHRcdHR5cGU6IFwiUGFydGljaXBhbnRNdWx0aXBsaWNpdHlcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJlbmRQb2ludFJlZnNcIixcblx0XHRcdFx0dHlwZTogXCJFbmRQb2ludFwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInByb2Nlc3NSZWZcIixcblx0XHRcdFx0dHlwZTogXCJQcm9jZXNzXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlBhcnRpY2lwYW50QXNzb2NpYXRpb25cIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkJhc2VFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpbm5lclBhcnRpY2lwYW50UmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiUGFydGljaXBhbnRcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJvdXRlclBhcnRpY2lwYW50UmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiUGFydGljaXBhbnRcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiUGFydGljaXBhbnRNdWx0aXBsaWNpdHlcIixcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibWluaW11bVwiLFxuXHRcdFx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIkludGVnZXJcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJtYXhpbXVtXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiAxLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiSW50ZWdlclwiXG5cdFx0XHR9XG5cdFx0XSxcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkJhc2VFbGVtZW50XCJcblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkNvbGxhYm9yYXRpb25cIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIlJvb3RFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpc0Nsb3NlZFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInBhcnRpY2lwYW50c1wiLFxuXHRcdFx0XHR0eXBlOiBcIlBhcnRpY2lwYW50XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJtZXNzYWdlRmxvd3NcIixcblx0XHRcdFx0dHlwZTogXCJNZXNzYWdlRmxvd1wiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiYXJ0aWZhY3RzXCIsXG5cdFx0XHRcdHR5cGU6IFwiQXJ0aWZhY3RcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImNvbnZlcnNhdGlvbnNcIixcblx0XHRcdFx0dHlwZTogXCJDb252ZXJzYXRpb25Ob2RlXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJjb252ZXJzYXRpb25Bc3NvY2lhdGlvbnNcIixcblx0XHRcdFx0dHlwZTogXCJDb252ZXJzYXRpb25Bc3NvY2lhdGlvblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInBhcnRpY2lwYW50QXNzb2NpYXRpb25zXCIsXG5cdFx0XHRcdHR5cGU6IFwiUGFydGljaXBhbnRBc3NvY2lhdGlvblwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibWVzc2FnZUZsb3dBc3NvY2lhdGlvbnNcIixcblx0XHRcdFx0dHlwZTogXCJNZXNzYWdlRmxvd0Fzc29jaWF0aW9uXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJjb3JyZWxhdGlvbktleXNcIixcblx0XHRcdFx0dHlwZTogXCJDb3JyZWxhdGlvbktleVwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY2hvcmVvZ3JhcGh5UmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiQ2hvcmVvZ3JhcGh5XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY29udmVyc2F0aW9uTGlua3NcIixcblx0XHRcdFx0dHlwZTogXCJDb252ZXJzYXRpb25MaW5rXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQ2hvcmVvZ3JhcGh5QWN0aXZpdHlcIixcblx0XHRpc0Fic3RyYWN0OiB0cnVlLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiRmxvd05vZGVcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInBhcnRpY2lwYW50UmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiUGFydGljaXBhbnRcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpbml0aWF0aW5nUGFydGljaXBhbnRSZWZcIixcblx0XHRcdFx0dHlwZTogXCJQYXJ0aWNpcGFudFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImNvcnJlbGF0aW9uS2V5c1wiLFxuXHRcdFx0XHR0eXBlOiBcIkNvcnJlbGF0aW9uS2V5XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJsb29wVHlwZVwiLFxuXHRcdFx0XHR0eXBlOiBcIkNob3Jlb2dyYXBoeUxvb3BUeXBlXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiBcIk5vbmVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJDYWxsQ2hvcmVvZ3JhcGh5XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJDaG9yZW9ncmFwaHlBY3Rpdml0eVwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY2FsbGVkQ2hvcmVvZ3JhcGh5UmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiQ2hvcmVvZ3JhcGh5XCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwicGFydGljaXBhbnRBc3NvY2lhdGlvbnNcIixcblx0XHRcdFx0dHlwZTogXCJQYXJ0aWNpcGFudEFzc29jaWF0aW9uXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiU3ViQ2hvcmVvZ3JhcGh5XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJDaG9yZW9ncmFwaHlBY3Rpdml0eVwiLFxuXHRcdFx0XCJGbG93RWxlbWVudHNDb250YWluZXJcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImFydGlmYWN0c1wiLFxuXHRcdFx0XHR0eXBlOiBcIkFydGlmYWN0XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQ2hvcmVvZ3JhcGh5VGFza1wiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiQ2hvcmVvZ3JhcGh5QWN0aXZpdHlcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm1lc3NhZ2VGbG93UmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiTWVzc2FnZUZsb3dcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQ2hvcmVvZ3JhcGh5XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJDb2xsYWJvcmF0aW9uXCIsXG5cdFx0XHRcIkZsb3dFbGVtZW50c0NvbnRhaW5lclwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJHbG9iYWxDaG9yZW9ncmFwaHlUYXNrXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJDaG9yZW9ncmFwaHlcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImluaXRpYXRpbmdQYXJ0aWNpcGFudFJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIlBhcnRpY2lwYW50XCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlRleHRBbm5vdGF0aW9uXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJBcnRpZmFjdFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwidGV4dFwiLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInRleHRGb3JtYXRcIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkdyb3VwXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJBcnRpZmFjdFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY2F0ZWdvcnlWYWx1ZVJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkNhdGVnb3J5VmFsdWVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQXNzb2NpYXRpb25cIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkFydGlmYWN0XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJhc3NvY2lhdGlvbkRpcmVjdGlvblwiLFxuXHRcdFx0XHR0eXBlOiBcIkFzc29jaWF0aW9uRGlyZWN0aW9uXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJzb3VyY2VSZWZcIixcblx0XHRcdFx0dHlwZTogXCJCYXNlRWxlbWVudFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInRhcmdldFJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkJhc2VFbGVtZW50XCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkNhdGVnb3J5XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJSb290RWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY2F0ZWdvcnlWYWx1ZVwiLFxuXHRcdFx0XHR0eXBlOiBcIkNhdGVnb3J5VmFsdWVcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJBcnRpZmFjdFwiLFxuXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJDYXRlZ29yeVZhbHVlXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY2F0ZWdvcml6ZWRGbG93RWxlbWVudHNcIixcblx0XHRcdFx0dHlwZTogXCJGbG93RWxlbWVudFwiLFxuXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWUsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwidmFsdWVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJBY3Rpdml0eVwiLFxuXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJGbG93Tm9kZVwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaXNGb3JDb21wZW5zYXRpb25cIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImRlZmF1bHRcIixcblx0XHRcdFx0dHlwZTogXCJTZXF1ZW5jZUZsb3dcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpb1NwZWNpZmljYXRpb25cIixcblx0XHRcdFx0dHlwZTogXCJJbnB1dE91dHB1dFNwZWNpZmljYXRpb25cIixcblx0XHRcdFx0eG1sOiB7XG5cdFx0XHRcdFx0c2VyaWFsaXplOiBcInByb3BlcnR5XCJcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJib3VuZGFyeUV2ZW50UmVmc1wiLFxuXHRcdFx0XHR0eXBlOiBcIkJvdW5kYXJ5RXZlbnRcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJwcm9wZXJ0aWVzXCIsXG5cdFx0XHRcdHR5cGU6IFwiUHJvcGVydHlcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImRhdGFJbnB1dEFzc29jaWF0aW9uc1wiLFxuXHRcdFx0XHR0eXBlOiBcIkRhdGFJbnB1dEFzc29jaWF0aW9uXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJkYXRhT3V0cHV0QXNzb2NpYXRpb25zXCIsXG5cdFx0XHRcdHR5cGU6IFwiRGF0YU91dHB1dEFzc29jaWF0aW9uXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJzdGFydFF1YW50aXR5XCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiAxLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiSW50ZWdlclwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInJlc291cmNlc1wiLFxuXHRcdFx0XHR0eXBlOiBcIlJlc291cmNlUm9sZVwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY29tcGxldGlvblF1YW50aXR5XCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiAxLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiSW50ZWdlclwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImxvb3BDaGFyYWN0ZXJpc3RpY3NcIixcblx0XHRcdFx0dHlwZTogXCJMb29wQ2hhcmFjdGVyaXN0aWNzXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlNlcnZpY2VUYXNrXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJUYXNrXCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpbXBsZW1lbnRhdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwib3BlcmF0aW9uUmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiT3BlcmF0aW9uXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlN1YlByb2Nlc3NcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkFjdGl2aXR5XCIsXG5cdFx0XHRcIkZsb3dFbGVtZW50c0NvbnRhaW5lclwiLFxuXHRcdFx0XCJJbnRlcmFjdGlvbk5vZGVcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInRyaWdnZXJlZEJ5RXZlbnRcIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImFydGlmYWN0c1wiLFxuXHRcdFx0XHR0eXBlOiBcIkFydGlmYWN0XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiTG9vcENoYXJhY3RlcmlzdGljc1wiLFxuXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJNdWx0aUluc3RhbmNlTG9vcENoYXJhY3RlcmlzdGljc1wiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiTG9vcENoYXJhY3RlcmlzdGljc1wiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaXNTZXF1ZW50aWFsXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiBmYWxzZSxcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIkJvb2xlYW5cIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJiZWhhdmlvclwiLFxuXHRcdFx0XHR0eXBlOiBcIk11bHRpSW5zdGFuY2VCZWhhdmlvclwiLFxuXHRcdFx0XHRcImRlZmF1bHRcIjogXCJBbGxcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImxvb3BDYXJkaW5hbGl0eVwiLFxuXHRcdFx0XHR0eXBlOiBcIkV4cHJlc3Npb25cIixcblx0XHRcdFx0eG1sOiB7XG5cdFx0XHRcdFx0c2VyaWFsaXplOiBcInhzaTp0eXBlXCJcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJsb29wRGF0YUlucHV0UmVmXCIsXG5cdFx0XHRcdHR5cGU6IFwiSXRlbUF3YXJlRWxlbWVudFwiLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJsb29wRGF0YU91dHB1dFJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkl0ZW1Bd2FyZUVsZW1lbnRcIixcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaW5wdXREYXRhSXRlbVwiLFxuXHRcdFx0XHR0eXBlOiBcIkRhdGFJbnB1dFwiLFxuXHRcdFx0XHR4bWw6IHtcblx0XHRcdFx0XHRzZXJpYWxpemU6IFwicHJvcGVydHlcIlxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm91dHB1dERhdGFJdGVtXCIsXG5cdFx0XHRcdHR5cGU6IFwiRGF0YU91dHB1dFwiLFxuXHRcdFx0XHR4bWw6IHtcblx0XHRcdFx0XHRzZXJpYWxpemU6IFwicHJvcGVydHlcIlxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImNvbXBsZXhCZWhhdmlvckRlZmluaXRpb25cIixcblx0XHRcdFx0dHlwZTogXCJDb21wbGV4QmVoYXZpb3JEZWZpbml0aW9uXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJjb21wbGV0aW9uQ29uZGl0aW9uXCIsXG5cdFx0XHRcdHR5cGU6IFwiRXhwcmVzc2lvblwiLFxuXHRcdFx0XHR4bWw6IHtcblx0XHRcdFx0XHRzZXJpYWxpemU6IFwieHNpOnR5cGVcIlxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm9uZUJlaGF2aW9yRXZlbnRSZWZcIixcblx0XHRcdFx0dHlwZTogXCJFdmVudERlZmluaXRpb25cIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJub25lQmVoYXZpb3JFdmVudFJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIkV2ZW50RGVmaW5pdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJTdGFuZGFyZExvb3BDaGFyYWN0ZXJpc3RpY3NcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkxvb3BDaGFyYWN0ZXJpc3RpY3NcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInRlc3RCZWZvcmVcIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImxvb3BDb25kaXRpb25cIixcblx0XHRcdFx0dHlwZTogXCJFeHByZXNzaW9uXCIsXG5cdFx0XHRcdHhtbDoge1xuXHRcdFx0XHRcdHNlcmlhbGl6ZTogXCJ4c2k6dHlwZVwiXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibG9vcE1heGltdW1cIixcblx0XHRcdFx0dHlwZTogXCJJbnRlZ2VyXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQ2FsbEFjdGl2aXR5XCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJBY3Rpdml0eVwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY2FsbGVkRWxlbWVudFwiLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlRhc2tcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkFjdGl2aXR5XCIsXG5cdFx0XHRcIkludGVyYWN0aW9uTm9kZVwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJTZW5kVGFza1wiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiVGFza1wiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaW1wbGVtZW50YXRpb25cIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm9wZXJhdGlvblJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIk9wZXJhdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm1lc3NhZ2VSZWZcIixcblx0XHRcdFx0dHlwZTogXCJNZXNzYWdlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlJlY2VpdmVUYXNrXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJUYXNrXCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpbXBsZW1lbnRhdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaW5zdGFudGlhdGVcIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm9wZXJhdGlvblJlZlwiLFxuXHRcdFx0XHR0eXBlOiBcIk9wZXJhdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm1lc3NhZ2VSZWZcIixcblx0XHRcdFx0dHlwZTogXCJNZXNzYWdlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlNjcmlwdFRhc2tcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIlRhc2tcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInNjcmlwdEZvcm1hdFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwic2NyaXB0XCIsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkJ1c2luZXNzUnVsZVRhc2tcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIlRhc2tcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImltcGxlbWVudGF0aW9uXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQWRIb2NTdWJQcm9jZXNzXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJTdWJQcm9jZXNzXCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJjb21wbGV0aW9uQ29uZGl0aW9uXCIsXG5cdFx0XHRcdHR5cGU6IFwiRXhwcmVzc2lvblwiLFxuXHRcdFx0XHR4bWw6IHtcblx0XHRcdFx0XHRzZXJpYWxpemU6IFwieHNpOnR5cGVcIlxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm9yZGVyaW5nXCIsXG5cdFx0XHRcdHR5cGU6IFwiQWRIb2NPcmRlcmluZ1wiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY2FuY2VsUmVtYWluaW5nSW5zdGFuY2VzXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiB0cnVlLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJUcmFuc2FjdGlvblwiLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiU3ViUHJvY2Vzc1wiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwicHJvdG9jb2xcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm1ldGhvZFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkdsb2JhbFNjcmlwdFRhc2tcIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkdsb2JhbFRhc2tcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInNjcmlwdExhbmd1YWdlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJzY3JpcHRcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJHbG9iYWxCdXNpbmVzc1J1bGVUYXNrXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJHbG9iYWxUYXNrXCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpbXBsZW1lbnRhdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkNvbXBsZXhCZWhhdmlvckRlZmluaXRpb25cIixcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkJhc2VFbGVtZW50XCJcblx0XHRdLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJjb25kaXRpb25cIixcblx0XHRcdFx0dHlwZTogXCJGb3JtYWxFeHByZXNzaW9uXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZXZlbnRcIixcblx0XHRcdFx0dHlwZTogXCJJbXBsaWNpdFRocm93RXZlbnRcIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiUmVzb3VyY2VSb2xlXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwicmVzb3VyY2VSZWZcIixcblx0XHRcdFx0dHlwZTogXCJSZXNvdXJjZVwiLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJyZXNvdXJjZVBhcmFtZXRlckJpbmRpbmdzXCIsXG5cdFx0XHRcdHR5cGU6IFwiUmVzb3VyY2VQYXJhbWV0ZXJCaW5kaW5nXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJyZXNvdXJjZUFzc2lnbm1lbnRFeHByZXNzaW9uXCIsXG5cdFx0XHRcdHR5cGU6IFwiUmVzb3VyY2VBc3NpZ25tZW50RXhwcmVzc2lvblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJSZXNvdXJjZVBhcmFtZXRlckJpbmRpbmdcIixcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZXhwcmVzc2lvblwiLFxuXHRcdFx0XHR0eXBlOiBcIkV4cHJlc3Npb25cIixcblx0XHRcdFx0eG1sOiB7XG5cdFx0XHRcdFx0c2VyaWFsaXplOiBcInhzaTp0eXBlXCJcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJwYXJhbWV0ZXJSZWZcIixcblx0XHRcdFx0dHlwZTogXCJSZXNvdXJjZVBhcmFtZXRlclwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XSxcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkJhc2VFbGVtZW50XCJcblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlJlc291cmNlQXNzaWdubWVudEV4cHJlc3Npb25cIixcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZXhwcmVzc2lvblwiLFxuXHRcdFx0XHR0eXBlOiBcIkV4cHJlc3Npb25cIixcblx0XHRcdFx0eG1sOiB7XG5cdFx0XHRcdFx0c2VyaWFsaXplOiBcInhzaTp0eXBlXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJJbXBvcnRcIixcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaW1wb3J0VHlwZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibG9jYXRpb25cIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm5hbWVzcGFjZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkRlZmluaXRpb25zXCIsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJCYXNlRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwidGFyZ2V0TmFtZXNwYWNlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJleHByZXNzaW9uTGFuZ3VhZ2VcIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS9YUGF0aFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwidHlwZUxhbmd1YWdlXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpbXBvcnRzXCIsXG5cdFx0XHRcdHR5cGU6IFwiSW1wb3J0XCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJleHRlbnNpb25zXCIsXG5cdFx0XHRcdHR5cGU6IFwiRXh0ZW5zaW9uXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJyb290RWxlbWVudHNcIixcblx0XHRcdFx0dHlwZTogXCJSb290RWxlbWVudFwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZGlhZ3JhbXNcIixcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcImJwbW5kaTpCUE1ORGlhZ3JhbVwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImV4cG9ydGVyXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJyZWxhdGlvbnNoaXBzXCIsXG5cdFx0XHRcdHR5cGU6IFwiUmVsYXRpb25zaGlwXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJleHBvcnRlclZlcnNpb25cIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG5cdFx0XHR9XG5cdFx0XVxuXHR9XG5dO1xudmFyIGVudW1lcmF0aW9ucyA9IFtcblx0e1xuXHRcdG5hbWU6IFwiUHJvY2Vzc1R5cGVcIixcblx0XHRsaXRlcmFsVmFsdWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiTm9uZVwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIlB1YmxpY1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIlByaXZhdGVcIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiR2F0ZXdheURpcmVjdGlvblwiLFxuXHRcdGxpdGVyYWxWYWx1ZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJVbnNwZWNpZmllZFwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIkNvbnZlcmdpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJEaXZlcmdpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJNaXhlZFwiXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJFdmVudEJhc2VkR2F0ZXdheVR5cGVcIixcblx0XHRsaXRlcmFsVmFsdWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiUGFyYWxsZWxcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJFeGNsdXNpdmVcIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiUmVsYXRpb25zaGlwRGlyZWN0aW9uXCIsXG5cdFx0bGl0ZXJhbFZhbHVlczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIk5vbmVcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJGb3J3YXJkXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiQmFja3dhcmRcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJCb3RoXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkl0ZW1LaW5kXCIsXG5cdFx0bGl0ZXJhbFZhbHVlczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIlBoeXNpY2FsXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiSW5mb3JtYXRpb25cIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQ2hvcmVvZ3JhcGh5TG9vcFR5cGVcIixcblx0XHRsaXRlcmFsVmFsdWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiTm9uZVwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIlN0YW5kYXJkXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiTXVsdGlJbnN0YW5jZVNlcXVlbnRpYWxcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJNdWx0aUluc3RhbmNlUGFyYWxsZWxcIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQXNzb2NpYXRpb25EaXJlY3Rpb25cIixcblx0XHRsaXRlcmFsVmFsdWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiTm9uZVwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIk9uZVwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIkJvdGhcIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiTXVsdGlJbnN0YW5jZUJlaGF2aW9yXCIsXG5cdFx0bGl0ZXJhbFZhbHVlczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIk5vbmVcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJPbmVcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJBbGxcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJDb21wbGV4XCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkFkSG9jT3JkZXJpbmdcIixcblx0XHRsaXRlcmFsVmFsdWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiUGFyYWxsZWxcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJTZXF1ZW50aWFsXCJcblx0XHRcdH1cblx0XHRdXG5cdH1cbl07XG52YXIgcHJlZml4ID0gXCJicG1uXCI7XG52YXIgeG1sID0ge1xuXHR0YWdBbGlhczogXCJsb3dlckNhc2VcIixcblx0dHlwZVByZWZpeDogXCJ0XCJcbn07XG52YXIgQnBtblBhY2thZ2UgPSB7XG5cdG5hbWU6IG5hbWUsXG5cdHVyaTogdXJpLFxuXHRhc3NvY2lhdGlvbnM6IGFzc29jaWF0aW9ucyxcblx0dHlwZXM6IHR5cGVzLFxuXHRlbnVtZXJhdGlvbnM6IGVudW1lcmF0aW9ucyxcblx0cHJlZml4OiBwcmVmaXgsXG5cdHhtbDogeG1sXG59O1xuXG52YXIgbmFtZSQxID0gXCJCUE1ORElcIjtcbnZhciB1cmkkMSA9IFwiaHR0cDovL3d3dy5vbWcub3JnL3NwZWMvQlBNTi8yMDEwMDUyNC9ESVwiO1xudmFyIHR5cGVzJDEgPSBbXG5cdHtcblx0XHRuYW1lOiBcIkJQTU5EaWFncmFtXCIsXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInBsYW5lXCIsXG5cdFx0XHRcdHR5cGU6IFwiQlBNTlBsYW5lXCIsXG5cdFx0XHRcdHJlZGVmaW5lczogXCJkaTpEaWFncmFtI3Jvb3RFbGVtZW50XCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibGFiZWxTdHlsZVwiLFxuXHRcdFx0XHR0eXBlOiBcIkJQTU5MYWJlbFN0eWxlXCIsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJkaTpEaWFncmFtXCJcblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkJQTU5QbGFuZVwiLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJicG1uRWxlbWVudFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcImJwbW46QmFzZUVsZW1lbnRcIixcblx0XHRcdFx0cmVkZWZpbmVzOiBcImRpOkRpYWdyYW1FbGVtZW50I21vZGVsRWxlbWVudFwiXG5cdFx0XHR9XG5cdFx0XSxcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcImRpOlBsYW5lXCJcblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkJQTU5TaGFwZVwiLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJicG1uRWxlbWVudFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcImJwbW46QmFzZUVsZW1lbnRcIixcblx0XHRcdFx0cmVkZWZpbmVzOiBcImRpOkRpYWdyYW1FbGVtZW50I21vZGVsRWxlbWVudFwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImlzSG9yaXpvbnRhbFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImlzRXhwYW5kZWRcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIkJvb2xlYW5cIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpc01hcmtlclZpc2libGVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIkJvb2xlYW5cIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJsYWJlbFwiLFxuXHRcdFx0XHR0eXBlOiBcIkJQTU5MYWJlbFwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImlzTWVzc2FnZVZpc2libGVcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIkJvb2xlYW5cIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJwYXJ0aWNpcGFudEJhbmRLaW5kXCIsXG5cdFx0XHRcdHR5cGU6IFwiUGFydGljaXBhbnRCYW5kS2luZFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiY2hvcmVvZ3JhcGh5QWN0aXZpdHlTaGFwZVwiLFxuXHRcdFx0XHR0eXBlOiBcIkJQTU5TaGFwZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9XG5cdFx0XSxcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcImRpOkxhYmVsZWRTaGFwZVwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJCUE1ORWRnZVwiLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJsYWJlbFwiLFxuXHRcdFx0XHR0eXBlOiBcIkJQTU5MYWJlbFwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImJwbW5FbGVtZW50XCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiYnBtbjpCYXNlRWxlbWVudFwiLFxuXHRcdFx0XHRyZWRlZmluZXM6IFwiZGk6RGlhZ3JhbUVsZW1lbnQjbW9kZWxFbGVtZW50XCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwic291cmNlRWxlbWVudFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcImRpOkRpYWdyYW1FbGVtZW50XCIsXG5cdFx0XHRcdHJlZGVmaW5lczogXCJkaTpFZGdlI3NvdXJjZVwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInRhcmdldEVsZW1lbnRcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJkaTpEaWFncmFtRWxlbWVudFwiLFxuXHRcdFx0XHRyZWRlZmluZXM6IFwiZGk6RWRnZSN0YXJnZXRcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJtZXNzYWdlVmlzaWJsZUtpbmRcIixcblx0XHRcdFx0dHlwZTogXCJNZXNzYWdlVmlzaWJsZUtpbmRcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRcImRlZmF1bHRcIjogXCJpbml0aWF0aW5nXCJcblx0XHRcdH1cblx0XHRdLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiZGk6TGFiZWxlZEVkZ2VcIlxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQlBNTkxhYmVsXCIsXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImxhYmVsU3R5bGVcIixcblx0XHRcdFx0dHlwZTogXCJCUE1OTGFiZWxTdHlsZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlLFxuXHRcdFx0XHRyZWRlZmluZXM6IFwiZGk6RGlhZ3JhbUVsZW1lbnQjc3R5bGVcIlxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJkaTpMYWJlbFwiXG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJCUE1OTGFiZWxTdHlsZVwiLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJmb250XCIsXG5cdFx0XHRcdHR5cGU6IFwiZGM6Rm9udFwiXG5cdFx0XHR9XG5cdFx0XSxcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcImRpOlN0eWxlXCJcblx0XHRdXG5cdH1cbl07XG52YXIgZW51bWVyYXRpb25zJDEgPSBbXG5cdHtcblx0XHRuYW1lOiBcIlBhcnRpY2lwYW50QmFuZEtpbmRcIixcblx0XHRsaXRlcmFsVmFsdWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwidG9wX2luaXRpYXRpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJtaWRkbGVfaW5pdGlhdGluZ1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImJvdHRvbV9pbml0aWF0aW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwidG9wX25vbl9pbml0aWF0aW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibWlkZGxlX25vbl9pbml0aWF0aW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiYm90dG9tX25vbl9pbml0aWF0aW5nXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIk1lc3NhZ2VWaXNpYmxlS2luZFwiLFxuXHRcdGxpdGVyYWxWYWx1ZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpbml0aWF0aW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibm9uX2luaXRpYXRpbmdcIlxuXHRcdFx0fVxuXHRcdF1cblx0fVxuXTtcbnZhciBhc3NvY2lhdGlvbnMkMSA9IFtcbl07XG52YXIgcHJlZml4JDEgPSBcImJwbW5kaVwiO1xudmFyIEJwbW5EaVBhY2thZ2UgPSB7XG5cdG5hbWU6IG5hbWUkMSxcblx0dXJpOiB1cmkkMSxcblx0dHlwZXM6IHR5cGVzJDEsXG5cdGVudW1lcmF0aW9uczogZW51bWVyYXRpb25zJDEsXG5cdGFzc29jaWF0aW9uczogYXNzb2NpYXRpb25zJDEsXG5cdHByZWZpeDogcHJlZml4JDFcbn07XG5cbnZhciBuYW1lJDIgPSBcIkRDXCI7XG52YXIgdXJpJDIgPSBcImh0dHA6Ly93d3cub21nLm9yZy9zcGVjL0RELzIwMTAwNTI0L0RDXCI7XG52YXIgdHlwZXMkMiA9IFtcblx0e1xuXHRcdG5hbWU6IFwiQm9vbGVhblwiXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkludGVnZXJcIlxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJSZWFsXCJcblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiU3RyaW5nXCJcblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiRm9udFwiLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJzaXplXCIsXG5cdFx0XHRcdHR5cGU6IFwiUmVhbFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaXNCb2xkXCIsXG5cdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaXNJdGFsaWNcIixcblx0XHRcdFx0dHlwZTogXCJCb29sZWFuXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpc1VuZGVybGluZVwiLFxuXHRcdFx0XHR0eXBlOiBcIkJvb2xlYW5cIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImlzU3RyaWtlVGhyb3VnaFwiLFxuXHRcdFx0XHR0eXBlOiBcIkJvb2xlYW5cIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJQb2ludFwiLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJ4XCIsXG5cdFx0XHRcdHR5cGU6IFwiUmVhbFwiLFxuXHRcdFx0XHRcImRlZmF1bHRcIjogXCIwXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJ5XCIsXG5cdFx0XHRcdHR5cGU6IFwiUmVhbFwiLFxuXHRcdFx0XHRcImRlZmF1bHRcIjogXCIwXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQm91bmRzXCIsXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInhcIixcblx0XHRcdFx0dHlwZTogXCJSZWFsXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiBcIjBcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInlcIixcblx0XHRcdFx0dHlwZTogXCJSZWFsXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiBcIjBcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIndpZHRoXCIsXG5cdFx0XHRcdHR5cGU6IFwiUmVhbFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaGVpZ2h0XCIsXG5cdFx0XHRcdHR5cGU6IFwiUmVhbFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH1cbl07XG52YXIgcHJlZml4JDIgPSBcImRjXCI7XG52YXIgYXNzb2NpYXRpb25zJDIgPSBbXG5dO1xudmFyIERjUGFja2FnZSA9IHtcblx0bmFtZTogbmFtZSQyLFxuXHR1cmk6IHVyaSQyLFxuXHR0eXBlczogdHlwZXMkMixcblx0cHJlZml4OiBwcmVmaXgkMixcblx0YXNzb2NpYXRpb25zOiBhc3NvY2lhdGlvbnMkMlxufTtcblxudmFyIG5hbWUkMyA9IFwiRElcIjtcbnZhciB1cmkkMyA9IFwiaHR0cDovL3d3dy5vbWcub3JnL3NwZWMvREQvMjAxMDA1MjQvRElcIjtcbnZhciB0eXBlcyQzID0gW1xuXHR7XG5cdFx0bmFtZTogXCJEaWFncmFtRWxlbWVudFwiLFxuXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcImlkXCIsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0aXNJZDogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJleHRlbnNpb25cIixcblx0XHRcdFx0dHlwZTogXCJFeHRlbnNpb25cIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJvd25pbmdEaWFncmFtXCIsXG5cdFx0XHRcdHR5cGU6IFwiRGlhZ3JhbVwiLFxuXHRcdFx0XHRpc1JlYWRPbmx5OiB0cnVlLFxuXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm93bmluZ0VsZW1lbnRcIixcblx0XHRcdFx0dHlwZTogXCJEaWFncmFtRWxlbWVudFwiLFxuXHRcdFx0XHRpc1JlYWRPbmx5OiB0cnVlLFxuXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm1vZGVsRWxlbWVudFwiLFxuXHRcdFx0XHRpc1JlYWRPbmx5OiB0cnVlLFxuXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcIkVsZW1lbnRcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJzdHlsZVwiLFxuXHRcdFx0XHR0eXBlOiBcIlN0eWxlXCIsXG5cdFx0XHRcdGlzUmVhZE9ubHk6IHRydWUsXG5cdFx0XHRcdGlzVmlydHVhbDogdHJ1ZSxcblx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwib3duZWRFbGVtZW50XCIsXG5cdFx0XHRcdHR5cGU6IFwiRGlhZ3JhbUVsZW1lbnRcIixcblx0XHRcdFx0aXNSZWFkT25seTogdHJ1ZSxcblx0XHRcdFx0aXNWaXJ0dWFsOiB0cnVlLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIk5vZGVcIixcblx0XHRpc0Fic3RyYWN0OiB0cnVlLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiRGlhZ3JhbUVsZW1lbnRcIlxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiRWRnZVwiLFxuXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJEaWFncmFtRWxlbWVudFwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwic291cmNlXCIsXG5cdFx0XHRcdHR5cGU6IFwiRGlhZ3JhbUVsZW1lbnRcIixcblx0XHRcdFx0aXNSZWFkT25seTogdHJ1ZSxcblx0XHRcdFx0aXNWaXJ0dWFsOiB0cnVlLFxuXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJ0YXJnZXRcIixcblx0XHRcdFx0dHlwZTogXCJEaWFncmFtRWxlbWVudFwiLFxuXHRcdFx0XHRpc1JlYWRPbmx5OiB0cnVlLFxuXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWUsXG5cdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIndheXBvaW50XCIsXG5cdFx0XHRcdGlzVW5pcXVlOiBmYWxzZSxcblx0XHRcdFx0aXNNYW55OiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBcImRjOlBvaW50XCIsXG5cdFx0XHRcdHhtbDoge1xuXHRcdFx0XHRcdHNlcmlhbGl6ZTogXCJ4c2k6dHlwZVwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkRpYWdyYW1cIixcblx0XHRpc0Fic3RyYWN0OiB0cnVlLFxuXHRcdHByb3BlcnRpZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJpZFwiLFxuXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdGlzSWQ6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwicm9vdEVsZW1lbnRcIixcblx0XHRcdFx0dHlwZTogXCJEaWFncmFtRWxlbWVudFwiLFxuXHRcdFx0XHRpc1JlYWRPbmx5OiB0cnVlLFxuXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZG9jdW1lbnRhdGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwicmVzb2x1dGlvblwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiUmVhbFwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm93bmVkU3R5bGVcIixcblx0XHRcdFx0dHlwZTogXCJTdHlsZVwiLFxuXHRcdFx0XHRpc1JlYWRPbmx5OiB0cnVlLFxuXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWUsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiU2hhcGVcIixcblx0XHRpc0Fic3RyYWN0OiB0cnVlLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiTm9kZVwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiYm91bmRzXCIsXG5cdFx0XHRcdHR5cGU6IFwiZGM6Qm91bmRzXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlBsYW5lXCIsXG5cdFx0aXNBYnN0cmFjdDogdHJ1ZSxcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIk5vZGVcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInBsYW5lRWxlbWVudFwiLFxuXHRcdFx0XHR0eXBlOiBcIkRpYWdyYW1FbGVtZW50XCIsXG5cdFx0XHRcdHN1YnNldHRlZFByb3BlcnR5OiBcIkRpYWdyYW1FbGVtZW50LW93bmVkRWxlbWVudFwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkxhYmVsZWRFZGdlXCIsXG5cdFx0aXNBYnN0cmFjdDogdHJ1ZSxcblx0XHRzdXBlckNsYXNzOiBbXG5cdFx0XHRcIkVkZ2VcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIm93bmVkTGFiZWxcIixcblx0XHRcdFx0dHlwZTogXCJMYWJlbFwiLFxuXHRcdFx0XHRpc1JlYWRPbmx5OiB0cnVlLFxuXHRcdFx0XHRzdWJzZXR0ZWRQcm9wZXJ0eTogXCJEaWFncmFtRWxlbWVudC1vd25lZEVsZW1lbnRcIixcblx0XHRcdFx0aXNWaXJ0dWFsOiB0cnVlLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIkxhYmVsZWRTaGFwZVwiLFxuXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG5cdFx0c3VwZXJDbGFzczogW1xuXHRcdFx0XCJTaGFwZVwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwib3duZWRMYWJlbFwiLFxuXHRcdFx0XHR0eXBlOiBcIkxhYmVsXCIsXG5cdFx0XHRcdGlzUmVhZE9ubHk6IHRydWUsXG5cdFx0XHRcdHN1YnNldHRlZFByb3BlcnR5OiBcIkRpYWdyYW1FbGVtZW50LW93bmVkRWxlbWVudFwiLFxuXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWUsXG5cdFx0XHRcdGlzTWFueTogdHJ1ZVxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiTGFiZWxcIixcblx0XHRpc0Fic3RyYWN0OiB0cnVlLFxuXHRcdHN1cGVyQ2xhc3M6IFtcblx0XHRcdFwiTm9kZVwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiYm91bmRzXCIsXG5cdFx0XHRcdHR5cGU6IFwiZGM6Qm91bmRzXCJcblx0XHRcdH1cblx0XHRdXG5cdH0sXG5cdHtcblx0XHRuYW1lOiBcIlN0eWxlXCIsXG5cdFx0aXNBYnN0cmFjdDogdHJ1ZSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiaWRcIixcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIixcblx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuXHRcdFx0XHRpc0lkOiB0cnVlXG5cdFx0XHR9XG5cdFx0XVxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJFeHRlbnNpb25cIixcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwidmFsdWVzXCIsXG5cdFx0XHRcdHR5cGU6IFwiRWxlbWVudFwiLFxuXHRcdFx0XHRpc01hbnk6IHRydWVcblx0XHRcdH1cblx0XHRdXG5cdH1cbl07XG52YXIgYXNzb2NpYXRpb25zJDMgPSBbXG5dO1xudmFyIHByZWZpeCQzID0gXCJkaVwiO1xudmFyIHhtbCQxID0ge1xuXHR0YWdBbGlhczogXCJsb3dlckNhc2VcIlxufTtcbnZhciBEaVBhY2thZ2UgPSB7XG5cdG5hbWU6IG5hbWUkMyxcblx0dXJpOiB1cmkkMyxcblx0dHlwZXM6IHR5cGVzJDMsXG5cdGFzc29jaWF0aW9uczogYXNzb2NpYXRpb25zJDMsXG5cdHByZWZpeDogcHJlZml4JDMsXG5cdHhtbDogeG1sJDFcbn07XG5cbnZhciBuYW1lJDQgPSBcImJwbW4uaW8gY29sb3JzIGZvciBCUE1OXCI7XG52YXIgdXJpJDQgPSBcImh0dHA6Ly9icG1uLmlvL3NjaGVtYS9icG1uL2Jpb2NvbG9yLzEuMFwiO1xudmFyIHByZWZpeCQ0ID0gXCJiaW9jXCI7XG52YXIgdHlwZXMkNCA9IFtcblx0e1xuXHRcdG5hbWU6IFwiQ29sb3JlZFNoYXBlXCIsXG5cdFx0XCJleHRlbmRzXCI6IFtcblx0XHRcdFwiYnBtbmRpOkJQTU5TaGFwZVwiXG5cdFx0XSxcblx0XHRwcm9wZXJ0aWVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwic3Ryb2tlXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJmaWxsXCIsXG5cdFx0XHRcdGlzQXR0cjogdHJ1ZSxcblx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuXHRcdFx0fVxuXHRcdF1cblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQ29sb3JlZEVkZ2VcIixcblx0XHRcImV4dGVuZHNcIjogW1xuXHRcdFx0XCJicG1uZGk6QlBNTkVkZ2VcIlxuXHRcdF0sXG5cdFx0cHJvcGVydGllczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcInN0cm9rZVwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiZmlsbFwiLFxuXHRcdFx0XHRpc0F0dHI6IHRydWUsXG5cdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcblx0XHRcdH1cblx0XHRdXG5cdH1cbl07XG52YXIgZW51bWVyYXRpb25zJDIgPSBbXG5dO1xudmFyIGFzc29jaWF0aW9ucyQ0ID0gW1xuXTtcbnZhciBCaW9jUGFja2FnZSA9IHtcblx0bmFtZTogbmFtZSQ0LFxuXHR1cmk6IHVyaSQ0LFxuXHRwcmVmaXg6IHByZWZpeCQ0LFxuXHR0eXBlczogdHlwZXMkNCxcblx0ZW51bWVyYXRpb25zOiBlbnVtZXJhdGlvbnMkMixcblx0YXNzb2NpYXRpb25zOiBhc3NvY2lhdGlvbnMkNFxufTtcblxudmFyIHBhY2thZ2VzID0ge1xuICBicG1uOiBCcG1uUGFja2FnZSxcbiAgYnBtbmRpOiBCcG1uRGlQYWNrYWdlLFxuICBkYzogRGNQYWNrYWdlLFxuICBkaTogRGlQYWNrYWdlLFxuICBiaW9jOiBCaW9jUGFja2FnZVxufTtcblxuZnVuY3Rpb24gc2ltcGxlKGFkZGl0aW9uYWxQYWNrYWdlcywgb3B0aW9ucykge1xuICB2YXIgcGtzID0gYXNzaWduKHt9LCBwYWNrYWdlcywgYWRkaXRpb25hbFBhY2thZ2VzKTtcblxuICByZXR1cm4gbmV3IEJwbW5Nb2RkbGUocGtzLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2ltcGxlO1xuIiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vbGliL0RpYWdyYW0nOyIsImltcG9ydCB7IEluamVjdG9yIH0gZnJvbSAnZGlkaSc7XG5cbmltcG9ydCBDb3JlTW9kdWxlIGZyb20gJy4vY29yZSc7XG5cblxuLyoqXG4gKiBCb290c3RyYXAgYW4gaW5qZWN0b3IgZnJvbSBhIGxpc3Qgb2YgbW9kdWxlcywgaW5zdGFudGlhdGluZyBhIG51bWJlciBvZiBkZWZhdWx0IGNvbXBvbmVudHNcbiAqXG4gKiBAaWdub3JlXG4gKiBAcGFyYW0ge0FycmF5PGRpZGkuTW9kdWxlPn0gYm9vdHN0cmFwTW9kdWxlc1xuICpcbiAqIEByZXR1cm4ge2RpZGkuSW5qZWN0b3J9IGEgaW5qZWN0b3IgdG8gdXNlIHRvIGFjY2VzcyB0aGUgY29tcG9uZW50c1xuICovXG5mdW5jdGlvbiBib290c3RyYXAoYm9vdHN0cmFwTW9kdWxlcykge1xuXG4gIHZhciBtb2R1bGVzID0gW10sXG4gICAgICBjb21wb25lbnRzID0gW107XG5cbiAgZnVuY3Rpb24gaGFzTW9kdWxlKG0pIHtcbiAgICByZXR1cm4gbW9kdWxlcy5pbmRleE9mKG0pID49IDA7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRNb2R1bGUobSkge1xuICAgIG1vZHVsZXMucHVzaChtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZpc2l0KG0pIHtcbiAgICBpZiAoaGFzTW9kdWxlKG0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgKG0uX19kZXBlbmRzX18gfHwgW10pLmZvckVhY2godmlzaXQpO1xuXG4gICAgaWYgKGhhc01vZHVsZShtKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGFkZE1vZHVsZShtKTtcblxuICAgIChtLl9faW5pdF9fIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcbiAgICAgIGNvbXBvbmVudHMucHVzaChjKTtcbiAgICB9KTtcbiAgfVxuXG4gIGJvb3RzdHJhcE1vZHVsZXMuZm9yRWFjaCh2aXNpdCk7XG5cbiAgdmFyIGluamVjdG9yID0gbmV3IEluamVjdG9yKG1vZHVsZXMpO1xuXG4gIGNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbihjKSB7XG5cbiAgICB0cnkge1xuXG4gICAgICAvLyBlYWdlcmx5IHJlc29sdmUgY29tcG9uZW50IChmbiBvciBzdHJpbmcpXG4gICAgICBpbmplY3Rvclt0eXBlb2YgYyA9PT0gJ3N0cmluZycgPyAnZ2V0JyA6ICdpbnZva2UnXShjKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gaW5zdGFudGlhdGUgY29tcG9uZW50Jyk7XG4gICAgICBjb25zb2xlLmVycm9yKGUuc3RhY2spO1xuXG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGluamVjdG9yO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gaW5qZWN0b3IgZnJvbSBwYXNzZWQgb3B0aW9ucy5cbiAqXG4gKiBAaWdub3JlXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge2RpZGkuSW5qZWN0b3J9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluamVjdG9yKG9wdGlvbnMpIHtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgY29uZmlnTW9kdWxlID0ge1xuICAgICdjb25maWcnOiBbJ3ZhbHVlJywgb3B0aW9uc11cbiAgfTtcblxuICB2YXIgbW9kdWxlcyA9IFsgY29uZmlnTW9kdWxlLCBDb3JlTW9kdWxlIF0uY29uY2F0KG9wdGlvbnMubW9kdWxlcyB8fCBbXSk7XG5cbiAgcmV0dXJuIGJvb3RzdHJhcChtb2R1bGVzKTtcbn1cblxuXG4vKipcbiAqIFRoZSBtYWluIGRpYWdyYW0tanMgZW50cnkgcG9pbnQgdGhhdCBib290c3RyYXBzIHRoZSBkaWFncmFtIHdpdGggdGhlIGdpdmVuXG4gKiBjb25maWd1cmF0aW9uLlxuICpcbiAqIFRvIHJlZ2lzdGVyIGV4dGVuc2lvbnMgd2l0aCB0aGUgZGlhZ3JhbSwgcGFzcyB0aGVtIGFzIEFycmF5PGRpZGkuTW9kdWxlPiB0byB0aGUgY29uc3RydWN0b3IuXG4gKlxuICogQGNsYXNzIGRqcy5EaWFncmFtXG4gKiBAbWVtYmVyT2YgZGpzXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIDxjYXB0aW9uPkNyZWF0aW5nIGEgcGx1Zy1pbiB0aGF0IGxvZ3Mgd2hlbmV2ZXIgYSBzaGFwZSBpcyBhZGRlZCB0byB0aGUgY2FudmFzLjwvY2FwdGlvbj5cbiAqXG4gKiAvLyBwbHVnLWluIGltcGxlbWVuZW50YXRpb25cbiAqIGZ1bmN0aW9uIE15TG9nZ2luZ1BsdWdpbihldmVudEJ1cykge1xuICogICBldmVudEJ1cy5vbignc2hhcGUuYWRkZWQnLCBmdW5jdGlvbihldmVudCkge1xuICogICAgIGNvbnNvbGUubG9nKCdzaGFwZSAnLCBldmVudC5zaGFwZSwgJyB3YXMgYWRkZWQgdG8gdGhlIGRpYWdyYW0nKTtcbiAqICAgfSk7XG4gKiB9XG4gKlxuICogLy8gZXhwb3J0IGFzIG1vZHVsZVxuICogZXhwb3J0IGRlZmF1bHQge1xuICogICBfX2luaXRfXzogWyAnbXlMb2dnaW5nUGx1Z2luJyBdLFxuICogICAgIG15TG9nZ2luZ1BsdWdpbjogWyAndHlwZScsIE15TG9nZ2luZ1BsdWdpbiBdXG4gKiB9O1xuICpcbiAqXG4gKiAvLyBpbnN0YW50aWF0ZSB0aGUgZGlhZ3JhbSB3aXRoIHRoZSBuZXcgcGx1Zy1pblxuICpcbiAqIGltcG9ydCBNeUxvZ2dpbmdNb2R1bGUgZnJvbSAncGF0aC10by1teS1sb2dnaW5nLXBsdWdpbic7XG4gKlxuICogdmFyIGRpYWdyYW0gPSBuZXcgRGlhZ3JhbSh7XG4gKiAgIG1vZHVsZXM6IFtcbiAqICAgICBNeUxvZ2dpbmdNb2R1bGVcbiAqICAgXVxuICogfSk7XG4gKlxuICogZGlhZ3JhbS5pbnZva2UoWyAnY2FudmFzJywgZnVuY3Rpb24oY2FudmFzKSB7XG4gKiAgIC8vIGFkZCBzaGFwZSB0byBkcmF3aW5nIGNhbnZhc1xuICogICBjYW52YXMuYWRkU2hhcGUoeyB4OiAxMCwgeTogMTAgfSk7XG4gKiB9KTtcbiAqXG4gKiAvLyAnc2hhcGUgLi4uIHdhcyBhZGRlZCB0byB0aGUgZGlhZ3JhbScgbG9nZ2VkIHRvIGNvbnNvbGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtBcnJheTxkaWRpLk1vZHVsZT59IFtvcHRpb25zLm1vZHVsZXNdIGV4dGVybmFsIG1vZHVsZXMgdG8gaW5zdGFudGlhdGUgd2l0aCB0aGUgZGlhZ3JhbVxuICogQHBhcmFtIHtkaWRpLkluamVjdG9yfSBbaW5qZWN0b3JdIGFuIChvcHRpb25hbCkgaW5qZWN0b3IgdG8gYm9vdHN0cmFwIHRoZSBkaWFncmFtIHdpdGhcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRGlhZ3JhbShvcHRpb25zLCBpbmplY3Rvcikge1xuXG4gIC8vIGNyZWF0ZSBpbmplY3RvciB1bmxlc3MgZXhwbGljaXRseSBzcGVjaWZpZWRcbiAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yID0gaW5qZWN0b3IgfHwgY3JlYXRlSW5qZWN0b3Iob3B0aW9ucyk7XG5cbiAgLy8gQVBJXG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIGEgZGlhZ3JhbSBzZXJ2aWNlXG4gICAqXG4gICAqIEBtZXRob2QgRGlhZ3JhbSNnZXRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGRpYWdyYW0gc2VydmljZSB0byBiZSByZXRyaWV2ZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RyaWN0PXRydWVdIGlmIGZhbHNlLCByZXNvbHZlIG1pc3Npbmcgc2VydmljZXMgdG8gbnVsbFxuICAgKi9cbiAgdGhpcy5nZXQgPSBpbmplY3Rvci5nZXQ7XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgZnVuY3Rpb24gaW50byB3aGljaCBkaWFncmFtIHNlcnZpY2VzIGFyZSBpbmplY3RlZFxuICAgKlxuICAgKiBAbWV0aG9kIERpYWdyYW0jaW52b2tlXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0W119IGZuIHRoZSBmdW5jdGlvbiB0byByZXNvbHZlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsb2NhbHMgYSBudW1iZXIgb2YgbG9jYWxzIHRvIHVzZSB0byByZXNvbHZlIGNlcnRhaW4gZGVwZW5kZW5jaWVzXG4gICAqL1xuICB0aGlzLmludm9rZSA9IGluamVjdG9yLmludm9rZTtcblxuICAvLyBpbml0XG5cbiAgLy8gaW5kaWNhdGUgdmlhIGV2ZW50XG5cblxuICAvKipcbiAgICogQW4gZXZlbnQgaW5kaWNhdGluZyB0aGF0IGFsbCBwbHVnLWlucyBhcmUgbG9hZGVkLlxuICAgKlxuICAgKiBVc2UgdGhpcyBldmVudCB0byBmaXJlIG90aGVyIGV2ZW50cyB0byBpbnRlcmVzdGVkIHBsdWctaW5zXG4gICAqXG4gICAqIEBtZW1iZXJPZiBEaWFncmFtXG4gICAqXG4gICAqIEBldmVudCBkaWFncmFtLmluaXRcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogZXZlbnRCdXMub24oJ2RpYWdyYW0uaW5pdCcsIGZ1bmN0aW9uKCkge1xuICAgKiAgIGV2ZW50QnVzLmZpcmUoJ215LWN1c3RvbS1ldmVudCcsIHsgZm9vOiAnQkFSJyB9KTtcbiAgICogfSk7XG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB0aGlzLmdldCgnZXZlbnRCdXMnKS5maXJlKCdkaWFncmFtLmluaXQnKTtcbn1cblxuXG4vKipcbiAqIERlc3Ryb3lzIHRoZSBkaWFncmFtXG4gKlxuICogQG1ldGhvZCAgRGlhZ3JhbSNkZXN0cm95XG4gKi9cbkRpYWdyYW0ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5nZXQoJ2V2ZW50QnVzJykuZmlyZSgnZGlhZ3JhbS5kZXN0cm95Jyk7XG59O1xuXG4vKipcbiAqIENsZWFyIHRoZSBkaWFncmFtLCByZW1vdmluZyBhbGwgY29udGVudHMuXG4gKi9cbkRpYWdyYW0ucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZ2V0KCdldmVudEJ1cycpLmZpcmUoJ2RpYWdyYW0uY2xlYXInKTtcbn07XG4iLCJpbXBvcnQge1xuICBpc051bWJlcixcbiAgYXNzaWduLFxuICBmb3JFYWNoLFxuICBldmVyeSxcbiAgZGVib3VuY2UsXG4gIGJpbmQsXG4gIHJlZHVjZVxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGFkZCBhcyBjb2xsZWN0aW9uQWRkLFxuICByZW1vdmUgYXMgY29sbGVjdGlvblJlbW92ZVxufSBmcm9tICcuLi91dGlsL0NvbGxlY3Rpb25zJztcblxuaW1wb3J0IHtcbiAgZ2V0VHlwZVxufSBmcm9tICcuLi91dGlsL0VsZW1lbnRzJztcblxuaW1wb3J0IHtcbiAgYXBwZW5kIGFzIHN2Z0FwcGVuZCxcbiAgYXR0ciBhcyBzdmdBdHRyLFxuICBjbGFzc2VzIGFzIHN2Z0NsYXNzZXMsXG4gIGNyZWF0ZSBhcyBzdmdDcmVhdGUsXG4gIHRyYW5zZm9ybSBhcyBzdmdUcmFuc2Zvcm1cbn0gZnJvbSAndGlueS1zdmcnO1xuXG5pbXBvcnQgeyBjcmVhdGVNYXRyaXggYXMgY3JlYXRlTWF0cml4IH0gZnJvbSAndGlueS1zdmcnO1xuXG5cbmZ1bmN0aW9uIHJvdW5kKG51bWJlciwgcmVzb2x1dGlvbikge1xuICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIgKiByZXNvbHV0aW9uKSAvIHJlc29sdXRpb247XG59XG5cbmZ1bmN0aW9uIGVuc3VyZVB4KG51bWJlcikge1xuICByZXR1cm4gaXNOdW1iZXIobnVtYmVyKSA/IG51bWJlciArICdweCcgOiBudW1iZXI7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIEhUTUwgY29udGFpbmVyIGVsZW1lbnQgZm9yIGEgU1ZHIGVsZW1lbnQgd2l0aFxuICogdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb25cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSB0aGUgY29udGFpbmVyIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29udGFpbmVyKG9wdGlvbnMpIHtcblxuICBvcHRpb25zID0gYXNzaWduKHt9LCB7IHdpZHRoOiAnMTAwJScsIGhlaWdodDogJzEwMCUnIH0sIG9wdGlvbnMpO1xuXG4gIHZhciBjb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5O1xuXG4gIC8vIGNyZWF0ZSBhIDxkaXY+IGFyb3VuZCB0aGUgc3ZnIGVsZW1lbnQgd2l0aCB0aGUgcmVzcGVjdGl2ZSBzaXplXG4gIC8vIHRoaXMgd2F5IHdlIGNhbiBhbHdheXMgZ2V0IHRoZSBjb3JyZWN0IGNvbnRhaW5lciBzaXplXG4gIC8vICh0aGlzIGlzIGltcG9zc2libGUgZm9yIDxzdmc+IGVsZW1lbnRzIGF0IHRoZSBtb21lbnQpXG4gIHZhciBwYXJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgcGFyZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnZGpzLWNvbnRhaW5lcicpO1xuXG4gIGFzc2lnbihwYXJlbnQuc3R5bGUsIHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgd2lkdGg6IGVuc3VyZVB4KG9wdGlvbnMud2lkdGgpLFxuICAgIGhlaWdodDogZW5zdXJlUHgob3B0aW9ucy5oZWlnaHQpXG4gIH0pO1xuXG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChwYXJlbnQpO1xuXG4gIHJldHVybiBwYXJlbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUdyb3VwKHBhcmVudCwgY2xzLCBjaGlsZEluZGV4KSB7XG4gIHZhciBncm91cCA9IHN2Z0NyZWF0ZSgnZycpO1xuICBzdmdDbGFzc2VzKGdyb3VwKS5hZGQoY2xzKTtcblxuICB2YXIgaW5kZXggPSBjaGlsZEluZGV4ICE9PSB1bmRlZmluZWQgPyBjaGlsZEluZGV4IDogcGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoIC0gMTtcblxuICAvLyBtdXN0IGVuc3VyZSBzZWNvbmQgYXJndW1lbnQgaXMgbm9kZSBvciBfbnVsbF9cbiAgLy8gY2YuIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlL2luc2VydEJlZm9yZVxuICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGdyb3VwLCBwYXJlbnQuY2hpbGROb2Rlc1tpbmRleF0gfHwgbnVsbCk7XG5cbiAgcmV0dXJuIGdyb3VwO1xufVxuXG52YXIgQkFTRV9MQVlFUiA9ICdiYXNlJztcblxuXG52YXIgUkVRVUlSRURfTU9ERUxfQVRUUlMgPSB7XG4gIHNoYXBlOiBbICd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0JyBdLFxuICBjb25uZWN0aW9uOiBbICd3YXlwb2ludHMnIF1cbn07XG5cbi8qKlxuICogVGhlIG1haW4gZHJhd2luZyBjYW52YXMuXG4gKlxuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAZW1pdHMgQ2FudmFzI2NhbnZhcy5pbml0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAqIEBwYXJhbSB7R3JhcGhpY3NGYWN0b3J5fSBncmFwaGljc0ZhY3RvcnlcbiAqIEBwYXJhbSB7RWxlbWVudFJlZ2lzdHJ5fSBlbGVtZW50UmVnaXN0cnlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2FudmFzKGNvbmZpZywgZXZlbnRCdXMsIGdyYXBoaWNzRmFjdG9yeSwgZWxlbWVudFJlZ2lzdHJ5KSB7XG5cbiAgdGhpcy5fZXZlbnRCdXMgPSBldmVudEJ1cztcbiAgdGhpcy5fZWxlbWVudFJlZ2lzdHJ5ID0gZWxlbWVudFJlZ2lzdHJ5O1xuICB0aGlzLl9ncmFwaGljc0ZhY3RvcnkgPSBncmFwaGljc0ZhY3Rvcnk7XG5cbiAgdGhpcy5faW5pdChjb25maWcgfHwge30pO1xufVxuXG5DYW52YXMuJGluamVjdCA9IFtcbiAgJ2NvbmZpZy5jYW52YXMnLFxuICAnZXZlbnRCdXMnLFxuICAnZ3JhcGhpY3NGYWN0b3J5JyxcbiAgJ2VsZW1lbnRSZWdpc3RyeSdcbl07XG5cblxuQ2FudmFzLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKGNvbmZpZykge1xuXG4gIHZhciBldmVudEJ1cyA9IHRoaXMuX2V2ZW50QnVzO1xuXG4gIC8vIENyZWF0ZXMgYSA8c3ZnPiBlbGVtZW50IHRoYXQgaXMgd3JhcHBlZCBpbnRvIGEgPGRpdj4uXG4gIC8vIFRoaXMgd2F5IHdlIGFyZSBhbHdheXMgYWJsZSB0byBjb3JyZWN0bHkgZmlndXJlIG91dCB0aGUgc2l6ZSBvZiB0aGUgc3ZnIGVsZW1lbnRcbiAgLy8gYnkgcXVlcnlpbmcgdGhlIHBhcmVudCBub2RlLlxuICAvL1xuICAvLyAoSXQgaXMgbm90IHBvc3NpYmxlIHRvIGdldCB0aGUgc2l6ZSBvZiBhIHN2ZyBlbGVtZW50IGNyb3NzIGJyb3dzZXIgQCAyMDE0LTA0LTAxKVxuICAvL1xuICAvLyA8ZGl2IGNsYXNzPVwiZGpzLWNvbnRhaW5lclwiIHN0eWxlPVwid2lkdGg6IHtkZXNpcmVkLXdpZHRofSwgaGVpZ2h0OiB7ZGVzaXJlZC1oZWlnaHR9XCI+XG4gIC8vICAgPHN2ZyB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCI+XG4gIC8vICAgIC4uLlxuICAvLyAgIDwvc3ZnPlxuICAvLyA8L2Rpdj5cblxuICAvLyBodG1sIGNvbnRhaW5lclxuICB2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gY3JlYXRlQ29udGFpbmVyKGNvbmZpZyk7XG5cbiAgdmFyIHN2ZyA9IHRoaXMuX3N2ZyA9IHN2Z0NyZWF0ZSgnc3ZnJyk7XG4gIHN2Z0F0dHIoc3ZnLCB7IHdpZHRoOiAnMTAwJScsIGhlaWdodDogJzEwMCUnIH0pO1xuXG4gIHN2Z0FwcGVuZChjb250YWluZXIsIHN2Zyk7XG5cbiAgdmFyIHZpZXdwb3J0ID0gdGhpcy5fdmlld3BvcnQgPSBjcmVhdGVHcm91cChzdmcsICd2aWV3cG9ydCcpO1xuXG4gIHRoaXMuX2xheWVycyA9IHt9O1xuXG4gIC8vIGRlYm91bmNlIGNhbnZhcy52aWV3Ym94LmNoYW5nZWQgZXZlbnRzXG4gIC8vIGZvciBzbW9vdGhlciBkaWFncmFtIGludGVyYWN0aW9uXG4gIGlmIChjb25maWcuZGVmZXJVcGRhdGUgIT09IGZhbHNlKSB7XG4gICAgdGhpcy5fdmlld2JveENoYW5nZWQgPSBkZWJvdW5jZShiaW5kKHRoaXMuX3ZpZXdib3hDaGFuZ2VkLCB0aGlzKSwgMzAwKTtcbiAgfVxuXG4gIGV2ZW50QnVzLm9uKCdkaWFncmFtLmluaXQnLCBmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIEFuIGV2ZW50IGluZGljYXRpbmcgdGhhdCB0aGUgY2FudmFzIGlzIHJlYWR5IHRvIGJlIGRyYXduIG9uLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIENhbnZhc1xuICAgICAqXG4gICAgICogQGV2ZW50IGNhbnZhcy5pbml0XG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7U1ZHRWxlbWVudH0gc3ZnIHRoZSBjcmVhdGVkIHN2ZyBlbGVtZW50XG4gICAgICogQHByb3BlcnR5IHtTVkdFbGVtZW50fSB2aWV3cG9ydCB0aGUgZGlyZWN0IHBhcmVudCBvZiBkaWFncmFtIGVsZW1lbnRzIGFuZCBzaGFwZXNcbiAgICAgKi9cbiAgICBldmVudEJ1cy5maXJlKCdjYW52YXMuaW5pdCcsIHtcbiAgICAgIHN2Zzogc3ZnLFxuICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0XG4gICAgfSk7XG5cbiAgfSwgdGhpcyk7XG5cbiAgLy8gcmVzZXQgdmlld2JveCBvbiBzaGFwZSBjaGFuZ2VzIHRvXG4gIC8vIHJlY29tcHV0ZSB0aGUgdmlld2JveFxuICBldmVudEJ1cy5vbihbXG4gICAgJ3NoYXBlLmFkZGVkJyxcbiAgICAnY29ubmVjdGlvbi5hZGRlZCcsXG4gICAgJ3NoYXBlLnJlbW92ZWQnLFxuICAgICdjb25uZWN0aW9uLnJlbW92ZWQnLFxuICAgICdlbGVtZW50cy5jaGFuZ2VkJ1xuICBdLCBmdW5jdGlvbigpIHtcbiAgICBkZWxldGUgdGhpcy5fY2FjaGVkVmlld2JveDtcbiAgfSwgdGhpcyk7XG5cbiAgZXZlbnRCdXMub24oJ2RpYWdyYW0uZGVzdHJveScsIDUwMCwgdGhpcy5fZGVzdHJveSwgdGhpcyk7XG4gIGV2ZW50QnVzLm9uKCdkaWFncmFtLmNsZWFyJywgNTAwLCB0aGlzLl9jbGVhciwgdGhpcyk7XG59O1xuXG5DYW52YXMucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24oZW1pdCkge1xuICB0aGlzLl9ldmVudEJ1cy5maXJlKCdjYW52YXMuZGVzdHJveScsIHtcbiAgICBzdmc6IHRoaXMuX3N2ZyxcbiAgICB2aWV3cG9ydDogdGhpcy5fdmlld3BvcnRcbiAgfSk7XG5cbiAgdmFyIHBhcmVudCA9IHRoaXMuX2NvbnRhaW5lci5wYXJlbnROb2RlO1xuXG4gIGlmIChwYXJlbnQpIHtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcbiAgfVxuXG4gIGRlbGV0ZSB0aGlzLl9zdmc7XG4gIGRlbGV0ZSB0aGlzLl9jb250YWluZXI7XG4gIGRlbGV0ZSB0aGlzLl9sYXllcnM7XG4gIGRlbGV0ZSB0aGlzLl9yb290RWxlbWVudDtcbiAgZGVsZXRlIHRoaXMuX3ZpZXdwb3J0O1xufTtcblxuQ2FudmFzLnByb3RvdHlwZS5fY2xlYXIgPSBmdW5jdGlvbigpIHtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIGFsbEVsZW1lbnRzID0gdGhpcy5fZWxlbWVudFJlZ2lzdHJ5LmdldEFsbCgpO1xuXG4gIC8vIHJlbW92ZSBhbGwgZWxlbWVudHNcbiAgYWxsRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgdmFyIHR5cGUgPSBnZXRUeXBlKGVsZW1lbnQpO1xuXG4gICAgaWYgKHR5cGUgPT09ICdyb290Jykge1xuICAgICAgc2VsZi5zZXRSb290RWxlbWVudChudWxsLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5fcmVtb3ZlRWxlbWVudChlbGVtZW50LCB0eXBlKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGZvcmNlIHJlY29tcHV0YXRpb24gb2YgdmlldyBib3hcbiAgZGVsZXRlIHRoaXMuX2NhY2hlZFZpZXdib3g7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGRlZmF1bHQgbGF5ZXIgb24gd2hpY2hcbiAqIGFsbCBlbGVtZW50cyBhcmUgZHJhd24uXG4gKlxuICogQHJldHVybnMge1NWR0VsZW1lbnR9XG4gKi9cbkNhbnZhcy5wcm90b3R5cGUuZ2V0RGVmYXVsdExheWVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmdldExheWVyKEJBU0VfTEFZRVIsIDApO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbGF5ZXIgdGhhdCBpcyB1c2VkIHRvIGRyYXcgZWxlbWVudHNcbiAqIG9yIGFubm90YXRpb25zIG9uIGl0LlxuICpcbiAqIE5vbi1leGlzdGluZyBsYXllcnMgcmV0cmlldmVkIHRocm91Z2ggdGhpcyBtZXRob2RcbiAqIHdpbGwgYmUgY3JlYXRlZC4gRHVyaW5nIGNyZWF0aW9uLCB0aGUgb3B0aW9uYWwgaW5kZXhcbiAqIG1heSBiZSB1c2VkIHRvIGNyZWF0ZSBsYXllcnMgYmVsb3cgb3IgYWJvdmUgZXhpc3RpbmcgbGF5ZXJzLlxuICogQSBsYXllciB3aXRoIGEgY2VydGFpbiBpbmRleCBpcyBhbHdheXMgY3JlYXRlZCBhYm92ZSBhbGxcbiAqIGV4aXN0aW5nIGxheWVycyB3aXRoIHRoZSBzYW1lIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAqXG4gKiBAcmV0dXJucyB7U1ZHRWxlbWVudH1cbiAqL1xuQ2FudmFzLnByb3RvdHlwZS5nZXRMYXllciA9IGZ1bmN0aW9uKG5hbWUsIGluZGV4KSB7XG5cbiAgaWYgKCFuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHNwZWNpZnkgYSBuYW1lJyk7XG4gIH1cblxuICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbbmFtZV07XG5cbiAgaWYgKCFsYXllcikge1xuICAgIGxheWVyID0gdGhpcy5fbGF5ZXJzW25hbWVdID0gdGhpcy5fY3JlYXRlTGF5ZXIobmFtZSwgaW5kZXgpO1xuICB9XG5cbiAgLy8gdGhyb3cgYW4gZXJyb3IgaWYgbGF5ZXIgY3JlYXRpb24gLyByZXRyaXZhbCBpc1xuICAvLyByZXF1ZXN0ZWQgb24gZGlmZmVyZW50IGluZGV4XG4gIGlmICh0eXBlb2YgaW5kZXggIT09ICd1bmRlZmluZWQnICYmIGxheWVyLmluZGV4ICE9PSBpbmRleCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbGF5ZXIgPCcgKyBuYW1lICsgJz4gYWxyZWFkeSBjcmVhdGVkIGF0IGluZGV4IDwnICsgaW5kZXggKyAnPicpO1xuICB9XG5cbiAgcmV0dXJuIGxheWVyLmdyb3VwO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZ2l2ZW4gbGF5ZXIgYW5kIHJldHVybnMgaXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbaW5kZXg9MF1cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGxheWVyIGRlc2NyaXB0b3Igd2l0aCB7IGluZGV4LCBncm91cDogU1ZHR3JvdXAgfVxuICovXG5DYW52YXMucHJvdG90eXBlLl9jcmVhdGVMYXllciA9IGZ1bmN0aW9uKG5hbWUsIGluZGV4KSB7XG5cbiAgaWYgKCFpbmRleCkge1xuICAgIGluZGV4ID0gMDtcbiAgfVxuXG4gIHZhciBjaGlsZEluZGV4ID0gcmVkdWNlKHRoaXMuX2xheWVycywgZnVuY3Rpb24oY2hpbGRJbmRleCwgbGF5ZXIpIHtcbiAgICBpZiAoaW5kZXggPj0gbGF5ZXIuaW5kZXgpIHtcbiAgICAgIGNoaWxkSW5kZXgrKztcbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGRJbmRleDtcbiAgfSwgMCk7XG5cbiAgcmV0dXJuIHtcbiAgICBncm91cDogY3JlYXRlR3JvdXAodGhpcy5fdmlld3BvcnQsICdsYXllci0nICsgbmFtZSwgY2hpbGRJbmRleCksXG4gICAgaW5kZXg6IGluZGV4XG4gIH07XG5cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaHRtbCBlbGVtZW50IHRoYXQgZW5jbG9zZXMgdGhlXG4gKiBkcmF3aW5nIGNhbnZhcy5cbiAqXG4gKiBAcmV0dXJuIHtET01Ob2RlfVxuICovXG5DYW52YXMucHJvdG90eXBlLmdldENvbnRhaW5lciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY29udGFpbmVyO1xufTtcblxuXG4vLyBtYXJrZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuQ2FudmFzLnByb3RvdHlwZS5fdXBkYXRlTWFya2VyID0gZnVuY3Rpb24oZWxlbWVudCwgbWFya2VyLCBhZGQpIHtcbiAgdmFyIGNvbnRhaW5lcjtcblxuICBpZiAoIWVsZW1lbnQuaWQpIHtcbiAgICBlbGVtZW50ID0gdGhpcy5fZWxlbWVudFJlZ2lzdHJ5LmdldChlbGVtZW50KTtcbiAgfVxuXG4gIC8vIHdlIG5lZWQgdG8gYWNjZXNzIGFsbFxuICBjb250YWluZXIgPSB0aGlzLl9lbGVtZW50UmVnaXN0cnkuX2VsZW1lbnRzW2VsZW1lbnQuaWRdO1xuXG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yRWFjaChbIGNvbnRhaW5lci5nZngsIGNvbnRhaW5lci5zZWNvbmRhcnlHZnggXSwgZnVuY3Rpb24oZ2Z4KSB7XG4gICAgaWYgKGdmeCkge1xuXG4gICAgICAvLyBpbnZva2UgZWl0aGVyIGFkZENsYXNzIG9yIHJlbW92ZUNsYXNzIGJhc2VkIG9uIG1vZGVcbiAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgc3ZnQ2xhc3NlcyhnZngpLmFkZChtYXJrZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3ZnQ2xhc3NlcyhnZngpLnJlbW92ZShtYXJrZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEFuIGV2ZW50IGluZGljYXRpbmcgdGhhdCBhIG1hcmtlciBoYXMgYmVlbiB1cGRhdGVkIGZvciBhbiBlbGVtZW50XG4gICAqXG4gICAqIEBldmVudCBlbGVtZW50Lm1hcmtlci51cGRhdGVcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByb3BlcnR5IHtkanMubW9kZWwuRWxlbWVudH0gZWxlbWVudCB0aGUgc2hhcGVcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IGdmeCB0aGUgZ3JhcGhpY2FsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzaGFwZVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gbWFya2VyXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gYWRkIHRydWUgaWYgdGhlIG1hcmtlciB3YXMgYWRkZWQsIGZhbHNlIGlmIGl0IGdvdCByZW1vdmVkXG4gICAqL1xuICB0aGlzLl9ldmVudEJ1cy5maXJlKCdlbGVtZW50Lm1hcmtlci51cGRhdGUnLCB7IGVsZW1lbnQ6IGVsZW1lbnQsIGdmeDogY29udGFpbmVyLmdmeCwgbWFya2VyOiBtYXJrZXIsIGFkZDogISFhZGQgfSk7XG59O1xuXG5cbi8qKlxuICogQWRkcyBhIG1hcmtlciB0byBhbiBlbGVtZW50IChiYXNpY2FsbHkgYSBjc3MgY2xhc3MpLlxuICpcbiAqIEZpcmVzIHRoZSBlbGVtZW50Lm1hcmtlci51cGRhdGUgZXZlbnQsIG1ha2luZyBpdCBwb3NzaWJsZSB0b1xuICogaW50ZWdyYXRlIGV4dGVuc2lvbiBpbnRvIHRoZSBtYXJrZXIgbGlmZS1jeWNsZSwgdG9vLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjYW52YXMuYWRkTWFya2VyKCdmb28nLCAnc29tZS1tYXJrZXInKTtcbiAqXG4gKiB2YXIgZm9vR2Z4ID0gY2FudmFzLmdldEdyYXBoaWNzKCdmb28nKTtcbiAqXG4gKiBmb29HZng7IC8vIDxnIGNsYXNzPVwiLi4uIHNvbWUtbWFya2VyXCI+IC4uLiA8L2c+XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBtYXJrZXJcbiAqL1xuQ2FudmFzLnByb3RvdHlwZS5hZGRNYXJrZXIgPSBmdW5jdGlvbihlbGVtZW50LCBtYXJrZXIpIHtcbiAgdGhpcy5fdXBkYXRlTWFya2VyKGVsZW1lbnQsIG1hcmtlciwgdHJ1ZSk7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlIGEgbWFya2VyIGZyb20gYW4gZWxlbWVudC5cbiAqXG4gKiBGaXJlcyB0aGUgZWxlbWVudC5tYXJrZXIudXBkYXRlIGV2ZW50LCBtYWtpbmcgaXQgcG9zc2libGUgdG9cbiAqIGludGVncmF0ZSBleHRlbnNpb24gaW50byB0aGUgbWFya2VyIGxpZmUtY3ljbGUsIHRvby5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd8ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAqIEBwYXJhbSAge1N0cmluZ30gbWFya2VyXG4gKi9cbkNhbnZhcy5wcm90b3R5cGUucmVtb3ZlTWFya2VyID0gZnVuY3Rpb24oZWxlbWVudCwgbWFya2VyKSB7XG4gIHRoaXMuX3VwZGF0ZU1hcmtlcihlbGVtZW50LCBtYXJrZXIsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgdGhlIGV4aXN0ZW5jZSBvZiBhIG1hcmtlciBvbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ3xkanMubW9kZWwuQmFzZX0gZWxlbWVudFxuICogQHBhcmFtICB7U3RyaW5nfSBtYXJrZXJcbiAqL1xuQ2FudmFzLnByb3RvdHlwZS5oYXNNYXJrZXIgPSBmdW5jdGlvbihlbGVtZW50LCBtYXJrZXIpIHtcbiAgaWYgKCFlbGVtZW50LmlkKSB7XG4gICAgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnRSZWdpc3RyeS5nZXQoZWxlbWVudCk7XG4gIH1cblxuICB2YXIgZ2Z4ID0gdGhpcy5nZXRHcmFwaGljcyhlbGVtZW50KTtcblxuICByZXR1cm4gc3ZnQ2xhc3NlcyhnZngpLmhhcyhtYXJrZXIpO1xufTtcblxuLyoqXG4gKiBUb2dnbGVzIGEgbWFya2VyIG9uIGFuIGVsZW1lbnQuXG4gKlxuICogRmlyZXMgdGhlIGVsZW1lbnQubWFya2VyLnVwZGF0ZSBldmVudCwgbWFraW5nIGl0IHBvc3NpYmxlIHRvXG4gKiBpbnRlZ3JhdGUgZXh0ZW5zaW9uIGludG8gdGhlIG1hcmtlciBsaWZlLWN5Y2xlLCB0b28uXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfGRqcy5tb2RlbC5CYXNlfSBlbGVtZW50XG4gKiBAcGFyYW0gIHtTdHJpbmd9IG1hcmtlclxuICovXG5DYW52YXMucHJvdG90eXBlLnRvZ2dsZU1hcmtlciA9IGZ1bmN0aW9uKGVsZW1lbnQsIG1hcmtlcikge1xuICBpZiAodGhpcy5oYXNNYXJrZXIoZWxlbWVudCwgbWFya2VyKSkge1xuICAgIHRoaXMucmVtb3ZlTWFya2VyKGVsZW1lbnQsIG1hcmtlcik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hZGRNYXJrZXIoZWxlbWVudCwgbWFya2VyKTtcbiAgfVxufTtcblxuQ2FudmFzLnByb3RvdHlwZS5nZXRSb290RWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX3Jvb3RFbGVtZW50KSB7XG4gICAgdGhpcy5zZXRSb290RWxlbWVudCh7IGlkOiAnX19pbXBsaWNpdHJvb3QnLCBjaGlsZHJlbjogW10gfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fcm9vdEVsZW1lbnQ7XG59O1xuXG5cblxuLy8gcm9vdCBlbGVtZW50IGhhbmRsaW5nIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBTZXRzIGEgZ2l2ZW4gZWxlbWVudCBhcyB0aGUgbmV3IHJvb3QgZWxlbWVudCBmb3IgdGhlIGNhbnZhc1xuICogYW5kIHJldHVybnMgdGhlIG5ldyByb290IGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8ZGpzLm1vZGVsLlJvb3R9IGVsZW1lbnRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW292ZXJyaWRlXSB3aGV0aGVyIHRvIG92ZXJyaWRlIHRoZSBjdXJyZW50IHJvb3QgZWxlbWVudCwgaWYgYW55XG4gKlxuICogQHJldHVybiB7T2JqZWN0fGRqcy5tb2RlbC5Sb290fSBuZXcgcm9vdCBlbGVtZW50XG4gKi9cbkNhbnZhcy5wcm90b3R5cGUuc2V0Um9vdEVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBvdmVycmlkZSkge1xuXG4gIGlmIChlbGVtZW50KSB7XG4gICAgdGhpcy5fZW5zdXJlVmFsaWQoJ3Jvb3QnLCBlbGVtZW50KTtcbiAgfVxuXG4gIHZhciBjdXJyZW50Um9vdCA9IHRoaXMuX3Jvb3RFbGVtZW50LFxuICAgICAgZWxlbWVudFJlZ2lzdHJ5ID0gdGhpcy5fZWxlbWVudFJlZ2lzdHJ5LFxuICAgICAgZXZlbnRCdXMgPSB0aGlzLl9ldmVudEJ1cztcblxuICBpZiAoY3VycmVudFJvb3QpIHtcbiAgICBpZiAoIW92ZXJyaWRlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jvb3RFbGVtZW50IGFscmVhZHkgc2V0LCBuZWVkIHRvIHNwZWNpZnkgb3ZlcnJpZGUnKTtcbiAgICB9XG5cbiAgICAvLyBzaW11bGF0ZSBlbGVtZW50IHJlbW92ZSBldmVudCBzZXF1ZW5jZVxuICAgIGV2ZW50QnVzLmZpcmUoJ3Jvb3QucmVtb3ZlJywgeyBlbGVtZW50OiBjdXJyZW50Um9vdCB9KTtcbiAgICBldmVudEJ1cy5maXJlKCdyb290LnJlbW92ZWQnLCB7IGVsZW1lbnQ6IGN1cnJlbnRSb290IH0pO1xuXG4gICAgZWxlbWVudFJlZ2lzdHJ5LnJlbW92ZShjdXJyZW50Um9vdCk7XG4gIH1cblxuICBpZiAoZWxlbWVudCkge1xuICAgIHZhciBnZnggPSB0aGlzLmdldERlZmF1bHRMYXllcigpO1xuXG4gICAgLy8gcmVzZW1ibGUgZWxlbWVudCBhZGQgZXZlbnQgc2VxdWVuY2VcbiAgICBldmVudEJ1cy5maXJlKCdyb290LmFkZCcsIHsgZWxlbWVudDogZWxlbWVudCB9KTtcblxuICAgIGVsZW1lbnRSZWdpc3RyeS5hZGQoZWxlbWVudCwgZ2Z4LCB0aGlzLl9zdmcpO1xuXG4gICAgZXZlbnRCdXMuZmlyZSgncm9vdC5hZGRlZCcsIHsgZWxlbWVudDogZWxlbWVudCwgZ2Z4OiBnZnggfSk7XG4gIH1cblxuICB0aGlzLl9yb290RWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG5cblxuLy8gYWRkIGZ1bmN0aW9uYWxpdHkgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5DYW52YXMucHJvdG90eXBlLl9lbnN1cmVWYWxpZCA9IGZ1bmN0aW9uKHR5cGUsIGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50LmlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbGVtZW50IG11c3QgaGF2ZSBhbiBpZCcpO1xuICB9XG5cbiAgaWYgKHRoaXMuX2VsZW1lbnRSZWdpc3RyeS5nZXQoZWxlbWVudC5pZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VsZW1lbnQgd2l0aCBpZCAnICsgZWxlbWVudC5pZCArICcgYWxyZWFkeSBleGlzdHMnKTtcbiAgfVxuXG4gIHZhciByZXF1aXJlZEF0dHJzID0gUkVRVUlSRURfTU9ERUxfQVRUUlNbdHlwZV07XG5cbiAgdmFyIHZhbGlkID0gZXZlcnkocmVxdWlyZWRBdHRycywgZnVuY3Rpb24oYXR0cikge1xuICAgIHJldHVybiB0eXBlb2YgZWxlbWVudFthdHRyXSAhPT0gJ3VuZGVmaW5lZCc7XG4gIH0pO1xuXG4gIGlmICghdmFsaWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnbXVzdCBzdXBwbHkgeyAnICsgcmVxdWlyZWRBdHRycy5qb2luKCcsICcpICsgJyB9IHdpdGggJyArIHR5cGUpO1xuICB9XG59O1xuXG5DYW52YXMucHJvdG90eXBlLl9zZXRQYXJlbnQgPSBmdW5jdGlvbihlbGVtZW50LCBwYXJlbnQsIHBhcmVudEluZGV4KSB7XG4gIGNvbGxlY3Rpb25BZGQocGFyZW50LmNoaWxkcmVuLCBlbGVtZW50LCBwYXJlbnRJbmRleCk7XG4gIGVsZW1lbnQucGFyZW50ID0gcGFyZW50O1xufTtcblxuLyoqXG4gKiBBZGRzIGFuIGVsZW1lbnQgdG8gdGhlIGNhbnZhcy5cbiAqXG4gKiBUaGlzIHdpcmVzIHRoZSBwYXJlbnQgPC0+IGNoaWxkIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHRoZSBlbGVtZW50IGFuZFxuICogYSBleHBsaWNpdGx5IHNwZWNpZmllZCBwYXJlbnQgb3IgYW4gaW1wbGljaXQgcm9vdCBlbGVtZW50LlxuICpcbiAqIER1cmluZyBhZGQgaXQgZW1pdHMgdGhlIGV2ZW50c1xuICpcbiAqICAqIDx7dHlwZX0uYWRkPiAoZWxlbWVudCwgcGFyZW50KVxuICogICogPHt0eXBlfS5hZGRlZD4gKGVsZW1lbnQsIGdmeClcbiAqXG4gKiBFeHRlbnNpb25zIG1heSBob29rIGludG8gdGhlc2UgZXZlbnRzIHRvIHBlcmZvcm0gdGhlaXIgbWFnaWMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fGRqcy5tb2RlbC5CYXNlfSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdHxkanMubW9kZWwuQmFzZX0gW3BhcmVudF1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyZW50SW5kZXhdXG4gKlxuICogQHJldHVybiB7T2JqZWN0fGRqcy5tb2RlbC5CYXNlfSB0aGUgYWRkZWQgZWxlbWVudFxuICovXG5DYW52YXMucHJvdG90eXBlLl9hZGRFbGVtZW50ID0gZnVuY3Rpb24odHlwZSwgZWxlbWVudCwgcGFyZW50LCBwYXJlbnRJbmRleCkge1xuXG4gIHBhcmVudCA9IHBhcmVudCB8fCB0aGlzLmdldFJvb3RFbGVtZW50KCk7XG5cbiAgdmFyIGV2ZW50QnVzID0gdGhpcy5fZXZlbnRCdXMsXG4gICAgICBncmFwaGljc0ZhY3RvcnkgPSB0aGlzLl9ncmFwaGljc0ZhY3Rvcnk7XG5cbiAgdGhpcy5fZW5zdXJlVmFsaWQodHlwZSwgZWxlbWVudCk7XG5cbiAgZXZlbnRCdXMuZmlyZSh0eXBlICsgJy5hZGQnLCB7IGVsZW1lbnQ6IGVsZW1lbnQsIHBhcmVudDogcGFyZW50IH0pO1xuXG4gIHRoaXMuX3NldFBhcmVudChlbGVtZW50LCBwYXJlbnQsIHBhcmVudEluZGV4KTtcblxuICAvLyBjcmVhdGUgZ3JhcGhpY3NcbiAgdmFyIGdmeCA9IGdyYXBoaWNzRmFjdG9yeS5jcmVhdGUodHlwZSwgZWxlbWVudCwgcGFyZW50SW5kZXgpO1xuXG4gIHRoaXMuX2VsZW1lbnRSZWdpc3RyeS5hZGQoZWxlbWVudCwgZ2Z4KTtcblxuICAvLyB1cGRhdGUgaXRzIHZpc3VhbFxuICBncmFwaGljc0ZhY3RvcnkudXBkYXRlKHR5cGUsIGVsZW1lbnQsIGdmeCk7XG5cbiAgZXZlbnRCdXMuZmlyZSh0eXBlICsgJy5hZGRlZCcsIHsgZWxlbWVudDogZWxlbWVudCwgZ2Z4OiBnZnggfSk7XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBzaGFwZSB0byB0aGUgY2FudmFzXG4gKlxuICogQHBhcmFtIHtPYmplY3R8ZGpzLm1vZGVsLlNoYXBlfSBzaGFwZSB0byBhZGQgdG8gdGhlIGRpYWdyYW1cbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IFtwYXJlbnRdXG4gKiBAcGFyYW0ge051bWJlcn0gW3BhcmVudEluZGV4XVxuICpcbiAqIEByZXR1cm4ge2Rqcy5tb2RlbC5TaGFwZX0gdGhlIGFkZGVkIHNoYXBlXG4gKi9cbkNhbnZhcy5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbihzaGFwZSwgcGFyZW50LCBwYXJlbnRJbmRleCkge1xuICByZXR1cm4gdGhpcy5fYWRkRWxlbWVudCgnc2hhcGUnLCBzaGFwZSwgcGFyZW50LCBwYXJlbnRJbmRleCk7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBjb25uZWN0aW9uIHRvIHRoZSBjYW52YXNcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxkanMubW9kZWwuQ29ubmVjdGlvbn0gY29ubmVjdGlvbiB0byBhZGQgdG8gdGhlIGRpYWdyYW1cbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IFtwYXJlbnRdXG4gKiBAcGFyYW0ge051bWJlcn0gW3BhcmVudEluZGV4XVxuICpcbiAqIEByZXR1cm4ge2Rqcy5tb2RlbC5Db25uZWN0aW9ufSB0aGUgYWRkZWQgY29ubmVjdGlvblxuICovXG5DYW52YXMucHJvdG90eXBlLmFkZENvbm5lY3Rpb24gPSBmdW5jdGlvbihjb25uZWN0aW9uLCBwYXJlbnQsIHBhcmVudEluZGV4KSB7XG4gIHJldHVybiB0aGlzLl9hZGRFbGVtZW50KCdjb25uZWN0aW9uJywgY29ubmVjdGlvbiwgcGFyZW50LCBwYXJlbnRJbmRleCk7XG59O1xuXG5cbi8qKlxuICogSW50ZXJuYWwgcmVtb3ZlIGVsZW1lbnRcbiAqL1xuQ2FudmFzLnByb3RvdHlwZS5fcmVtb3ZlRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIHR5cGUpIHtcblxuICB2YXIgZWxlbWVudFJlZ2lzdHJ5ID0gdGhpcy5fZWxlbWVudFJlZ2lzdHJ5LFxuICAgICAgZ3JhcGhpY3NGYWN0b3J5ID0gdGhpcy5fZ3JhcGhpY3NGYWN0b3J5LFxuICAgICAgZXZlbnRCdXMgPSB0aGlzLl9ldmVudEJ1cztcblxuICBlbGVtZW50ID0gZWxlbWVudFJlZ2lzdHJ5LmdldChlbGVtZW50LmlkIHx8IGVsZW1lbnQpO1xuXG4gIGlmICghZWxlbWVudCkge1xuXG4gICAgLy8gZWxlbWVudCB3YXMgcmVtb3ZlZCBhbHJlYWR5XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZXZlbnRCdXMuZmlyZSh0eXBlICsgJy5yZW1vdmUnLCB7IGVsZW1lbnQ6IGVsZW1lbnQgfSk7XG5cbiAgZ3JhcGhpY3NGYWN0b3J5LnJlbW92ZShlbGVtZW50KTtcblxuICAvLyB1bnNldCBwYXJlbnQgPC0+IGNoaWxkIHJlbGF0aW9uc2hpcFxuICBjb2xsZWN0aW9uUmVtb3ZlKGVsZW1lbnQucGFyZW50ICYmIGVsZW1lbnQucGFyZW50LmNoaWxkcmVuLCBlbGVtZW50KTtcbiAgZWxlbWVudC5wYXJlbnQgPSBudWxsO1xuXG4gIGV2ZW50QnVzLmZpcmUodHlwZSArICcucmVtb3ZlZCcsIHsgZWxlbWVudDogZWxlbWVudCB9KTtcblxuICBlbGVtZW50UmVnaXN0cnkucmVtb3ZlKGVsZW1lbnQpO1xuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuXG4vKipcbiAqIFJlbW92ZXMgYSBzaGFwZSBmcm9tIHRoZSBjYW52YXNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xkanMubW9kZWwuU2hhcGV9IHNoYXBlIG9yIHNoYXBlIGlkIHRvIGJlIHJlbW92ZWRcbiAqXG4gKiBAcmV0dXJuIHtkanMubW9kZWwuU2hhcGV9IHRoZSByZW1vdmVkIHNoYXBlXG4gKi9cbkNhbnZhcy5wcm90b3R5cGUucmVtb3ZlU2hhcGUgPSBmdW5jdGlvbihzaGFwZSkge1xuXG4gIC8qKlxuICAgKiBBbiBldmVudCBpbmRpY2F0aW5nIHRoYXQgYSBzaGFwZSBpcyBhYm91dCB0byBiZSByZW1vdmVkIGZyb20gdGhlIGNhbnZhcy5cbiAgICpcbiAgICogQG1lbWJlck9mIENhbnZhc1xuICAgKlxuICAgKiBAZXZlbnQgc2hhcGUucmVtb3ZlXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7ZGpzLm1vZGVsLlNoYXBlfSBlbGVtZW50IHRoZSBzaGFwZSBkZXNjcmlwdG9yXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBnZnggdGhlIGdyYXBoaWNhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2hhcGVcbiAgICovXG5cbiAgLyoqXG4gICAqIEFuIGV2ZW50IGluZGljYXRpbmcgdGhhdCBhIHNoYXBlIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgY2FudmFzLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgQ2FudmFzXG4gICAqXG4gICAqIEBldmVudCBzaGFwZS5yZW1vdmVkXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7ZGpzLm1vZGVsLlNoYXBlfSBlbGVtZW50IHRoZSBzaGFwZSBkZXNjcmlwdG9yXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBnZnggdGhlIGdyYXBoaWNhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2hhcGVcbiAgICovXG4gIHJldHVybiB0aGlzLl9yZW1vdmVFbGVtZW50KHNoYXBlLCAnc2hhcGUnKTtcbn07XG5cblxuLyoqXG4gKiBSZW1vdmVzIGEgY29ubmVjdGlvbiBmcm9tIHRoZSBjYW52YXNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xkanMubW9kZWwuQ29ubmVjdGlvbn0gY29ubmVjdGlvbiBvciBjb25uZWN0aW9uIGlkIHRvIGJlIHJlbW92ZWRcbiAqXG4gKiBAcmV0dXJuIHtkanMubW9kZWwuQ29ubmVjdGlvbn0gdGhlIHJlbW92ZWQgY29ubmVjdGlvblxuICovXG5DYW52YXMucHJvdG90eXBlLnJlbW92ZUNvbm5lY3Rpb24gPSBmdW5jdGlvbihjb25uZWN0aW9uKSB7XG5cbiAgLyoqXG4gICAqIEFuIGV2ZW50IGluZGljYXRpbmcgdGhhdCBhIGNvbm5lY3Rpb24gaXMgYWJvdXQgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBjYW52YXMuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBDYW52YXNcbiAgICpcbiAgICogQGV2ZW50IGNvbm5lY3Rpb24ucmVtb3ZlXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7ZGpzLm1vZGVsLkNvbm5lY3Rpb259IGVsZW1lbnQgdGhlIGNvbm5lY3Rpb24gZGVzY3JpcHRvclxuICAgKiBAcHJvcGVydHkge09iamVjdH0gZ2Z4IHRoZSBncmFwaGljYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbm5lY3Rpb25cbiAgICovXG5cbiAgLyoqXG4gICAqIEFuIGV2ZW50IGluZGljYXRpbmcgdGhhdCBhIGNvbm5lY3Rpb24gaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBjYW52YXMuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBDYW52YXNcbiAgICpcbiAgICogQGV2ZW50IGNvbm5lY3Rpb24ucmVtb3ZlZFxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJvcGVydHkge2Rqcy5tb2RlbC5Db25uZWN0aW9ufSBlbGVtZW50IHRoZSBjb25uZWN0aW9uIGRlc2NyaXB0b3JcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IGdmeCB0aGUgZ3JhcGhpY2FsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb25uZWN0aW9uXG4gICAqL1xuICByZXR1cm4gdGhpcy5fcmVtb3ZlRWxlbWVudChjb25uZWN0aW9uLCAnY29ubmVjdGlvbicpO1xufTtcblxuXG4vKipcbiAqIFJldHVybiB0aGUgZ3JhcGhpY2FsIG9iamVjdCB1bmRlcmxheWluZyBhIGNlcnRhaW4gZGlhZ3JhbSBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnQgZGVzY3JpcHRvciBvZiB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtCb29sZWFufSBbc2Vjb25kYXJ5PWZhbHNlXSB3aGV0aGVyIHRvIHJldHVybiB0aGUgc2Vjb25kYXJ5IGNvbm5lY3RlZCBlbGVtZW50XG4gKlxuICogQHJldHVybiB7U1ZHRWxlbWVudH1cbiAqL1xuQ2FudmFzLnByb3RvdHlwZS5nZXRHcmFwaGljcyA9IGZ1bmN0aW9uKGVsZW1lbnQsIHNlY29uZGFyeSkge1xuICByZXR1cm4gdGhpcy5fZWxlbWVudFJlZ2lzdHJ5LmdldEdyYXBoaWNzKGVsZW1lbnQsIHNlY29uZGFyeSk7XG59O1xuXG5cbi8qKlxuICogUGVyZm9ybSBhIHZpZXdib3ggdXBkYXRlIHZpYSBhIGdpdmVuIGNoYW5nZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjaGFuZ2VGblxuICovXG5DYW52YXMucHJvdG90eXBlLl9jaGFuZ2VWaWV3Ym94ID0gZnVuY3Rpb24oY2hhbmdlRm4pIHtcblxuICAvLyBub3RpZnkgb3RoZXJzIG9mIHRoZSB1cGNvbWluZyB2aWV3Ym94IGNoYW5nZVxuICB0aGlzLl9ldmVudEJ1cy5maXJlKCdjYW52YXMudmlld2JveC5jaGFuZ2luZycpO1xuXG4gIC8vIHBlcmZvcm0gYWN0dWFsIGNoYW5nZVxuICBjaGFuZ2VGbi5hcHBseSh0aGlzKTtcblxuICAvLyByZXNldCB0aGUgY2FjaGVkIHZpZXdib3ggc28gdGhhdFxuICAvLyBhIG5ldyBnZXQgb3BlcmF0aW9uIG9uIHZpZXdib3ggb3Igem9vbVxuICAvLyB0cmlnZ2VycyBhIHZpZXdib3ggcmUtY29tcHV0YXRpb25cbiAgdGhpcy5fY2FjaGVkVmlld2JveCA9IG51bGw7XG5cbiAgLy8gbm90aWZ5IG90aGVycyBvZiB0aGUgY2hhbmdlOyB0aGlzIHN0ZXBcbiAgLy8gbWF5IG9yIG1heSBub3QgYmUgZGVib3VuY2VkXG4gIHRoaXMuX3ZpZXdib3hDaGFuZ2VkKCk7XG59O1xuXG5DYW52YXMucHJvdG90eXBlLl92aWV3Ym94Q2hhbmdlZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9ldmVudEJ1cy5maXJlKCdjYW52YXMudmlld2JveC5jaGFuZ2VkJywgeyB2aWV3Ym94OiB0aGlzLnZpZXdib3goKSB9KTtcbn07XG5cblxuLyoqXG4gKiBHZXRzIG9yIHNldHMgdGhlIHZpZXcgYm94IG9mIHRoZSBjYW52YXMsIGkuZS4gdGhlXG4gKiBhcmVhIHRoYXQgaXMgY3VycmVudGx5IGRpc3BsYXllZC5cbiAqXG4gKiBUaGUgZ2V0dGVyIG1heSByZXR1cm4gYSBjYWNoZWQgdmlld2JveCAoaWYgaXQgaXMgY3VycmVudGx5XG4gKiBjaGFuZ2luZykuIFRvIGZvcmNlIGEgcmVjb21wdXRhdGlvbiwgcGFzcyBgZmFsc2VgIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGNhbnZhcy52aWV3Ym94KHsgeDogMTAwLCB5OiAxMDAsIHdpZHRoOiA1MDAsIGhlaWdodDogNTAwIH0pXG4gKlxuICogLy8gc2V0cyB0aGUgdmlzaWJsZSBhcmVhIG9mIHRoZSBkaWFncmFtIHRvICgxMDB8MTAwKSAtPiAoNjAwfDEwMClcbiAqIC8vIGFuZCBhbmQgc2NhbGVzIGl0IGFjY29yZGluZyB0byB0aGUgZGlhZ3JhbSB3aWR0aFxuICpcbiAqIHZhciB2aWV3Ym94ID0gY2FudmFzLnZpZXdib3goKTsgLy8gcGFzcyBgZmFsc2VgIHRvIGZvcmNlIHJlY29tcHV0aW5nIHRoZSBib3guXG4gKlxuICogY29uc29sZS5sb2codmlld2JveCk7XG4gKiAvLyB7XG4gKiAvLyAgIGlubmVyOiBEaW1lbnNpb25zLFxuICogLy8gICBvdXRlcjogRGltZW5zaW9ucyxcbiAqIC8vICAgc2NhbGUsXG4gKiAvLyAgIHgsIHksXG4gKiAvLyAgIHdpZHRoLCBoZWlnaHRcbiAqIC8vIH1cbiAqXG4gKiAvLyBpZiB0aGUgY3VycmVudCBkaWFncmFtIGlzIHpvb21lZCBhbmQgc2Nyb2xsZWQsIHlvdSBtYXkgcmVzZXQgaXQgdG8gdGhlXG4gKiAvLyBkZWZhdWx0IHpvb20gdmlhIHRoaXMgbWV0aG9kLCB0b286XG4gKlxuICogdmFyIHpvb21lZEFuZFNjcm9sbGVkVmlld2JveCA9IGNhbnZhcy52aWV3Ym94KCk7XG4gKlxuICogY2FudmFzLnZpZXdib3goe1xuICogICB4OiAwLFxuICogICB5OiAwLFxuICogICB3aWR0aDogem9vbWVkQW5kU2Nyb2xsZWRWaWV3Ym94Lm91dGVyLndpZHRoLFxuICogICBoZWlnaHQ6IHpvb21lZEFuZFNjcm9sbGVkVmlld2JveC5vdXRlci5oZWlnaHRcbiAqIH0pO1xuICpcbiAqIEBwYXJhbSAge09iamVjdH0gW2JveF0gdGhlIG5ldyB2aWV3IGJveCB0byBzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gYm94LnggdGhlIHRvcCBsZWZ0IFggY29vcmRpbmF0ZSBvZiB0aGUgY2FudmFzIHZpc2libGUgaW4gdmlldyBib3hcbiAqIEBwYXJhbSAge051bWJlcn0gYm94LnkgdGhlIHRvcCBsZWZ0IFkgY29vcmRpbmF0ZSBvZiB0aGUgY2FudmFzIHZpc2libGUgaW4gdmlldyBib3hcbiAqIEBwYXJhbSAge051bWJlcn0gYm94LndpZHRoIHRoZSB2aXNpYmxlIHdpZHRoXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGJveC5oZWlnaHRcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBjdXJyZW50IHZpZXcgYm94XG4gKi9cbkNhbnZhcy5wcm90b3R5cGUudmlld2JveCA9IGZ1bmN0aW9uKGJveCkge1xuXG4gIGlmIChib3ggPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9jYWNoZWRWaWV3Ym94KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFZpZXdib3g7XG4gIH1cblxuICB2YXIgdmlld3BvcnQgPSB0aGlzLl92aWV3cG9ydCxcbiAgICAgIGlubmVyQm94LFxuICAgICAgb3V0ZXJCb3ggPSB0aGlzLmdldFNpemUoKSxcbiAgICAgIG1hdHJpeCxcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIHNjYWxlLFxuICAgICAgeCwgeTtcblxuICBpZiAoIWJveCkge1xuXG4gICAgLy8gY29tcHV0ZSB0aGUgaW5uZXIgYm94IGJhc2VkIG9uIHRoZVxuICAgIC8vIGRpYWdyYW1zIGRlZmF1bHQgbGF5ZXIuIFRoaXMgYWxsb3dzIHVzIHRvIGV4Y2x1ZGVcbiAgICAvLyBleHRlcm5hbCBjb21wb25lbnRzLCBzdWNoIGFzIG92ZXJsYXlzXG4gICAgaW5uZXJCb3ggPSB0aGlzLmdldERlZmF1bHRMYXllcigpLmdldEJCb3goKTtcblxuICAgIHRyYW5zZm9ybSA9IHN2Z1RyYW5zZm9ybSh2aWV3cG9ydCk7XG4gICAgbWF0cml4ID0gdHJhbnNmb3JtID8gdHJhbnNmb3JtLm1hdHJpeCA6IGNyZWF0ZU1hdHJpeCgpO1xuICAgIHNjYWxlID0gcm91bmQobWF0cml4LmEsIDEwMDApO1xuXG4gICAgeCA9IHJvdW5kKC1tYXRyaXguZSB8fCAwLCAxMDAwKTtcbiAgICB5ID0gcm91bmQoLW1hdHJpeC5mIHx8IDAsIDEwMDApO1xuXG4gICAgYm94ID0gdGhpcy5fY2FjaGVkVmlld2JveCA9IHtcbiAgICAgIHg6IHggPyB4IC8gc2NhbGUgOiAwLFxuICAgICAgeTogeSA/IHkgLyBzY2FsZSA6IDAsXG4gICAgICB3aWR0aDogb3V0ZXJCb3gud2lkdGggLyBzY2FsZSxcbiAgICAgIGhlaWdodDogb3V0ZXJCb3guaGVpZ2h0IC8gc2NhbGUsXG4gICAgICBzY2FsZTogc2NhbGUsXG4gICAgICBpbm5lcjoge1xuICAgICAgICB3aWR0aDogaW5uZXJCb3gud2lkdGgsXG4gICAgICAgIGhlaWdodDogaW5uZXJCb3guaGVpZ2h0LFxuICAgICAgICB4OiBpbm5lckJveC54LFxuICAgICAgICB5OiBpbm5lckJveC55XG4gICAgICB9LFxuICAgICAgb3V0ZXI6IG91dGVyQm94XG4gICAgfTtcblxuICAgIHJldHVybiBib3g7XG4gIH0gZWxzZSB7XG5cbiAgICB0aGlzLl9jaGFuZ2VWaWV3Ym94KGZ1bmN0aW9uKCkge1xuICAgICAgc2NhbGUgPSBNYXRoLm1pbihvdXRlckJveC53aWR0aCAvIGJveC53aWR0aCwgb3V0ZXJCb3guaGVpZ2h0IC8gYm94LmhlaWdodCk7XG5cbiAgICAgIHZhciBtYXRyaXggPSB0aGlzLl9zdmcuY3JlYXRlU1ZHTWF0cml4KClcbiAgICAgICAgLnNjYWxlKHNjYWxlKVxuICAgICAgICAudHJhbnNsYXRlKC1ib3gueCwgLWJveC55KTtcblxuICAgICAgc3ZnVHJhbnNmb3JtKHZpZXdwb3J0LCBtYXRyaXgpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGJveDtcbn07XG5cblxuLyoqXG4gKiBHZXRzIG9yIHNldHMgdGhlIHNjcm9sbCBvZiB0aGUgY2FudmFzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZGVsdGFdIHRoZSBuZXcgc2Nyb2xsIHRvIGFwcGx5LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGEuZHhdXG4gKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhLmR5XVxuICovXG5DYW52YXMucHJvdG90eXBlLnNjcm9sbCA9IGZ1bmN0aW9uKGRlbHRhKSB7XG5cbiAgdmFyIG5vZGUgPSB0aGlzLl92aWV3cG9ydDtcbiAgdmFyIG1hdHJpeCA9IG5vZGUuZ2V0Q1RNKCk7XG5cbiAgaWYgKGRlbHRhKSB7XG4gICAgdGhpcy5fY2hhbmdlVmlld2JveChmdW5jdGlvbigpIHtcbiAgICAgIGRlbHRhID0gYXNzaWduKHsgZHg6IDAsIGR5OiAwIH0sIGRlbHRhIHx8IHt9KTtcblxuICAgICAgbWF0cml4ID0gdGhpcy5fc3ZnLmNyZWF0ZVNWR01hdHJpeCgpLnRyYW5zbGF0ZShkZWx0YS5keCwgZGVsdGEuZHkpLm11bHRpcGx5KG1hdHJpeCk7XG5cbiAgICAgIHNldENUTShub2RlLCBtYXRyaXgpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHsgeDogbWF0cml4LmUsIHk6IG1hdHJpeC5mIH07XG59O1xuXG5cbi8qKlxuICogR2V0cyBvciBzZXRzIHRoZSBjdXJyZW50IHpvb20gb2YgdGhlIGNhbnZhcywgb3B0aW9uYWxseSB6b29taW5nXG4gKiB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxuICpcbiAqIFRoZSBnZXR0ZXIgbWF5IHJldHVybiBhIGNhY2hlZCB6b29tIGxldmVsLiBDYWxsIGl0IHdpdGggYGZhbHNlYCBhc1xuICogdGhlIGZpcnN0IGFyZ3VtZW50IHRvIGZvcmNlIHJlY29tcHV0YXRpb24gb2YgdGhlIGN1cnJlbnQgbGV2ZWwuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBbbmV3U2NhbGVdIHRoZSBuZXcgem9vbSBsZXZlbCwgZWl0aGVyIGEgbnVtYmVyLCBpLmUuIDAuOSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBgZml0LXZpZXdwb3J0YCB0byBhZGp1c3QgdGhlIHNpemUgdG8gZml0IHRoZSBjdXJyZW50IHZpZXdwb3J0XG4gKiBAcGFyYW0ge1N0cmluZ3xQb2ludH0gW2NlbnRlcl0gdGhlIHJlZmVyZW5jZSBwb2ludCB7IHg6IC4uLCB5OiAuLn0gdG8gem9vbSB0bywgJ2F1dG8nIHRvIHpvb20gaW50byBtaWQgb3IgbnVsbFxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gdGhlIGN1cnJlbnQgc2NhbGVcbiAqL1xuQ2FudmFzLnByb3RvdHlwZS56b29tID0gZnVuY3Rpb24obmV3U2NhbGUsIGNlbnRlcikge1xuXG4gIGlmICghbmV3U2NhbGUpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3Ym94KG5ld1NjYWxlKS5zY2FsZTtcbiAgfVxuXG4gIGlmIChuZXdTY2FsZSA9PT0gJ2ZpdC12aWV3cG9ydCcpIHtcbiAgICByZXR1cm4gdGhpcy5fZml0Vmlld3BvcnQoY2VudGVyKTtcbiAgfVxuXG4gIHZhciBvdXRlcixcbiAgICAgIG1hdHJpeDtcblxuICB0aGlzLl9jaGFuZ2VWaWV3Ym94KGZ1bmN0aW9uKCkge1xuXG4gICAgaWYgKHR5cGVvZiBjZW50ZXIgIT09ICdvYmplY3QnKSB7XG4gICAgICBvdXRlciA9IHRoaXMudmlld2JveCgpLm91dGVyO1xuXG4gICAgICBjZW50ZXIgPSB7XG4gICAgICAgIHg6IG91dGVyLndpZHRoIC8gMixcbiAgICAgICAgeTogb3V0ZXIuaGVpZ2h0IC8gMlxuICAgICAgfTtcbiAgICB9XG5cbiAgICBtYXRyaXggPSB0aGlzLl9zZXRab29tKG5ld1NjYWxlLCBjZW50ZXIpO1xuICB9KTtcblxuICByZXR1cm4gcm91bmQobWF0cml4LmEsIDEwMDApO1xufTtcblxuZnVuY3Rpb24gc2V0Q1RNKG5vZGUsIG0pIHtcbiAgdmFyIG1zdHIgPSAnbWF0cml4KCcgKyBtLmEgKyAnLCcgKyBtLmIgKyAnLCcgKyBtLmMgKyAnLCcgKyBtLmQgKyAnLCcgKyBtLmUgKyAnLCcgKyBtLmYgKyAnKSc7XG4gIG5vZGUuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBtc3RyKTtcbn1cblxuQ2FudmFzLnByb3RvdHlwZS5fZml0Vmlld3BvcnQgPSBmdW5jdGlvbihjZW50ZXIpIHtcblxuICB2YXIgdmJveCA9IHRoaXMudmlld2JveCgpLFxuICAgICAgb3V0ZXIgPSB2Ym94Lm91dGVyLFxuICAgICAgaW5uZXIgPSB2Ym94LmlubmVyLFxuICAgICAgbmV3U2NhbGUsXG4gICAgICBuZXdWaWV3Ym94O1xuXG4gIC8vIGRpc3BsYXkgdGhlIGNvbXBsZXRlIGRpYWdyYW0gd2l0aG91dCB6b29taW5nIGluLlxuICAvLyBpbnN0ZWFkIG9mIHJlbHlpbmcgb24gaW50ZXJuYWwgem9vbSwgd2UgcGVyZm9ybSBhXG4gIC8vIGhhcmQgcmVzZXQgb24gdGhlIGNhbnZhcyB2aWV3Ym94IHRvIHJlYWxpemUgdGhpc1xuICAvL1xuICAvLyBpZiBkaWFncmFtIGRvZXMgbm90IG5lZWQgdG8gYmUgem9vbWVkIGluLCB3ZSBmb2N1cyBpdCBhcm91bmRcbiAgLy8gdGhlIGRpYWdyYW0gb3JpZ2luIGluc3RlYWRcblxuICBpZiAoaW5uZXIueCA+PSAwICYmXG4gICAgICBpbm5lci55ID49IDAgJiZcbiAgICAgIGlubmVyLnggKyBpbm5lci53aWR0aCA8PSBvdXRlci53aWR0aCAmJlxuICAgICAgaW5uZXIueSArIGlubmVyLmhlaWdodCA8PSBvdXRlci5oZWlnaHQgJiZcbiAgICAgICFjZW50ZXIpIHtcblxuICAgIG5ld1ZpZXdib3ggPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiBNYXRoLm1heChpbm5lci53aWR0aCArIGlubmVyLngsIG91dGVyLndpZHRoKSxcbiAgICAgIGhlaWdodDogTWF0aC5tYXgoaW5uZXIuaGVpZ2h0ICsgaW5uZXIueSwgb3V0ZXIuaGVpZ2h0KVxuICAgIH07XG4gIH0gZWxzZSB7XG5cbiAgICBuZXdTY2FsZSA9IE1hdGgubWluKDEsIG91dGVyLndpZHRoIC8gaW5uZXIud2lkdGgsIG91dGVyLmhlaWdodCAvIGlubmVyLmhlaWdodCk7XG4gICAgbmV3Vmlld2JveCA9IHtcbiAgICAgIHg6IGlubmVyLnggKyAoY2VudGVyID8gaW5uZXIud2lkdGggLyAyIC0gb3V0ZXIud2lkdGggLyBuZXdTY2FsZSAvIDIgOiAwKSxcbiAgICAgIHk6IGlubmVyLnkgKyAoY2VudGVyID8gaW5uZXIuaGVpZ2h0IC8gMiAtIG91dGVyLmhlaWdodCAvIG5ld1NjYWxlIC8gMiA6IDApLFxuICAgICAgd2lkdGg6IG91dGVyLndpZHRoIC8gbmV3U2NhbGUsXG4gICAgICBoZWlnaHQ6IG91dGVyLmhlaWdodCAvIG5ld1NjYWxlXG4gICAgfTtcbiAgfVxuXG4gIHRoaXMudmlld2JveChuZXdWaWV3Ym94KTtcblxuICByZXR1cm4gdGhpcy52aWV3Ym94KGZhbHNlKS5zY2FsZTtcbn07XG5cblxuQ2FudmFzLnByb3RvdHlwZS5fc2V0Wm9vbSA9IGZ1bmN0aW9uKHNjYWxlLCBjZW50ZXIpIHtcblxuICB2YXIgc3ZnID0gdGhpcy5fc3ZnLFxuICAgICAgdmlld3BvcnQgPSB0aGlzLl92aWV3cG9ydDtcblxuICB2YXIgbWF0cml4ID0gc3ZnLmNyZWF0ZVNWR01hdHJpeCgpO1xuICB2YXIgcG9pbnQgPSBzdmcuY3JlYXRlU1ZHUG9pbnQoKTtcblxuICB2YXIgY2VudGVyUG9pbnQsXG4gICAgICBvcmlnaW5hbFBvaW50LFxuICAgICAgY3VycmVudE1hdHJpeCxcbiAgICAgIHNjYWxlTWF0cml4LFxuICAgICAgbmV3TWF0cml4O1xuXG4gIGN1cnJlbnRNYXRyaXggPSB2aWV3cG9ydC5nZXRDVE0oKTtcblxuICB2YXIgY3VycmVudFNjYWxlID0gY3VycmVudE1hdHJpeC5hO1xuXG4gIGlmIChjZW50ZXIpIHtcbiAgICBjZW50ZXJQb2ludCA9IGFzc2lnbihwb2ludCwgY2VudGVyKTtcblxuICAgIC8vIHJldmVydCBhcHBsaWVkIHZpZXdwb3J0IHRyYW5zZm9ybWF0aW9uc1xuICAgIG9yaWdpbmFsUG9pbnQgPSBjZW50ZXJQb2ludC5tYXRyaXhUcmFuc2Zvcm0oY3VycmVudE1hdHJpeC5pbnZlcnNlKCkpO1xuXG4gICAgLy8gY3JlYXRlIHNjYWxlIG1hdHJpeFxuICAgIHNjYWxlTWF0cml4ID0gbWF0cml4XG4gICAgICAudHJhbnNsYXRlKG9yaWdpbmFsUG9pbnQueCwgb3JpZ2luYWxQb2ludC55KVxuICAgICAgLnNjYWxlKDEgLyBjdXJyZW50U2NhbGUgKiBzY2FsZSlcbiAgICAgIC50cmFuc2xhdGUoLW9yaWdpbmFsUG9pbnQueCwgLW9yaWdpbmFsUG9pbnQueSk7XG5cbiAgICBuZXdNYXRyaXggPSBjdXJyZW50TWF0cml4Lm11bHRpcGx5KHNjYWxlTWF0cml4KTtcbiAgfSBlbHNlIHtcbiAgICBuZXdNYXRyaXggPSBtYXRyaXguc2NhbGUoc2NhbGUpO1xuICB9XG5cbiAgc2V0Q1RNKHRoaXMuX3ZpZXdwb3J0LCBuZXdNYXRyaXgpO1xuXG4gIHJldHVybiBuZXdNYXRyaXg7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgY2FudmFzXG4gKlxuICogQHJldHVybiB7RGltZW5zaW9uc31cbiAqL1xuQ2FudmFzLnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCxcbiAgICBoZWlnaHQ6IHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHRcbiAgfTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGFic29sdXRlIGJvdW5kaW5nIGJveCBmb3IgdGhlIGdpdmVuIGVsZW1lbnRcbiAqXG4gKiBUaGUgYWJzb2x1dGUgYm91bmRpbmcgYm94IG1heSBiZSB1c2VkIHRvIGRpc3BsYXkgb3ZlcmxheXMgaW4gdGhlXG4gKiBjYWxsZXJzIChicm93c2VyKSBjb29yZGluYXRlIHN5c3RlbSByYXRoZXIgdGhhbiB0aGUgem9vbWVkIGluL291dFxuICogY2FudmFzIGNvb3JkaW5hdGVzLlxuICpcbiAqIEBwYXJhbSAge0VsZW1lbnREZXNjcmlwdG9yfSBlbGVtZW50XG4gKiBAcmV0dXJuIHtCb3VuZHN9IHRoZSBhYnNvbHV0ZSBib3VuZGluZyBib3hcbiAqL1xuQ2FudmFzLnByb3RvdHlwZS5nZXRBYnNvbHV0ZUJCb3ggPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHZhciB2Ym94ID0gdGhpcy52aWV3Ym94KCk7XG4gIHZhciBiYm94O1xuXG4gIC8vIGNvbm5lY3Rpb25cbiAgLy8gdXNlIHN2ZyBiYm94XG4gIGlmIChlbGVtZW50LndheXBvaW50cykge1xuICAgIHZhciBnZnggPSB0aGlzLmdldEdyYXBoaWNzKGVsZW1lbnQpO1xuXG4gICAgYmJveCA9IGdmeC5nZXRCQm94KCk7XG4gIH1cblxuICAvLyBzaGFwZXNcbiAgLy8gdXNlIGRhdGFcbiAgZWxzZSB7XG4gICAgYmJveCA9IGVsZW1lbnQ7XG4gIH1cblxuICB2YXIgeCA9IGJib3gueCAqIHZib3guc2NhbGUgLSB2Ym94LnggKiB2Ym94LnNjYWxlO1xuICB2YXIgeSA9IGJib3gueSAqIHZib3guc2NhbGUgLSB2Ym94LnkgKiB2Ym94LnNjYWxlO1xuXG4gIHZhciB3aWR0aCA9IGJib3gud2lkdGggKiB2Ym94LnNjYWxlO1xuICB2YXIgaGVpZ2h0ID0gYmJveC5oZWlnaHQgKiB2Ym94LnNjYWxlO1xuXG4gIHJldHVybiB7XG4gICAgeDogeCxcbiAgICB5OiB5LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufTtcblxuLyoqXG4gKiBGaXJlcyBhbiBldmVudCBpbiBvcmRlciBvdGhlciBtb2R1bGVzIGNhbiByZWFjdCB0byB0aGVcbiAqIGNhbnZhcyByZXNpemluZ1xuICovXG5DYW52YXMucHJvdG90eXBlLnJlc2l6ZWQgPSBmdW5jdGlvbigpIHtcblxuICAvLyBmb3JjZSByZWNvbXB1dGF0aW9uIG9mIHZpZXcgYm94XG4gIGRlbGV0ZSB0aGlzLl9jYWNoZWRWaWV3Ym94O1xuXG4gIHRoaXMuX2V2ZW50QnVzLmZpcmUoJ2NhbnZhcy5yZXNpemVkJyk7XG59O1xuIiwiaW1wb3J0IHtcbiAgY3JlYXRlXG59IGZyb20gJy4uL21vZGVsJztcblxuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnbWluLWRhc2gnO1xuXG4vKipcbiAqIEEgZmFjdG9yeSBmb3IgZGlhZ3JhbS1qcyBzaGFwZXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRWxlbWVudEZhY3RvcnkoKSB7XG4gIHRoaXMuX3VpZCA9IDEyO1xufVxuXG5cbkVsZW1lbnRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVSb290ID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgcmV0dXJuIHRoaXMuY3JlYXRlKCdyb290JywgYXR0cnMpO1xufTtcblxuRWxlbWVudEZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZUxhYmVsID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgcmV0dXJuIHRoaXMuY3JlYXRlKCdsYWJlbCcsIGF0dHJzKTtcbn07XG5cbkVsZW1lbnRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVTaGFwZSA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gIHJldHVybiB0aGlzLmNyZWF0ZSgnc2hhcGUnLCBhdHRycyk7XG59O1xuXG5FbGVtZW50RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gIHJldHVybiB0aGlzLmNyZWF0ZSgnY29ubmVjdGlvbicsIGF0dHJzKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbW9kZWwgZWxlbWVudCB3aXRoIHRoZSBnaXZlbiB0eXBlIGFuZFxuICogYSBudW1iZXIgb2YgcHJlLXNldCBhdHRyaWJ1dGVzLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVxuICogQHBhcmFtICB7T2JqZWN0fSBhdHRyc1xuICogQHJldHVybiB7ZGpzLm1vZGVsLkJhc2V9IHRoZSBuZXdseSBjcmVhdGVkIG1vZGVsIGluc3RhbmNlXG4gKi9cbkVsZW1lbnRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbih0eXBlLCBhdHRycykge1xuXG4gIGF0dHJzID0gYXNzaWduKHt9LCBhdHRycyB8fCB7fSk7XG5cbiAgaWYgKCFhdHRycy5pZCkge1xuICAgIGF0dHJzLmlkID0gdHlwZSArICdfJyArICh0aGlzLl91aWQrKyk7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlKHR5cGUsIGF0dHJzKTtcbn07IiwidmFyIEVMRU1FTlRfSUQgPSAnZGF0YS1lbGVtZW50LWlkJztcblxuaW1wb3J0IHsgYXR0ciBhcyBzdmdBdHRyIH0gZnJvbSAndGlueS1zdmcnO1xuXG5cbi8qKlxuICogQGNsYXNzXG4gKlxuICogQSByZWdpc3RyeSB0aGF0IGtlZXBzIHRyYWNrIG9mIGFsbCBzaGFwZXMgaW4gdGhlIGRpYWdyYW0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEVsZW1lbnRSZWdpc3RyeShldmVudEJ1cykge1xuICB0aGlzLl9lbGVtZW50cyA9IHt9O1xuXG4gIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG59XG5cbkVsZW1lbnRSZWdpc3RyeS4kaW5qZWN0ID0gWyAnZXZlbnRCdXMnIF07XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBwYWlyIG9mIChlbGVtZW50LCBnZngsIChzZWNvbmRhcnlHZngpKS5cbiAqXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5CYXNlfSBlbGVtZW50XG4gKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGdmeFxuICogQHBhcmFtIHtTVkdFbGVtZW50fSBbc2Vjb25kYXJ5R2Z4XSBvcHRpb25hbCBvdGhlciBlbGVtZW50IHRvIHJlZ2lzdGVyLCB0b29cbiAqL1xuRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihlbGVtZW50LCBnZngsIHNlY29uZGFyeUdmeCkge1xuXG4gIHZhciBpZCA9IGVsZW1lbnQuaWQ7XG5cbiAgdGhpcy5fdmFsaWRhdGVJZChpZCk7XG5cbiAgLy8gYXNzb2NpYXRlIGRvbSBub2RlIHdpdGggZWxlbWVudFxuICBzdmdBdHRyKGdmeCwgRUxFTUVOVF9JRCwgaWQpO1xuXG4gIGlmIChzZWNvbmRhcnlHZngpIHtcbiAgICBzdmdBdHRyKHNlY29uZGFyeUdmeCwgRUxFTUVOVF9JRCwgaWQpO1xuICB9XG5cbiAgdGhpcy5fZWxlbWVudHNbaWRdID0geyBlbGVtZW50OiBlbGVtZW50LCBnZng6IGdmeCwgc2Vjb25kYXJ5R2Z4OiBzZWNvbmRhcnlHZnggfTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbiBlbGVtZW50IGZyb20gdGhlIHJlZ2lzdHJ5LlxuICpcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAqL1xuRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHZhciBlbGVtZW50cyA9IHRoaXMuX2VsZW1lbnRzLFxuICAgICAgaWQgPSBlbGVtZW50LmlkIHx8IGVsZW1lbnQsXG4gICAgICBjb250YWluZXIgPSBpZCAmJiBlbGVtZW50c1tpZF07XG5cbiAgaWYgKGNvbnRhaW5lcikge1xuXG4gICAgLy8gdW5zZXQgZWxlbWVudCBpZCBvbiBnZnhcbiAgICBzdmdBdHRyKGNvbnRhaW5lci5nZngsIEVMRU1FTlRfSUQsICcnKTtcblxuICAgIGlmIChjb250YWluZXIuc2Vjb25kYXJ5R2Z4KSB7XG4gICAgICBzdmdBdHRyKGNvbnRhaW5lci5zZWNvbmRhcnlHZngsIEVMRU1FTlRfSUQsICcnKTtcbiAgICB9XG5cbiAgICBkZWxldGUgZWxlbWVudHNbaWRdO1xuICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgaWQgb2YgYW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBuZXdJZFxuICovXG5FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlLnVwZGF0ZUlkID0gZnVuY3Rpb24oZWxlbWVudCwgbmV3SWQpIHtcblxuICB0aGlzLl92YWxpZGF0ZUlkKG5ld0lkKTtcblxuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgZWxlbWVudCA9IHRoaXMuZ2V0KGVsZW1lbnQpO1xuICB9XG5cbiAgdGhpcy5fZXZlbnRCdXMuZmlyZSgnZWxlbWVudC51cGRhdGVJZCcsIHtcbiAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgIG5ld0lkOiBuZXdJZFxuICB9KTtcblxuICB2YXIgZ2Z4ID0gdGhpcy5nZXRHcmFwaGljcyhlbGVtZW50KSxcbiAgICAgIHNlY29uZGFyeUdmeCA9IHRoaXMuZ2V0R3JhcGhpY3MoZWxlbWVudCwgdHJ1ZSk7XG5cbiAgdGhpcy5yZW1vdmUoZWxlbWVudCk7XG5cbiAgZWxlbWVudC5pZCA9IG5ld0lkO1xuXG4gIHRoaXMuYWRkKGVsZW1lbnQsIGdmeCwgc2Vjb25kYXJ5R2Z4KTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBtb2RlbCBlbGVtZW50IGZvciBhIGdpdmVuIGlkIG9yIGdyYXBoaWNzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogZWxlbWVudFJlZ2lzdHJ5LmdldCgnU29tZUVsZW1lbnRJZF8xJyk7XG4gKiBlbGVtZW50UmVnaXN0cnkuZ2V0KGdmeCk7XG4gKlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFNWR0VsZW1lbnR9IGZpbHRlciBmb3Igc2VsZWN0aW5nIHRoZSBlbGVtZW50XG4gKlxuICogQHJldHVybiB7ZGpzLm1vZGVsLkJhc2V9XG4gKi9cbkVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oZmlsdGVyKSB7XG4gIHZhciBpZDtcblxuICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZycpIHtcbiAgICBpZCA9IGZpbHRlcjtcbiAgfSBlbHNlIHtcbiAgICBpZCA9IGZpbHRlciAmJiBzdmdBdHRyKGZpbHRlciwgRUxFTUVOVF9JRCk7XG4gIH1cblxuICB2YXIgY29udGFpbmVyID0gdGhpcy5fZWxlbWVudHNbaWRdO1xuICByZXR1cm4gY29udGFpbmVyICYmIGNvbnRhaW5lci5lbGVtZW50O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYWxsIGVsZW1lbnRzIHRoYXQgbWF0Y2ggYSBnaXZlbiBmaWx0ZXIgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheTxkanMubW9kZWwuQmFzZT59XG4gKi9cbkVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24oZm4pIHtcblxuICB2YXIgZmlsdGVyZWQgPSBbXTtcblxuICB0aGlzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCwgZ2Z4KSB7XG4gICAgaWYgKGZuKGVsZW1lbnQsIGdmeCkpIHtcbiAgICAgIGZpbHRlcmVkLnB1c2goZWxlbWVudCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZmlsdGVyZWQ7XG59O1xuXG4vKipcbiAqIFJldHVybiBhbGwgcmVuZGVyZWQgbW9kZWwgZWxlbWVudHMuXG4gKlxuICogQHJldHVybiB7QXJyYXk8ZGpzLm1vZGVsLkJhc2U+fVxuICovXG5FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oZSkgeyByZXR1cm4gZTsgfSk7XG59O1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgZGlhZ3JhbSBlbGVtZW50cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihmbikge1xuXG4gIHZhciBtYXAgPSB0aGlzLl9lbGVtZW50cztcblxuICBPYmplY3Qua2V5cyhtYXApLmZvckVhY2goZnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgY29udGFpbmVyID0gbWFwW2lkXSxcbiAgICAgICAgZWxlbWVudCA9IGNvbnRhaW5lci5lbGVtZW50LFxuICAgICAgICBnZnggPSBjb250YWluZXIuZ2Z4O1xuXG4gICAgcmV0dXJuIGZuKGVsZW1lbnQsIGdmeCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGdyYXBoaWNhbCByZXByZXNlbnRhdGlvbiBvZiBhbiBlbGVtZW50IG9yIGl0cyBpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogZWxlbWVudFJlZ2lzdHJ5LmdldEdyYXBoaWNzKCdTb21lRWxlbWVudElkXzEnKTtcbiAqIGVsZW1lbnRSZWdpc3RyeS5nZXRHcmFwaGljcyhyb290RWxlbWVudCk7IC8vIDxnIC4uLj5cbiAqXG4gKiBlbGVtZW50UmVnaXN0cnkuZ2V0R3JhcGhpY3Mocm9vdEVsZW1lbnQsIHRydWUpOyAvLyA8c3ZnIC4uLj5cbiAqXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8ZGpzLm1vZGVsLkJhc2V9IGZpbHRlclxuICogQHBhcmFtIHtCb29sZWFufSBbc2Vjb25kYXJ5PWZhbHNlXSB3aGV0aGVyIHRvIHJldHVybiB0aGUgc2Vjb25kYXJ5IGNvbm5lY3RlZCBlbGVtZW50XG4gKlxuICogQHJldHVybiB7U1ZHRWxlbWVudH1cbiAqL1xuRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRHcmFwaGljcyA9IGZ1bmN0aW9uKGZpbHRlciwgc2Vjb25kYXJ5KSB7XG4gIHZhciBpZCA9IGZpbHRlci5pZCB8fCBmaWx0ZXI7XG5cbiAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2VsZW1lbnRzW2lkXTtcbiAgcmV0dXJuIGNvbnRhaW5lciAmJiAoc2Vjb25kYXJ5ID8gY29udGFpbmVyLnNlY29uZGFyeUdmeCA6IGNvbnRhaW5lci5nZngpO1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSB0aGUgc3VpdGFiaWxpdHkgb2YgdGhlIGdpdmVuIGlkIGFuZCBzaWduYWxzIGEgcHJvYmxlbVxuICogd2l0aCBhbiBleGNlcHRpb24uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKlxuICogQHRocm93cyB7RXJyb3J9IGlmIGlkIGlzIGVtcHR5IG9yIGFscmVhZHkgYXNzaWduZWRcbiAqL1xuRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZS5fdmFsaWRhdGVJZCA9IGZ1bmN0aW9uKGlkKSB7XG4gIGlmICghaWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VsZW1lbnQgbXVzdCBoYXZlIGFuIGlkJyk7XG4gIH1cblxuICBpZiAodGhpcy5fZWxlbWVudHNbaWRdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbGVtZW50IHdpdGggaWQgJyArIGlkICsgJyBhbHJlYWR5IGFkZGVkJyk7XG4gIH1cbn07XG4iLCJpbXBvcnQge1xuICBpc0Z1bmN0aW9uLFxuICBpc0FycmF5LFxuICBpc051bWJlcixcbiAgYmluZCxcbiAgYXNzaWduXG59IGZyb20gJ21pbi1kYXNoJztcblxudmFyIEZOX1JFRiA9ICdfX2ZuJztcblxudmFyIERFRkFVTFRfUFJJT1JJVFkgPSAxMDAwO1xuXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbi8qKlxuICogQSBnZW5lcmFsIHB1cnBvc2UgZXZlbnQgYnVzLlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGlzIHVzZWQgdG8gY29tbXVuaWNhdGUgYWNyb3NzIGEgZGlhZ3JhbSBpbnN0YW5jZS5cbiAqIE90aGVyIHBhcnRzIG9mIGEgZGlhZ3JhbSBjYW4gdXNlIGl0IHRvIGxpc3RlbiB0byBhbmQgYnJvYWRjYXN0IGV2ZW50cy5cbiAqXG4gKlxuICogIyMgUmVnaXN0ZXJpbmcgZm9yIEV2ZW50c1xuICpcbiAqIFRoZSBldmVudCBidXMgcHJvdmlkZXMgdGhlIHtAbGluayBFdmVudEJ1cyNvbn0gYW5kIHtAbGluayBFdmVudEJ1cyNvbmNlfVxuICogbWV0aG9kcyB0byByZWdpc3RlciBmb3IgZXZlbnRzLiB7QGxpbmsgRXZlbnRCdXMjb2ZmfSBjYW4gYmUgdXNlZCB0b1xuICogcmVtb3ZlIGV2ZW50IHJlZ2lzdHJhdGlvbnMuIExpc3RlbmVycyByZWNlaXZlIGFuIGluc3RhbmNlIG9mIHtAbGluayBFdmVudH1cbiAqIGFzIHRoZSBmaXJzdCBhcmd1bWVudC4gSXQgYWxsb3dzIHRoZW0gdG8gaG9vayBpbnRvIHRoZSBldmVudCBleGVjdXRpb24uXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICpcbiAqIC8vIGxpc3RlbiBmb3IgZXZlbnRcbiAqIGV2ZW50QnVzLm9uKCdmb28nLCBmdW5jdGlvbihldmVudCkge1xuICpcbiAqICAgLy8gYWNjZXNzIGV2ZW50IHR5cGVcbiAqICAgZXZlbnQudHlwZTsgLy8gJ2ZvbydcbiAqXG4gKiAgIC8vIHN0b3AgcHJvcGFnYXRpb24gdG8gb3RoZXIgbGlzdGVuZXJzXG4gKiAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICpcbiAqICAgLy8gcHJldmVudCBldmVudCBkZWZhdWx0XG4gKiAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gKiB9KTtcbiAqXG4gKiAvLyBsaXN0ZW4gZm9yIGV2ZW50IHdpdGggY3VzdG9tIHBheWxvYWRcbiAqIGV2ZW50QnVzLm9uKCdiYXInLCBmdW5jdGlvbihldmVudCwgcGF5bG9hZCkge1xuICogICBjb25zb2xlLmxvZyhwYXlsb2FkKTtcbiAqIH0pO1xuICpcbiAqIC8vIGxpc3RlbiBmb3IgZXZlbnQgcmV0dXJuaW5nIHZhbHVlXG4gKiBldmVudEJ1cy5vbignZm9vYmFyJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAqXG4gKiAgIC8vIHN0b3AgZXZlbnQgcHJvcGFnYXRpb24gKyBwcmV2ZW50IGRlZmF1bHRcbiAqICAgcmV0dXJuIGZhbHNlO1xuICpcbiAqICAgLy8gc3RvcCBldmVudCBwcm9wYWdhdGlvbiArIHJldHVybiBjdXN0b20gcmVzdWx0XG4gKiAgIHJldHVybiB7XG4gKiAgICAgY29tcGxleDogJ2xpc3RlbmluZyByZXN1bHQnXG4gKiAgIH07XG4gKiB9KTtcbiAqXG4gKlxuICogLy8gbGlzdGVuIHdpdGggY3VzdG9tIHByaW9yaXR5IChkZWZhdWx0PTEwMDAsIGhpZ2hlciBpcyBiZXR0ZXIpXG4gKiBldmVudEJ1cy5vbigncHJpb3JpdHlmb28nLCAxNTAwLCBmdW5jdGlvbihldmVudCkge1xuICogICBjb25zb2xlLmxvZygnaW52b2tlZCBmaXJzdCEnKTtcbiAqIH0pO1xuICpcbiAqXG4gKiAvLyBsaXN0ZW4gZm9yIGV2ZW50IGFuZCBwYXNzIHRoZSBjb250ZXh0IChgdGhpc2ApXG4gKiBldmVudEJ1cy5vbignZm9vYmFyJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAqICAgdGhpcy5mb28oKTtcbiAqIH0sIHRoaXMpO1xuICogYGBgXG4gKlxuICpcbiAqICMjIEVtaXR0aW5nIEV2ZW50c1xuICpcbiAqIEV2ZW50cyBjYW4gYmUgZW1pdHRlZCB2aWEgdGhlIGV2ZW50IGJ1cyB1c2luZyB7QGxpbmsgRXZlbnRCdXMjZmlyZX0uXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICpcbiAqIC8vIGZhbHNlIGluZGljYXRlcyB0aGF0IHRoZSBkZWZhdWx0IGFjdGlvblxuICogLy8gd2FzIHByZXZlbnRlZCBieSBsaXN0ZW5lcnNcbiAqIGlmIChldmVudEJ1cy5maXJlKCdmb28nKSA9PT0gZmFsc2UpIHtcbiAqICAgY29uc29sZS5sb2coJ2RlZmF1bHQgaGFzIGJlZW4gcHJldmVudGVkIScpO1xuICogfTtcbiAqXG4gKlxuICogLy8gY3VzdG9tIGFyZ3MgKyByZXR1cm4gdmFsdWUgbGlzdGVuZXJcbiAqIGV2ZW50QnVzLm9uKCdzdW0nLCBmdW5jdGlvbihldmVudCwgYSwgYikge1xuICogICByZXR1cm4gYSArIGI7XG4gKiB9KTtcbiAqXG4gKiAvLyB5b3UgY2FuIHBhc3MgY3VzdG9tIGFyZ3VtZW50cyArIHJldHJpZXZlIHJlc3VsdCB2YWx1ZXMuXG4gKiB2YXIgc3VtID0gZXZlbnRCdXMuZmlyZSgnc3VtJywgMSwgMik7XG4gKiBjb25zb2xlLmxvZyhzdW0pOyAvLyAzXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRXZlbnRCdXMoKSB7XG4gIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuXG4gIC8vIGNsZWFudXAgb24gZGVzdHJveSBvbiBsb3dlc3QgcHJpb3JpdHkgdG8gYWxsb3dcbiAgLy8gbWVzc2FnZSBwYXNzaW5nIHVudGlsIHRoZSBiaXR0ZXIgZW5kXG4gIHRoaXMub24oJ2RpYWdyYW0uZGVzdHJveScsIDEsIHRoaXMuX2Rlc3Ryb3ksIHRoaXMpO1xufVxuXG5cbi8qKlxuICogUmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIGV2ZW50cyB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICpcbiAqIFRoZSBjYWxsYmFjayB3aWxsIGJlIGludm9rZWQgd2l0aCBgZXZlbnQsIC4uLmFkZGl0aW9uYWxBcmd1bWVudHNgXG4gKiB0aGF0IGhhdmUgYmVlbiBwYXNzZWQgdG8ge0BsaW5rIEV2ZW50QnVzI2ZpcmV9LlxuICpcbiAqIFJldHVybmluZyBmYWxzZSBmcm9tIGEgbGlzdGVuZXIgd2lsbCBwcmV2ZW50IHRoZSBldmVudHMgZGVmYXVsdCBhY3Rpb25cbiAqIChpZiBhbnkgaXMgc3BlY2lmaWVkKS4gVG8gc3RvcCBhbiBldmVudCBmcm9tIGJlaW5nIHByb2Nlc3NlZCBmdXJ0aGVyIGluXG4gKiBvdGhlciBsaXN0ZW5lcnMgZXhlY3V0ZSB7QGxpbmsgRXZlbnQjc3RvcFByb3BhZ2F0aW9ufS5cbiAqXG4gKiBSZXR1cm5pbmcgYW55dGhpbmcgYnV0IGB1bmRlZmluZWRgIGZyb20gYSBsaXN0ZW5lciB3aWxsIHN0b3AgdGhlIGxpc3RlbmVyIHByb3BhZ2F0aW9uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5PFN0cmluZz59IGV2ZW50c1xuICogQHBhcmFtIHtOdW1iZXJ9IFtwcmlvcml0eT0xMDAwXSB0aGUgcHJpb3JpdHkgaW4gd2hpY2ggdGhpcyBsaXN0ZW5lciBpcyBjYWxsZWQsIGxhcmdlciBpcyBoaWdoZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdH0gW3RoYXRdIFBhc3MgY29udGV4dCAoYHRoaXNgKSB0byB0aGUgY2FsbGJhY2tcbiAqL1xuRXZlbnRCdXMucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXZlbnRzLCBwcmlvcml0eSwgY2FsbGJhY2ssIHRoYXQpIHtcblxuICBldmVudHMgPSBpc0FycmF5KGV2ZW50cykgPyBldmVudHMgOiBbIGV2ZW50cyBdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKHByaW9yaXR5KSkge1xuICAgIHRoYXQgPSBjYWxsYmFjaztcbiAgICBjYWxsYmFjayA9IHByaW9yaXR5O1xuICAgIHByaW9yaXR5ID0gREVGQVVMVF9QUklPUklUWTtcbiAgfVxuXG4gIGlmICghaXNOdW1iZXIocHJpb3JpdHkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcmlvcml0eSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIH1cblxuICB2YXIgYWN0dWFsQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICBpZiAodGhhdCkge1xuICAgIGFjdHVhbENhbGxiYWNrID0gYmluZChjYWxsYmFjaywgdGhhdCk7XG5cbiAgICAvLyBtYWtlIHN1cmUgd2UgcmVtZW1iZXIgYW5kIGFyZSBhYmxlIHRvIHJlbW92ZVxuICAgIC8vIGJvdW5kIGNhbGxiYWNrcyB2aWEge0BsaW5rICNvZmZ9IHVzaW5nIHRoZSBvcmlnaW5hbFxuICAgIC8vIGNhbGxiYWNrXG4gICAgYWN0dWFsQ2FsbGJhY2tbRk5fUkVGXSA9IGNhbGxiYWNrW0ZOX1JFRl0gfHwgY2FsbGJhY2s7XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgIHNlbGYuX2FkZExpc3RlbmVyKGUsIHtcbiAgICAgIHByaW9yaXR5OiBwcmlvcml0eSxcbiAgICAgIGNhbGxiYWNrOiBhY3R1YWxDYWxsYmFjayxcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogUmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCBpcyBleGVjdXRlZCBvbmx5IG9uY2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IHRoZSBldmVudCBuYW1lIHRvIHJlZ2lzdGVyIGZvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtwcmlvcml0eT0xMDAwXSB0aGUgcHJpb3JpdHkgaW4gd2hpY2ggdGhpcyBsaXN0ZW5lciBpcyBjYWxsZWQsIGxhcmdlciBpcyBoaWdoZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRoZSBjYWxsYmFjayB0byBleGVjdXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW3RoYXRdIFBhc3MgY29udGV4dCAoYHRoaXNgKSB0byB0aGUgY2FsbGJhY2tcbiAqL1xuRXZlbnRCdXMucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgcHJpb3JpdHksIGNhbGxiYWNrLCB0aGF0KSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoaXNGdW5jdGlvbihwcmlvcml0eSkpIHtcbiAgICB0aGF0ID0gY2FsbGJhY2s7XG4gICAgY2FsbGJhY2sgPSBwcmlvcml0eTtcbiAgICBwcmlvcml0eSA9IERFRkFVTFRfUFJJT1JJVFk7XG4gIH1cblxuICBpZiAoIWlzTnVtYmVyKHByaW9yaXR5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJpb3JpdHkgbXVzdCBiZSBhIG51bWJlcicpO1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcHBlZENhbGxiYWNrKCkge1xuICAgIHZhciByZXN1bHQgPSBjYWxsYmFjay5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuXG4gICAgc2VsZi5vZmYoZXZlbnQsIHdyYXBwZWRDYWxsYmFjayk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHdlIHJlbWVtYmVyIGFuZCBhcmUgYWJsZSB0byByZW1vdmVcbiAgLy8gYm91bmQgY2FsbGJhY2tzIHZpYSB7QGxpbmsgI29mZn0gdXNpbmcgdGhlIG9yaWdpbmFsXG4gIC8vIGNhbGxiYWNrXG4gIHdyYXBwZWRDYWxsYmFja1tGTl9SRUZdID0gY2FsbGJhY2s7XG5cbiAgdGhpcy5vbihldmVudCwgcHJpb3JpdHksIHdyYXBwZWRDYWxsYmFjayk7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lcnMgYnkgZXZlbnQgYW5kIGNhbGxiYWNrLlxuICpcbiAqIElmIG5vIGNhbGxiYWNrIGlzIGdpdmVuLCBhbGwgbGlzdGVuZXJzIGZvciBhIGdpdmVuIGV2ZW50IG5hbWUgYXJlIGJlaW5nIHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXk8U3RyaW5nPn0gZXZlbnRzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gKi9cbkV2ZW50QnVzLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbihldmVudHMsIGNhbGxiYWNrKSB7XG5cbiAgZXZlbnRzID0gaXNBcnJheShldmVudHMpID8gZXZlbnRzIDogWyBldmVudHMgXTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBzZWxmLl9yZW1vdmVMaXN0ZW5lcihldmVudCwgY2FsbGJhY2spO1xuICB9KTtcblxufTtcblxuXG4vKipcbiAqIENyZWF0ZSBhbiBFdmVudEJ1cyBldmVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gZXZlbnQsIHJlY29nbml6ZWQgYnkgdGhlIGV2ZW50QnVzXG4gKi9cbkV2ZW50QnVzLnByb3RvdHlwZS5jcmVhdGVFdmVudCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIGV2ZW50ID0gbmV3IEludGVybmFsRXZlbnQoKTtcblxuICBldmVudC5pbml0KGRhdGEpO1xuXG4gIHJldHVybiBldmVudDtcbn07XG5cblxuLyoqXG4gKiBGaXJlcyBhIG5hbWVkIGV2ZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gZmlyZSBldmVudCBieSBuYW1lXG4gKiBldmVudHMuZmlyZSgnZm9vJyk7XG4gKlxuICogLy8gZmlyZSBldmVudCBvYmplY3Qgd2l0aCBuZXN0ZWQgdHlwZVxuICogdmFyIGV2ZW50ID0geyB0eXBlOiAnZm9vJyB9O1xuICogZXZlbnRzLmZpcmUoZXZlbnQpO1xuICpcbiAqIC8vIGZpcmUgZXZlbnQgd2l0aCBleHBsaWNpdCB0eXBlXG4gKiB2YXIgZXZlbnQgPSB7IHg6IDEwLCB5OiAyMCB9O1xuICogZXZlbnRzLmZpcmUoJ2VsZW1lbnQubW92ZWQnLCBldmVudCk7XG4gKlxuICogLy8gcGFzcyBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byB0aGUgZXZlbnRcbiAqIGV2ZW50cy5vbignZm9vJywgZnVuY3Rpb24oZXZlbnQsIGJhcikge1xuICogICBhbGVydChiYXIpO1xuICogfSk7XG4gKlxuICogZXZlbnRzLmZpcmUoeyB0eXBlOiAnZm9vJyB9LCAnSSBhbSBiYXIhJyk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lXSB0aGUgb3B0aW9uYWwgZXZlbnQgbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IFtldmVudF0gdGhlIGV2ZW50IG9iamVjdFxuICogQHBhcmFtIHsuLi5PYmplY3R9IGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb25zXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gdGhlIGV2ZW50cyByZXR1cm4gdmFsdWUsIGlmIHNwZWNpZmllZCBvciBmYWxzZSBpZiB0aGVcbiAqICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgYWN0aW9uIHdhcyBwcmV2ZW50ZWQgYnkgbGlzdGVuZXJzXG4gKi9cbkV2ZW50QnVzLnByb3RvdHlwZS5maXJlID0gZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuICB2YXIgZXZlbnQsXG4gICAgICBmaXJzdExpc3RlbmVyLFxuICAgICAgcmV0dXJuVmFsdWUsXG4gICAgICBhcmdzO1xuXG4gIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIGRhdGEgPSB0eXBlO1xuICAgIHR5cGUgPSBkYXRhLnR5cGU7XG4gIH1cblxuICBpZiAoIXR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGV2ZW50IHR5cGUgc3BlY2lmaWVkJyk7XG4gIH1cblxuICBmaXJzdExpc3RlbmVyID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xuXG4gIGlmICghZmlyc3RMaXN0ZW5lcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHdlIG1ha2Ugc3VyZSB3ZSBmaXJlIGluc3RhbmNlcyBvZiBvdXIgaG9tZSBtYWRlXG4gIC8vIGV2ZW50cyBoZXJlLiBXZSB3cmFwIHRoZW0gb25seSBvbmNlLCB0aG91Z2hcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBJbnRlcm5hbEV2ZW50KSB7XG5cbiAgICAvLyB3ZSBhcmUgZmluZSwgd2UgYWxyZWFkIGhhdmUgYW4gZXZlbnRcbiAgICBldmVudCA9IGRhdGE7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnQgPSB0aGlzLmNyZWF0ZUV2ZW50KGRhdGEpO1xuICB9XG5cbiAgLy8gZW5zdXJlIHdlIHBhc3MgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXJcbiAgYXJnc1swXSA9IGV2ZW50O1xuXG4gIC8vIG9yaWdpbmFsIGV2ZW50IHR5cGUgKGluIGNhc2Ugd2UgZGVsZWdhdGUpXG4gIHZhciBvcmlnaW5hbFR5cGUgPSBldmVudC50eXBlO1xuXG4gIC8vIHVwZGF0ZSBldmVudCB0eXBlIGJlZm9yZSBkZWxlZ2F0aW9uXG4gIGlmICh0eXBlICE9PSBvcmlnaW5hbFR5cGUpIHtcbiAgICBldmVudC50eXBlID0gdHlwZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuVmFsdWUgPSB0aGlzLl9pbnZva2VMaXN0ZW5lcnMoZXZlbnQsIGFyZ3MsIGZpcnN0TGlzdGVuZXIpO1xuICB9IGZpbmFsbHkge1xuXG4gICAgLy8gcmVzZXQgZXZlbnQgdHlwZSBhZnRlciBkZWxlZ2F0aW9uXG4gICAgaWYgKHR5cGUgIT09IG9yaWdpbmFsVHlwZSkge1xuICAgICAgZXZlbnQudHlwZSA9IG9yaWdpbmFsVHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBzZXQgdGhlIHJldHVybiB2YWx1ZSB0byBmYWxzZSBpZiB0aGUgZXZlbnQgZGVmYXVsdFxuICAvLyBnb3QgcHJldmVudGVkIGFuZCBubyBvdGhlciByZXR1cm4gdmFsdWUgZXhpc3RzXG4gIGlmIChyZXR1cm5WYWx1ZSA9PT0gdW5kZWZpbmVkICYmIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICByZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufTtcblxuXG5FdmVudEJ1cy5wcm90b3R5cGUuaGFuZGxlRXJyb3IgPSBmdW5jdGlvbihlcnJvcikge1xuICByZXR1cm4gdGhpcy5maXJlKCdlcnJvcicsIHsgZXJyb3I6IGVycm9yIH0pID09PSBmYWxzZTtcbn07XG5cblxuRXZlbnRCdXMucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xufTtcblxuRXZlbnRCdXMucHJvdG90eXBlLl9pbnZva2VMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCwgYXJncywgbGlzdGVuZXIpIHtcblxuICB2YXIgcmV0dXJuVmFsdWU7XG5cbiAgd2hpbGUgKGxpc3RlbmVyKSB7XG5cbiAgICAvLyBoYW5kbGUgc3RvcHBlZCBwcm9wYWdhdGlvblxuICAgIGlmIChldmVudC5jYW5jZWxCdWJibGUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVyblZhbHVlID0gdGhpcy5faW52b2tlTGlzdGVuZXIoZXZlbnQsIGFyZ3MsIGxpc3RlbmVyKTtcblxuICAgIGxpc3RlbmVyID0gbGlzdGVuZXIubmV4dDtcbiAgfVxuXG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn07XG5cbkV2ZW50QnVzLnByb3RvdHlwZS5faW52b2tlTGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgYXJncywgbGlzdGVuZXIpIHtcblxuICB2YXIgcmV0dXJuVmFsdWU7XG5cbiAgdHJ5IHtcblxuICAgIC8vIHJldHVybmluZyBmYWxzZSBwcmV2ZW50cyB0aGUgZGVmYXVsdCBhY3Rpb25cbiAgICByZXR1cm5WYWx1ZSA9IGludm9rZUZ1bmN0aW9uKGxpc3RlbmVyLmNhbGxiYWNrLCBhcmdzKTtcblxuICAgIC8vIHN0b3AgcHJvcGFnYXRpb24gb24gcmV0dXJuIHZhbHVlXG4gICAgaWYgKHJldHVyblZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gcmV0dXJuVmFsdWU7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICAvLyBwcmV2ZW50IGRlZmF1bHQgb24gcmV0dXJuIGZhbHNlXG4gICAgaWYgKHJldHVyblZhbHVlID09PSBmYWxzZSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoIXRoaXMuaGFuZGxlRXJyb3IoZSkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ3VuaGFuZGxlZCBlcnJvciBpbiBldmVudCBsaXN0ZW5lcicpO1xuICAgICAgY29uc29sZS5lcnJvcihlLnN0YWNrKTtcblxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59O1xuXG4vKlxuICogQWRkIG5ldyBsaXN0ZW5lciB3aXRoIGEgY2VydGFpbiBwcmlvcml0eSB0byB0aGUgbGlzdFxuICogb2YgbGlzdGVuZXJzIChmb3IgdGhlIGdpdmVuIGV2ZW50KS5cbiAqXG4gKiBUaGUgc2VtYW50aWNzIG9mIGxpc3RlbmVyIHJlZ2lzdHJhdGlvbiAvIGxpc3RlbmVyIGV4ZWN1dGlvbiBhcmVcbiAqIGZpcnN0IHJlZ2lzdGVyLCBmaXJzdCBzZXJ2ZTogTmV3IGxpc3RlbmVycyB3aWxsIGFsd2F5cyBiZSBpbnNlcnRlZFxuICogYWZ0ZXIgZXhpc3RpbmcgbGlzdGVuZXJzIHdpdGggdGhlIHNhbWUgcHJpb3JpdHkuXG4gKlxuICogRXhhbXBsZTogSW5zZXJ0aW5nIHR3byBsaXN0ZW5lcnMgd2l0aCBwcmlvcml0eSAxMDAwIGFuZCAxMzAwXG4gKlxuICogICAgKiBiZWZvcmU6IFsgMTUwMCwgMTUwMCwgMTAwMCwgMTAwMCBdXG4gKiAgICAqIGFmdGVyOiBbIDE1MDAsIDE1MDAsIChuZXc9MTMwMCksIDEwMDAsIDEwMDAsIChuZXc9MTAwMCkgXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtPYmplY3R9IGxpc3RlbmVyIHsgcHJpb3JpdHksIGNhbGxiYWNrIH1cbiAqL1xuRXZlbnRCdXMucHJvdG90eXBlLl9hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBuZXdMaXN0ZW5lcikge1xuXG4gIHZhciBsaXN0ZW5lciA9IHRoaXMuX2dldExpc3RlbmVycyhldmVudCksXG4gICAgICBwcmV2aW91c0xpc3RlbmVyO1xuXG4gIC8vIG5vIHByaW9yIGxpc3RlbmVyc1xuICBpZiAoIWxpc3RlbmVyKSB7XG4gICAgdGhpcy5fc2V0TGlzdGVuZXJzKGV2ZW50LCBuZXdMaXN0ZW5lcik7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBlbnN1cmUgd2Ugb3JkZXIgbGlzdGVuZXJzIGJ5IHByaW9yaXR5IGZyb21cbiAgLy8gMCAoaGlnaCkgdG8gbiA+IDAgKGxvdylcbiAgd2hpbGUgKGxpc3RlbmVyKSB7XG5cbiAgICBpZiAobGlzdGVuZXIucHJpb3JpdHkgPCBuZXdMaXN0ZW5lci5wcmlvcml0eSkge1xuXG4gICAgICBuZXdMaXN0ZW5lci5uZXh0ID0gbGlzdGVuZXI7XG5cbiAgICAgIGlmIChwcmV2aW91c0xpc3RlbmVyKSB7XG4gICAgICAgIHByZXZpb3VzTGlzdGVuZXIubmV4dCA9IG5ld0xpc3RlbmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2V0TGlzdGVuZXJzKGV2ZW50LCBuZXdMaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwcmV2aW91c0xpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5uZXh0O1xuICB9XG5cbiAgLy8gYWRkIG5ldyBsaXN0ZW5lciB0byBiYWNrXG4gIHByZXZpb3VzTGlzdGVuZXIubmV4dCA9IG5ld0xpc3RlbmVyO1xufTtcblxuXG5FdmVudEJ1cy5wcm90b3R5cGUuX2dldExpc3RlbmVycyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuX2xpc3RlbmVyc1tuYW1lXTtcbn07XG5cbkV2ZW50QnVzLnByb3RvdHlwZS5fc2V0TGlzdGVuZXJzID0gZnVuY3Rpb24obmFtZSwgbGlzdGVuZXIpIHtcbiAgdGhpcy5fbGlzdGVuZXJzW25hbWVdID0gbGlzdGVuZXI7XG59O1xuXG5FdmVudEJ1cy5wcm90b3R5cGUuX3JlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrKSB7XG5cbiAgdmFyIGxpc3RlbmVyID0gdGhpcy5fZ2V0TGlzdGVuZXJzKGV2ZW50KSxcbiAgICAgIG5leHRMaXN0ZW5lcixcbiAgICAgIHByZXZpb3VzTGlzdGVuZXIsXG4gICAgICBsaXN0ZW5lckNhbGxiYWNrO1xuXG4gIGlmICghY2FsbGJhY2spIHtcblxuICAgIC8vIGNsZWFyIGxpc3RlbmVyc1xuICAgIHRoaXMuX3NldExpc3RlbmVycyhldmVudCwgbnVsbCk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICB3aGlsZSAobGlzdGVuZXIpIHtcblxuICAgIG5leHRMaXN0ZW5lciA9IGxpc3RlbmVyLm5leHQ7XG5cbiAgICBsaXN0ZW5lckNhbGxiYWNrID0gbGlzdGVuZXIuY2FsbGJhY2s7XG5cbiAgICBpZiAobGlzdGVuZXJDYWxsYmFjayA9PT0gY2FsbGJhY2sgfHwgbGlzdGVuZXJDYWxsYmFja1tGTl9SRUZdID09PSBjYWxsYmFjaykge1xuICAgICAgaWYgKHByZXZpb3VzTGlzdGVuZXIpIHtcbiAgICAgICAgcHJldmlvdXNMaXN0ZW5lci5uZXh0ID0gbmV4dExpc3RlbmVyO1xuICAgICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBuZXcgZmlyc3QgbGlzdGVuZXJcbiAgICAgICAgdGhpcy5fc2V0TGlzdGVuZXJzKGV2ZW50LCBuZXh0TGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByZXZpb3VzTGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICBsaXN0ZW5lciA9IG5leHRMaXN0ZW5lcjtcbiAgfVxufTtcblxuLyoqXG4gKiBBIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB2aWEgdGhlIGV2ZW50IGJ1cy5cbiAqL1xuZnVuY3Rpb24gSW50ZXJuYWxFdmVudCgpIHsgfVxuXG5JbnRlcm5hbEV2ZW50LnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jYW5jZWxCdWJibGUgPSB0cnVlO1xufTtcblxuSW50ZXJuYWxFdmVudC5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbn07XG5cbkludGVybmFsRXZlbnQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIGFzc2lnbih0aGlzLCBkYXRhIHx8IHt9KTtcbn07XG5cblxuLyoqXG4gKiBJbnZva2UgZnVuY3Rpb24uIEJlIGZhc3QuLi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBhcmdzXG4gKlxuICogQHJldHVybiB7QW55fVxuICovXG5mdW5jdGlvbiBpbnZva2VGdW5jdGlvbihmbiwgYXJncykge1xuICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG59XG4iLCJpbXBvcnQge1xuICBmb3JFYWNoLFxuICByZWR1Y2Vcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBnZXRDaGlsZHJlbixcbiAgZ2V0VmlzdWFsXG59IGZyb20gJy4uL3V0aWwvR3JhcGhpY3NVdGlsJztcblxuaW1wb3J0IHsgdHJhbnNsYXRlIH0gZnJvbSAnLi4vdXRpbC9TdmdUcmFuc2Zvcm1VdGlsJztcblxuaW1wb3J0IHsgY2xlYXIgYXMgZG9tQ2xlYXIgfSBmcm9tICdtaW4tZG9tJztcblxuaW1wb3J0IHtcbiAgYXBwZW5kIGFzIHN2Z0FwcGVuZCxcbiAgYXR0ciBhcyBzdmdBdHRyLFxuICBjbGFzc2VzIGFzIHN2Z0NsYXNzZXMsXG4gIGNyZWF0ZSBhcyBzdmdDcmVhdGUsXG4gIHJlbW92ZSBhcyBzdmdSZW1vdmVcbn0gZnJvbSAndGlueS1zdmcnO1xuXG5pbXBvcnQge1xuICBpc0ZyYW1lRWxlbWVudFxufSBmcm9tICcuLi91dGlsL0VsZW1lbnRzJztcblxuLyoqXG4gKiBBIGZhY3RvcnkgdGhhdCBjcmVhdGVzIGdyYXBoaWNhbCBlbGVtZW50c1xuICpcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gKiBAcGFyYW0ge0VsZW1lbnRSZWdpc3RyeX0gZWxlbWVudFJlZ2lzdHJ5XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEdyYXBoaWNzRmFjdG9yeShldmVudEJ1cywgZWxlbWVudFJlZ2lzdHJ5KSB7XG4gIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG4gIHRoaXMuX2VsZW1lbnRSZWdpc3RyeSA9IGVsZW1lbnRSZWdpc3RyeTtcbn1cblxuR3JhcGhpY3NGYWN0b3J5LiRpbmplY3QgPSBbICdldmVudEJ1cycgLCAnZWxlbWVudFJlZ2lzdHJ5JyBdO1xuXG5cbkdyYXBoaWNzRmFjdG9yeS5wcm90b3R5cGUuX2dldENoaWxkcmVuQ29udGFpbmVyID0gZnVuY3Rpb24oZWxlbWVudCkge1xuXG4gIHZhciBnZnggPSB0aGlzLl9lbGVtZW50UmVnaXN0cnkuZ2V0R3JhcGhpY3MoZWxlbWVudCk7XG5cbiAgdmFyIGNoaWxkcmVuR2Z4O1xuXG4gIC8vIHJvb3QgZWxlbWVudFxuICBpZiAoIWVsZW1lbnQucGFyZW50KSB7XG4gICAgY2hpbGRyZW5HZnggPSBnZng7XG4gIH0gZWxzZSB7XG4gICAgY2hpbGRyZW5HZnggPSBnZXRDaGlsZHJlbihnZngpO1xuICAgIGlmICghY2hpbGRyZW5HZngpIHtcbiAgICAgIGNoaWxkcmVuR2Z4ID0gc3ZnQ3JlYXRlKCdnJyk7XG4gICAgICBzdmdDbGFzc2VzKGNoaWxkcmVuR2Z4KS5hZGQoJ2Rqcy1jaGlsZHJlbicpO1xuXG4gICAgICBzdmdBcHBlbmQoZ2Z4LnBhcmVudE5vZGUsIGNoaWxkcmVuR2Z4KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW5HZng7XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGUgZ3JhcGhpY2FsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlbGVtZW50IGFuZCByZXR1cm5zIHRoZVxuICogY2xlYXJlZCB2aXN1YWwgKHRoZSA8ZyBjbGFzcz1cImRqcy12aXN1YWxcIiAvPiBlbGVtZW50KS5cbiAqL1xuR3JhcGhpY3NGYWN0b3J5LnByb3RvdHlwZS5fY2xlYXIgPSBmdW5jdGlvbihnZngpIHtcbiAgdmFyIHZpc3VhbCA9IGdldFZpc3VhbChnZngpO1xuXG4gIGRvbUNsZWFyKHZpc3VhbCk7XG5cbiAgcmV0dXJuIHZpc3VhbDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGdmeCBjb250YWluZXIgZm9yIHNoYXBlcyBhbmQgY29ubmVjdGlvbnNcbiAqXG4gKiBUaGUgbGF5b3V0IGlzIGFzIGZvbGxvd3M6XG4gKlxuICogPGcgY2xhc3M9XCJkanMtZ3JvdXBcIj5cbiAqXG4gKiAgIDwhLS0gdGhlIGdmeCAtLT5cbiAqICAgPGcgY2xhc3M9XCJkanMtZWxlbWVudCBkanMtKHNoYXBlfGNvbm5lY3Rpb258ZnJhbWUpXCI+XG4gKiAgICAgPGcgY2xhc3M9XCJkanMtdmlzdWFsXCI+XG4gKiAgICAgICA8IS0tIHRoZSByZW5kZXJlciBkcmF3cyBpbiBoZXJlIC0tPlxuICogICAgIDwvZz5cbiAqXG4gKiAgICAgPCEtLSBleHRlbnNpb25zIChvdmVybGF5cywgY2xpY2sgYm94LCAuLi4pIGdvZXMgaGVyZVxuICogICA8L2c+XG4gKlxuICogICA8IS0tIHRoZSBnZnggY2hpbGQgbm9kZXMgLS0+XG4gKiAgIDxnIGNsYXNzPVwiZGpzLWNoaWxkcmVuXCI+PC9nPlxuICogPC9nPlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIHRoZSBlbGVtZW50LCBpLmUuIHNoYXBlIHwgY29ubmVjdGlvblxuICogQHBhcmFtIHtTVkdFbGVtZW50fSBbY2hpbGRyZW5HZnhdXG4gKiBAcGFyYW0ge051bWJlcn0gW3BhcmVudEluZGV4XSBwb3NpdGlvbiB0byBjcmVhdGUgY29udGFpbmVyIGluIHBhcmVudFxuICogQHBhcmFtIHtCb29sZWFufSBbaXNGcmFtZV0gaXMgZnJhbWUgZWxlbWVudFxuICpcbiAqIEByZXR1cm4ge1NWR0VsZW1lbnR9XG4gKi9cbkdyYXBoaWNzRmFjdG9yeS5wcm90b3R5cGUuX2NyZWF0ZUNvbnRhaW5lciA9IGZ1bmN0aW9uKFxuICAgIHR5cGUsIGNoaWxkcmVuR2Z4LCBwYXJlbnRJbmRleCwgaXNGcmFtZVxuKSB7XG4gIHZhciBvdXRlckdmeCA9IHN2Z0NyZWF0ZSgnZycpO1xuICBzdmdDbGFzc2VzKG91dGVyR2Z4KS5hZGQoJ2Rqcy1ncm91cCcpO1xuXG4gIC8vIGluc2VydCBub2RlIGF0IHBvc2l0aW9uXG4gIGlmICh0eXBlb2YgcGFyZW50SW5kZXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcHJlcGVuZFRvKG91dGVyR2Z4LCBjaGlsZHJlbkdmeCwgY2hpbGRyZW5HZnguY2hpbGROb2Rlc1twYXJlbnRJbmRleF0pO1xuICB9IGVsc2Uge1xuICAgIHN2Z0FwcGVuZChjaGlsZHJlbkdmeCwgb3V0ZXJHZngpO1xuICB9XG5cbiAgdmFyIGdmeCA9IHN2Z0NyZWF0ZSgnZycpO1xuICBzdmdDbGFzc2VzKGdmeCkuYWRkKCdkanMtZWxlbWVudCcpO1xuICBzdmdDbGFzc2VzKGdmeCkuYWRkKCdkanMtJyArIHR5cGUpO1xuXG4gIGlmIChpc0ZyYW1lKSB7XG4gICAgc3ZnQ2xhc3NlcyhnZngpLmFkZCgnZGpzLWZyYW1lJyk7XG4gIH1cblxuICBzdmdBcHBlbmQob3V0ZXJHZngsIGdmeCk7XG5cbiAgLy8gY3JlYXRlIHZpc3VhbFxuICB2YXIgdmlzdWFsID0gc3ZnQ3JlYXRlKCdnJyk7XG4gIHN2Z0NsYXNzZXModmlzdWFsKS5hZGQoJ2Rqcy12aXN1YWwnKTtcblxuICBzdmdBcHBlbmQoZ2Z4LCB2aXN1YWwpO1xuXG4gIHJldHVybiBnZng7XG59O1xuXG5HcmFwaGljc0ZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKHR5cGUsIGVsZW1lbnQsIHBhcmVudEluZGV4KSB7XG4gIHZhciBjaGlsZHJlbkdmeCA9IHRoaXMuX2dldENoaWxkcmVuQ29udGFpbmVyKGVsZW1lbnQucGFyZW50KTtcbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZUNvbnRhaW5lcih0eXBlLCBjaGlsZHJlbkdmeCwgcGFyZW50SW5kZXgsIGlzRnJhbWVFbGVtZW50KGVsZW1lbnQpKTtcbn07XG5cbkdyYXBoaWNzRmFjdG9yeS5wcm90b3R5cGUudXBkYXRlQ29udGFpbm1lbnRzID0gZnVuY3Rpb24oZWxlbWVudHMpIHtcblxuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICBlbGVtZW50UmVnaXN0cnkgPSB0aGlzLl9lbGVtZW50UmVnaXN0cnksXG4gICAgICBwYXJlbnRzO1xuXG4gIHBhcmVudHMgPSByZWR1Y2UoZWxlbWVudHMsIGZ1bmN0aW9uKG1hcCwgZSkge1xuXG4gICAgaWYgKGUucGFyZW50KSB7XG4gICAgICBtYXBbZS5wYXJlbnQuaWRdID0gZS5wYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcDtcbiAgfSwge30pO1xuXG4gIC8vIHVwZGF0ZSBhbGwgcGFyZW50cyBvZiBjaGFuZ2VkIGFuZCByZW9yZ2FuaXplZCB0aGVpciBjaGlsZHJlblxuICAvLyBpbiB0aGUgY29ycmVjdCBvcmRlciAoYXMgaW5kaWNhdGVkIGluIG91ciBtb2RlbClcbiAgZm9yRWFjaChwYXJlbnRzLCBmdW5jdGlvbihwYXJlbnQpIHtcblxuICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudC5jaGlsZHJlbjtcblxuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRyZW5HZnggPSBzZWxmLl9nZXRDaGlsZHJlbkNvbnRhaW5lcihwYXJlbnQpO1xuXG4gICAgZm9yRWFjaChjaGlsZHJlbi5zbGljZSgpLnJldmVyc2UoKSwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIHZhciBjaGlsZEdmeCA9IGVsZW1lbnRSZWdpc3RyeS5nZXRHcmFwaGljcyhjaGlsZCk7XG5cbiAgICAgIHByZXBlbmRUbyhjaGlsZEdmeC5wYXJlbnROb2RlLCBjaGlsZHJlbkdmeCk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuR3JhcGhpY3NGYWN0b3J5LnByb3RvdHlwZS5kcmF3U2hhcGUgPSBmdW5jdGlvbih2aXN1YWwsIGVsZW1lbnQpIHtcbiAgdmFyIGV2ZW50QnVzID0gdGhpcy5fZXZlbnRCdXM7XG5cbiAgcmV0dXJuIGV2ZW50QnVzLmZpcmUoJ3JlbmRlci5zaGFwZScsIHsgZ2Z4OiB2aXN1YWwsIGVsZW1lbnQ6IGVsZW1lbnQgfSk7XG59O1xuXG5HcmFwaGljc0ZhY3RvcnkucHJvdG90eXBlLmdldFNoYXBlUGF0aCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgdmFyIGV2ZW50QnVzID0gdGhpcy5fZXZlbnRCdXM7XG5cbiAgcmV0dXJuIGV2ZW50QnVzLmZpcmUoJ3JlbmRlci5nZXRTaGFwZVBhdGgnLCBlbGVtZW50KTtcbn07XG5cbkdyYXBoaWNzRmFjdG9yeS5wcm90b3R5cGUuZHJhd0Nvbm5lY3Rpb24gPSBmdW5jdGlvbih2aXN1YWwsIGVsZW1lbnQpIHtcbiAgdmFyIGV2ZW50QnVzID0gdGhpcy5fZXZlbnRCdXM7XG5cbiAgcmV0dXJuIGV2ZW50QnVzLmZpcmUoJ3JlbmRlci5jb25uZWN0aW9uJywgeyBnZng6IHZpc3VhbCwgZWxlbWVudDogZWxlbWVudCB9KTtcbn07XG5cbkdyYXBoaWNzRmFjdG9yeS5wcm90b3R5cGUuZ2V0Q29ubmVjdGlvblBhdGggPSBmdW5jdGlvbih3YXlwb2ludHMpIHtcbiAgdmFyIGV2ZW50QnVzID0gdGhpcy5fZXZlbnRCdXM7XG5cbiAgcmV0dXJuIGV2ZW50QnVzLmZpcmUoJ3JlbmRlci5nZXRDb25uZWN0aW9uUGF0aCcsIHdheXBvaW50cyk7XG59O1xuXG5HcmFwaGljc0ZhY3RvcnkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKHR5cGUsIGVsZW1lbnQsIGdmeCkge1xuXG4gIC8vIGRvIE5PVCB1cGRhdGUgcm9vdCBlbGVtZW50XG4gIGlmICghZWxlbWVudC5wYXJlbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdmlzdWFsID0gdGhpcy5fY2xlYXIoZ2Z4KTtcblxuICAvLyByZWRyYXdcbiAgaWYgKHR5cGUgPT09ICdzaGFwZScpIHtcbiAgICB0aGlzLmRyYXdTaGFwZSh2aXN1YWwsIGVsZW1lbnQpO1xuXG4gICAgLy8gdXBkYXRlIHBvc2l0aW9uaW5nXG4gICAgdHJhbnNsYXRlKGdmeCwgZWxlbWVudC54LCBlbGVtZW50LnkpO1xuICB9IGVsc2VcbiAgaWYgKHR5cGUgPT09ICdjb25uZWN0aW9uJykge1xuICAgIHRoaXMuZHJhd0Nvbm5lY3Rpb24odmlzdWFsLCBlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gdHlwZTogJyArIHR5cGUpO1xuICB9XG5cbiAgaWYgKGVsZW1lbnQuaGlkZGVuKSB7XG4gICAgc3ZnQXR0cihnZngsICdkaXNwbGF5JywgJ25vbmUnKTtcbiAgfSBlbHNlIHtcbiAgICBzdmdBdHRyKGdmeCwgJ2Rpc3BsYXknLCAnYmxvY2snKTtcbiAgfVxufTtcblxuR3JhcGhpY3NGYWN0b3J5LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHZhciBnZnggPSB0aGlzLl9lbGVtZW50UmVnaXN0cnkuZ2V0R3JhcGhpY3MoZWxlbWVudCk7XG5cbiAgLy8gcmVtb3ZlXG4gIHN2Z1JlbW92ZShnZngucGFyZW50Tm9kZSk7XG59O1xuXG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBwcmVwZW5kVG8obmV3Tm9kZSwgcGFyZW50Tm9kZSwgc2libGluZ05vZGUpIHtcbiAgdmFyIG5vZGUgPSBzaWJsaW5nTm9kZSB8fCBwYXJlbnROb2RlLmZpcnN0Q2hpbGQ7XG5cbiAgLy8gZG8gbm90IHByZXBlbmQgbm9kZSB0byBpdHNlbGYgdG8gcHJldmVudCBJRSBmcm9tIGNyYXNoaW5nXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9icG1uLWlvL2JwbW4tanMvaXNzdWVzLzc0NlxuICBpZiAobmV3Tm9kZSA9PT0gbm9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIG5vZGUpO1xufVxuIiwiaW1wb3J0IERyYXdNb2R1bGUgZnJvbSAnLi4vZHJhdyc7XG5cbmltcG9ydCBDYW52YXMgZnJvbSAnLi9DYW52YXMnO1xuaW1wb3J0IEVsZW1lbnRSZWdpc3RyeSBmcm9tICcuL0VsZW1lbnRSZWdpc3RyeSc7XG5pbXBvcnQgRWxlbWVudEZhY3RvcnkgZnJvbSAnLi9FbGVtZW50RmFjdG9yeSc7XG5pbXBvcnQgRXZlbnRCdXMgZnJvbSAnLi9FdmVudEJ1cyc7XG5pbXBvcnQgR3JhcGhpY3NGYWN0b3J5IGZyb20gJy4vR3JhcGhpY3NGYWN0b3J5JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2RlcGVuZHNfXzogWyBEcmF3TW9kdWxlIF0sXG4gIF9faW5pdF9fOiBbICdjYW52YXMnIF0sXG4gIGNhbnZhczogWyAndHlwZScsIENhbnZhcyBdLFxuICBlbGVtZW50UmVnaXN0cnk6IFsgJ3R5cGUnLCBFbGVtZW50UmVnaXN0cnkgXSxcbiAgZWxlbWVudEZhY3Rvcnk6IFsgJ3R5cGUnLCBFbGVtZW50RmFjdG9yeSBdLFxuICBldmVudEJ1czogWyAndHlwZScsIEV2ZW50QnVzIF0sXG4gIGdyYXBoaWNzRmFjdG9yeTogWyAndHlwZScsIEdyYXBoaWNzRmFjdG9yeSBdXG59OyIsInZhciBERUZBVUxUX1JFTkRFUl9QUklPUklUWSA9IDEwMDA7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2Ygc2hhcGUgYW5kIGNvbm5lY3Rpb24gcmVuZGVyZXJzLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gKiBAcGFyYW0ge051bWJlcn0gW3JlbmRlclByaW9yaXR5PTEwMDBdXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEJhc2VSZW5kZXJlcihldmVudEJ1cywgcmVuZGVyUHJpb3JpdHkpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHJlbmRlclByaW9yaXR5ID0gcmVuZGVyUHJpb3JpdHkgfHwgREVGQVVMVF9SRU5ERVJfUFJJT1JJVFk7XG5cbiAgZXZlbnRCdXMub24oWyAncmVuZGVyLnNoYXBlJywgJ3JlbmRlci5jb25uZWN0aW9uJyBdLCByZW5kZXJQcmlvcml0eSwgZnVuY3Rpb24oZXZ0LCBjb250ZXh0KSB7XG4gICAgdmFyIHR5cGUgPSBldnQudHlwZSxcbiAgICAgICAgZWxlbWVudCA9IGNvbnRleHQuZWxlbWVudCxcbiAgICAgICAgdmlzdWFscyA9IGNvbnRleHQuZ2Z4O1xuXG4gICAgaWYgKHNlbGYuY2FuUmVuZGVyKGVsZW1lbnQpKSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ3JlbmRlci5zaGFwZScpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZHJhd1NoYXBlKHZpc3VhbHMsIGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZHJhd0Nvbm5lY3Rpb24odmlzdWFscywgZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBldmVudEJ1cy5vbihbICdyZW5kZXIuZ2V0U2hhcGVQYXRoJywgJ3JlbmRlci5nZXRDb25uZWN0aW9uUGF0aCddLCByZW5kZXJQcmlvcml0eSwgZnVuY3Rpb24oZXZ0LCBlbGVtZW50KSB7XG4gICAgaWYgKHNlbGYuY2FuUmVuZGVyKGVsZW1lbnQpKSB7XG4gICAgICBpZiAoZXZ0LnR5cGUgPT09ICdyZW5kZXIuZ2V0U2hhcGVQYXRoJykge1xuICAgICAgICByZXR1cm4gc2VsZi5nZXRTaGFwZVBhdGgoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZi5nZXRDb25uZWN0aW9uUGF0aChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFNob3VsZCBjaGVjayB3aGV0aGVyICp0aGlzKiByZW5kZXJlciBjYW4gcmVuZGVyXG4gKiB0aGUgZWxlbWVudC9jb25uZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7ZWxlbWVudH0gZWxlbWVudFxuICpcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5CYXNlUmVuZGVyZXIucHJvdG90eXBlLmNhblJlbmRlciA9IGZ1bmN0aW9uKCkge307XG5cbi8qKlxuICogUHJvdmlkZXMgdGhlIHNoYXBlJ3Mgc25hcCBzdmcgZWxlbWVudCB0byBiZSBkcmF3biBvbiB0aGUgYGNhbnZhc2AuXG4gKlxuICogQHBhcmFtIHtkanMuR3JhcGhpY3N9IHZpc3VhbHNcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlXG4gKlxuICogQHJldHVybnMge1NuYXAuc3ZnfSBbcmV0dXJucyBhIFNuYXAuc3ZnIHBhcGVyIGVsZW1lbnQgXVxuICovXG5CYXNlUmVuZGVyZXIucHJvdG90eXBlLmRyYXdTaGFwZSA9IGZ1bmN0aW9uKCkge307XG5cbi8qKlxuICogUHJvdmlkZXMgdGhlIHNoYXBlJ3Mgc25hcCBzdmcgZWxlbWVudCB0byBiZSBkcmF3biBvbiB0aGUgYGNhbnZhc2AuXG4gKlxuICogQHBhcmFtIHtkanMuR3JhcGhpY3N9IHZpc3VhbHNcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvblxuICpcbiAqIEByZXR1cm5zIHtTbmFwLnN2Z30gW3JldHVybnMgYSBTbmFwLnN2ZyBwYXBlciBlbGVtZW50IF1cbiAqL1xuQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5kcmF3Q29ubmVjdGlvbiA9IGZ1bmN0aW9uKCkge307XG5cbi8qKlxuICogR2V0cyB0aGUgU1ZHIHBhdGggb2YgYSBzaGFwZSB0aGF0IHJlcHJlc2VudHMgaXQncyB2aXN1YWwgYm91bmRzLlxuICpcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBzdmcgcGF0aFxuICovXG5CYXNlUmVuZGVyZXIucHJvdG90eXBlLmdldFNoYXBlUGF0aCA9IGZ1bmN0aW9uKCkge307XG5cbi8qKlxuICogR2V0cyB0aGUgU1ZHIHBhdGggb2YgYSBjb25uZWN0aW9uIHRoYXQgcmVwcmVzZW50cyBpdCdzIHZpc3VhbCBib3VuZHMuXG4gKlxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBzdmcgcGF0aFxuICovXG5CYXNlUmVuZGVyZXIucHJvdG90eXBlLmdldENvbm5lY3Rpb25QYXRoID0gZnVuY3Rpb24oKSB7fTtcbiIsImltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5cbmltcG9ydCBCYXNlUmVuZGVyZXIgZnJvbSAnLi9CYXNlUmVuZGVyZXInO1xuXG5pbXBvcnQge1xuICBjb21wb25lbnRzVG9QYXRoLFxuICBjcmVhdGVMaW5lXG59IGZyb20gJy4uL3V0aWwvUmVuZGVyVXRpbCc7XG5cbmltcG9ydCB7XG4gIGFwcGVuZCBhcyBzdmdBcHBlbmQsXG4gIGF0dHIgYXMgc3ZnQXR0cixcbiAgY3JlYXRlIGFzIHN2Z0NyZWF0ZVxufSBmcm9tICd0aW55LXN2Zyc7XG5cbmltcG9ydCB7XG4gIGlzRnJhbWVFbGVtZW50XG59IGZyb20gJy4uL3V0aWwvRWxlbWVudHMnO1xuXG4vLyBhcHBseSBkZWZhdWx0IHJlbmRlcmVyIHdpdGggbG93ZXN0IHBvc3NpYmxlIHByaW9yaXR5XG4vLyBzbyB0aGF0IGl0IG9ubHkga2lja3MgaW4gaWYgbm9vbmUgZWxzZSBjb3VsZCByZW5kZXJcbnZhciBERUZBVUxUX1JFTkRFUl9QUklPUklUWSA9IDE7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgcmVuZGVyZXIgdXNlZCBmb3Igc2hhcGVzIGFuZCBjb25uZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICogQHBhcmFtIHtTdHlsZXN9IHN0eWxlc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEZWZhdWx0UmVuZGVyZXIoZXZlbnRCdXMsIHN0eWxlcykge1xuXG4gIC8vXG4gIEJhc2VSZW5kZXJlci5jYWxsKHRoaXMsIGV2ZW50QnVzLCBERUZBVUxUX1JFTkRFUl9QUklPUklUWSk7XG5cbiAgdGhpcy5DT05ORUNUSU9OX1NUWUxFID0gc3R5bGVzLnN0eWxlKFsgJ25vLWZpbGwnIF0sIHsgc3Ryb2tlV2lkdGg6IDUsIHN0cm9rZTogJ2Z1Y2hzaWEnIH0pO1xuICB0aGlzLlNIQVBFX1NUWUxFID0gc3R5bGVzLnN0eWxlKHsgZmlsbDogJ3doaXRlJywgc3Ryb2tlOiAnZnVjaHNpYScsIHN0cm9rZVdpZHRoOiAyIH0pO1xuICB0aGlzLkZSQU1FX1NUWUxFID0gc3R5bGVzLnN0eWxlKFsgJ25vLWZpbGwnIF0sIHsgc3Ryb2tlOiAnZnVjaHNpYScsIHN0cm9rZURhc2hhcnJheTogNCwgc3Ryb2tlV2lkdGg6IDIgfSk7XG59XG5cbmluaGVyaXRzKERlZmF1bHRSZW5kZXJlciwgQmFzZVJlbmRlcmVyKTtcblxuXG5EZWZhdWx0UmVuZGVyZXIucHJvdG90eXBlLmNhblJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkRlZmF1bHRSZW5kZXJlci5wcm90b3R5cGUuZHJhd1NoYXBlID0gZnVuY3Rpb24gZHJhd1NoYXBlKHZpc3VhbHMsIGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSBzdmdDcmVhdGUoJ3JlY3QnKTtcblxuICBzdmdBdHRyKHJlY3QsIHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgd2lkdGg6IGVsZW1lbnQud2lkdGggfHwgMCxcbiAgICBoZWlnaHQ6IGVsZW1lbnQuaGVpZ2h0IHx8IDBcbiAgfSk7XG5cbiAgaWYgKGlzRnJhbWVFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgc3ZnQXR0cihyZWN0LCB0aGlzLkZSQU1FX1NUWUxFKTtcbiAgfSBlbHNlIHtcbiAgICBzdmdBdHRyKHJlY3QsIHRoaXMuU0hBUEVfU1RZTEUpO1xuICB9XG5cbiAgc3ZnQXBwZW5kKHZpc3VhbHMsIHJlY3QpO1xuXG4gIHJldHVybiByZWN0O1xufTtcblxuRGVmYXVsdFJlbmRlcmVyLnByb3RvdHlwZS5kcmF3Q29ubmVjdGlvbiA9IGZ1bmN0aW9uIGRyYXdDb25uZWN0aW9uKHZpc3VhbHMsIGNvbm5lY3Rpb24pIHtcblxuICB2YXIgbGluZSA9IGNyZWF0ZUxpbmUoY29ubmVjdGlvbi53YXlwb2ludHMsIHRoaXMuQ09OTkVDVElPTl9TVFlMRSk7XG4gIHN2Z0FwcGVuZCh2aXN1YWxzLCBsaW5lKTtcblxuICByZXR1cm4gbGluZTtcbn07XG5cbkRlZmF1bHRSZW5kZXJlci5wcm90b3R5cGUuZ2V0U2hhcGVQYXRoID0gZnVuY3Rpb24gZ2V0U2hhcGVQYXRoKHNoYXBlKSB7XG5cbiAgdmFyIHggPSBzaGFwZS54LFxuICAgICAgeSA9IHNoYXBlLnksXG4gICAgICB3aWR0aCA9IHNoYXBlLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xuXG4gIHZhciBzaGFwZVBhdGggPSBbXG4gICAgWydNJywgeCwgeV0sXG4gICAgWydsJywgd2lkdGgsIDBdLFxuICAgIFsnbCcsIDAsIGhlaWdodF0sXG4gICAgWydsJywgLXdpZHRoLCAwXSxcbiAgICBbJ3onXVxuICBdO1xuXG4gIHJldHVybiBjb21wb25lbnRzVG9QYXRoKHNoYXBlUGF0aCk7XG59O1xuXG5EZWZhdWx0UmVuZGVyZXIucHJvdG90eXBlLmdldENvbm5lY3Rpb25QYXRoID0gZnVuY3Rpb24gZ2V0Q29ubmVjdGlvblBhdGgoY29ubmVjdGlvbikge1xuICB2YXIgd2F5cG9pbnRzID0gY29ubmVjdGlvbi53YXlwb2ludHM7XG5cbiAgdmFyIGlkeCwgcG9pbnQsIGNvbm5lY3Rpb25QYXRoID0gW107XG5cbiAgZm9yIChpZHggPSAwOyAocG9pbnQgPSB3YXlwb2ludHNbaWR4XSk7IGlkeCsrKSB7XG5cbiAgICAvLyB0YWtlIGludmlzaWJsZSBkb2NraW5nIGludG8gYWNjb3VudFxuICAgIC8vIHdoZW4gY3JlYXRpbmcgdGhlIHBhdGhcbiAgICBwb2ludCA9IHBvaW50Lm9yaWdpbmFsIHx8IHBvaW50O1xuXG4gICAgY29ubmVjdGlvblBhdGgucHVzaChbIGlkeCA9PT0gMCA/ICdNJyA6ICdMJywgcG9pbnQueCwgcG9pbnQueSBdKTtcbiAgfVxuXG4gIHJldHVybiBjb21wb25lbnRzVG9QYXRoKGNvbm5lY3Rpb25QYXRoKTtcbn07XG5cblxuRGVmYXVsdFJlbmRlcmVyLiRpbmplY3QgPSBbICdldmVudEJ1cycsICdzdHlsZXMnIF07XG4iLCJpbXBvcnQge1xuICBpc0FycmF5LFxuICBhc3NpZ24sXG4gIHJlZHVjZVxufSBmcm9tICdtaW4tZGFzaCc7XG5cblxuLyoqXG4gKiBBIGNvbXBvbmVudCB0aGF0IG1hbmFnZXMgc2hhcGUgc3R5bGVzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFN0eWxlcygpIHtcblxuICB2YXIgZGVmYXVsdFRyYWl0cyA9IHtcblxuICAgICduby1maWxsJzoge1xuICAgICAgZmlsbDogJ25vbmUnXG4gICAgfSxcbiAgICAnbm8tYm9yZGVyJzoge1xuICAgICAgc3Ryb2tlT3BhY2l0eTogMC4wXG4gICAgfSxcbiAgICAnbm8tZXZlbnRzJzoge1xuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gICAgfVxuICB9O1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvKipcbiAgICogQnVpbGRzIGEgc3R5bGUgZGVmaW5pdGlvbiBmcm9tIGEgY2xhc3NOYW1lLCBhIGxpc3Qgb2YgdHJhaXRzIGFuZCBhbiBvYmplY3Qgb2YgYWRkaXRpb25hbCBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcGFyYW0gIHtBcnJheTxTdHJpbmc+fSB0cmFpdHNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBhZGRpdGlvbmFsQXR0cnNcbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgc3R5bGUgZGVmaW50aW9uXG4gICAqL1xuICB0aGlzLmNscyA9IGZ1bmN0aW9uKGNsYXNzTmFtZSwgdHJhaXRzLCBhZGRpdGlvbmFsQXR0cnMpIHtcbiAgICB2YXIgYXR0cnMgPSB0aGlzLnN0eWxlKHRyYWl0cywgYWRkaXRpb25hbEF0dHJzKTtcblxuICAgIHJldHVybiBhc3NpZ24oYXR0cnMsIHsgJ2NsYXNzJzogY2xhc3NOYW1lIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBzdHlsZSBkZWZpbml0aW9uIGZyb20gYSBsaXN0IG9mIHRyYWl0cyBhbmQgYW4gb2JqZWN0IG9mIGFkZGl0aW9uYWwgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQHBhcmFtICB7QXJyYXk8U3RyaW5nPn0gdHJhaXRzXG4gICAqIEBwYXJhbSAge09iamVjdH0gYWRkaXRpb25hbEF0dHJzXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gdGhlIHN0eWxlIGRlZmludGlvblxuICAgKi9cbiAgdGhpcy5zdHlsZSA9IGZ1bmN0aW9uKHRyYWl0cywgYWRkaXRpb25hbEF0dHJzKSB7XG5cbiAgICBpZiAoIWlzQXJyYXkodHJhaXRzKSAmJiAhYWRkaXRpb25hbEF0dHJzKSB7XG4gICAgICBhZGRpdGlvbmFsQXR0cnMgPSB0cmFpdHM7XG4gICAgICB0cmFpdHMgPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgYXR0cnMgPSByZWR1Y2UodHJhaXRzLCBmdW5jdGlvbihhdHRycywgdCkge1xuICAgICAgcmV0dXJuIGFzc2lnbihhdHRycywgZGVmYXVsdFRyYWl0c1t0XSB8fCB7fSk7XG4gICAgfSwge30pO1xuXG4gICAgcmV0dXJuIGFkZGl0aW9uYWxBdHRycyA/IGFzc2lnbihhdHRycywgYWRkaXRpb25hbEF0dHJzKSA6IGF0dHJzO1xuICB9O1xuXG4gIHRoaXMuY29tcHV0ZVN0eWxlID0gZnVuY3Rpb24oY3VzdG9tLCB0cmFpdHMsIGRlZmF1bHRTdHlsZXMpIHtcbiAgICBpZiAoIWlzQXJyYXkodHJhaXRzKSkge1xuICAgICAgZGVmYXVsdFN0eWxlcyA9IHRyYWl0cztcbiAgICAgIHRyYWl0cyA9IFtdO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmLnN0eWxlKHRyYWl0cyB8fCBbXSwgYXNzaWduKHt9LCBkZWZhdWx0U3R5bGVzLCBjdXN0b20gfHwge30pKTtcbiAgfTtcbn1cbiIsImltcG9ydCBEZWZhdWx0UmVuZGVyZXIgZnJvbSAnLi9EZWZhdWx0UmVuZGVyZXInO1xuaW1wb3J0IFN0eWxlcyBmcm9tICcuL1N0eWxlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19pbml0X186IFsgJ2RlZmF1bHRSZW5kZXJlcicgXSxcbiAgZGVmYXVsdFJlbmRlcmVyOiBbICd0eXBlJywgRGVmYXVsdFJlbmRlcmVyIF0sXG4gIHN0eWxlczogWyAndHlwZScsIFN0eWxlcyBdXG59O1xuIiwiaW1wb3J0IHtcbiAgZm9yRWFjaCxcbiAgYXNzaWduXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHtcbiAgZGVsZWdhdGUgYXMgZG9tRGVsZWdhdGUsXG4gIHF1ZXJ5IGFzIGRvbVF1ZXJ5LFxuICBxdWVyeUFsbCBhcyBkb21RdWVyeUFsbFxufSBmcm9tICdtaW4tZG9tJztcblxuaW1wb3J0IHsgaXNQcmltYXJ5QnV0dG9uIH0gZnJvbSAnLi4vLi4vdXRpbC9Nb3VzZSc7XG5cbmltcG9ydCB7XG4gIGFwcGVuZCBhcyBzdmdBcHBlbmQsXG4gIGF0dHIgYXMgc3ZnQXR0cixcbiAgY3JlYXRlIGFzIHN2Z0NyZWF0ZSxcbiAgcmVtb3ZlIGFzIHN2Z1JlbW92ZVxufSBmcm9tICd0aW55LXN2Zyc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZUxpbmUsXG4gIHVwZGF0ZUxpbmVcbn0gZnJvbSAnLi4vLi4vdXRpbC9SZW5kZXJVdGlsJztcblxuZnVuY3Rpb24gYWxsb3dBbGwoZSkgeyByZXR1cm4gdHJ1ZTsgfVxuXG52YXIgTE9XX1BSSU9SSVRZID0gNTAwO1xuXG5cbi8qKlxuICogQSBwbHVnaW4gdGhhdCBwcm92aWRlcyBpbnRlcmFjdGlvbiBldmVudHMgZm9yIGRpYWdyYW0gZWxlbWVudHMuXG4gKlxuICogSXQgZW1pdHMgdGhlIGZvbGxvd2luZyBldmVudHM6XG4gKlxuICogICAqIGVsZW1lbnQuY2xpY2tcbiAqICAgKiBlbGVtZW50LmNvbnRleHRtZW51XG4gKiAgICogZWxlbWVudC5kYmxjbGlja1xuICogICAqIGVsZW1lbnQuaG92ZXJcbiAqICAgKiBlbGVtZW50Lm1vdXNlZG93blxuICogICAqIGVsZW1lbnQubW91c2Vtb3ZlXG4gKiAgICogZWxlbWVudC5tb3VzZXVwXG4gKiAgICogZWxlbWVudC5vdXRcbiAqXG4gKiBFYWNoIGV2ZW50IGlzIGEgdHVwbGUgeyBlbGVtZW50LCBnZngsIG9yaWdpbmFsRXZlbnQgfS5cbiAqXG4gKiBDYW5jZWxpbmcgdGhlIGV2ZW50IHZpYSBFdmVudCNwcmV2ZW50RGVmYXVsdCgpXG4gKiBwcmV2ZW50cyB0aGUgb3JpZ2luYWwgRE9NIG9wZXJhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBJbnRlcmFjdGlvbkV2ZW50cyhldmVudEJ1cywgZWxlbWVudFJlZ2lzdHJ5LCBzdHlsZXMpIHtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLyoqXG4gICAqIEZpcmUgYW4gaW50ZXJhY3Rpb24gZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIGxvY2FsIGV2ZW50IG5hbWUsIGUuZy4gZWxlbWVudC5jbGljay5cbiAgICogQHBhcmFtIHtET01FdmVudH0gZXZlbnQgbmF0aXZlIGV2ZW50XG4gICAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IFtlbGVtZW50XSB0aGUgZGlhZ3JhbSBlbGVtZW50IHRvIGVtaXQgdGhlIGV2ZW50IG9uO1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdHMgdG8gdGhlIGV2ZW50IHRhcmdldFxuICAgKi9cbiAgZnVuY3Rpb24gZmlyZSh0eXBlLCBldmVudCwgZWxlbWVudCkge1xuXG4gICAgaWYgKGlzSWdub3JlZCh0eXBlLCBldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0LCBnZngsIHJldHVyblZhbHVlO1xuXG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICB0YXJnZXQgPSBldmVudC5kZWxlZ2F0ZVRhcmdldCB8fCBldmVudC50YXJnZXQ7XG5cbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgZ2Z4ID0gdGFyZ2V0O1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudFJlZ2lzdHJ5LmdldChnZngpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBnZnggPSBlbGVtZW50UmVnaXN0cnkuZ2V0R3JhcGhpY3MoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKCFnZnggfHwgIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm5WYWx1ZSA9IGV2ZW50QnVzLmZpcmUodHlwZSwge1xuICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgIGdmeDogZ2Z4LFxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICB9KTtcblxuICAgIGlmIChyZXR1cm5WYWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPKG5pa2t1KTogZG9jdW1lbnQgdGhpc1xuICB2YXIgaGFuZGxlcnMgPSB7fTtcblxuICBmdW5jdGlvbiBtb3VzZUhhbmRsZXIobG9jYWxFdmVudE5hbWUpIHtcbiAgICByZXR1cm4gaGFuZGxlcnNbbG9jYWxFdmVudE5hbWVdO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNJZ25vcmVkKGxvY2FsRXZlbnROYW1lLCBldmVudCkge1xuXG4gICAgdmFyIGZpbHRlciA9IGlnbm9yZWRGaWx0ZXJzW2xvY2FsRXZlbnROYW1lXSB8fCBpc1ByaW1hcnlCdXR0b247XG5cbiAgICAvLyBvbmx5IHJlYWN0IG9uIGxlZnQgbW91c2UgYnV0dG9uIGludGVyYWN0aW9uc1xuICAgIC8vIGV4Y2VwdCBmb3IgaW50ZXJhY3Rpb24gZXZlbnRzIHRoYXQgYXJlIGVuYWJsZWRcbiAgICAvLyBmb3Igc2VjdW5kYXJ5IG1vdXNlIGJ1dHRvblxuICAgIHJldHVybiAhZmlsdGVyKGV2ZW50KTtcbiAgfVxuXG4gIHZhciBiaW5kaW5ncyA9IHtcbiAgICBjbGljazogJ2VsZW1lbnQuY2xpY2snLFxuICAgIGNvbnRleHRtZW51OiAnZWxlbWVudC5jb250ZXh0bWVudScsXG4gICAgZGJsY2xpY2s6ICdlbGVtZW50LmRibGNsaWNrJyxcbiAgICBtb3VzZWRvd246ICdlbGVtZW50Lm1vdXNlZG93bicsXG4gICAgbW91c2Vtb3ZlOiAnZWxlbWVudC5tb3VzZW1vdmUnLFxuICAgIG1vdXNlb3ZlcjogJ2VsZW1lbnQuaG92ZXInLFxuICAgIG1vdXNlb3V0OiAnZWxlbWVudC5vdXQnLFxuICAgIG1vdXNldXA6ICdlbGVtZW50Lm1vdXNldXAnLFxuICB9O1xuXG4gIHZhciBpZ25vcmVkRmlsdGVycyA9IHtcbiAgICAnZWxlbWVudC5jb250ZXh0bWVudSc6IGFsbG93QWxsXG4gIH07XG5cblxuICAvLyBtYW51YWwgZXZlbnQgdHJpZ2dlciAvLy8vLy8vLy8vXG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgYW4gaW50ZXJhY3Rpb24gZXZlbnQgKGJhc2VkIG9uIGEgbmF0aXZlIGRvbSBldmVudClcbiAgICogb24gdGhlIHRhcmdldCBzaGFwZSBvciBjb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lIHRoZSBuYW1lIG9mIHRoZSB0cmlnZ2VyZWQgRE9NIGV2ZW50XG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHtkanMubW9kZWwuQmFzZX0gdGFyZ2V0RWxlbWVudFxuICAgKi9cbiAgZnVuY3Rpb24gdHJpZ2dlck1vdXNlRXZlbnQoZXZlbnROYW1lLCBldmVudCwgdGFyZ2V0RWxlbWVudCkge1xuXG4gICAgLy8gaS5lLiBlbGVtZW50Lm1vdXNlZG93bi4uLlxuICAgIHZhciBsb2NhbEV2ZW50TmFtZSA9IGJpbmRpbmdzW2V2ZW50TmFtZV07XG5cbiAgICBpZiAoIWxvY2FsRXZlbnROYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VubWFwcGVkIERPTSBldmVudCBuYW1lIDwnICsgZXZlbnROYW1lICsgJz4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmlyZShsb2NhbEV2ZW50TmFtZSwgZXZlbnQsIHRhcmdldEVsZW1lbnQpO1xuICB9XG5cblxuICB2YXIgRUxFTUVOVF9TRUxFQ1RPUiA9ICdzdmcsIC5kanMtZWxlbWVudCc7XG5cbiAgLy8gZXZlbnQgaGFuZGxpbmcgLy8vLy8vL1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyRXZlbnQobm9kZSwgZXZlbnQsIGxvY2FsRXZlbnQsIGlnbm9yZWRGaWx0ZXIpIHtcblxuICAgIHZhciBoYW5kbGVyID0gaGFuZGxlcnNbbG9jYWxFdmVudF0gPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgZmlyZShsb2NhbEV2ZW50LCBldmVudCk7XG4gICAgfTtcblxuICAgIGlmIChpZ25vcmVkRmlsdGVyKSB7XG4gICAgICBpZ25vcmVkRmlsdGVyc1tsb2NhbEV2ZW50XSA9IGlnbm9yZWRGaWx0ZXI7XG4gICAgfVxuXG4gICAgaGFuZGxlci4kZGVsZWdhdGUgPSBkb21EZWxlZ2F0ZS5iaW5kKG5vZGUsIEVMRU1FTlRfU0VMRUNUT1IsIGV2ZW50LCBoYW5kbGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVucmVnaXN0ZXJFdmVudChub2RlLCBldmVudCwgbG9jYWxFdmVudCkge1xuXG4gICAgdmFyIGhhbmRsZXIgPSBtb3VzZUhhbmRsZXIobG9jYWxFdmVudCk7XG5cbiAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkb21EZWxlZ2F0ZS51bmJpbmQobm9kZSwgZXZlbnQsIGhhbmRsZXIuJGRlbGVnYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyRXZlbnRzKHN2Zykge1xuICAgIGZvckVhY2goYmluZGluZ3MsIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgICByZWdpc3RlckV2ZW50KHN2Zywga2V5LCB2YWwpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdW5yZWdpc3RlckV2ZW50cyhzdmcpIHtcbiAgICBmb3JFYWNoKGJpbmRpbmdzLCBmdW5jdGlvbih2YWwsIGtleSkge1xuICAgICAgdW5yZWdpc3RlckV2ZW50KHN2Zywga2V5LCB2YWwpO1xuICAgIH0pO1xuICB9XG5cbiAgZXZlbnRCdXMub24oJ2NhbnZhcy5kZXN0cm95JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB1bnJlZ2lzdGVyRXZlbnRzKGV2ZW50LnN2Zyk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdjYW52YXMuaW5pdCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgcmVnaXN0ZXJFdmVudHMoZXZlbnQuc3ZnKTtcbiAgfSk7XG5cblxuICAvLyBoaXQgYm94IHVwZGF0aW5nIC8vLy8vLy8vLy8vLy8vLy9cblxuICBldmVudEJ1cy5vbihbICdzaGFwZS5hZGRlZCcsICdjb25uZWN0aW9uLmFkZGVkJyBdLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBlbGVtZW50ID0gZXZlbnQuZWxlbWVudCxcbiAgICAgICAgZ2Z4ID0gZXZlbnQuZ2Z4O1xuXG4gICAgZXZlbnRCdXMuZmlyZSgnaW50ZXJhY3Rpb25FdmVudHMuY3JlYXRlSGl0JywgeyBlbGVtZW50OiBlbGVtZW50LCBnZng6IGdmeCB9KTtcbiAgfSk7XG5cbiAgLy8gVXBkYXRlIGRqcy1oaXQgb24gY2hhbmdlLlxuICAvLyBBIGxvdyBwcmlvcnRpdHkgaXMgbmVjZXNzYXJ5LCBiZWNhdXNlIGRqcy1oaXQgb2YgbGFiZWxzIGhhcyB0byBiZSB1cGRhdGVkXG4gIC8vIGFmdGVyIHRoZSBsYWJlbCBib3VuZHMgaGF2ZSBiZWVuIHVwZGF0ZWQgaW4gdGhlIHJlbmRlcmVyLlxuICBldmVudEJ1cy5vbihbXG4gICAgJ3NoYXBlLmNoYW5nZWQnLFxuICAgICdjb25uZWN0aW9uLmNoYW5nZWQnXG4gIF0sIExPV19QUklPUklUWSwgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIHZhciBlbGVtZW50ID0gZXZlbnQuZWxlbWVudCxcbiAgICAgICAgZ2Z4ID0gZXZlbnQuZ2Z4O1xuXG4gICAgZXZlbnRCdXMuZmlyZSgnaW50ZXJhY3Rpb25FdmVudHMudXBkYXRlSGl0JywgeyBlbGVtZW50OiBlbGVtZW50LCBnZng6IGdmeCB9KTtcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2ludGVyYWN0aW9uRXZlbnRzLmNyZWF0ZUhpdCcsIExPV19QUklPUklUWSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGV2ZW50LmVsZW1lbnQsXG4gICAgICAgIGdmeCA9IGV2ZW50LmdmeDtcblxuICAgIHNlbGYuY3JlYXRlRGVmYXVsdEhpdChlbGVtZW50LCBnZngpO1xuICB9KTtcblxuICBldmVudEJ1cy5vbignaW50ZXJhY3Rpb25FdmVudHMudXBkYXRlSGl0JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGV2ZW50LmVsZW1lbnQsXG4gICAgICAgIGdmeCA9IGV2ZW50LmdmeDtcblxuICAgIHNlbGYudXBkYXRlRGVmYXVsdEhpdChlbGVtZW50LCBnZngpO1xuICB9KTtcblxuXG4gIC8vIGhpdCBzdHlsZXMgLy8vLy8vLy8vLy8vXG5cbiAgdmFyIFNUUk9LRV9ISVRfU1RZTEUgPSBjcmVhdGVIaXRTdHlsZSgnZGpzLWhpdCBkanMtaGl0LXN0cm9rZScpO1xuXG4gIHZhciBDTElDS19TVFJPS0VfSElUX1NUWUxFID0gY3JlYXRlSGl0U3R5bGUoJ2Rqcy1oaXQgZGpzLWhpdC1jbGljay1zdHJva2UnKTtcblxuICB2YXIgQUxMX0hJVF9TVFlMRSA9IGNyZWF0ZUhpdFN0eWxlKCdkanMtaGl0IGRqcy1oaXQtYWxsJyk7XG5cbiAgdmFyIEhJVF9UWVBFUyA9IHtcbiAgICAnYWxsJzogQUxMX0hJVF9TVFlMRSxcbiAgICAnY2xpY2stc3Ryb2tlJzogQ0xJQ0tfU1RST0tFX0hJVF9TVFlMRSxcbiAgICAnc3Ryb2tlJzogU1RST0tFX0hJVF9TVFlMRVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUhpdFN0eWxlKGNsYXNzTmFtZXMsIGF0dHJzKSB7XG5cbiAgICBhdHRycyA9IGFzc2lnbih7XG4gICAgICBzdHJva2U6ICd3aGl0ZScsXG4gICAgICBzdHJva2VXaWR0aDogMTVcbiAgICB9LCBhdHRycyB8fCB7fSk7XG5cbiAgICByZXR1cm4gc3R5bGVzLmNscyhjbGFzc05hbWVzLCBbICduby1maWxsJywgJ25vLWJvcmRlcicgXSwgYXR0cnMpO1xuICB9XG5cblxuICAvLyBzdHlsZSBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vL1xuXG4gIGZ1bmN0aW9uIGFwcGx5U3R5bGUoaGl0LCB0eXBlKSB7XG5cbiAgICB2YXIgYXR0cnMgPSBISVRfVFlQRVNbdHlwZV07XG5cbiAgICBpZiAoIWF0dHJzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaGl0IHR5cGUgPCcgKyB0eXBlICsgJz4nKTtcbiAgICB9XG5cbiAgICBzdmdBdHRyKGhpdCwgYXR0cnMpO1xuXG4gICAgcmV0dXJuIGhpdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGVuZEhpdChnZngsIGhpdCkge1xuICAgIHN2Z0FwcGVuZChnZngsIGhpdCk7XG4gIH1cblxuXG4gIC8vIEFQSVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgaGludHMgb24gdGhlIGdpdmVuIGdyYXBoaWNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGdmeFxuICAgKi9cbiAgdGhpcy5yZW1vdmVIaXRzID0gZnVuY3Rpb24oZ2Z4KSB7XG4gICAgdmFyIGhpdHMgPSBkb21RdWVyeUFsbCgnLmRqcy1oaXQnLCBnZngpO1xuXG4gICAgZm9yRWFjaChoaXRzLCBzdmdSZW1vdmUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgZGVmYXVsdCBoaXQgZm9yIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge2Rqcy5tb2RlbC5CYXNlfSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZ2Z4XG4gICAqXG4gICAqIEByZXR1cm4ge1NWR0VsZW1lbnR9IGNyZWF0ZWQgaGl0XG4gICAqL1xuICB0aGlzLmNyZWF0ZURlZmF1bHRIaXQgPSBmdW5jdGlvbihlbGVtZW50LCBnZngpIHtcbiAgICB2YXIgd2F5cG9pbnRzID0gZWxlbWVudC53YXlwb2ludHMsXG4gICAgICAgIGlzRnJhbWUgPSBlbGVtZW50LmlzRnJhbWUsXG4gICAgICAgIGJveFR5cGU7XG5cbiAgICBpZiAod2F5cG9pbnRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVXYXlwb2ludHNIaXQoZ2Z4LCB3YXlwb2ludHMpO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIGJveFR5cGUgPSBpc0ZyYW1lID8gJ3N0cm9rZScgOiAnYWxsJztcblxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQm94SGl0KGdmeCwgYm94VHlwZSwge1xuICAgICAgICB3aWR0aDogZWxlbWVudC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBlbGVtZW50LmhlaWdodFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgaGl0cyBmb3IgdGhlIGdpdmVuIHdheXBvaW50cy5cbiAgICpcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBnZnhcbiAgICogQHBhcmFtIHtBcnJheTxQb2ludD59IHdheXBvaW50c1xuICAgKlxuICAgKiBAcmV0dXJuIHtTVkdFbGVtZW50fVxuICAgKi9cbiAgdGhpcy5jcmVhdGVXYXlwb2ludHNIaXQgPSBmdW5jdGlvbihnZngsIHdheXBvaW50cykge1xuXG4gICAgdmFyIGhpdCA9IGNyZWF0ZUxpbmUod2F5cG9pbnRzKTtcblxuICAgIGFwcGx5U3R5bGUoaGl0LCAnc3Ryb2tlJyk7XG5cbiAgICBhcHBlbmRIaXQoZ2Z4LCBoaXQpO1xuXG4gICAgcmV0dXJuIGhpdDtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGhpdHMgZm9yIGEgYm94LlxuICAgKlxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGdmeFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaGl0VHlwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cnNcbiAgICpcbiAgICogQHJldHVybiB7U1ZHRWxlbWVudH1cbiAgICovXG4gIHRoaXMuY3JlYXRlQm94SGl0ID0gZnVuY3Rpb24oZ2Z4LCB0eXBlLCBhdHRycykge1xuXG4gICAgYXR0cnMgPSBhc3NpZ24oe1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9LCBhdHRycyk7XG5cbiAgICB2YXIgaGl0ID0gc3ZnQ3JlYXRlKCdyZWN0Jyk7XG5cbiAgICBhcHBseVN0eWxlKGhpdCwgdHlwZSk7XG5cbiAgICBzdmdBdHRyKGhpdCwgYXR0cnMpO1xuXG4gICAgYXBwZW5kSGl0KGdmeCwgaGl0KTtcblxuICAgIHJldHVybiBoaXQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBkZWZhdWx0IGhpdCBvZiB0aGUgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtICB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAgICogQHBhcmFtICB7U1ZHRWxlbWVudH0gZ2Z4XG4gICAqXG4gICAqIEByZXR1cm4ge1NWR0VsZW1lbnR9IHVwZGF0ZWQgaGl0XG4gICAqL1xuICB0aGlzLnVwZGF0ZURlZmF1bHRIaXQgPSBmdW5jdGlvbihlbGVtZW50LCBnZngpIHtcblxuICAgIHZhciBoaXQgPSBkb21RdWVyeSgnLmRqcy1oaXQnLCBnZngpO1xuXG4gICAgaWYgKCFoaXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC53YXlwb2ludHMpIHtcbiAgICAgIHVwZGF0ZUxpbmUoaGl0LCBlbGVtZW50LndheXBvaW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN2Z0F0dHIoaGl0LCB7XG4gICAgICAgIHdpZHRoOiBlbGVtZW50LndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGVsZW1lbnQuaGVpZ2h0XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGl0O1xuICB9O1xuXG4gIHRoaXMuZmlyZSA9IGZpcmU7XG5cbiAgdGhpcy50cmlnZ2VyTW91c2VFdmVudCA9IHRyaWdnZXJNb3VzZUV2ZW50O1xuXG4gIHRoaXMubW91c2VIYW5kbGVyID0gbW91c2VIYW5kbGVyO1xuXG4gIHRoaXMucmVnaXN0ZXJFdmVudCA9IHJlZ2lzdGVyRXZlbnQ7XG4gIHRoaXMudW5yZWdpc3RlckV2ZW50ID0gdW5yZWdpc3RlckV2ZW50O1xufVxuXG5cbkludGVyYWN0aW9uRXZlbnRzLiRpbmplY3QgPSBbXG4gICdldmVudEJ1cycsXG4gICdlbGVtZW50UmVnaXN0cnknLFxuICAnc3R5bGVzJ1xuXTtcblxuXG4vKipcbiAqIEFuIGV2ZW50IGluZGljYXRpbmcgdGhhdCB0aGUgbW91c2UgaG92ZXJlZCBvdmVyIGFuIGVsZW1lbnRcbiAqXG4gKiBAZXZlbnQgZWxlbWVudC5ob3ZlclxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge2Rqcy5tb2RlbC5CYXNlfSBlbGVtZW50XG4gKiBAcHJvcGVydHkge1NWR0VsZW1lbnR9IGdmeFxuICogQHByb3BlcnR5IHtFdmVudH0gb3JpZ2luYWxFdmVudFxuICovXG5cbi8qKlxuICogQW4gZXZlbnQgaW5kaWNhdGluZyB0aGF0IHRoZSBtb3VzZSBoYXMgbGVmdCBhbiBlbGVtZW50XG4gKlxuICogQGV2ZW50IGVsZW1lbnQub3V0XG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAqIEBwcm9wZXJ0eSB7U1ZHRWxlbWVudH0gZ2Z4XG4gKiBAcHJvcGVydHkge0V2ZW50fSBvcmlnaW5hbEV2ZW50XG4gKi9cblxuLyoqXG4gKiBBbiBldmVudCBpbmRpY2F0aW5nIHRoYXQgdGhlIG1vdXNlIGhhcyBjbGlja2VkIGFuIGVsZW1lbnRcbiAqXG4gKiBAZXZlbnQgZWxlbWVudC5jbGlja1xuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge2Rqcy5tb2RlbC5CYXNlfSBlbGVtZW50XG4gKiBAcHJvcGVydHkge1NWR0VsZW1lbnR9IGdmeFxuICogQHByb3BlcnR5IHtFdmVudH0gb3JpZ2luYWxFdmVudFxuICovXG5cbi8qKlxuICogQW4gZXZlbnQgaW5kaWNhdGluZyB0aGF0IHRoZSBtb3VzZSBoYXMgZG91YmxlIGNsaWNrZWQgYW4gZWxlbWVudFxuICpcbiAqIEBldmVudCBlbGVtZW50LmRibGNsaWNrXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAqIEBwcm9wZXJ0eSB7U1ZHRWxlbWVudH0gZ2Z4XG4gKiBAcHJvcGVydHkge0V2ZW50fSBvcmlnaW5hbEV2ZW50XG4gKi9cblxuLyoqXG4gKiBBbiBldmVudCBpbmRpY2F0aW5nIHRoYXQgdGhlIG1vdXNlIGhhcyBnb25lIGRvd24gb24gYW4gZWxlbWVudC5cbiAqXG4gKiBAZXZlbnQgZWxlbWVudC5tb3VzZWRvd25cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtkanMubW9kZWwuQmFzZX0gZWxlbWVudFxuICogQHByb3BlcnR5IHtTVkdFbGVtZW50fSBnZnhcbiAqIEBwcm9wZXJ0eSB7RXZlbnR9IG9yaWdpbmFsRXZlbnRcbiAqL1xuXG4vKipcbiAqIEFuIGV2ZW50IGluZGljYXRpbmcgdGhhdCB0aGUgbW91c2UgaGFzIGdvbmUgdXAgb24gYW4gZWxlbWVudC5cbiAqXG4gKiBAZXZlbnQgZWxlbWVudC5tb3VzZXVwXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAqIEBwcm9wZXJ0eSB7U1ZHRWxlbWVudH0gZ2Z4XG4gKiBAcHJvcGVydHkge0V2ZW50fSBvcmlnaW5hbEV2ZW50XG4gKi9cblxuLyoqXG4gKiBBbiBldmVudCBpbmRpY2F0aW5nIHRoYXQgdGhlIGNvbnRleHQgbWVudSBhY3Rpb24gaXMgdHJpZ2dlcmVkXG4gKiB2aWEgbW91c2Ugb3IgdG91Y2ggY29udHJvbHMuXG4gKlxuICogQGV2ZW50IGVsZW1lbnQuY29udGV4dG1lbnVcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtkanMubW9kZWwuQmFzZX0gZWxlbWVudFxuICogQHByb3BlcnR5IHtTVkdFbGVtZW50fSBnZnhcbiAqIEBwcm9wZXJ0eSB7RXZlbnR9IG9yaWdpbmFsRXZlbnRcbiAqLyIsImltcG9ydCBJbnRlcmFjdGlvbkV2ZW50cyBmcm9tICcuL0ludGVyYWN0aW9uRXZlbnRzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2luaXRfXzogWyAnaW50ZXJhY3Rpb25FdmVudHMnIF0sXG4gIGludGVyYWN0aW9uRXZlbnRzOiBbICd0eXBlJywgSW50ZXJhY3Rpb25FdmVudHMgXVxufTsiLCJpbXBvcnQgeyBnZXRCQm94IH0gZnJvbSAnLi4vLi4vdXRpbC9FbGVtZW50cyc7XG5cbnZhciBMT1dfUFJJT1JJVFkgPSA1MDA7XG5cbmltcG9ydCB7XG4gIGFwcGVuZCBhcyBzdmdBcHBlbmQsXG4gIGF0dHIgYXMgc3ZnQXR0cixcbiAgY3JlYXRlIGFzIHN2Z0NyZWF0ZVxufSBmcm9tICd0aW55LXN2Zyc7XG5cbmltcG9ydCB7XG4gIHF1ZXJ5IGFzIGRvbVF1ZXJ5XG59IGZyb20gJ21pbi1kb20nO1xuXG5pbXBvcnQge1xuICBhc3NpZ25cbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5cbi8qKlxuICogQGNsYXNzXG4gKlxuICogQSBwbHVnaW4gdGhhdCBhZGRzIGFuIG91dGxpbmUgdG8gc2hhcGVzIGFuZCBjb25uZWN0aW9ucyB0aGF0IG1heSBiZSBhY3RpdmF0ZWQgYW5kIHN0eWxlZFxuICogdmlhIENTUyBjbGFzc2VzLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gKiBAcGFyYW0ge1N0eWxlc30gc3R5bGVzXG4gKiBAcGFyYW0ge0VsZW1lbnRSZWdpc3RyeX0gZWxlbWVudFJlZ2lzdHJ5XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE91dGxpbmUoZXZlbnRCdXMsIHN0eWxlcywgZWxlbWVudFJlZ2lzdHJ5KSB7XG5cbiAgdGhpcy5vZmZzZXQgPSA2O1xuXG4gIHZhciBPVVRMSU5FX1NUWUxFID0gc3R5bGVzLmNscygnZGpzLW91dGxpbmUnLCBbICduby1maWxsJyBdKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gY3JlYXRlT3V0bGluZShnZngsIGJvdW5kcykge1xuICAgIHZhciBvdXRsaW5lID0gc3ZnQ3JlYXRlKCdyZWN0Jyk7XG5cbiAgICBzdmdBdHRyKG91dGxpbmUsIGFzc2lnbih7XG4gICAgICB4OiAxMCxcbiAgICAgIHk6IDEwLFxuICAgICAgd2lkdGg6IDEwMCxcbiAgICAgIGhlaWdodDogMTAwXG4gICAgfSwgT1VUTElORV9TVFlMRSkpO1xuXG4gICAgc3ZnQXBwZW5kKGdmeCwgb3V0bGluZSk7XG5cbiAgICByZXR1cm4gb3V0bGluZTtcbiAgfVxuXG4gIC8vIEEgbG93IHByaW9ydGl0eSBpcyBuZWNlc3NhcnksIGJlY2F1c2Ugb3V0bGluZXMgb2YgbGFiZWxzIGhhdmUgdG8gYmUgdXBkYXRlZFxuICAvLyBhZnRlciB0aGUgbGFiZWwgYm91bmRzIGhhdmUgYmVlbiB1cGRhdGVkIGluIHRoZSByZW5kZXJlci5cbiAgZXZlbnRCdXMub24oWyAnc2hhcGUuYWRkZWQnLCAnc2hhcGUuY2hhbmdlZCcgXSwgTE9XX1BSSU9SSVRZLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBlbGVtZW50ID0gZXZlbnQuZWxlbWVudCxcbiAgICAgICAgZ2Z4ID0gZXZlbnQuZ2Z4O1xuXG4gICAgdmFyIG91dGxpbmUgPSBkb21RdWVyeSgnLmRqcy1vdXRsaW5lJywgZ2Z4KTtcblxuICAgIGlmICghb3V0bGluZSkge1xuICAgICAgb3V0bGluZSA9IGNyZWF0ZU91dGxpbmUoZ2Z4LCBlbGVtZW50KTtcbiAgICB9XG5cbiAgICBzZWxmLnVwZGF0ZVNoYXBlT3V0bGluZShvdXRsaW5lLCBlbGVtZW50KTtcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oWyAnY29ubmVjdGlvbi5hZGRlZCcsICdjb25uZWN0aW9uLmNoYW5nZWQnIF0sIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGVsZW1lbnQgPSBldmVudC5lbGVtZW50LFxuICAgICAgICBnZnggPSBldmVudC5nZng7XG5cbiAgICB2YXIgb3V0bGluZSA9IGRvbVF1ZXJ5KCcuZGpzLW91dGxpbmUnLCBnZngpO1xuXG4gICAgaWYgKCFvdXRsaW5lKSB7XG4gICAgICBvdXRsaW5lID0gY3JlYXRlT3V0bGluZShnZngsIGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHNlbGYudXBkYXRlQ29ubmVjdGlvbk91dGxpbmUob3V0bGluZSwgZWxlbWVudCk7XG4gIH0pO1xufVxuXG5cbi8qKlxuICogVXBkYXRlcyB0aGUgb3V0bGluZSBvZiBhIHNoYXBlIHJlc3BlY3RpbmcgdGhlIGRpbWVuc2lvbiBvZiB0aGVcbiAqIGVsZW1lbnQgYW5kIGFuIG91dGxpbmUgb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSAge1NWR0VsZW1lbnR9IG91dGxpbmVcbiAqIEBwYXJhbSAge2Rqcy5tb2RlbC5CYXNlfSBlbGVtZW50XG4gKi9cbk91dGxpbmUucHJvdG90eXBlLnVwZGF0ZVNoYXBlT3V0bGluZSA9IGZ1bmN0aW9uKG91dGxpbmUsIGVsZW1lbnQpIHtcblxuICBzdmdBdHRyKG91dGxpbmUsIHtcbiAgICB4OiAtdGhpcy5vZmZzZXQsXG4gICAgeTogLXRoaXMub2Zmc2V0LFxuICAgIHdpZHRoOiBlbGVtZW50LndpZHRoICsgdGhpcy5vZmZzZXQgKiAyLFxuICAgIGhlaWdodDogZWxlbWVudC5oZWlnaHQgKyB0aGlzLm9mZnNldCAqIDJcbiAgfSk7XG5cbn07XG5cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBvdXRsaW5lIG9mIGEgY29ubmVjdGlvbiByZXNwZWN0aW5nIHRoZSBib3VuZGluZyBib3ggb2ZcbiAqIHRoZSBjb25uZWN0aW9uIGFuZCBhbiBvdXRsaW5lIG9mZnNldC5cbiAqXG4gKiBAcGFyYW0gIHtTVkdFbGVtZW50fSBvdXRsaW5lXG4gKiBAcGFyYW0gIHtkanMubW9kZWwuQmFzZX0gZWxlbWVudFxuICovXG5PdXRsaW5lLnByb3RvdHlwZS51cGRhdGVDb25uZWN0aW9uT3V0bGluZSA9IGZ1bmN0aW9uKG91dGxpbmUsIGNvbm5lY3Rpb24pIHtcblxuICB2YXIgYmJveCA9IGdldEJCb3goY29ubmVjdGlvbik7XG5cbiAgc3ZnQXR0cihvdXRsaW5lLCB7XG4gICAgeDogYmJveC54IC0gdGhpcy5vZmZzZXQsXG4gICAgeTogYmJveC55IC0gdGhpcy5vZmZzZXQsXG4gICAgd2lkdGg6IGJib3gud2lkdGggKyB0aGlzLm9mZnNldCAqIDIsXG4gICAgaGVpZ2h0OiBiYm94LmhlaWdodCArIHRoaXMub2Zmc2V0ICogMlxuICB9KTtcblxufTtcblxuXG5PdXRsaW5lLiRpbmplY3QgPSBbJ2V2ZW50QnVzJywgJ3N0eWxlcycsICdlbGVtZW50UmVnaXN0cnknXTsiLCJpbXBvcnQgT3V0bGluZSBmcm9tICcuL091dGxpbmUnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9faW5pdF9fOiBbICdvdXRsaW5lJyBdLFxuICBvdXRsaW5lOiBbICd0eXBlJywgT3V0bGluZSBdXG59OyIsImltcG9ydCB7XG4gIGlzQXJyYXksXG4gIGlzU3RyaW5nLFxuICBpc09iamVjdCxcbiAgYXNzaWduLFxuICBmb3JFYWNoLFxuICBmaW5kLFxuICBmaWx0ZXIsXG4gIG1hdGNoUGF0dGVybixcbiAgaXNEZWZpbmVkXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHtcbiAgZG9taWZ5LFxuICBjbGFzc2VzIGFzIGRvbUNsYXNzZXMsXG4gIGF0dHIgYXMgZG9tQXR0cixcbiAgcmVtb3ZlIGFzIGRvbVJlbW92ZSxcbiAgY2xlYXIgYXMgZG9tQ2xlYXJcbn0gZnJvbSAnbWluLWRvbSc7XG5cbmltcG9ydCB7XG4gIGdldEJCb3hcbn0gZnJvbSAnLi4vLi4vdXRpbC9FbGVtZW50cyc7XG5cbmltcG9ydCBJZHMgZnJvbSAnLi4vLi4vdXRpbC9JZEdlbmVyYXRvcic7XG5cbi8vIGRvY3VtZW50IHdpZGUgdW5pcXVlIG92ZXJsYXkgaWRzXG52YXIgaWRzID0gbmV3IElkcygnb3YnKTtcblxudmFyIExPV19QUklPUklUWSA9IDUwMDtcblxuXG4vKipcbiAqIEEgc2VydmljZSB0aGF0IGFsbG93cyB1c2VycyB0byBhdHRhY2ggb3ZlcmxheXMgdG8gZGlhZ3JhbSBlbGVtZW50cy5cbiAqXG4gKiBUaGUgb3ZlcmxheSBzZXJ2aWNlIHdpbGwgdGFrZSBjYXJlIG9mIG92ZXJsYXkgcG9zaXRpb25pbmcgZHVyaW5nIHVwZGF0ZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBhZGQgYSBwaW5rIGJhZGdlIG9uIHRoZSB0b3AgbGVmdCBvZiB0aGUgc2hhcGVcbiAqIG92ZXJsYXlzLmFkZChzb21lU2hhcGUsIHtcbiAqICAgcG9zaXRpb246IHtcbiAqICAgICB0b3A6IC01LFxuICogICAgIGxlZnQ6IC01XG4gKiAgIH0sXG4gKiAgIGh0bWw6ICc8ZGl2IHN0eWxlPVwid2lkdGg6IDEwcHg7IGJhY2tncm91bmQ6IGZ1Y2hzaWE7IGNvbG9yOiB3aGl0ZTtcIj4wPC9kaXY+J1xuICogfSk7XG4gKlxuICogLy8gb3IgYWRkIHZpYSBzaGFwZSBpZFxuICpcbiAqIG92ZXJsYXlzLmFkZCgnc29tZS1lbGVtZW50LWlkJywge1xuICogICBwb3NpdGlvbjoge1xuICogICAgIHRvcDogLTUsXG4gKiAgICAgbGVmdDogLTVcbiAqICAgfVxuICogICBodG1sOiAnPGRpdiBzdHlsZT1cIndpZHRoOiAxMHB4OyBiYWNrZ3JvdW5kOiBmdWNoc2lhOyBjb2xvcjogd2hpdGU7XCI+MDwvZGl2PidcbiAqIH0pO1xuICpcbiAqIC8vIG9yIGFkZCB3aXRoIG9wdGlvbmFsIHR5cGVcbiAqXG4gKiBvdmVybGF5cy5hZGQoc29tZVNoYXBlLCAnYmFkZ2UnLCB7XG4gKiAgIHBvc2l0aW9uOiB7XG4gKiAgICAgdG9wOiAtNSxcbiAqICAgICBsZWZ0OiAtNVxuICogICB9XG4gKiAgIGh0bWw6ICc8ZGl2IHN0eWxlPVwid2lkdGg6IDEwcHg7IGJhY2tncm91bmQ6IGZ1Y2hzaWE7IGNvbG9yOiB3aGl0ZTtcIj4wPC9kaXY+J1xuICogfSk7XG4gKlxuICpcbiAqIC8vIHJlbW92ZSBhbiBvdmVybGF5XG4gKlxuICogdmFyIGlkID0gb3ZlcmxheXMuYWRkKC4uLik7XG4gKiBvdmVybGF5cy5yZW1vdmUoaWQpO1xuICpcbiAqXG4gKiBZb3UgbWF5IGNvbmZpZ3VyZSBvdmVybGF5IGRlZmF1bHRzIGR1cmluZyB0b29sIGJ5IHByb3ZpZGluZyBhIGBjb25maWdgIG1vZHVsZVxuICogd2l0aCBgb3ZlcmxheXMuZGVmYXVsdHNgIGFzIGFuIGVudHJ5OlxuICpcbiAqIHtcbiAqICAgb3ZlcmxheXM6IHtcbiAqICAgICBkZWZhdWx0czoge1xuICogICAgICAgc2hvdzoge1xuICogICAgICAgICBtaW5ab29tOiAwLjcsXG4gKiAgICAgICAgIG1heFpvb206IDUuMFxuICogICAgICAgfSxcbiAqICAgICAgIHNjYWxlOiB7XG4gKiAgICAgICAgIG1pbjogMVxuICogICAgICAgfVxuICogICAgIH1cbiAqIH1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICogQHBhcmFtIHtFbGVtZW50UmVnaXN0cnl9IGVsZW1lbnRSZWdpc3RyeVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBPdmVybGF5cyhjb25maWcsIGV2ZW50QnVzLCBjYW52YXMsIGVsZW1lbnRSZWdpc3RyeSkge1xuXG4gIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG4gIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbiAgdGhpcy5fZWxlbWVudFJlZ2lzdHJ5ID0gZWxlbWVudFJlZ2lzdHJ5O1xuXG4gIHRoaXMuX2lkcyA9IGlkcztcblxuICB0aGlzLl9vdmVybGF5RGVmYXVsdHMgPSBhc3NpZ24oe1xuXG4gICAgLy8gbm8gc2hvdyBjb25zdHJhaW50c1xuICAgIHNob3c6IG51bGwsXG5cbiAgICAvLyBhbHdheXMgc2NhbGVcbiAgICBzY2FsZTogdHJ1ZVxuICB9LCBjb25maWcgJiYgY29uZmlnLmRlZmF1bHRzKTtcblxuICAvKipcbiAgICogTWFwcGluZyBvdmVybGF5SWQgLT4gb3ZlcmxheVxuICAgKi9cbiAgdGhpcy5fb3ZlcmxheXMgPSB7fTtcblxuICAvKipcbiAgICogTWFwcGluZyBlbGVtZW50SWQgLT4gb3ZlcmxheSBjb250YWluZXJcbiAgICovXG4gIHRoaXMuX292ZXJsYXlDb250YWluZXJzID0gW107XG5cbiAgLy8gcm9vdCBodG1sIGVsZW1lbnQgZm9yIGFsbCBvdmVybGF5c1xuICB0aGlzLl9vdmVybGF5Um9vdCA9IGNyZWF0ZVJvb3QoY2FudmFzLmdldENvbnRhaW5lcigpKTtcblxuICB0aGlzLl9pbml0KCk7XG59XG5cblxuT3ZlcmxheXMuJGluamVjdCA9IFtcbiAgJ2NvbmZpZy5vdmVybGF5cycsXG4gICdldmVudEJ1cycsXG4gICdjYW52YXMnLFxuICAnZWxlbWVudFJlZ2lzdHJ5J1xuXTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIG92ZXJsYXkgd2l0aCB0aGUgc3BlY2lmaWVkIGlkIG9yIGEgbGlzdCBvZiBvdmVybGF5c1xuICogZm9yIGFuIGVsZW1lbnQgd2l0aCBhIGdpdmVuIHR5cGUuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyByZXR1cm4gdGhlIHNpbmdsZSBvdmVybGF5IHdpdGggdGhlIGdpdmVuIGlkXG4gKiBvdmVybGF5cy5nZXQoJ3NvbWUtaWQnKTtcbiAqXG4gKiAvLyByZXR1cm4gYWxsIG92ZXJsYXlzIGZvciB0aGUgc2hhcGVcbiAqIG92ZXJsYXlzLmdldCh7IGVsZW1lbnQ6IHNvbWVTaGFwZSB9KTtcbiAqXG4gKiAvLyByZXR1cm4gYWxsIG92ZXJsYXlzIG9uIHNoYXBlIHdpdGggdHlwZSAnYmFkZ2UnXG4gKiBvdmVybGF5cy5nZXQoeyBlbGVtZW50OiBzb21lU2hhcGUsIHR5cGU6ICdiYWRnZScgfSk7XG4gKlxuICogLy8gc2hhcGUgY2FuIGFsc28gYmUgc3BlY2lmaWVkIGFzIGlkXG4gKiBvdmVybGF5cy5nZXQoeyBlbGVtZW50OiAnZWxlbWVudC1pZCcsIHR5cGU6ICdiYWRnZScgfSk7XG4gKlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWFyY2hcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc2VhcmNoLmlkXVxuICogQHBhcmFtIHtTdHJpbmd8ZGpzLm1vZGVsLkJhc2V9IFtzZWFyY2guZWxlbWVudF1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbc2VhcmNoLnR5cGVdXG4gKlxuICogQHJldHVybiB7T2JqZWN0fEFycmF5PE9iamVjdD59IHRoZSBvdmVybGF5KHMpXG4gKi9cbk92ZXJsYXlzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihzZWFyY2gpIHtcblxuICBpZiAoaXNTdHJpbmcoc2VhcmNoKSkge1xuICAgIHNlYXJjaCA9IHsgaWQ6IHNlYXJjaCB9O1xuICB9XG5cbiAgaWYgKGlzU3RyaW5nKHNlYXJjaC5lbGVtZW50KSkge1xuICAgIHNlYXJjaC5lbGVtZW50ID0gdGhpcy5fZWxlbWVudFJlZ2lzdHJ5LmdldChzZWFyY2guZWxlbWVudCk7XG4gIH1cblxuICBpZiAoc2VhcmNoLmVsZW1lbnQpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fZ2V0T3ZlcmxheUNvbnRhaW5lcihzZWFyY2guZWxlbWVudCwgdHJ1ZSk7XG5cbiAgICAvLyByZXR1cm4gYSBsaXN0IG9mIG92ZXJsYXlzIHdoZW4gc2VhcmNoaW5nIGJ5IGVsZW1lbnQgKCt0eXBlKVxuICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgIHJldHVybiBzZWFyY2gudHlwZSA/IGZpbHRlcihjb250YWluZXIub3ZlcmxheXMsIG1hdGNoUGF0dGVybih7IHR5cGU6IHNlYXJjaC50eXBlIH0pKSA6IGNvbnRhaW5lci5vdmVybGF5cy5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9IGVsc2VcbiAgaWYgKHNlYXJjaC50eXBlKSB7XG4gICAgcmV0dXJuIGZpbHRlcih0aGlzLl9vdmVybGF5cywgbWF0Y2hQYXR0ZXJuKHsgdHlwZTogc2VhcmNoLnR5cGUgfSkpO1xuICB9IGVsc2Uge1xuXG4gICAgLy8gcmV0dXJuIHNpbmdsZSBlbGVtZW50IHdoZW4gc2VhcmNoaW5nIGJ5IGlkXG4gICAgcmV0dXJuIHNlYXJjaC5pZCA/IHRoaXMuX292ZXJsYXlzW3NlYXJjaC5pZF0gOiBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEFkZHMgYSBIVE1MIG92ZXJsYXkgdG8gYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xkanMubW9kZWwuQmFzZX0gICBlbGVtZW50ICAgYXR0YWNoIG92ZXJsYXkgdG8gdGhpcyBzaGFwZVxuICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICAgICAgICAgICAgW3R5cGVdICAgIG9wdGlvbmFsIHR5cGUgdG8gYXNzaWduIHRvIHRoZSBvdmVybGF5XG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgICAgICAgICBvdmVybGF5ICAgdGhlIG92ZXJsYXkgY29uZmlndXJhdGlvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfERPTUVsZW1lbnR9ICAgICAgIG92ZXJsYXkuaHRtbCAgICAgICAgICAgICAgICAgaHRtbCBlbGVtZW50IHRvIHVzZSBhcyBhbiBvdmVybGF5XG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgICAgICAgICBbb3ZlcmxheS5zaG93XSAgICAgICAgICAgICAgIHNob3cgY29uZmlndXJhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgW292ZXJsYXkuc2hvdy5taW5ab29tXSAgICAgICBtaW5pbWFsIHpvb20gbGV2ZWwgdG8gc2hvdyB0aGUgb3ZlcmxheVxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgW292ZXJsYXkuc2hvdy5tYXhab29tXSAgICAgICBtYXhpbXVtIHpvb20gbGV2ZWwgdG8gc2hvdyB0aGUgb3ZlcmxheVxuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgb3ZlcmxheS5wb3NpdGlvbiAgICAgICAgICAgICB3aGVyZSB0byBhdHRhY2ggdGhlIG92ZXJsYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICAgICAgICAgIFtvdmVybGF5LnBvc2l0aW9uLmxlZnRdICAgICAgcmVsYXRpdmUgdG8gZWxlbWVudCBiYm94IGxlZnQgYXR0YWNobWVudFxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgW292ZXJsYXkucG9zaXRpb24udG9wXSAgICAgICByZWxhdGl2ZSB0byBlbGVtZW50IGJib3ggdG9wIGF0dGFjaG1lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICAgICAgICAgIFtvdmVybGF5LnBvc2l0aW9uLmJvdHRvbV0gICAgcmVsYXRpdmUgdG8gZWxlbWVudCBiYm94IGJvdHRvbSBhdHRhY2htZW50XG4gKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgICAgICAgICBbb3ZlcmxheS5wb3NpdGlvbi5yaWdodF0gICAgIHJlbGF0aXZlIHRvIGVsZW1lbnQgYmJveCByaWdodCBhdHRhY2htZW50XG4gKiBAcGFyYW0ge0Jvb2xlYW58T2JqZWN0fSAgICAgICAgICBbb3ZlcmxheS5zY2FsZT10cnVlXSAgICAgICAgIGZhbHNlIHRvIHByZXNlcnZlIHRoZSBzYW1lIHNpemUgcmVnYXJkbGVzcyBvZlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWFncmFtIHpvb21cbiAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICAgICAgICAgIFtvdmVybGF5LnNjYWxlLm1pbl1cbiAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICAgICAgICAgIFtvdmVybGF5LnNjYWxlLm1heF1cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICAgICAgICBpZCB0aGF0IG1heSBiZSB1c2VkIHRvIHJlZmVyZW5jZSB0aGUgb3ZlcmxheSBmb3IgdXBkYXRlIG9yIHJlbW92YWxcbiAqL1xuT3ZlcmxheXMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGVsZW1lbnQsIHR5cGUsIG92ZXJsYXkpIHtcblxuICBpZiAoaXNPYmplY3QodHlwZSkpIHtcbiAgICBvdmVybGF5ID0gdHlwZTtcbiAgICB0eXBlID0gbnVsbDtcbiAgfVxuXG4gIGlmICghZWxlbWVudC5pZCkge1xuICAgIGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50UmVnaXN0cnkuZ2V0KGVsZW1lbnQpO1xuICB9XG5cbiAgaWYgKCFvdmVybGF5LnBvc2l0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHNwZWNpZml5IG92ZXJsYXkgcG9zaXRpb24nKTtcbiAgfVxuXG4gIGlmICghb3ZlcmxheS5odG1sKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHNwZWNpZml5IG92ZXJsYXkgaHRtbCcpO1xuICB9XG5cbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGVsZW1lbnQgc3BlY2lmaWVkJyk7XG4gIH1cblxuICB2YXIgaWQgPSB0aGlzLl9pZHMubmV4dCgpO1xuXG4gIG92ZXJsYXkgPSBhc3NpZ24oe30sIHRoaXMuX292ZXJsYXlEZWZhdWx0cywgb3ZlcmxheSwge1xuICAgIGlkOiBpZCxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgaHRtbDogb3ZlcmxheS5odG1sXG4gIH0pO1xuXG4gIHRoaXMuX2FkZE92ZXJsYXkob3ZlcmxheSk7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuXG4vKipcbiAqIFJlbW92ZSBhbiBvdmVybGF5IHdpdGggdGhlIGdpdmVuIGlkIG9yIGFsbCBvdmVybGF5cyBtYXRjaGluZyB0aGUgZ2l2ZW4gZmlsdGVyLlxuICpcbiAqIEBzZWUgT3ZlcmxheXMjZ2V0IGZvciBmaWx0ZXIgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW2lkXVxuICogQHBhcmFtIHtPYmplY3R9IFtmaWx0ZXJdXG4gKi9cbk92ZXJsYXlzLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihmaWx0ZXIpIHtcblxuICB2YXIgb3ZlcmxheXMgPSB0aGlzLmdldChmaWx0ZXIpIHx8IFtdO1xuXG4gIGlmICghaXNBcnJheShvdmVybGF5cykpIHtcbiAgICBvdmVybGF5cyA9IFsgb3ZlcmxheXMgXTtcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmb3JFYWNoKG92ZXJsYXlzLCBmdW5jdGlvbihvdmVybGF5KSB7XG5cbiAgICB2YXIgY29udGFpbmVyID0gc2VsZi5fZ2V0T3ZlcmxheUNvbnRhaW5lcihvdmVybGF5LmVsZW1lbnQsIHRydWUpO1xuXG4gICAgaWYgKG92ZXJsYXkpIHtcbiAgICAgIGRvbVJlbW92ZShvdmVybGF5Lmh0bWwpO1xuICAgICAgZG9tUmVtb3ZlKG92ZXJsYXkuaHRtbENvbnRhaW5lcik7XG5cbiAgICAgIGRlbGV0ZSBvdmVybGF5Lmh0bWxDb250YWluZXI7XG4gICAgICBkZWxldGUgb3ZlcmxheS5lbGVtZW50O1xuXG4gICAgICBkZWxldGUgc2VsZi5fb3ZlcmxheXNbb3ZlcmxheS5pZF07XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgdmFyIGlkeCA9IGNvbnRhaW5lci5vdmVybGF5cy5pbmRleE9mKG92ZXJsYXkpO1xuICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgY29udGFpbmVyLm92ZXJsYXlzLnNwbGljZShpZHgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbn07XG5cblxuT3ZlcmxheXMucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgc2V0VmlzaWJsZSh0aGlzLl9vdmVybGF5Um9vdCk7XG59O1xuXG5cbk92ZXJsYXlzLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XG4gIHNldFZpc2libGUodGhpcy5fb3ZlcmxheVJvb3QsIGZhbHNlKTtcbn07XG5cbk92ZXJsYXlzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9vdmVybGF5cyA9IHt9O1xuXG4gIHRoaXMuX292ZXJsYXlDb250YWluZXJzID0gW107XG5cbiAgZG9tQ2xlYXIodGhpcy5fb3ZlcmxheVJvb3QpO1xufTtcblxuT3ZlcmxheXMucHJvdG90eXBlLl91cGRhdGVPdmVybGF5Q29udGFpbmVyID0gZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gIHZhciBlbGVtZW50ID0gY29udGFpbmVyLmVsZW1lbnQsXG4gICAgICBodG1sID0gY29udGFpbmVyLmh0bWw7XG5cbiAgLy8gdXBkYXRlIGNvbnRhaW5lciBsZWZ0LHRvcCBhY2NvcmRpbmcgdG8gdGhlIGVsZW1lbnRzIHgseSBjb29yZGluYXRlc1xuICAvLyB0aGlzIGVuc3VyZXMgd2UgY2FuIGF0dGFjaCBjaGlsZCBlbGVtZW50cyByZWxhdGl2ZSB0byB0aGlzIGNvbnRhaW5lclxuXG4gIHZhciB4ID0gZWxlbWVudC54LFxuICAgICAgeSA9IGVsZW1lbnQueTtcblxuICBpZiAoZWxlbWVudC53YXlwb2ludHMpIHtcbiAgICB2YXIgYmJveCA9IGdldEJCb3goZWxlbWVudCk7XG4gICAgeCA9IGJib3gueDtcbiAgICB5ID0gYmJveC55O1xuICB9XG5cbiAgc2V0UG9zaXRpb24oaHRtbCwgeCwgeSk7XG5cbiAgZG9tQXR0cihjb250YWluZXIuaHRtbCwgJ2RhdGEtY29udGFpbmVyLWlkJywgZWxlbWVudC5pZCk7XG59O1xuXG5cbk92ZXJsYXlzLnByb3RvdHlwZS5fdXBkYXRlT3ZlcmxheSA9IGZ1bmN0aW9uKG92ZXJsYXkpIHtcblxuICB2YXIgcG9zaXRpb24gPSBvdmVybGF5LnBvc2l0aW9uLFxuICAgICAgaHRtbENvbnRhaW5lciA9IG92ZXJsYXkuaHRtbENvbnRhaW5lcixcbiAgICAgIGVsZW1lbnQgPSBvdmVybGF5LmVsZW1lbnQ7XG5cbiAgLy8gdXBkYXRlIG92ZXJsYXkgaHRtbCByZWxhdGl2ZSB0byBzaGFwZSBiZWNhdXNlXG4gIC8vIGl0IGlzIGFscmVhZHkgcG9zaXRpb25lZCBvbiB0aGUgZWxlbWVudFxuXG4gIC8vIHVwZGF0ZSByZWxhdGl2ZVxuICB2YXIgbGVmdCA9IHBvc2l0aW9uLmxlZnQsXG4gICAgICB0b3AgPSBwb3NpdGlvbi50b3A7XG5cbiAgaWYgKHBvc2l0aW9uLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcblxuICAgIHZhciB3aWR0aDtcblxuICAgIGlmIChlbGVtZW50LndheXBvaW50cykge1xuICAgICAgd2lkdGggPSBnZXRCQm94KGVsZW1lbnQpLndpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aWR0aCA9IGVsZW1lbnQud2lkdGg7XG4gICAgfVxuXG4gICAgbGVmdCA9IHBvc2l0aW9uLnJpZ2h0ICogLTEgKyB3aWR0aDtcbiAgfVxuXG4gIGlmIChwb3NpdGlvbi5ib3R0b20gIT09IHVuZGVmaW5lZCkge1xuXG4gICAgdmFyIGhlaWdodDtcblxuICAgIGlmIChlbGVtZW50LndheXBvaW50cykge1xuICAgICAgaGVpZ2h0ID0gZ2V0QkJveChlbGVtZW50KS5oZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlaWdodCA9IGVsZW1lbnQuaGVpZ2h0O1xuICAgIH1cblxuICAgIHRvcCA9IHBvc2l0aW9uLmJvdHRvbSAqIC0xICsgaGVpZ2h0O1xuICB9XG5cbiAgc2V0UG9zaXRpb24oaHRtbENvbnRhaW5lciwgbGVmdCB8fCAwLCB0b3AgfHwgMCk7XG59O1xuXG5cbk92ZXJsYXlzLnByb3RvdHlwZS5fY3JlYXRlT3ZlcmxheUNvbnRhaW5lciA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgdmFyIGh0bWwgPSBkb21pZnkoJzxkaXYgY2xhc3M9XCJkanMtb3ZlcmxheXNcIiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZVwiIC8+Jyk7XG5cbiAgdGhpcy5fb3ZlcmxheVJvb3QuYXBwZW5kQ2hpbGQoaHRtbCk7XG5cbiAgdmFyIGNvbnRhaW5lciA9IHtcbiAgICBodG1sOiBodG1sLFxuICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgb3ZlcmxheXM6IFtdXG4gIH07XG5cbiAgdGhpcy5fdXBkYXRlT3ZlcmxheUNvbnRhaW5lcihjb250YWluZXIpO1xuXG4gIHRoaXMuX292ZXJsYXlDb250YWluZXJzLnB1c2goY29udGFpbmVyKTtcblxuICByZXR1cm4gY29udGFpbmVyO1xufTtcblxuXG5PdmVybGF5cy5wcm90b3R5cGUuX3VwZGF0ZVJvb3QgPSBmdW5jdGlvbih2aWV3Ym94KSB7XG4gIHZhciBzY2FsZSA9IHZpZXdib3guc2NhbGUgfHwgMTtcblxuICB2YXIgbWF0cml4ID0gJ21hdHJpeCgnICtcbiAgW1xuICAgIHNjYWxlLFxuICAgIDAsXG4gICAgMCxcbiAgICBzY2FsZSxcbiAgICAtMSAqIHZpZXdib3gueCAqIHNjYWxlLFxuICAgIC0xICogdmlld2JveC55ICogc2NhbGVcbiAgXS5qb2luKCcsJykgK1xuICAnKSc7XG5cbiAgc2V0VHJhbnNmb3JtKHRoaXMuX292ZXJsYXlSb290LCBtYXRyaXgpO1xufTtcblxuXG5PdmVybGF5cy5wcm90b3R5cGUuX2dldE92ZXJsYXlDb250YWluZXIgPSBmdW5jdGlvbihlbGVtZW50LCByYXcpIHtcbiAgdmFyIGNvbnRhaW5lciA9IGZpbmQodGhpcy5fb3ZlcmxheUNvbnRhaW5lcnMsIGZ1bmN0aW9uKGMpIHtcbiAgICByZXR1cm4gYy5lbGVtZW50ID09PSBlbGVtZW50O1xuICB9KTtcblxuXG4gIGlmICghY29udGFpbmVyICYmICFyYXcpIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlT3ZlcmxheUNvbnRhaW5lcihlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBjb250YWluZXI7XG59O1xuXG5cbk92ZXJsYXlzLnByb3RvdHlwZS5fYWRkT3ZlcmxheSA9IGZ1bmN0aW9uKG92ZXJsYXkpIHtcblxuICB2YXIgaWQgPSBvdmVybGF5LmlkLFxuICAgICAgZWxlbWVudCA9IG92ZXJsYXkuZWxlbWVudCxcbiAgICAgIGh0bWwgPSBvdmVybGF5Lmh0bWwsXG4gICAgICBodG1sQ29udGFpbmVyLFxuICAgICAgb3ZlcmxheUNvbnRhaW5lcjtcblxuICAvLyB1bndyYXAganF1ZXJ5IChmb3IgdGhvc2Ugd2hvIG5lZWQgaXQpXG4gIGlmIChodG1sLmdldCAmJiBodG1sLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5qcXVlcnkpIHtcbiAgICBodG1sID0gaHRtbC5nZXQoMCk7XG4gIH1cblxuICAvLyBjcmVhdGUgcHJvcGVyIGh0bWwgZWxlbWVudHMgZnJvbVxuICAvLyBvdmVybGF5IEhUTUwgc3RyaW5nc1xuICBpZiAoaXNTdHJpbmcoaHRtbCkpIHtcbiAgICBodG1sID0gZG9taWZ5KGh0bWwpO1xuICB9XG5cbiAgb3ZlcmxheUNvbnRhaW5lciA9IHRoaXMuX2dldE92ZXJsYXlDb250YWluZXIoZWxlbWVudCk7XG5cbiAgaHRtbENvbnRhaW5lciA9IGRvbWlmeSgnPGRpdiBjbGFzcz1cImRqcy1vdmVybGF5XCIgZGF0YS1vdmVybGF5LWlkPVwiJyArIGlkICsgJ1wiIHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlXCI+Jyk7XG5cbiAgaHRtbENvbnRhaW5lci5hcHBlbmRDaGlsZChodG1sKTtcblxuICBpZiAob3ZlcmxheS50eXBlKSB7XG4gICAgZG9tQ2xhc3NlcyhodG1sQ29udGFpbmVyKS5hZGQoJ2Rqcy1vdmVybGF5LScgKyBvdmVybGF5LnR5cGUpO1xuICB9XG5cbiAgb3ZlcmxheS5odG1sQ29udGFpbmVyID0gaHRtbENvbnRhaW5lcjtcblxuICBvdmVybGF5Q29udGFpbmVyLm92ZXJsYXlzLnB1c2gob3ZlcmxheSk7XG4gIG92ZXJsYXlDb250YWluZXIuaHRtbC5hcHBlbmRDaGlsZChodG1sQ29udGFpbmVyKTtcblxuICB0aGlzLl9vdmVybGF5c1tpZF0gPSBvdmVybGF5O1xuXG4gIHRoaXMuX3VwZGF0ZU92ZXJsYXkob3ZlcmxheSk7XG4gIHRoaXMuX3VwZGF0ZU92ZXJsYXlWaXNpYmlsdHkob3ZlcmxheSwgdGhpcy5fY2FudmFzLnZpZXdib3goKSk7XG59O1xuXG5cbk92ZXJsYXlzLnByb3RvdHlwZS5fdXBkYXRlT3ZlcmxheVZpc2liaWx0eSA9IGZ1bmN0aW9uKG92ZXJsYXksIHZpZXdib3gpIHtcbiAgdmFyIHNob3cgPSBvdmVybGF5LnNob3csXG4gICAgICBtaW5ab29tID0gc2hvdyAmJiBzaG93Lm1pblpvb20sXG4gICAgICBtYXhab29tID0gc2hvdyAmJiBzaG93Lm1heFpvb20sXG4gICAgICBodG1sQ29udGFpbmVyID0gb3ZlcmxheS5odG1sQ29udGFpbmVyLFxuICAgICAgdmlzaWJsZSA9IHRydWU7XG5cbiAgaWYgKHNob3cpIHtcbiAgICBpZiAoXG4gICAgICAoaXNEZWZpbmVkKG1pblpvb20pICYmIG1pblpvb20gPiB2aWV3Ym94LnNjYWxlKSB8fFxuICAgICAgKGlzRGVmaW5lZChtYXhab29tKSAmJiBtYXhab29tIDwgdmlld2JveC5zY2FsZSlcbiAgICApIHtcbiAgICAgIHZpc2libGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBzZXRWaXNpYmxlKGh0bWxDb250YWluZXIsIHZpc2libGUpO1xuICB9XG5cbiAgdGhpcy5fdXBkYXRlT3ZlcmxheVNjYWxlKG92ZXJsYXksIHZpZXdib3gpO1xufTtcblxuXG5PdmVybGF5cy5wcm90b3R5cGUuX3VwZGF0ZU92ZXJsYXlTY2FsZSA9IGZ1bmN0aW9uKG92ZXJsYXksIHZpZXdib3gpIHtcbiAgdmFyIHNob3VsZFNjYWxlID0gb3ZlcmxheS5zY2FsZSxcbiAgICAgIG1pblNjYWxlLFxuICAgICAgbWF4U2NhbGUsXG4gICAgICBodG1sQ29udGFpbmVyID0gb3ZlcmxheS5odG1sQ29udGFpbmVyO1xuXG4gIHZhciBzY2FsZSwgdHJhbnNmb3JtID0gJyc7XG5cbiAgaWYgKHNob3VsZFNjYWxlICE9PSB0cnVlKSB7XG5cbiAgICBpZiAoc2hvdWxkU2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICBtaW5TY2FsZSA9IDE7XG4gICAgICBtYXhTY2FsZSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pblNjYWxlID0gc2hvdWxkU2NhbGUubWluO1xuICAgICAgbWF4U2NhbGUgPSBzaG91bGRTY2FsZS5tYXg7XG4gICAgfVxuXG4gICAgaWYgKGlzRGVmaW5lZChtaW5TY2FsZSkgJiYgdmlld2JveC5zY2FsZSA8IG1pblNjYWxlKSB7XG4gICAgICBzY2FsZSA9ICgxIC8gdmlld2JveC5zY2FsZSB8fCAxKSAqIG1pblNjYWxlO1xuICAgIH1cblxuICAgIGlmIChpc0RlZmluZWQobWF4U2NhbGUpICYmIHZpZXdib3guc2NhbGUgPiBtYXhTY2FsZSkge1xuICAgICAgc2NhbGUgPSAoMSAvIHZpZXdib3guc2NhbGUgfHwgMSkgKiBtYXhTY2FsZTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNEZWZpbmVkKHNjYWxlKSkge1xuICAgIHRyYW5zZm9ybSA9ICdzY2FsZSgnICsgc2NhbGUgKyAnLCcgKyBzY2FsZSArICcpJztcbiAgfVxuXG4gIHNldFRyYW5zZm9ybShodG1sQ29udGFpbmVyLCB0cmFuc2Zvcm0pO1xufTtcblxuXG5PdmVybGF5cy5wcm90b3R5cGUuX3VwZGF0ZU92ZXJsYXlzVmlzaWJpbHR5ID0gZnVuY3Rpb24odmlld2JveCkge1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmb3JFYWNoKHRoaXMuX292ZXJsYXlzLCBmdW5jdGlvbihvdmVybGF5KSB7XG4gICAgc2VsZi5fdXBkYXRlT3ZlcmxheVZpc2liaWx0eShvdmVybGF5LCB2aWV3Ym94KTtcbiAgfSk7XG59O1xuXG5cbk92ZXJsYXlzLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciBldmVudEJ1cyA9IHRoaXMuX2V2ZW50QnVzO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuXG4gIC8vIHNjcm9sbC96b29tIGludGVncmF0aW9uXG5cbiAgZnVuY3Rpb24gdXBkYXRlVmlld2JveCh2aWV3Ym94KSB7XG4gICAgc2VsZi5fdXBkYXRlUm9vdCh2aWV3Ym94KTtcbiAgICBzZWxmLl91cGRhdGVPdmVybGF5c1Zpc2liaWx0eSh2aWV3Ym94KTtcblxuICAgIHNlbGYuc2hvdygpO1xuICB9XG5cbiAgZXZlbnRCdXMub24oJ2NhbnZhcy52aWV3Ym94LmNoYW5naW5nJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBzZWxmLmhpZGUoKTtcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2NhbnZhcy52aWV3Ym94LmNoYW5nZWQnLCBmdW5jdGlvbihldmVudCkge1xuICAgIHVwZGF0ZVZpZXdib3goZXZlbnQudmlld2JveCk7XG4gIH0pO1xuXG5cbiAgLy8gcmVtb3ZlIGludGVncmF0aW9uXG5cbiAgZXZlbnRCdXMub24oWyAnc2hhcGUucmVtb3ZlJywgJ2Nvbm5lY3Rpb24ucmVtb3ZlJyBdLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBlLmVsZW1lbnQ7XG4gICAgdmFyIG92ZXJsYXlzID0gc2VsZi5nZXQoeyBlbGVtZW50OiBlbGVtZW50IH0pO1xuXG4gICAgZm9yRWFjaChvdmVybGF5cywgZnVuY3Rpb24obykge1xuICAgICAgc2VsZi5yZW1vdmUoby5pZCk7XG4gICAgfSk7XG5cbiAgICB2YXIgY29udGFpbmVyID0gc2VsZi5fZ2V0T3ZlcmxheUNvbnRhaW5lcihlbGVtZW50KTtcblxuICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgIGRvbVJlbW92ZShjb250YWluZXIuaHRtbCk7XG4gICAgICB2YXIgaSA9IHNlbGYuX292ZXJsYXlDb250YWluZXJzLmluZGV4T2YoY29udGFpbmVyKTtcbiAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICBzZWxmLl9vdmVybGF5Q29udGFpbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuXG4gIC8vIG1vdmUgaW50ZWdyYXRpb25cblxuICBldmVudEJ1cy5vbignZWxlbWVudC5jaGFuZ2VkJywgTE9XX1BSSU9SSVRZLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBlLmVsZW1lbnQ7XG5cbiAgICB2YXIgY29udGFpbmVyID0gc2VsZi5fZ2V0T3ZlcmxheUNvbnRhaW5lcihlbGVtZW50LCB0cnVlKTtcblxuICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgIGZvckVhY2goY29udGFpbmVyLm92ZXJsYXlzLCBmdW5jdGlvbihvdmVybGF5KSB7XG4gICAgICAgIHNlbGYuX3VwZGF0ZU92ZXJsYXkob3ZlcmxheSk7XG4gICAgICB9KTtcblxuICAgICAgc2VsZi5fdXBkYXRlT3ZlcmxheUNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIH1cbiAgfSk7XG5cblxuICAvLyBtYXJrZXIgaW50ZWdyYXRpb24sIHNpbXBseSBhZGQgdGhlbSBvbiB0aGUgb3ZlcmxheXMgYXMgY2xhc3NlcywgdG9vLlxuXG4gIGV2ZW50QnVzLm9uKCdlbGVtZW50Lm1hcmtlci51cGRhdGUnLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IHNlbGYuX2dldE92ZXJsYXlDb250YWluZXIoZS5lbGVtZW50LCB0cnVlKTtcbiAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICBkb21DbGFzc2VzKGNvbnRhaW5lci5odG1sKVtlLmFkZCA/ICdhZGQnIDogJ3JlbW92ZSddKGUubWFya2VyKTtcbiAgICB9XG4gIH0pO1xuXG5cbiAgLy8gY2xlYXIgb3ZlcmxheXMgd2l0aCBkaWFncmFtXG5cbiAgZXZlbnRCdXMub24oJ2RpYWdyYW0uY2xlYXInLCB0aGlzLmNsZWFyLCB0aGlzKTtcbn07XG5cblxuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGNyZWF0ZVJvb3QocGFyZW50Tm9kZSkge1xuICB2YXIgcm9vdCA9IGRvbWlmeShcbiAgICAnPGRpdiBjbGFzcz1cImRqcy1vdmVybGF5LWNvbnRhaW5lclwiIHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMDsgaGVpZ2h0OiAwO1wiIC8+J1xuICApO1xuXG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHJvb3QsIHBhcmVudE5vZGUuZmlyc3RDaGlsZCk7XG5cbiAgcmV0dXJuIHJvb3Q7XG59XG5cbmZ1bmN0aW9uIHNldFBvc2l0aW9uKGVsLCB4LCB5KSB7XG4gIGFzc2lnbihlbC5zdHlsZSwgeyBsZWZ0OiB4ICsgJ3B4JywgdG9wOiB5ICsgJ3B4JyB9KTtcbn1cblxuZnVuY3Rpb24gc2V0VmlzaWJsZShlbCwgdmlzaWJsZSkge1xuICBlbC5zdHlsZS5kaXNwbGF5ID0gdmlzaWJsZSA9PT0gZmFsc2UgPyAnbm9uZScgOiAnJztcbn1cblxuZnVuY3Rpb24gc2V0VHJhbnNmb3JtKGVsLCB0cmFuc2Zvcm0pIHtcblxuICBlbC5zdHlsZVsndHJhbnNmb3JtLW9yaWdpbiddID0gJ3RvcCBsZWZ0JztcblxuICBbICcnLCAnLW1zLScsICctd2Via2l0LScgXS5mb3JFYWNoKGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIGVsLnN0eWxlW3ByZWZpeCArICd0cmFuc2Zvcm0nXSA9IHRyYW5zZm9ybTtcbiAgfSk7XG59IiwiaW1wb3J0IE92ZXJsYXlzIGZyb20gJy4vT3ZlcmxheXMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9faW5pdF9fOiBbICdvdmVybGF5cycgXSxcbiAgb3ZlcmxheXM6IFsgJ3R5cGUnLCBPdmVybGF5cyBdXG59OyIsImltcG9ydCB7XG4gIGlzQXJyYXksXG4gIGZvckVhY2hcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5cbi8qKlxuICogQSBzZXJ2aWNlIHRoYXQgb2ZmZXJzIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpbiBhIGRpYWdyYW0uXG4gKiBPZmZlcnMgdGhlIGFwaSB0byBjb250cm9sIHRoZSBzZWxlY3Rpb24sIHRvby5cbiAqXG4gKiBAY2xhc3NcbiAqXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1cyB0aGUgZXZlbnQgYnVzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNlbGVjdGlvbihldmVudEJ1cykge1xuXG4gIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG5cbiAgdGhpcy5fc2VsZWN0ZWRFbGVtZW50cyA9IFtdO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBldmVudEJ1cy5vbihbICdzaGFwZS5yZW1vdmUnLCAnY29ubmVjdGlvbi5yZW1vdmUnIF0sIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWxlbWVudCA9IGUuZWxlbWVudDtcbiAgICBzZWxmLmRlc2VsZWN0KGVsZW1lbnQpO1xuICB9KTtcblxuICBldmVudEJ1cy5vbihbICdkaWFncmFtLmNsZWFyJyBdLCBmdW5jdGlvbihlKSB7XG4gICAgc2VsZi5zZWxlY3QobnVsbCk7XG4gIH0pO1xufVxuXG5TZWxlY3Rpb24uJGluamVjdCA9IFsgJ2V2ZW50QnVzJyBdO1xuXG5cblNlbGVjdGlvbi5wcm90b3R5cGUuZGVzZWxlY3QgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHZhciBzZWxlY3RlZEVsZW1lbnRzID0gdGhpcy5fc2VsZWN0ZWRFbGVtZW50cztcblxuICB2YXIgaWR4ID0gc2VsZWN0ZWRFbGVtZW50cy5pbmRleE9mKGVsZW1lbnQpO1xuXG4gIGlmIChpZHggIT09IC0xKSB7XG4gICAgdmFyIG9sZFNlbGVjdGlvbiA9IHNlbGVjdGVkRWxlbWVudHMuc2xpY2UoKTtcblxuICAgIHNlbGVjdGVkRWxlbWVudHMuc3BsaWNlKGlkeCwgMSk7XG5cbiAgICB0aGlzLl9ldmVudEJ1cy5maXJlKCdzZWxlY3Rpb24uY2hhbmdlZCcsIHsgb2xkU2VsZWN0aW9uOiBvbGRTZWxlY3Rpb24sIG5ld1NlbGVjdGlvbjogc2VsZWN0ZWRFbGVtZW50cyB9KTtcbiAgfVxufTtcblxuXG5TZWxlY3Rpb24ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRFbGVtZW50cztcbn07XG5cblNlbGVjdGlvbi5wcm90b3R5cGUuaXNTZWxlY3RlZCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkRWxlbWVudHMuaW5kZXhPZihlbGVtZW50KSAhPT0gLTE7XG59O1xuXG5cbi8qKlxuICogVGhpcyBtZXRob2Qgc2VsZWN0cyBvbmUgb3IgbW9yZSBlbGVtZW50cyBvbiB0aGUgZGlhZ3JhbS5cbiAqXG4gKiBCeSBwYXNzaW5nIGFuIGFkZGl0aW9uYWwgYWRkIHBhcmFtZXRlciB5b3UgY2FuIGRlY2lkZSB3aGV0aGVyIG9yIG5vdCB0aGUgZWxlbWVudChzKVxuICogc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBhbHJlYWR5IGV4aXN0aW5nIHNlbGVjdGlvbiBvciBub3QuXG4gKlxuICogQG1ldGhvZCBTZWxlY3Rpb24jc2VsZWN0XG4gKlxuICogQHBhcmFtICB7T2JqZWN0fE9iamVjdFtdfSBlbGVtZW50cyBlbGVtZW50IG9yIGFycmF5IG9mIGVsZW1lbnRzIHRvIGJlIHNlbGVjdGVkXG4gKiBAcGFyYW0gIHtib29sZWFufSBbYWRkXSB3aGV0aGVyIHRoZSBlbGVtZW50KHMpIHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24sIGRlZmF1bHRzIHRvIGZhbHNlXG4gKi9cblNlbGVjdGlvbi5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24oZWxlbWVudHMsIGFkZCkge1xuICB2YXIgc2VsZWN0ZWRFbGVtZW50cyA9IHRoaXMuX3NlbGVjdGVkRWxlbWVudHMsXG4gICAgICBvbGRTZWxlY3Rpb24gPSBzZWxlY3RlZEVsZW1lbnRzLnNsaWNlKCk7XG5cbiAgaWYgKCFpc0FycmF5KGVsZW1lbnRzKSkge1xuICAgIGVsZW1lbnRzID0gZWxlbWVudHMgPyBbIGVsZW1lbnRzIF0gOiBbXTtcbiAgfVxuXG4gIC8vIHNlbGVjdGlvbiBtYXkgYmUgY2xlYXJlZCBieSBwYXNzaW5nIGFuIGVtcHR5IGFycmF5IG9yIG51bGxcbiAgLy8gdG8gdGhlIG1ldGhvZFxuICBpZiAoYWRkKSB7XG4gICAgZm9yRWFjaChlbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgaWYgKHNlbGVjdGVkRWxlbWVudHMuaW5kZXhPZihlbGVtZW50KSAhPT0gLTEpIHtcblxuICAgICAgICAvLyBhbHJlYWR5IHNlbGVjdGVkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdGVkRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9zZWxlY3RlZEVsZW1lbnRzID0gc2VsZWN0ZWRFbGVtZW50cyA9IGVsZW1lbnRzLnNsaWNlKCk7XG4gIH1cblxuICB0aGlzLl9ldmVudEJ1cy5maXJlKCdzZWxlY3Rpb24uY2hhbmdlZCcsIHsgb2xkU2VsZWN0aW9uOiBvbGRTZWxlY3Rpb24sIG5ld1NlbGVjdGlvbjogc2VsZWN0ZWRFbGVtZW50cyB9KTtcbn07XG4iLCJpbXBvcnQge1xuICBoYXNQcmltYXJ5TW9kaWZpZXJcbn0gZnJvbSAnLi4vLi4vdXRpbC9Nb3VzZSc7XG5cbmltcG9ydCB7XG4gIGZpbmQsIGlzQXJyYXlcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNlbGVjdGlvbkJlaGF2aW9yKFxuICAgIGV2ZW50QnVzLCBzZWxlY3Rpb24sIGNhbnZhcyxcbiAgICBlbGVtZW50UmVnaXN0cnkpIHtcblxuICBldmVudEJ1cy5vbignY3JlYXRlLmVuZCcsIDUwMCwgZnVuY3Rpb24oZSkge1xuXG4gICAgdmFyIGNvbnRleHQgPSBlLmNvbnRleHQsXG4gICAgICAgIGNhbkV4ZWN1dGUgPSBjb250ZXh0LmNhbkV4ZWN1dGUsXG4gICAgICAgIGVsZW1lbnRzID0gY29udGV4dC5lbGVtZW50cyxcbiAgICAgICAgaGludHMgPSBjb250ZXh0LmhpbnRzIHx8IHt9LFxuICAgICAgICBhdXRvU2VsZWN0ID0gaGludHMuYXV0b1NlbGVjdDtcblxuICAgIC8vIHNlbGVjdCBlbGVtZW50cyBhZnRlciB0aGV5IGhhdmUgYmVlbiBjcmVhdGVkXG4gICAgaWYgKGNhbkV4ZWN1dGUpIHtcbiAgICAgIGlmIChhdXRvU2VsZWN0ID09PSBmYWxzZSkge1xuXG4gICAgICAgIC8vIHNlbGVjdCBubyBlbGVtZW50c1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KGF1dG9TZWxlY3QpKSB7XG4gICAgICAgIHNlbGVjdGlvbi5zZWxlY3QoYXV0b1NlbGVjdCk7XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIHNlbGVjdCBhbGwgZWxlbWVudHMgYnkgZGVmYXVsdFxuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0KGVsZW1lbnRzLmZpbHRlcihpc1Nob3duKSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBldmVudEJ1cy5vbignY29ubmVjdC5lbmQnLCA1MDAsIGZ1bmN0aW9uKGUpIHtcblxuICAgIC8vIHNlbGVjdCB0aGUgY29ubmVjdCBlbmQgdGFyZ2V0XG4gICAgLy8gYWZ0ZXIgYSBjb25uZWN0IG9wZXJhdGlvblxuICAgIGlmIChlLmNvbnRleHQuY2FuRXhlY3V0ZSAmJiBlLmNvbnRleHQuaG92ZXIpIHtcbiAgICAgIHNlbGVjdGlvbi5zZWxlY3QoZS5jb250ZXh0LmhvdmVyKTtcbiAgICB9XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdzaGFwZS5tb3ZlLmVuZCcsIDUwMCwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBwcmV2aW91c1NlbGVjdGlvbiA9IGUucHJldmlvdXNTZWxlY3Rpb24gfHwgW107XG5cbiAgICB2YXIgc2hhcGUgPSBlbGVtZW50UmVnaXN0cnkuZ2V0KGUuY29udGV4dC5zaGFwZS5pZCk7XG5cbiAgICAvLyBtYWtlIHN1cmUgYXQgbGVhc3QgdGhlIG1haW4gbW92ZWQgZWxlbWVudCBpcyBiZWluZ1xuICAgIC8vIHNlbGVjdGVkIGFmdGVyIGEgbW92ZSBvcGVyYXRpb25cbiAgICB2YXIgaW5TZWxlY3Rpb24gPSBmaW5kKHByZXZpb3VzU2VsZWN0aW9uLCBmdW5jdGlvbihzZWxlY3RlZFNoYXBlKSB7XG4gICAgICByZXR1cm4gc2hhcGUuaWQgPT09IHNlbGVjdGVkU2hhcGUuaWQ7XG4gICAgfSk7XG5cbiAgICBpZiAoIWluU2VsZWN0aW9uKSB7XG4gICAgICBzZWxlY3Rpb24uc2VsZWN0KHNoYXBlKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFNoaWZ0ICsgY2xpY2sgc2VsZWN0aW9uXG4gIGV2ZW50QnVzLm9uKCdlbGVtZW50LmNsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIHZhciBlbGVtZW50ID0gZXZlbnQuZWxlbWVudDtcblxuICAgIC8vIGRvIG5vdCBzZWxlY3QgdGhlIHJvb3QgZWxlbWVudFxuICAgIC8vIG9yIGNvbm5lY3Rpb25zXG4gICAgaWYgKGVsZW1lbnQgPT09IGNhbnZhcy5nZXRSb290RWxlbWVudCgpKSB7XG4gICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgaXNTZWxlY3RlZCA9IHNlbGVjdGlvbi5pc1NlbGVjdGVkKGVsZW1lbnQpLFxuICAgICAgICBpc011bHRpU2VsZWN0ID0gc2VsZWN0aW9uLmdldCgpLmxlbmd0aCA+IDE7XG5cbiAgICAvLyBtb3VzZS1ldmVudDogU0VMRUNUSU9OX0tFWVxuICAgIHZhciBhZGQgPSBoYXNQcmltYXJ5TW9kaWZpZXIoZXZlbnQpO1xuXG4gICAgLy8gc2VsZWN0IE9SIGRlc2VsZWN0IGVsZW1lbnQgaW4gbXVsdGkgc2VsZWN0aW9uXG4gICAgaWYgKGlzU2VsZWN0ZWQgJiYgaXNNdWx0aVNlbGVjdCkge1xuICAgICAgaWYgKGFkZCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0aW9uLmRlc2VsZWN0KGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbi5zZWxlY3QoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlXG4gICAgaWYgKCFpc1NlbGVjdGVkKSB7XG4gICAgICBzZWxlY3Rpb24uc2VsZWN0KGVsZW1lbnQsIGFkZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGlvbi5kZXNlbGVjdChlbGVtZW50KTtcbiAgICB9XG4gIH0pO1xufVxuXG5TZWxlY3Rpb25CZWhhdmlvci4kaW5qZWN0ID0gW1xuICAnZXZlbnRCdXMnLFxuICAnc2VsZWN0aW9uJyxcbiAgJ2NhbnZhcycsXG4gICdlbGVtZW50UmVnaXN0cnknXG5dO1xuXG5cbmZ1bmN0aW9uIGlzU2hvd24oZWxlbWVudCkge1xuICByZXR1cm4gIWVsZW1lbnQuaGlkZGVuO1xufVxuIiwiaW1wb3J0IHtcbiAgZm9yRWFjaFxufSBmcm9tICdtaW4tZGFzaCc7XG5cbnZhciBNQVJLRVJfSE9WRVIgPSAnaG92ZXInLFxuICAgIE1BUktFUl9TRUxFQ1RFRCA9ICdzZWxlY3RlZCc7XG5cblxuLyoqXG4gKiBBIHBsdWdpbiB0aGF0IGFkZHMgYSB2aXNpYmxlIHNlbGVjdGlvbiBVSSB0byBzaGFwZXMgYW5kIGNvbm5lY3Rpb25zXG4gKiBieSBhcHBlbmRpbmcgdGhlIDxjb2RlPmhvdmVyPC9jb2RlPiBhbmQgPGNvZGU+c2VsZWN0ZWQ8L2NvZGU+IGNsYXNzZXMgdG8gdGhlbS5cbiAqXG4gKiBAY2xhc3NcbiAqXG4gKiBNYWtlcyBlbGVtZW50cyBzZWxlY3RhYmxlLCB0b28uXG4gKlxuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRzXG4gKiBAcGFyYW0ge1NlbGVjdGlvblNlcnZpY2V9IHNlbGVjdGlvblxuICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTZWxlY3Rpb25WaXN1YWxzKGV2ZW50cywgY2FudmFzLCBzZWxlY3Rpb24sIHN0eWxlcykge1xuXG4gIHRoaXMuX211bHRpU2VsZWN0aW9uQm94ID0gbnVsbDtcblxuICBmdW5jdGlvbiBhZGRNYXJrZXIoZSwgY2xzKSB7XG4gICAgY2FudmFzLmFkZE1hcmtlcihlLCBjbHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTWFya2VyKGUsIGNscykge1xuICAgIGNhbnZhcy5yZW1vdmVNYXJrZXIoZSwgY2xzKTtcbiAgfVxuXG4gIGV2ZW50cy5vbignZWxlbWVudC5ob3ZlcicsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgYWRkTWFya2VyKGV2ZW50LmVsZW1lbnQsIE1BUktFUl9IT1ZFUik7XG4gIH0pO1xuXG4gIGV2ZW50cy5vbignZWxlbWVudC5vdXQnLCBmdW5jdGlvbihldmVudCkge1xuICAgIHJlbW92ZU1hcmtlcihldmVudC5lbGVtZW50LCBNQVJLRVJfSE9WRVIpO1xuICB9KTtcblxuICBldmVudHMub24oJ3NlbGVjdGlvbi5jaGFuZ2VkJywgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIGZ1bmN0aW9uIGRlc2VsZWN0KHMpIHtcbiAgICAgIHJlbW92ZU1hcmtlcihzLCBNQVJLRVJfU0VMRUNURUQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlbGVjdChzKSB7XG4gICAgICBhZGRNYXJrZXIocywgTUFSS0VSX1NFTEVDVEVEKTtcbiAgICB9XG5cbiAgICB2YXIgb2xkU2VsZWN0aW9uID0gZXZlbnQub2xkU2VsZWN0aW9uLFxuICAgICAgICBuZXdTZWxlY3Rpb24gPSBldmVudC5uZXdTZWxlY3Rpb247XG5cbiAgICBmb3JFYWNoKG9sZFNlbGVjdGlvbiwgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKG5ld1NlbGVjdGlvbi5pbmRleE9mKGUpID09PSAtMSkge1xuICAgICAgICBkZXNlbGVjdChlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGZvckVhY2gobmV3U2VsZWN0aW9uLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAob2xkU2VsZWN0aW9uLmluZGV4T2YoZSkgPT09IC0xKSB7XG4gICAgICAgIHNlbGVjdChlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cblNlbGVjdGlvblZpc3VhbHMuJGluamVjdCA9IFtcbiAgJ2V2ZW50QnVzJyxcbiAgJ2NhbnZhcycsXG4gICdzZWxlY3Rpb24nLFxuICAnc3R5bGVzJ1xuXTsiLCJpbXBvcnQgSW50ZXJhY3Rpb25FdmVudHNNb2R1bGUgZnJvbSAnLi4vaW50ZXJhY3Rpb24tZXZlbnRzJztcbmltcG9ydCBPdXRsaW5lTW9kdWxlIGZyb20gJy4uL291dGxpbmUnO1xuXG5pbXBvcnQgU2VsZWN0aW9uIGZyb20gJy4vU2VsZWN0aW9uJztcbmltcG9ydCBTZWxlY3Rpb25WaXN1YWxzIGZyb20gJy4vU2VsZWN0aW9uVmlzdWFscyc7XG5pbXBvcnQgU2VsZWN0aW9uQmVoYXZpb3IgZnJvbSAnLi9TZWxlY3Rpb25CZWhhdmlvcic7XG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2luaXRfXzogWyAnc2VsZWN0aW9uVmlzdWFscycsICdzZWxlY3Rpb25CZWhhdmlvcicgXSxcbiAgX19kZXBlbmRzX186IFtcbiAgICBJbnRlcmFjdGlvbkV2ZW50c01vZHVsZSxcbiAgICBPdXRsaW5lTW9kdWxlXG4gIF0sXG4gIHNlbGVjdGlvbjogWyAndHlwZScsIFNlbGVjdGlvbiBdLFxuICBzZWxlY3Rpb25WaXN1YWxzOiBbICd0eXBlJywgU2VsZWN0aW9uVmlzdWFscyBdLFxuICBzZWxlY3Rpb25CZWhhdmlvcjogWyAndHlwZScsIFNlbGVjdGlvbkJlaGF2aW9yIF1cbn07XG4iLCJpbXBvcnQgdHJhbnNsYXRlIGZyb20gJy4vdHJhbnNsYXRlJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICB0cmFuc2xhdGU6IFsgJ3ZhbHVlJywgdHJhbnNsYXRlIF1cbn07IiwiLyoqXG4gKiBBIHNpbXBsZSB0cmFuc2xhdGlvbiBzdHViIHRvIGJlIHVzZWQgZm9yIG11bHRpLWxhbmd1YWdlIHN1cHBvcnRcbiAqIGluIGRpYWdyYW1zLiBDYW4gYmUgZWFzaWx5IHJlcGxhY2VkIHdpdGggYSBtb3JlIHNvcGhpc3RpY2F0ZWRcbiAqIHNvbHV0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gdXNlIGl0IGluc2lkZSBhbnkgZGlhZ3JhbSBjb21wb25lbnQgYnkgaW5qZWN0aW5nIGB0cmFuc2xhdGVgLlxuICpcbiAqIGZ1bmN0aW9uIE15U2VydmljZSh0cmFuc2xhdGUpIHtcbiAqICAgYWxlcnQodHJhbnNsYXRlKCdIRUxMTyB7eW91fScsIHsgeW91OiAnWW91IScgfSkpO1xuICogfVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZW1wbGF0ZSB0byBpbnRlcnBvbGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtyZXBsYWNlbWVudHNdIGEgbWFwIHdpdGggc3Vic3RpdHV0ZXNcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSB0cmFuc2xhdGVkIHN0cmluZ1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmFuc2xhdGUodGVtcGxhdGUsIHJlcGxhY2VtZW50cykge1xuXG4gIHJlcGxhY2VtZW50cyA9IHJlcGxhY2VtZW50cyB8fCB7fTtcblxuICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZSgveyhbXn1dKyl9L2csIGZ1bmN0aW9uKF8sIGtleSkge1xuICAgIHJldHVybiByZXBsYWNlbWVudHNba2V5XSB8fCAneycgKyBrZXkgKyAnfSc7XG4gIH0pO1xufSIsImltcG9ydCB7XG4gIGlzT2JqZWN0LFxuICBzb3J0Qnlcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBwb2ludERpc3RhbmNlLFxuICBwb2ludHNPbkxpbmVcbn0gZnJvbSAnLi4vdXRpbC9HZW9tZXRyeSc7XG5cbmltcG9ydCBpbnRlcnNlY3RQYXRocyBmcm9tICdwYXRoLWludGVyc2VjdGlvbic7XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kQm91bmRzKGJvdW5kcykge1xuICByZXR1cm4ge1xuICAgIHg6IE1hdGgucm91bmQoYm91bmRzLngpLFxuICAgIHk6IE1hdGgucm91bmQoYm91bmRzLnkpLFxuICAgIHdpZHRoOiBNYXRoLnJvdW5kKGJvdW5kcy53aWR0aCksXG4gICAgaGVpZ2h0OiBNYXRoLnJvdW5kKGJvdW5kcy5oZWlnaHQpXG4gIH07XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kUG9pbnQocG9pbnQpIHtcblxuICByZXR1cm4ge1xuICAgIHg6IE1hdGgucm91bmQocG9pbnQueCksXG4gICAgeTogTWF0aC5yb3VuZChwb2ludC55KVxuICB9O1xufVxuXG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gYm91bmRzIHRvIGEgeyB0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQgfSBkZXNjcmlwdG9yLlxuICpcbiAqIEBwYXJhbSB7Qm91bmRzfFBvaW50fSBib3VuZHNcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc1RSQkwoYm91bmRzKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiBib3VuZHMueSxcbiAgICByaWdodDogYm91bmRzLnggKyAoYm91bmRzLndpZHRoIHx8IDApLFxuICAgIGJvdHRvbTogYm91bmRzLnkgKyAoYm91bmRzLmhlaWdodCB8fCAwKSxcbiAgICBsZWZ0OiBib3VuZHMueFxuICB9O1xufVxuXG5cbi8qKlxuICogQ29udmVydCBhIHsgdG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0IH0gdG8gYW4gb2JqZWN0cyBib3VuZHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRyYmxcbiAqXG4gKiBAcmV0dXJuIHtCb3VuZHN9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc0JvdW5kcyh0cmJsKSB7XG4gIHJldHVybiB7XG4gICAgeDogdHJibC5sZWZ0LFxuICAgIHk6IHRyYmwudG9wLFxuICAgIHdpZHRoOiB0cmJsLnJpZ2h0IC0gdHJibC5sZWZ0LFxuICAgIGhlaWdodDogdHJibC5ib3R0b20gLSB0cmJsLnRvcFxuICB9O1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBtaWQgb2YgdGhlIGdpdmVuIGJvdW5kcyBvciBwb2ludC5cbiAqXG4gKiBAcGFyYW0ge0JvdW5kc3xQb2ludH0gYm91bmRzXG4gKlxuICogQHJldHVybiB7UG9pbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNaWQoYm91bmRzKSB7XG4gIHJldHVybiByb3VuZFBvaW50KHtcbiAgICB4OiBib3VuZHMueCArIChib3VuZHMud2lkdGggfHwgMCkgLyAyLFxuICAgIHk6IGJvdW5kcy55ICsgKGJvdW5kcy5oZWlnaHQgfHwgMCkgLyAyXG4gIH0pO1xufVxuXG5cbi8vIG9yaWVudGF0aW9uIHV0aWxzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBHZXQgb3JpZW50YXRpb24gb2YgdGhlIGdpdmVuIHJlY3RhbmdsZSB3aXRoIHJlc3BlY3QgdG9cbiAqIHRoZSByZWZlcmVuY2UgcmVjdGFuZ2xlLlxuICpcbiAqIEEgcGFkZGluZyAocG9zaXRpdmUgb3IgbmVnYXRpdmUpIG1heSBiZSBwYXNzZWQgdG8gaW5mbHVlbmNlXG4gKiBob3Jpem9udGFsIC8gdmVydGljYWwgb3JpZW50YXRpb24gYW5kIGludGVyc2VjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0JvdW5kc30gcmVjdFxuICogQHBhcmFtIHtCb3VuZHN9IHJlZmVyZW5jZVxuICogQHBhcmFtIHtQb2ludHxOdW1iZXJ9IHBhZGRpbmdcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBvcmllbnRhdGlvbjsgb25lIG9mIHRvcCwgdG9wLWxlZnQsIGxlZnQsIC4uLiwgYm90dG9tLCByaWdodCBvciBpbnRlcnNlY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcmllbnRhdGlvbihyZWN0LCByZWZlcmVuY2UsIHBhZGRpbmcpIHtcblxuICBwYWRkaW5nID0gcGFkZGluZyB8fCAwO1xuXG4gIC8vIG1ha2Ugc3VyZSB3ZSBjYW4gdXNlIGFuIG9iamVjdCwgdG9vXG4gIC8vIGZvciBpbmRpdmlkdWFsIHsgeCwgeSB9IHBhZGRpbmdcbiAgaWYgKCFpc09iamVjdChwYWRkaW5nKSkge1xuICAgIHBhZGRpbmcgPSB7IHg6IHBhZGRpbmcsIHk6IHBhZGRpbmcgfTtcbiAgfVxuXG5cbiAgdmFyIHJlY3RPcmllbnRhdGlvbiA9IGFzVFJCTChyZWN0KSxcbiAgICAgIHJlZmVyZW5jZU9yaWVudGF0aW9uID0gYXNUUkJMKHJlZmVyZW5jZSk7XG5cbiAgdmFyIHRvcCA9IHJlY3RPcmllbnRhdGlvbi5ib3R0b20gKyBwYWRkaW5nLnkgPD0gcmVmZXJlbmNlT3JpZW50YXRpb24udG9wLFxuICAgICAgcmlnaHQgPSByZWN0T3JpZW50YXRpb24ubGVmdCAtIHBhZGRpbmcueCA+PSByZWZlcmVuY2VPcmllbnRhdGlvbi5yaWdodCxcbiAgICAgIGJvdHRvbSA9IHJlY3RPcmllbnRhdGlvbi50b3AgLSBwYWRkaW5nLnkgPj0gcmVmZXJlbmNlT3JpZW50YXRpb24uYm90dG9tLFxuICAgICAgbGVmdCA9IHJlY3RPcmllbnRhdGlvbi5yaWdodCArIHBhZGRpbmcueCA8PSByZWZlcmVuY2VPcmllbnRhdGlvbi5sZWZ0O1xuXG4gIHZhciB2ZXJ0aWNhbCA9IHRvcCA/ICd0b3AnIDogKGJvdHRvbSA/ICdib3R0b20nIDogbnVsbCksXG4gICAgICBob3Jpem9udGFsID0gbGVmdCA/ICdsZWZ0JyA6IChyaWdodCA/ICdyaWdodCcgOiBudWxsKTtcblxuICBpZiAoaG9yaXpvbnRhbCAmJiB2ZXJ0aWNhbCkge1xuICAgIHJldHVybiB2ZXJ0aWNhbCArICctJyArIGhvcml6b250YWw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGhvcml6b250YWwgfHwgdmVydGljYWwgfHwgJ2ludGVyc2VjdCc7XG4gIH1cbn1cblxuXG4vLyBpbnRlcnNlY3Rpb24gdXRpbHMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEdldCBpbnRlcnNlY3Rpb24gYmV0d2VlbiBhbiBlbGVtZW50IGFuZCBhIGxpbmUgcGF0aC5cbiAqXG4gKiBAcGFyYW0ge1BhdGhEZWZ9IGVsZW1lbnRQYXRoXG4gKiBAcGFyYW0ge1BhdGhEZWZ9IGxpbmVQYXRoXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNyb3BTdGFydCBjcm9wIGZyb20gc3RhcnQgb3IgZW5kXG4gKlxuICogQHJldHVybiB7UG9pbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbGVtZW50TGluZUludGVyc2VjdGlvbihlbGVtZW50UGF0aCwgbGluZVBhdGgsIGNyb3BTdGFydCkge1xuXG4gIHZhciBpbnRlcnNlY3Rpb25zID0gZ2V0SW50ZXJzZWN0aW9ucyhlbGVtZW50UGF0aCwgbGluZVBhdGgpO1xuXG4gIC8vIHJlY29nbml6ZSBpbnRlcnNlY3Rpb25zXG4gIC8vIG9ubHkgb25lIC0+IGNob29zZVxuICAvLyB0d28gY2xvc2UgdG9nZXRoZXIgLT4gY2hvb3NlIGZpcnN0XG4gIC8vIHR3byBvciBtb3JlIGRpc3RpbmN0IC0+IHB1bGwgb3V0IGFwcHJvcHJpYXRlIG9uZVxuICAvLyBub25lIC0+IG9rIChmYWxsYmFjayB0byBwb2ludCBpdHNlbGYpXG4gIGlmIChpbnRlcnNlY3Rpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiByb3VuZFBvaW50KGludGVyc2VjdGlvbnNbMF0pO1xuICB9IGVsc2UgaWYgKGludGVyc2VjdGlvbnMubGVuZ3RoID09PSAyICYmIHBvaW50RGlzdGFuY2UoaW50ZXJzZWN0aW9uc1swXSwgaW50ZXJzZWN0aW9uc1sxXSkgPCAxKSB7XG4gICAgcmV0dXJuIHJvdW5kUG9pbnQoaW50ZXJzZWN0aW9uc1swXSk7XG4gIH0gZWxzZSBpZiAoaW50ZXJzZWN0aW9ucy5sZW5ndGggPiAxKSB7XG5cbiAgICAvLyBzb3J0IGJ5IGludGVyc2VjdGlvbnMgYmFzZWQgb24gY29ubmVjdGlvbiBzZWdtZW50ICtcbiAgICAvLyBkaXN0YW5jZSBmcm9tIHN0YXJ0XG4gICAgaW50ZXJzZWN0aW9ucyA9IHNvcnRCeShpbnRlcnNlY3Rpb25zLCBmdW5jdGlvbihpKSB7XG4gICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLmZsb29yKGkudDIgKiAxMDApIHx8IDE7XG5cbiAgICAgIGRpc3RhbmNlID0gMTAwIC0gZGlzdGFuY2U7XG5cbiAgICAgIGRpc3RhbmNlID0gKGRpc3RhbmNlIDwgMTAgPyAnMCcgOiAnJykgKyBkaXN0YW5jZTtcblxuICAgICAgLy8gY3JlYXRlIGEgc29ydCBzdHJpbmcgdGhhdCBtYWtlcyBzdXJlIHdlIHNvcnRcbiAgICAgIC8vIGxpbmUgc2VnbWVudCBBU0MgKyBsaW5lIHNlZ21lbnQgcG9zaXRpb24gREVTQyAoZm9yIGNyb3BTdGFydClcbiAgICAgIC8vIGxpbmUgc2VnbWVudCBBU0MgKyBsaW5lIHNlZ21lbnQgcG9zaXRpb24gQVNDIChmb3IgY3JvcEVuZClcbiAgICAgIHJldHVybiBpLnNlZ21lbnQyICsgJyMnICsgZGlzdGFuY2U7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcm91bmRQb2ludChpbnRlcnNlY3Rpb25zW2Nyb3BTdGFydCA/IDAgOiBpbnRlcnNlY3Rpb25zLmxlbmd0aCAtIDFdKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25zKGEsIGIpIHtcbiAgcmV0dXJuIGludGVyc2VjdFBhdGhzKGEsIGIpO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJSZWR1bmRhbnRXYXlwb2ludHMod2F5cG9pbnRzKSB7XG5cbiAgLy8gYWx0ZXIgY29weSBvZiB3YXlwb2ludHMsIG5vdCBvcmlnaW5hbFxuICB3YXlwb2ludHMgPSB3YXlwb2ludHMuc2xpY2UoKTtcblxuICB2YXIgaWR4ID0gMCxcbiAgICAgIHBvaW50LFxuICAgICAgcHJldmlvdXNQb2ludCxcbiAgICAgIG5leHRQb2ludDtcblxuICB3aGlsZSAod2F5cG9pbnRzW2lkeF0pIHtcbiAgICBwb2ludCA9IHdheXBvaW50c1tpZHhdO1xuICAgIHByZXZpb3VzUG9pbnQgPSB3YXlwb2ludHNbaWR4IC0gMV07XG4gICAgbmV4dFBvaW50ID0gd2F5cG9pbnRzW2lkeCArIDFdO1xuXG4gICAgaWYgKHBvaW50RGlzdGFuY2UocG9pbnQsIG5leHRQb2ludCkgPT09IDAgfHxcbiAgICAgICAgcG9pbnRzT25MaW5lKHByZXZpb3VzUG9pbnQsIG5leHRQb2ludCwgcG9pbnQpKSB7XG5cbiAgICAgIC8vIHJlbW92ZSBwb2ludCwgaWYgb3ZlcmxhcHBpbmcgd2l0aCB7bmV4dFBvaW50fVxuICAgICAgLy8gb3Igb24gbGluZSB3aXRoIHtwcmV2aW91c1BvaW50fSAtPiB7cG9pbnR9IC0+IHtuZXh0UG9pbnR9XG4gICAgICB3YXlwb2ludHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlkeCsrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3YXlwb2ludHM7XG59XG4iLCJpbXBvcnQgeyBhc3NpZ24gfSBmcm9tICdtaW4tZGFzaCc7XG5pbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuXG5pbXBvcnQgUmVmcyBmcm9tICdvYmplY3QtcmVmcyc7XG5cbnZhciBwYXJlbnRSZWZzID0gbmV3IFJlZnMoeyBuYW1lOiAnY2hpbGRyZW4nLCBlbnVtZXJhYmxlOiB0cnVlLCBjb2xsZWN0aW9uOiB0cnVlIH0sIHsgbmFtZTogJ3BhcmVudCcgfSksXG4gICAgbGFiZWxSZWZzID0gbmV3IFJlZnMoeyBuYW1lOiAnbGFiZWxzJywgZW51bWVyYWJsZTogdHJ1ZSwgY29sbGVjdGlvbjogdHJ1ZSB9LCB7IG5hbWU6ICdsYWJlbFRhcmdldCcgfSksXG4gICAgYXR0YWNoZXJSZWZzID0gbmV3IFJlZnMoeyBuYW1lOiAnYXR0YWNoZXJzJywgY29sbGVjdGlvbjogdHJ1ZSB9LCB7IG5hbWU6ICdob3N0JyB9KSxcbiAgICBvdXRnb2luZ1JlZnMgPSBuZXcgUmVmcyh7IG5hbWU6ICdvdXRnb2luZycsIGNvbGxlY3Rpb246IHRydWUgfSwgeyBuYW1lOiAnc291cmNlJyB9KSxcbiAgICBpbmNvbWluZ1JlZnMgPSBuZXcgUmVmcyh7IG5hbWU6ICdpbmNvbWluZycsIGNvbGxlY3Rpb246IHRydWUgfSwgeyBuYW1lOiAndGFyZ2V0JyB9KTtcblxuLyoqXG4gKiBAbmFtZXNwYWNlIGRqcy5tb2RlbFxuICovXG5cbi8qKlxuICogQG1lbWJlck9mIGRqcy5tb2RlbFxuICovXG5cbi8qKlxuICogVGhlIGJhc2ljIGdyYXBoaWNhbCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBjbGFzc1xuICpcbiAqIEBhYnN0cmFjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gQmFzZSgpIHtcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0aGF0IGJhY2tzIHVwIHRoZSBzaGFwZVxuICAgKlxuICAgKiBAbmFtZSBCYXNlI2J1c2luZXNzT2JqZWN0XG4gICAqIEB0eXBlIE9iamVjdFxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdidXNpbmVzc09iamVjdCcsIHtcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KTtcblxuXG4gIC8qKlxuICAgKiBTaW5nbGUgbGFiZWwgc3VwcG9ydCwgd2lsbCBtYXBwZWQgdG8gbXVsdGkgbGFiZWwgYXJyYXlcbiAgICpcbiAgICogQG5hbWUgQmFzZSNsYWJlbFxuICAgKiBAdHlwZSBPYmplY3RcbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbGFiZWwnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhYmVsc1swXTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24obmV3TGFiZWwpIHtcblxuICAgICAgdmFyIGxhYmVsID0gdGhpcy5sYWJlbCxcbiAgICAgICAgICBsYWJlbHMgPSB0aGlzLmxhYmVscztcblxuICAgICAgaWYgKCFuZXdMYWJlbCAmJiBsYWJlbCkge1xuICAgICAgICBsYWJlbHMucmVtb3ZlKGxhYmVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhYmVscy5hZGQobmV3TGFiZWwsIDApO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoZSBwYXJlbnQgc2hhcGVcbiAgICpcbiAgICogQG5hbWUgQmFzZSNwYXJlbnRcbiAgICogQHR5cGUgU2hhcGVcbiAgICovXG4gIHBhcmVudFJlZnMuYmluZCh0aGlzLCAncGFyZW50Jyk7XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIGxhYmVsc1xuICAgKlxuICAgKiBAbmFtZSBCYXNlI2xhYmVsc1xuICAgKiBAdHlwZSBMYWJlbFxuICAgKi9cbiAgbGFiZWxSZWZzLmJpbmQodGhpcywgJ2xhYmVscycpO1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBvdXRnb2luZyBjb25uZWN0aW9uc1xuICAgKlxuICAgKiBAbmFtZSBCYXNlI291dGdvaW5nXG4gICAqIEB0eXBlIEFycmF5PENvbm5lY3Rpb24+XG4gICAqL1xuICBvdXRnb2luZ1JlZnMuYmluZCh0aGlzLCAnb3V0Z29pbmcnKTtcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2YgaW5jb21pbmcgY29ubmVjdGlvbnNcbiAgICpcbiAgICogQG5hbWUgQmFzZSNpbmNvbWluZ1xuICAgKiBAdHlwZSBBcnJheTxDb25uZWN0aW9uPlxuICAgKi9cbiAgaW5jb21pbmdSZWZzLmJpbmQodGhpcywgJ2luY29taW5nJyk7XG59XG5cblxuLyoqXG4gKiBBIGdyYXBoaWNhbCBvYmplY3RcbiAqXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBleHRlbmRzIEJhc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNoYXBlKCkge1xuICBCYXNlLmNhbGwodGhpcyk7XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBmcmFtZSBzaGFwZXNcbiAgICpcbiAgICogQG5hbWUgU2hhcGUjaXNGcmFtZVxuICAgKiBAdHlwZSBCb29sZWFuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBjaGlsZHJlblxuICAgKlxuICAgKiBAbmFtZSBTaGFwZSNjaGlsZHJlblxuICAgKiBAdHlwZSBBcnJheTxCYXNlPlxuICAgKi9cbiAgcGFyZW50UmVmcy5iaW5kKHRoaXMsICdjaGlsZHJlbicpO1xuXG4gIC8qKlxuICAgKiBAbmFtZSBTaGFwZSNob3N0XG4gICAqIEB0eXBlIFNoYXBlXG4gICAqL1xuICBhdHRhY2hlclJlZnMuYmluZCh0aGlzLCAnaG9zdCcpO1xuXG4gIC8qKlxuICAgKiBAbmFtZSBTaGFwZSNhdHRhY2hlcnNcbiAgICogQHR5cGUgU2hhcGVcbiAgICovXG4gIGF0dGFjaGVyUmVmcy5iaW5kKHRoaXMsICdhdHRhY2hlcnMnKTtcbn1cblxuaW5oZXJpdHMoU2hhcGUsIEJhc2UpO1xuXG5cbi8qKlxuICogQSByb290IGdyYXBoaWNhbCBvYmplY3RcbiAqXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBleHRlbmRzIFNoYXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSb290KCkge1xuICBTaGFwZS5jYWxsKHRoaXMpO1xufVxuXG5pbmhlcml0cyhSb290LCBTaGFwZSk7XG5cblxuLyoqXG4gKiBBIGxhYmVsIGZvciBhbiBlbGVtZW50XG4gKlxuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAZXh0ZW5kcyBTaGFwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gTGFiZWwoKSB7XG4gIFNoYXBlLmNhbGwodGhpcyk7XG5cbiAgLyoqXG4gICAqIFRoZSBsYWJlbGVkIGVsZW1lbnRcbiAgICpcbiAgICogQG5hbWUgTGFiZWwjbGFiZWxUYXJnZXRcbiAgICogQHR5cGUgQmFzZVxuICAgKi9cbiAgbGFiZWxSZWZzLmJpbmQodGhpcywgJ2xhYmVsVGFyZ2V0Jyk7XG59XG5cbmluaGVyaXRzKExhYmVsLCBTaGFwZSk7XG5cblxuLyoqXG4gKiBBIGNvbm5lY3Rpb24gYmV0d2VlbiB0d28gZWxlbWVudHNcbiAqXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBleHRlbmRzIEJhc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIENvbm5lY3Rpb24oKSB7XG4gIEJhc2UuY2FsbCh0aGlzKTtcblxuICAvKipcbiAgICogVGhlIGVsZW1lbnQgdGhpcyBjb25uZWN0aW9uIG9yaWdpbmF0ZXMgZnJvbVxuICAgKlxuICAgKiBAbmFtZSBDb25uZWN0aW9uI3NvdXJjZVxuICAgKiBAdHlwZSBCYXNlXG4gICAqL1xuICBvdXRnb2luZ1JlZnMuYmluZCh0aGlzLCAnc291cmNlJyk7XG5cbiAgLyoqXG4gICAqIFRoZSBlbGVtZW50IHRoaXMgY29ubmVjdGlvbiBwb2ludHMgdG9cbiAgICpcbiAgICogQG5hbWUgQ29ubmVjdGlvbiN0YXJnZXRcbiAgICogQHR5cGUgQmFzZVxuICAgKi9cbiAgaW5jb21pbmdSZWZzLmJpbmQodGhpcywgJ3RhcmdldCcpO1xufVxuXG5pbmhlcml0cyhDb25uZWN0aW9uLCBCYXNlKTtcblxuXG52YXIgdHlwZXMgPSB7XG4gIGNvbm5lY3Rpb246IENvbm5lY3Rpb24sXG4gIHNoYXBlOiBTaGFwZSxcbiAgbGFiZWw6IExhYmVsLFxuICByb290OiBSb290XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbW9kZWwgZWxlbWVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGVcbiAqXG4gKiBAbWV0aG9kIGNyZWF0ZVxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHNoYXBlMSA9IE1vZGVsLmNyZWF0ZSgnc2hhcGUnLCB7IHg6IDEwLCB5OiAxMCwgd2lkdGg6IDEwMCwgaGVpZ2h0OiAxMDAgfSk7XG4gKiB2YXIgc2hhcGUyID0gTW9kZWwuY3JlYXRlKCdzaGFwZScsIHsgeDogMjEwLCB5OiAyMTAsIHdpZHRoOiAxMDAsIGhlaWdodDogMTAwIH0pO1xuICpcbiAqIHZhciBjb25uZWN0aW9uID0gTW9kZWwuY3JlYXRlKCdjb25uZWN0aW9uJywgeyB3YXlwb2ludHM6IFsgeyB4OiAxMTAsIHk6IDU1IH0sIHt4OiAyMTAsIHk6IDU1IH0gXSB9KTtcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGUgbG93ZXItY2FzZWQgbW9kZWwgbmFtZVxuICogQHBhcmFtICB7T2JqZWN0fSBhdHRycyBhdHRyaWJ1dGVzIHRvIGluaXRpYWxpemUgdGhlIG5ldyBtb2RlbCBpbnN0YW5jZSB3aXRoXG4gKlxuICogQHJldHVybiB7QmFzZX0gdGhlIG5ldyBtb2RlbCBpbnN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKHR5cGUsIGF0dHJzKSB7XG4gIHZhciBUeXBlID0gdHlwZXNbdHlwZV07XG4gIGlmICghVHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biB0eXBlOiA8JyArIHR5cGUgKyAnPicpO1xuICB9XG4gIHJldHVybiBhc3NpZ24obmV3IFR5cGUoKSwgYXR0cnMpO1xufSIsIi8qKlxuICogRmFpbHNhZmUgcmVtb3ZlIGFuIGVsZW1lbnQgZnJvbSBhIGNvbGxlY3Rpb25cbiAqXG4gKiBAcGFyYW0gIHtBcnJheTxPYmplY3Q+fSBbY29sbGVjdGlvbl1cbiAqIEBwYXJhbSAge09iamVjdH0gW2VsZW1lbnRdXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgcHJldmlvdXMgaW5kZXggb2YgdGhlIGVsZW1lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZShjb2xsZWN0aW9uLCBlbGVtZW50KSB7XG5cbiAgaWYgKCFjb2xsZWN0aW9uIHx8ICFlbGVtZW50KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgdmFyIGlkeCA9IGNvbGxlY3Rpb24uaW5kZXhPZihlbGVtZW50KTtcblxuICBpZiAoaWR4ICE9PSAtMSkge1xuICAgIGNvbGxlY3Rpb24uc3BsaWNlKGlkeCwgMSk7XG4gIH1cblxuICByZXR1cm4gaWR4O1xufVxuXG4vKipcbiAqIEZhaWwgc2F2ZSBhZGQgYW4gZWxlbWVudCB0byB0aGUgZ2l2ZW4gY29ubmVjdGlvbiwgZW5zdXJpbmdcbiAqIGl0IGRvZXMgbm90IHlldCBleGlzdC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IGNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50XG4gKiBAcGFyYW0ge051bWJlcn0gaWR4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQoY29sbGVjdGlvbiwgZWxlbWVudCwgaWR4KSB7XG5cbiAgaWYgKCFjb2xsZWN0aW9uIHx8ICFlbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpZHggIT09ICdudW1iZXInKSB7XG4gICAgaWR4ID0gLTE7XG4gIH1cblxuICB2YXIgY3VycmVudElkeCA9IGNvbGxlY3Rpb24uaW5kZXhPZihlbGVtZW50KTtcblxuICBpZiAoY3VycmVudElkeCAhPT0gLTEpIHtcblxuICAgIGlmIChjdXJyZW50SWR4ID09PSBpZHgpIHtcblxuICAgICAgLy8gbm90aGluZyB0byBkbywgcG9zaXRpb24gaGFzIG5vdCBjaGFuZ2VkXG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcblxuICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcblxuICAgICAgICAvLyByZW1vdmUgZnJvbSBjdXJyZW50IHBvc2l0aW9uXG4gICAgICAgIGNvbGxlY3Rpb24uc3BsaWNlKGN1cnJlbnRJZHgsIDEpO1xuICAgICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBhbHJlYWR5IGV4aXN0cyBpbiBjb2xsZWN0aW9uXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaWR4ICE9PSAtMSkge1xuXG4gICAgLy8gaW5zZXJ0IGF0IHNwZWNpZmllZCBwb3NpdGlvblxuICAgIGNvbGxlY3Rpb24uc3BsaWNlKGlkeCwgMCwgZWxlbWVudCk7XG4gIH0gZWxzZSB7XG5cbiAgICAvLyBwdXNoIHRvIGVuZFxuICAgIGNvbGxlY3Rpb24ucHVzaChlbGVtZW50KTtcbiAgfVxufVxuXG5cbi8qKlxuICogRmFpbCBzYXZlIGdldCB0aGUgaW5kZXggb2YgYW4gZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24uXG4gKlxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudFxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gdGhlIGluZGV4IG9yIC0xIGlmIGNvbGxlY3Rpb24gb3IgZWxlbWVudCBkb1xuICogICAgICAgICAgICAgICAgICBub3QgZXhpc3Qgb3IgdGhlIGVsZW1lbnQgaXMgbm90IGNvbnRhaW5lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluZGV4T2YoY29sbGVjdGlvbiwgZWxlbWVudCkge1xuXG4gIGlmICghY29sbGVjdGlvbiB8fCAhZWxlbWVudCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHJldHVybiBjb2xsZWN0aW9uLmluZGV4T2YoZWxlbWVudCk7XG59XG4iLCJpbXBvcnQge1xuICBhc3NpZ24sXG4gIGZpbHRlcixcbiAgZmluZCxcbiAgaXNBcnJheSxcbiAgaXNOdW1iZXIsXG4gIGlzT2JqZWN0LFxuICBpc1VuZGVmaW5lZCxcbiAgZ3JvdXBCeSxcbiAgZm9yRWFjaFxufSBmcm9tICdtaW4tZGFzaCc7XG5cblxuLyoqXG4gKiBHZXQgcGFyZW50IGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8ZGpzLm1vZGVsLmJhc2U+fSBlbGVtZW50c1xuICpcbiAqIEByZXR1cm5zIHtBcnJheTxkanMubW9kZWwuQmFzZT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJlbnRzKGVsZW1lbnRzKSB7XG5cbiAgLy8gZmluZCBlbGVtZW50cyB0aGF0IGFyZSBub3QgY2hpbGRyZW4gb2YgYW55IG90aGVyIGVsZW1lbnRzXG4gIHJldHVybiBmaWx0ZXIoZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gIWZpbmQoZWxlbWVudHMsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHJldHVybiBlICE9PSBlbGVtZW50ICYmIGdldFBhcmVudChlbGVtZW50LCBlKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cblxuZnVuY3Rpb24gZ2V0UGFyZW50KGVsZW1lbnQsIHBhcmVudCkge1xuICBpZiAoIXBhcmVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChlbGVtZW50ID09PSBwYXJlbnQpIHtcbiAgICByZXR1cm4gcGFyZW50O1xuICB9XG5cbiAgaWYgKCFlbGVtZW50LnBhcmVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBnZXRQYXJlbnQoZWxlbWVudC5wYXJlbnQsIHBhcmVudCk7XG59XG5cblxuLyoqXG4gKiBBZGRzIGFuIGVsZW1lbnQgdG8gYSBjb2xsZWN0aW9uIGFuZCByZXR1cm5zIHRydWUgaWYgdGhlXG4gKiBlbGVtZW50IHdhcyBhZGRlZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IGVsZW1lbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gZVxuICogQHBhcmFtIHtCb29sZWFufSB1bmlxdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZChlbGVtZW50cywgZSwgdW5pcXVlKSB7XG4gIHZhciBjYW5BZGQgPSAhdW5pcXVlIHx8IGVsZW1lbnRzLmluZGV4T2YoZSkgPT09IC0xO1xuXG4gIGlmIChjYW5BZGQpIHtcbiAgICBlbGVtZW50cy5wdXNoKGUpO1xuICB9XG5cbiAgcmV0dXJuIGNhbkFkZDtcbn1cblxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uLCBjYWxsaW5nIHRoZSBpdGVyYXRvciBmdW5jdGlvbiBgZm5gXG4gKiB3aXRoIChlbGVtZW50LCBpbmRleCwgcmVjdXJzaW9uRGVwdGgpLlxuICpcbiAqIFJlY3Vyc2UgaW50byBhbGwgZWxlbWVudHMgdGhhdCBhcmUgcmV0dXJuZWQgYnkgYGZuYC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R8QXJyYXk8T2JqZWN0Pn0gZWxlbWVudHNcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiBpdGVyYXRvciBmdW5jdGlvbiBjYWxsZWQgd2l0aCAoZWxlbWVudCwgaW5kZXgsIHJlY3Vyc2lvbkRlcHRoKVxuICogQHBhcmFtICB7TnVtYmVyfSBbZGVwdGhdIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlYWNoRWxlbWVudChlbGVtZW50cywgZm4sIGRlcHRoKSB7XG5cbiAgZGVwdGggPSBkZXB0aCB8fCAwO1xuXG4gIGlmICghaXNBcnJheShlbGVtZW50cykpIHtcbiAgICBlbGVtZW50cyA9IFsgZWxlbWVudHMgXTtcbiAgfVxuXG4gIGZvckVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKHMsIGkpIHtcbiAgICB2YXIgZmlsdGVyID0gZm4ocywgaSwgZGVwdGgpO1xuXG4gICAgaWYgKGlzQXJyYXkoZmlsdGVyKSAmJiBmaWx0ZXIubGVuZ3RoKSB7XG4gICAgICBlYWNoRWxlbWVudChmaWx0ZXIsIGZuLCBkZXB0aCArIDEpO1xuICAgIH1cbiAgfSk7XG59XG5cblxuLyoqXG4gKiBDb2xsZWN0cyBzZWxmICsgY2hpbGQgZWxlbWVudHMgdXAgdG8gYSBnaXZlbiBkZXB0aCBmcm9tIGEgbGlzdCBvZiBlbGVtZW50cy5cbiAqXG4gKiBAcGFyYW0gIHtkanMubW9kZWwuQmFzZXxBcnJheTxkanMubW9kZWwuQmFzZT59IGVsZW1lbnRzIHRoZSBlbGVtZW50cyB0byBzZWxlY3QgdGhlIGNoaWxkcmVuIGZyb21cbiAqIEBwYXJhbSAge0Jvb2xlYW59IHVuaXF1ZSB3aGV0aGVyIHRvIHJldHVybiBhIHVuaXF1ZSByZXN1bHQgc2V0IChubyBkdXBsaWNhdGVzKVxuICogQHBhcmFtICB7TnVtYmVyfSBtYXhEZXB0aCB0aGUgZGVwdGggdG8gc2VhcmNoIHRocm91Z2ggb3IgLTEgZm9yIGluZmluaXRlXG4gKlxuICogQHJldHVybiB7QXJyYXk8ZGpzLm1vZGVsLkJhc2U+fSBmb3VuZCBlbGVtZW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2VsZkFuZENoaWxkcmVuKGVsZW1lbnRzLCB1bmlxdWUsIG1heERlcHRoKSB7XG4gIHZhciByZXN1bHQgPSBbXSxcbiAgICAgIHByb2Nlc3NlZENoaWxkcmVuID0gW107XG5cbiAgZWFjaEVsZW1lbnQoZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQsIGksIGRlcHRoKSB7XG4gICAgYWRkKHJlc3VsdCwgZWxlbWVudCwgdW5pcXVlKTtcblxuICAgIHZhciBjaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW47XG5cbiAgICAvLyBtYXggdHJhdmVyc2FsIGRlcHRoIG5vdCByZWFjaGVkIHlldFxuICAgIGlmIChtYXhEZXB0aCA9PT0gLTEgfHwgZGVwdGggPCBtYXhEZXB0aCkge1xuXG4gICAgICAvLyBjaGlsZHJlbiBleGlzdCAmJiBjaGlsZHJlbiBub3QgeWV0IHByb2Nlc3NlZFxuICAgICAgaWYgKGNoaWxkcmVuICYmIGFkZChwcm9jZXNzZWRDaGlsZHJlbiwgY2hpbGRyZW4sIHVuaXF1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gc2VsZiArIGRpcmVjdCBjaGlsZHJlbiBmb3IgYSBudW1iZXIgb2YgZWxlbWVudHNcbiAqXG4gKiBAcGFyYW0gIHtBcnJheTxkanMubW9kZWwuQmFzZT59IGVsZW1lbnRzIHRvIHF1ZXJ5XG4gKiBAcGFyYW0gIHtCb29sZWFufSBhbGxvd0R1cGxpY2F0ZXMgdG8gYWxsb3cgZHVwbGljYXRlcyBpbiB0aGUgcmVzdWx0IHNldFxuICpcbiAqIEByZXR1cm4ge0FycmF5PGRqcy5tb2RlbC5CYXNlPn0gdGhlIGNvbGxlY3RlZCBlbGVtZW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2VsZkFuZERpcmVjdENoaWxkcmVuKGVsZW1lbnRzLCBhbGxvd0R1cGxpY2F0ZXMpIHtcbiAgcmV0dXJuIHNlbGZBbmRDaGlsZHJlbihlbGVtZW50cywgIWFsbG93RHVwbGljYXRlcywgMSk7XG59XG5cblxuLyoqXG4gKiBSZXR1cm4gc2VsZiArIEFMTCBjaGlsZHJlbiBmb3IgYSBudW1iZXIgb2YgZWxlbWVudHNcbiAqXG4gKiBAcGFyYW0gIHtBcnJheTxkanMubW9kZWwuQmFzZT59IGVsZW1lbnRzIHRvIHF1ZXJ5XG4gKiBAcGFyYW0gIHtCb29sZWFufSBhbGxvd0R1cGxpY2F0ZXMgdG8gYWxsb3cgZHVwbGljYXRlcyBpbiB0aGUgcmVzdWx0IHNldFxuICpcbiAqIEByZXR1cm4ge0FycmF5PGRqcy5tb2RlbC5CYXNlPn0gdGhlIGNvbGxlY3RlZCBlbGVtZW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2VsZkFuZEFsbENoaWxkcmVuKGVsZW1lbnRzLCBhbGxvd0R1cGxpY2F0ZXMpIHtcbiAgcmV0dXJuIHNlbGZBbmRDaGlsZHJlbihlbGVtZW50cywgIWFsbG93RHVwbGljYXRlcywgLTEpO1xufVxuXG5cbi8qKlxuICogR2V0cyB0aGUgdGhlIGNsb3N1cmUgZm9yIGFsbCBzZWxlY3RlZCBlbGVtZW50cyxcbiAqIHRoZWlyIGVuY2xvc2VkIGNoaWxkcmVuIGFuZCBjb25uZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PGRqcy5tb2RlbC5CYXNlPn0gZWxlbWVudHNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzVG9wTGV2ZWw9dHJ1ZV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbZXhpc3RpbmdDbG9zdXJlXVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gbmV3Q2xvc3VyZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xvc3VyZShlbGVtZW50cywgaXNUb3BMZXZlbCwgY2xvc3VyZSkge1xuXG4gIGlmIChpc1VuZGVmaW5lZChpc1RvcExldmVsKSkge1xuICAgIGlzVG9wTGV2ZWwgPSB0cnVlO1xuICB9XG5cbiAgaWYgKGlzT2JqZWN0KGlzVG9wTGV2ZWwpKSB7XG4gICAgY2xvc3VyZSA9IGlzVG9wTGV2ZWw7XG4gICAgaXNUb3BMZXZlbCA9IHRydWU7XG4gIH1cblxuXG4gIGNsb3N1cmUgPSBjbG9zdXJlIHx8IHt9O1xuXG4gIHZhciBhbGxTaGFwZXMgPSBjb3B5T2JqZWN0KGNsb3N1cmUuYWxsU2hhcGVzKSxcbiAgICAgIGFsbENvbm5lY3Rpb25zID0gY29weU9iamVjdChjbG9zdXJlLmFsbENvbm5lY3Rpb25zKSxcbiAgICAgIGVuY2xvc2VkRWxlbWVudHMgPSBjb3B5T2JqZWN0KGNsb3N1cmUuZW5jbG9zZWRFbGVtZW50cyksXG4gICAgICBlbmNsb3NlZENvbm5lY3Rpb25zID0gY29weU9iamVjdChjbG9zdXJlLmVuY2xvc2VkQ29ubmVjdGlvbnMpO1xuXG4gIHZhciB0b3BMZXZlbCA9IGNvcHlPYmplY3QoXG4gICAgY2xvc3VyZS50b3BMZXZlbCxcbiAgICBpc1RvcExldmVsICYmIGdyb3VwQnkoZWxlbWVudHMsIGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUuaWQ7IH0pXG4gICk7XG5cblxuICBmdW5jdGlvbiBoYW5kbGVDb25uZWN0aW9uKGMpIHtcbiAgICBpZiAodG9wTGV2ZWxbYy5zb3VyY2UuaWRdICYmIHRvcExldmVsW2MudGFyZ2V0LmlkXSkge1xuICAgICAgdG9wTGV2ZWxbYy5pZF0gPSBbIGMgXTtcbiAgICB9XG5cbiAgICAvLyBub3QgZW5jbG9zZWQgYXMgYSBjaGlsZCwgYnV0IG1heWJlIGxvZ2ljYWxseVxuICAgIC8vIChjb25uZWN0aW5nIHR3byBtb3ZlZCBlbGVtZW50cz8pXG4gICAgaWYgKGFsbFNoYXBlc1tjLnNvdXJjZS5pZF0gJiYgYWxsU2hhcGVzW2MudGFyZ2V0LmlkXSkge1xuICAgICAgZW5jbG9zZWRDb25uZWN0aW9uc1tjLmlkXSA9IGVuY2xvc2VkRWxlbWVudHNbYy5pZF0gPSBjO1xuICAgIH1cblxuICAgIGFsbENvbm5lY3Rpb25zW2MuaWRdID0gYztcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUVsZW1lbnQoZWxlbWVudCkge1xuXG4gICAgZW5jbG9zZWRFbGVtZW50c1tlbGVtZW50LmlkXSA9IGVsZW1lbnQ7XG5cbiAgICBpZiAoZWxlbWVudC53YXlwb2ludHMpIHtcblxuICAgICAgLy8gcmVtZW1iZXIgY29ubmVjdGlvblxuICAgICAgZW5jbG9zZWRDb25uZWN0aW9uc1tlbGVtZW50LmlkXSA9IGFsbENvbm5lY3Rpb25zW2VsZW1lbnQuaWRdID0gZWxlbWVudDtcbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyByZW1lbWJlciBzaGFwZVxuICAgICAgYWxsU2hhcGVzW2VsZW1lbnQuaWRdID0gZWxlbWVudDtcblxuICAgICAgLy8gcmVtZW1iZXIgYWxsIGNvbm5lY3Rpb25zXG4gICAgICBmb3JFYWNoKGVsZW1lbnQuaW5jb21pbmcsIGhhbmRsZUNvbm5lY3Rpb24pO1xuXG4gICAgICBmb3JFYWNoKGVsZW1lbnQub3V0Z29pbmcsIGhhbmRsZUNvbm5lY3Rpb24pO1xuXG4gICAgICAvLyByZWN1cnNlIGludG8gY2hpbGRyZW5cbiAgICAgIHJldHVybiBlbGVtZW50LmNoaWxkcmVuO1xuICAgIH1cbiAgfVxuXG4gIGVhY2hFbGVtZW50KGVsZW1lbnRzLCBoYW5kbGVFbGVtZW50KTtcblxuICByZXR1cm4ge1xuICAgIGFsbFNoYXBlczogYWxsU2hhcGVzLFxuICAgIGFsbENvbm5lY3Rpb25zOiBhbGxDb25uZWN0aW9ucyxcbiAgICB0b3BMZXZlbDogdG9wTGV2ZWwsXG4gICAgZW5jbG9zZWRDb25uZWN0aW9uczogZW5jbG9zZWRDb25uZWN0aW9ucyxcbiAgICBlbmNsb3NlZEVsZW1lbnRzOiBlbmNsb3NlZEVsZW1lbnRzXG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3Vycm91bmRpbmcgYmJveCBmb3IgYWxsIGVsZW1lbnRzIGluXG4gKiB0aGUgYXJyYXkgb3IgdGhlIGVsZW1lbnQgcHJpbWl0aXZlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8ZGpzLm1vZGVsLlNoYXBlPnxkanMubW9kZWwuU2hhcGV9IGVsZW1lbnRzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHN0b3BSZWN1cnNpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJCb3goZWxlbWVudHMsIHN0b3BSZWN1cnNpb24pIHtcblxuICBzdG9wUmVjdXJzaW9uID0gISFzdG9wUmVjdXJzaW9uO1xuICBpZiAoIWlzQXJyYXkoZWxlbWVudHMpKSB7XG4gICAgZWxlbWVudHMgPSBbZWxlbWVudHNdO1xuICB9XG5cbiAgdmFyIG1pblgsXG4gICAgICBtaW5ZLFxuICAgICAgbWF4WCxcbiAgICAgIG1heFk7XG5cbiAgZm9yRWFjaChlbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xuXG4gICAgLy8gSWYgZWxlbWVudCBpcyBhIGNvbm5lY3Rpb24gdGhlIGJib3ggbXVzdCBiZSBjb21wdXRlZCBmaXJzdFxuICAgIHZhciBiYm94ID0gZWxlbWVudDtcbiAgICBpZiAoZWxlbWVudC53YXlwb2ludHMgJiYgIXN0b3BSZWN1cnNpb24pIHtcbiAgICAgIGJib3ggPSBnZXRCQm94KGVsZW1lbnQud2F5cG9pbnRzLCB0cnVlKTtcbiAgICB9XG5cbiAgICB2YXIgeCA9IGJib3gueCxcbiAgICAgICAgeSA9IGJib3gueSxcbiAgICAgICAgaGVpZ2h0ID0gYmJveC5oZWlnaHQgfHwgMCxcbiAgICAgICAgd2lkdGggPSBiYm94LndpZHRoIHx8IDA7XG5cbiAgICBpZiAoeCA8IG1pblggfHwgbWluWCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBtaW5YID0geDtcbiAgICB9XG4gICAgaWYgKHkgPCBtaW5ZIHx8IG1pblkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbWluWSA9IHk7XG4gICAgfVxuXG4gICAgaWYgKCh4ICsgd2lkdGgpID4gbWF4WCB8fCBtYXhYID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG1heFggPSB4ICsgd2lkdGg7XG4gICAgfVxuICAgIGlmICgoeSArIGhlaWdodCkgPiBtYXhZIHx8IG1heFkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbWF4WSA9IHkgKyBoZWlnaHQ7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHg6IG1pblgsXG4gICAgeTogbWluWSxcbiAgICBoZWlnaHQ6IG1heFkgLSBtaW5ZLFxuICAgIHdpZHRoOiBtYXhYIC0gbWluWFxuICB9O1xufVxuXG5cbi8qKlxuICogUmV0dXJucyBhbGwgZWxlbWVudHMgdGhhdCBhcmUgZW5jbG9zZWQgZnJvbSB0aGUgYm91bmRpbmcgYm94LlxuICpcbiAqICAgKiBJZiBiYm94Lih3aWR0aHxoZWlnaHQpIGlzIG5vdCBzcGVjaWZpZWQgdGhlIG1ldGhvZCByZXR1cm5zXG4gKiAgICAgYWxsIGVsZW1lbnRzIHdpdGggZWxlbWVudC54L3kgPiBiYm94LngveVxuICogICAqIElmIG9ubHkgYmJveC54IG9yIGJib3gueSBpcyBzcGVjaWZpZWQsIG1ldGhvZCByZXR1cm4gYWxsIGVsZW1lbnRzIHdpdGhcbiAqICAgICBlLnggPiBiYm94Lnggb3IgZS55ID4gYmJveC55XG4gKlxuICogQHBhcmFtIHtBcnJheTxkanMubW9kZWwuU2hhcGU+fSBlbGVtZW50cyBMaXN0IG9mIEVsZW1lbnRzIHRvIHNlYXJjaCB0aHJvdWdoXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5TaGFwZX0gYmJveCB0aGUgZW5jbG9zaW5nIGJib3guXG4gKlxuICogQHJldHVybiB7QXJyYXk8ZGpzLm1vZGVsLlNoYXBlPn0gZW5jbG9zZWQgZWxlbWVudHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEVuY2xvc2VkRWxlbWVudHMoZWxlbWVudHMsIGJib3gpIHtcblxuICB2YXIgZmlsdGVyZWRFbGVtZW50cyA9IHt9O1xuXG4gIGZvckVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICAgIHZhciBlID0gZWxlbWVudDtcblxuICAgIGlmIChlLndheXBvaW50cykge1xuICAgICAgZSA9IGdldEJCb3goZSk7XG4gICAgfVxuXG4gICAgaWYgKCFpc051bWJlcihiYm94LnkpICYmIChlLnggPiBiYm94LngpKSB7XG4gICAgICBmaWx0ZXJlZEVsZW1lbnRzW2VsZW1lbnQuaWRdID0gZWxlbWVudDtcbiAgICB9XG4gICAgaWYgKCFpc051bWJlcihiYm94LngpICYmIChlLnkgPiBiYm94LnkpKSB7XG4gICAgICBmaWx0ZXJlZEVsZW1lbnRzW2VsZW1lbnQuaWRdID0gZWxlbWVudDtcbiAgICB9XG4gICAgaWYgKGUueCA+IGJib3gueCAmJiBlLnkgPiBiYm94LnkpIHtcbiAgICAgIGlmIChpc051bWJlcihiYm94LndpZHRoKSAmJiBpc051bWJlcihiYm94LmhlaWdodCkgJiZcbiAgICAgICAgICBlLndpZHRoICsgZS54IDwgYmJveC53aWR0aCArIGJib3gueCAmJlxuICAgICAgICAgIGUuaGVpZ2h0ICsgZS55IDwgYmJveC5oZWlnaHQgKyBiYm94LnkpIHtcblxuICAgICAgICBmaWx0ZXJlZEVsZW1lbnRzW2VsZW1lbnQuaWRdID0gZWxlbWVudDtcbiAgICAgIH0gZWxzZSBpZiAoIWlzTnVtYmVyKGJib3gud2lkdGgpIHx8ICFpc051bWJlcihiYm94LmhlaWdodCkpIHtcbiAgICAgICAgZmlsdGVyZWRFbGVtZW50c1tlbGVtZW50LmlkXSA9IGVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZmlsdGVyZWRFbGVtZW50cztcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHlwZShlbGVtZW50KSB7XG5cbiAgaWYgKCd3YXlwb2ludHMnIGluIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gJ2Nvbm5lY3Rpb24nO1xuICB9XG5cbiAgaWYgKCd4JyBpbiBlbGVtZW50KSB7XG4gICAgcmV0dXJuICdzaGFwZSc7XG4gIH1cblxuICByZXR1cm4gJ3Jvb3QnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNGcmFtZUVsZW1lbnQoZWxlbWVudCkge1xuXG4gIHJldHVybiAhIShlbGVtZW50ICYmIGVsZW1lbnQuaXNGcmFtZSk7XG59XG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNyYzEsIHNyYzIpIHtcbiAgcmV0dXJuIGFzc2lnbih7fSwgc3JjMSB8fCB7fSwgc3JjMiB8fCB7fSk7XG59IiwiZnVuY3Rpb24gX19zdG9wUHJvcGFnYXRpb24oZXZlbnQpIHtcbiAgaWYgKCFldmVudCB8fCB0eXBlb2YgZXZlbnQuc3RvcFByb3BhZ2F0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE9yaWdpbmFsKGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5vcmlnaW5hbEV2ZW50IHx8IGV2ZW50LnNyY0V2ZW50O1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZXZlbnQsIGltbWVkaWF0ZSkge1xuICBfX3N0b3BQcm9wYWdhdGlvbihldmVudCwgaW1tZWRpYXRlKTtcbiAgX19zdG9wUHJvcGFnYXRpb24oZ2V0T3JpZ2luYWwoZXZlbnQpLCBpbW1lZGlhdGUpO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiB0b1BvaW50KGV2ZW50KSB7XG5cbiAgaWYgKGV2ZW50LnBvaW50ZXJzICYmIGV2ZW50LnBvaW50ZXJzLmxlbmd0aCkge1xuICAgIGV2ZW50ID0gZXZlbnQucG9pbnRlcnNbMF07XG4gIH1cblxuICBpZiAoZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCkge1xuICAgIGV2ZW50ID0gZXZlbnQudG91Y2hlc1swXTtcbiAgfVxuXG4gIHJldHVybiBldmVudCA/IHtcbiAgICB4OiBldmVudC5jbGllbnRYLFxuICAgIHk6IGV2ZW50LmNsaWVudFlcbiAgfSA6IG51bGw7XG59IiwiaW1wb3J0IHtcbiAgZXZlcnksXG4gIGlzQXJyYXlcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqXG4gKiBAcGFyYW0gIHtQb2ludH0gIHBcbiAqIEBwYXJhbSAge1BvaW50fSAgcVxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gIGRpc3RhbmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb2ludERpc3RhbmNlKGEsIGIpIHtcbiAgaWYgKCFhIHx8ICFiKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgcmV0dXJuIE1hdGguc3FydChcbiAgICBNYXRoLnBvdyhhLnggLSBiLngsIDIpICtcbiAgICBNYXRoLnBvdyhhLnkgLSBiLnksIDIpXG4gICk7XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBvaW50IHIgaXMgb24gdGhlIGxpbmUgYmV0d2VlbiBwIGFuZCBxXG4gKlxuICogQHBhcmFtICB7UG9pbnR9ICBwXG4gKiBAcGFyYW0gIHtQb2ludH0gIHFcbiAqIEBwYXJhbSAge1BvaW50fSAgclxuICogQHBhcmFtICB7TnVtYmVyfSBbYWNjdXJhY3k9NV0gYWNjdXJhY3kgZm9yIHBvaW50cyBvbiBsaW5lIGNoZWNrIChsb3dlciBpcyBiZXR0ZXIpXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvaW50c09uTGluZShwLCBxLCByLCBhY2N1cmFjeSkge1xuXG4gIGlmICh0eXBlb2YgYWNjdXJhY3kgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgYWNjdXJhY3kgPSA1O1xuICB9XG5cbiAgaWYgKCFwIHx8ICFxIHx8ICFyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHZhbCA9IChxLnggLSBwLngpICogKHIueSAtIHAueSkgLSAocS55IC0gcC55KSAqIChyLnggLSBwLngpLFxuICAgICAgZGlzdCA9IHBvaW50RGlzdGFuY2UocCwgcSk7XG5cbiAgLy8gQHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS85MDc0OTEvNDEyMTkwXG4gIHJldHVybiBNYXRoLmFicyh2YWwgLyBkaXN0KSA8PSBhY2N1cmFjeTtcbn1cblxuXG52YXIgQUxJR05FRF9USFJFU0hPTEQgPSAyO1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdHdvIHBvaW50cyBhcmUgaG9yaXpvbnRhbGx5IG9yIHZlcnRpY2FsbHkgYWxpZ25lZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFBvaW50PnxQb2ludH1cbiAqIEBwYXJhbSB7UG9pbnR9XG4gKlxuICogQHJldHVybiB7c3RyaW5nfEJvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb2ludHNBbGlnbmVkKGEsIGIpIHtcbiAgdmFyIHBvaW50cztcblxuICBpZiAoaXNBcnJheShhKSkge1xuICAgIHBvaW50cyA9IGE7XG4gIH0gZWxzZSB7XG4gICAgcG9pbnRzID0gWyBhLCBiIF07XG4gIH1cblxuICBpZiAocG9pbnRzQWxpZ25lZEhvcml6b250YWxseShwb2ludHMpKSB7XG4gICAgcmV0dXJuICdoJztcbiAgfVxuXG4gIGlmIChwb2ludHNBbGlnbmVkVmVydGljYWxseShwb2ludHMpKSB7XG4gICAgcmV0dXJuICd2JztcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50c0FsaWduZWRIb3Jpem9udGFsbHkoYSwgYikge1xuICB2YXIgcG9pbnRzO1xuXG4gIGlmIChpc0FycmF5KGEpKSB7XG4gICAgcG9pbnRzID0gYTtcbiAgfSBlbHNlIHtcbiAgICBwb2ludHMgPSBbIGEsIGIgXTtcbiAgfVxuXG4gIHZhciBmaXJzdFBvaW50ID0gcG9pbnRzLnNsaWNlKCkuc2hpZnQoKTtcblxuICByZXR1cm4gZXZlcnkocG9pbnRzLCBmdW5jdGlvbihwb2ludCkge1xuICAgIHJldHVybiBNYXRoLmFicyhmaXJzdFBvaW50LnkgLSBwb2ludC55KSA8PSBBTElHTkVEX1RIUkVTSE9MRDtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb2ludHNBbGlnbmVkVmVydGljYWxseShhLCBiKSB7XG4gIHZhciBwb2ludHM7XG5cbiAgaWYgKGlzQXJyYXkoYSkpIHtcbiAgICBwb2ludHMgPSBhO1xuICB9IGVsc2Uge1xuICAgIHBvaW50cyA9IFsgYSwgYiBdO1xuICB9XG5cbiAgdmFyIGZpcnN0UG9pbnQgPSBwb2ludHMuc2xpY2UoKS5zaGlmdCgpO1xuXG4gIHJldHVybiBldmVyeShwb2ludHMsIGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKGZpcnN0UG9pbnQueCAtIHBvaW50LngpIDw9IEFMSUdORURfVEhSRVNIT0xEO1xuICB9KTtcbn1cblxuXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwb2ludCBwIGlzIGluc2lkZSB0aGUgcmVjdGFuZ2xlIHJlY3RcbiAqXG4gKiBAcGFyYW0gIHtQb2ludH0gIHBcbiAqIEBwYXJhbSAge1JlY3R9IHJlY3RcbiAqIEBwYXJhbSAge051bWJlcn0gdG9sZXJhbmNlXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvaW50SW5SZWN0KHAsIHJlY3QsIHRvbGVyYW5jZSkge1xuICB0b2xlcmFuY2UgPSB0b2xlcmFuY2UgfHwgMDtcblxuICByZXR1cm4gcC54ID4gcmVjdC54IC0gdG9sZXJhbmNlICYmXG4gICAgICAgICBwLnkgPiByZWN0LnkgLSB0b2xlcmFuY2UgJiZcbiAgICAgICAgIHAueCA8IHJlY3QueCArIHJlY3Qud2lkdGggKyB0b2xlcmFuY2UgJiZcbiAgICAgICAgIHAueSA8IHJlY3QueSArIHJlY3QuaGVpZ2h0ICsgdG9sZXJhbmNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBwb2ludCBpbiB0aGUgbWlkZGxlIG9mIHBvaW50cyBwIGFuZCBxXG4gKlxuICogQHBhcmFtICB7UG9pbnR9ICBwXG4gKiBAcGFyYW0gIHtQb2ludH0gIHFcbiAqXG4gKiBAcmV0dXJuIHtQb2ludH0gbWlkZGxlIHBvaW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNaWRQb2ludChwLCBxKSB7XG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5yb3VuZChwLnggKyAoKHEueCAtIHAueCkgLyAyLjApKSxcbiAgICB5OiBNYXRoLnJvdW5kKHAueSArICgocS55IC0gcC55KSAvIDIuMCkpXG4gIH07XG59XG4iLCIvKipcbiAqIFNWR3MgZm9yIGVsZW1lbnRzIGFyZSBnZW5lcmF0ZWQgYnkgdGhlIHtAbGluayBHcmFwaGljc0ZhY3Rvcnl9LlxuICpcbiAqIFRoaXMgdXRpbGl0eSBnaXZlcyBxdWljayBhY2Nlc3MgdG8gdGhlIGltcG9ydGFudCBzZW1hbnRpY1xuICogcGFydHMgb2YgYW4gZWxlbWVudC5cbiAqL1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHZpc3VhbCBwYXJ0IG9mIGEgZGlhZ3JhbSBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtTbmFwPFNWR0VsZW1lbnQ+fSBnZnhcbiAqXG4gKiBAcmV0dXJuIHtTbmFwPFNWR0VsZW1lbnQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmlzdWFsKGdmeCkge1xuICByZXR1cm4gZ2Z4LmNoaWxkTm9kZXNbMF07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY2hpbGRyZW4gZm9yIGEgZ2l2ZW4gZGlhZ3JhbSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7U25hcDxTVkdFbGVtZW50Pn0gZ2Z4XG4gKiBAcmV0dXJuIHtTbmFwPFNWR0VsZW1lbnQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2hpbGRyZW4oZ2Z4KSB7XG4gIHJldHVybiBnZngucGFyZW50Tm9kZS5jaGlsZE5vZGVzWzFdO1xufSIsIi8qKlxuICogVXRpbCB0aGF0IHByb3ZpZGVzIHVuaXF1ZSBJRHMuXG4gKlxuICogQGNsYXNzIGRqcy51dGlsLklkR2VuZXJhdG9yXG4gKiBAY29uc3RydWN0b3JcbiAqIEBtZW1iZXJPZiBkanMudXRpbFxuICpcbiAqIFRoZSBpZHMgY2FuIGJlIGN1c3RvbWl6ZWQgdmlhIGEgZ2l2ZW4gcHJlZml4IGFuZCBjb250YWluIGEgcmFuZG9tIHZhbHVlIHRvIGF2b2lkIGNvbGxpc2lvbnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeCBhIHByZWZpeCB0byBwcmVwZW5kIHRvIGdlbmVyYXRlZCBpZHMgKGZvciBiZXR0ZXIgcmVhZGFiaWxpdHkpXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIElkR2VuZXJhdG9yKHByZWZpeCkge1xuXG4gIHRoaXMuX2NvdW50ZXIgPSAwO1xuICB0aGlzLl9wcmVmaXggPSAocHJlZml4ID8gcHJlZml4ICsgJy0nIDogJycpICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMDAwMCkgKyAnLSc7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG5leHQgdW5pcXVlIElELlxuICpcbiAqIEBtZXRob2QgZGpzLnV0aWwuSWRHZW5lcmF0b3IjbmV4dFxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBpZFxuICovXG5JZEdlbmVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcHJlZml4ICsgKCsrdGhpcy5fY291bnRlcik7XG59O1xuIiwiaW1wb3J0IHtcbiAgZ2V0T3JpZ2luYWwgYXMgZ2V0T3JpZ2luYWxFdmVudFxufSBmcm9tICcuL0V2ZW50JztcblxuaW1wb3J0IHtcbiAgaXNNYWNcbn0gZnJvbSAnLi9QbGF0Zm9ybSc7XG5cbmV4cG9ydCB7XG4gIGlzTWFjXG59IGZyb20gJy4vUGxhdGZvcm0nO1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBpc1ByaW1hcnlCdXR0b24oZXZlbnQpIHtcblxuICAvLyBidXR0b24gPT09IDAgLT4gbGVmdCDDoWthIHByaW1hcnkgbW91c2UgYnV0dG9uXG4gIHJldHVybiAhKGdldE9yaWdpbmFsRXZlbnQoZXZlbnQpIHx8IGV2ZW50KS5idXR0b247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNQcmltYXJ5TW9kaWZpZXIoZXZlbnQpIHtcbiAgdmFyIG9yaWdpbmFsRXZlbnQgPSBnZXRPcmlnaW5hbEV2ZW50KGV2ZW50KSB8fCBldmVudDtcblxuICBpZiAoIWlzUHJpbWFyeUJ1dHRvbihldmVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBVc2UgYWx0IGFzIHByaW1hcnkgbW9kaWZpZXIga2V5IGZvciBtYWMgT1NcbiAgaWYgKGlzTWFjKCkpIHtcbiAgICByZXR1cm4gb3JpZ2luYWxFdmVudC5tZXRhS2V5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvcmlnaW5hbEV2ZW50LmN0cmxLZXk7XG4gIH1cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gaGFzU2Vjb25kYXJ5TW9kaWZpZXIoZXZlbnQpIHtcbiAgdmFyIG9yaWdpbmFsRXZlbnQgPSBnZXRPcmlnaW5hbEV2ZW50KGV2ZW50KSB8fCBldmVudDtcblxuICByZXR1cm4gaXNQcmltYXJ5QnV0dG9uKGV2ZW50KSAmJiBvcmlnaW5hbEV2ZW50LnNoaWZ0S2V5O1xufSIsImV4cG9ydCBmdW5jdGlvbiBpc01hYygpIHtcbiAgcmV0dXJuICgvbWFjL2kpLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcbn0iLCJpbXBvcnQge1xuICBhdHRyIGFzIHN2Z0F0dHIsXG4gIGNyZWF0ZSBhcyBzdmdDcmVhdGVcbn0gZnJvbSAndGlueS1zdmcnO1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wb25lbnRzVG9QYXRoKGVsZW1lbnRzKSB7XG4gIHJldHVybiBlbGVtZW50cy5qb2luKCcsJykucmVwbGFjZSgvLD8oW0Etel0pLD8vZywgJyQxJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1NWR1BvaW50cyhwb2ludHMpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBwOyAocCA9IHBvaW50c1tpXSk7IGkrKykge1xuICAgIHJlc3VsdCArPSBwLnggKyAnLCcgKyBwLnkgKyAnICc7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTGluZShwb2ludHMsIGF0dHJzKSB7XG5cbiAgdmFyIGxpbmUgPSBzdmdDcmVhdGUoJ3BvbHlsaW5lJyk7XG4gIHN2Z0F0dHIobGluZSwgeyBwb2ludHM6IHRvU1ZHUG9pbnRzKHBvaW50cykgfSk7XG5cbiAgaWYgKGF0dHJzKSB7XG4gICAgc3ZnQXR0cihsaW5lLCBhdHRycyk7XG4gIH1cblxuICByZXR1cm4gbGluZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUxpbmUoZ2Z4LCBwb2ludHMpIHtcbiAgc3ZnQXR0cihnZngsIHsgcG9pbnRzOiB0b1NWR1BvaW50cyhwb2ludHMpIH0pO1xuXG4gIHJldHVybiBnZng7XG59XG4iLCJpbXBvcnQge1xyXG4gIHRyYW5zZm9ybSBhcyBzdmdUcmFuc2Zvcm0sXHJcbiAgY3JlYXRlVHJhbnNmb3JtXHJcbn0gZnJvbSAndGlueS1zdmcnO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0gezxTVkdFbGVtZW50Pn0gZWxlbWVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geFxyXG4gKiBAcGFyYW0ge051bWJlcn0geVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYW5nbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybShnZngsIHgsIHksIGFuZ2xlLCBhbW91bnQpIHtcclxuICB2YXIgdHJhbnNsYXRlID0gY3JlYXRlVHJhbnNmb3JtKCk7XHJcbiAgdHJhbnNsYXRlLnNldFRyYW5zbGF0ZSh4LCB5KTtcclxuXHJcbiAgdmFyIHJvdGF0ZSA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xyXG4gIHJvdGF0ZS5zZXRSb3RhdGUoYW5nbGUgfHwgMCwgMCwgMCk7XHJcblxyXG4gIHZhciBzY2FsZSA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xyXG4gIHNjYWxlLnNldFNjYWxlKGFtb3VudCB8fCAxLCBhbW91bnQgfHwgMSk7XHJcblxyXG4gIHN2Z1RyYW5zZm9ybShnZngsIFsgdHJhbnNsYXRlLCByb3RhdGUsIHNjYWxlIF0pO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geFxyXG4gKiBAcGFyYW0ge051bWJlcn0geVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShnZngsIHgsIHkpIHtcclxuICB2YXIgdHJhbnNsYXRlID0gY3JlYXRlVHJhbnNmb3JtKCk7XHJcbiAgdHJhbnNsYXRlLnNldFRyYW5zbGF0ZSh4LCB5KTtcclxuXHJcbiAgc3ZnVHJhbnNmb3JtKGdmeCwgdHJhbnNsYXRlKTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKGdmeCwgYW5nbGUpIHtcclxuICB2YXIgcm90YXRlID0gY3JlYXRlVHJhbnNmb3JtKCk7XHJcbiAgcm90YXRlLnNldFJvdGF0ZShhbmdsZSwgMCwgMCk7XHJcblxyXG4gIHN2Z1RyYW5zZm9ybShnZngsIHJvdGF0ZSk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShnZngsIGFtb3VudCkge1xyXG4gIHZhciBzY2FsZSA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xyXG4gIHNjYWxlLnNldFNjYWxlKGFtb3VudCwgYW1vdW50KTtcclxuXHJcbiAgc3ZnVHJhbnNmb3JtKGdmeCwgc2NhbGUpO1xyXG59IiwiaW1wb3J0IHtcbiAgaXNPYmplY3QsXG4gIGFzc2lnbixcbiAgZm9yRWFjaCxcbiAgcmVkdWNlXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHtcbiAgYXBwZW5kIGFzIHN2Z0FwcGVuZCxcbiAgYXR0ciBhcyBzdmdBdHRyLFxuICBjcmVhdGUgYXMgc3ZnQ3JlYXRlLFxuICByZW1vdmUgYXMgc3ZnUmVtb3ZlXG59IGZyb20gJ3Rpbnktc3ZnJztcblxudmFyIERFRkFVTFRfQk9YX1BBRERJTkcgPSAwO1xuXG52YXIgREVGQVVMVF9MQUJFTF9TSVpFID0ge1xuICB3aWR0aDogMTUwLFxuICBoZWlnaHQ6IDUwXG59O1xuXG5cbmZ1bmN0aW9uIHBhcnNlQWxpZ24oYWxpZ24pIHtcblxuICB2YXIgcGFydHMgPSBhbGlnbi5zcGxpdCgnLScpO1xuXG4gIHJldHVybiB7XG4gICAgaG9yaXpvbnRhbDogcGFydHNbMF0gfHwgJ2NlbnRlcicsXG4gICAgdmVydGljYWw6IHBhcnRzWzFdIHx8ICd0b3AnXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlUGFkZGluZyhwYWRkaW5nKSB7XG5cbiAgaWYgKGlzT2JqZWN0KHBhZGRpbmcpKSB7XG4gICAgcmV0dXJuIGFzc2lnbih7IHRvcDogMCwgbGVmdDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCB9LCBwYWRkaW5nKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiBwYWRkaW5nLFxuICAgICAgbGVmdDogcGFkZGluZyxcbiAgICAgIHJpZ2h0OiBwYWRkaW5nLFxuICAgICAgYm90dG9tOiBwYWRkaW5nXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUZXh0QkJveCh0ZXh0LCBmYWtlVGV4dCkge1xuXG4gIGZha2VUZXh0LnRleHRDb250ZW50ID0gdGV4dDtcblxuICB2YXIgdGV4dEJCb3g7XG5cbiAgdHJ5IHtcbiAgICB2YXIgYmJveCxcbiAgICAgICAgZW1wdHlMaW5lID0gdGV4dCA9PT0gJyc7XG5cbiAgICAvLyBhZGQgZHVtbXkgdGV4dCwgd2hlbiBsaW5lIGlzIGVtcHR5IHRvXG4gICAgLy8gZGV0ZXJtaW5lIGNvcnJlY3QgaGVpZ2h0XG4gICAgZmFrZVRleHQudGV4dENvbnRlbnQgPSBlbXB0eUxpbmUgPyAnZHVtbXknIDogdGV4dDtcblxuICAgIHRleHRCQm94ID0gZmFrZVRleHQuZ2V0QkJveCgpO1xuXG4gICAgLy8gdGFrZSB0ZXh0IHJlbmRlcmluZyByZWxhdGVkIGhvcml6b250YWxcbiAgICAvLyBwYWRkaW5nIGludG8gYWNjb3VudFxuICAgIGJib3ggPSB7XG4gICAgICB3aWR0aDogdGV4dEJCb3gud2lkdGggKyB0ZXh0QkJveC54ICogMixcbiAgICAgIGhlaWdodDogdGV4dEJCb3guaGVpZ2h0XG4gICAgfTtcblxuICAgIGlmIChlbXB0eUxpbmUpIHtcblxuICAgICAgLy8gY29ycmVjdCB3aWR0aFxuICAgICAgYmJveC53aWR0aCA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJib3g7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gIH1cbn1cblxuXG4vKipcbiAqIExheW91dCB0aGUgbmV4dCBsaW5lIGFuZCByZXR1cm4gdGhlIGxheW91dGVkIGVsZW1lbnQuXG4gKlxuICogQWx0ZXJzIHRoZSBsaW5lcyBwYXNzZWQuXG4gKlxuICogQHBhcmFtICB7QXJyYXk8U3RyaW5nPn0gbGluZXNcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIGxpbmUgZGVzY3JpcHRvciwgYW4gb2JqZWN0IHsgd2lkdGgsIGhlaWdodCwgdGV4dCB9XG4gKi9cbmZ1bmN0aW9uIGxheW91dE5leHQobGluZXMsIG1heFdpZHRoLCBmYWtlVGV4dCkge1xuXG4gIHZhciBvcmlnaW5hbExpbmUgPSBsaW5lcy5zaGlmdCgpLFxuICAgICAgZml0TGluZSA9IG9yaWdpbmFsTGluZTtcblxuICB2YXIgdGV4dEJCb3g7XG5cbiAgZm9yICg7Oykge1xuICAgIHRleHRCQm94ID0gZ2V0VGV4dEJCb3goZml0TGluZSwgZmFrZVRleHQpO1xuXG4gICAgdGV4dEJCb3gud2lkdGggPSBmaXRMaW5lID8gdGV4dEJCb3gud2lkdGggOiAwO1xuXG4gICAgLy8gdHJ5IHRvIGZpdFxuICAgIGlmIChmaXRMaW5lID09PSAnICcgfHwgZml0TGluZSA9PT0gJycgfHwgdGV4dEJCb3gud2lkdGggPCBNYXRoLnJvdW5kKG1heFdpZHRoKSB8fCBmaXRMaW5lLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiBmaXQobGluZXMsIGZpdExpbmUsIG9yaWdpbmFsTGluZSwgdGV4dEJCb3gpO1xuICAgIH1cblxuICAgIGZpdExpbmUgPSBzaG9ydGVuTGluZShmaXRMaW5lLCB0ZXh0QkJveC53aWR0aCwgbWF4V2lkdGgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpdChsaW5lcywgZml0TGluZSwgb3JpZ2luYWxMaW5lLCB0ZXh0QkJveCkge1xuICBpZiAoZml0TGluZS5sZW5ndGggPCBvcmlnaW5hbExpbmUubGVuZ3RoKSB7XG4gICAgdmFyIHJlbWFpbmRlciA9IG9yaWdpbmFsTGluZS5zbGljZShmaXRMaW5lLmxlbmd0aCkudHJpbSgpO1xuXG4gICAgbGluZXMudW5zaGlmdChyZW1haW5kZXIpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogdGV4dEJCb3gud2lkdGgsXG4gICAgaGVpZ2h0OiB0ZXh0QkJveC5oZWlnaHQsXG4gICAgdGV4dDogZml0TGluZVxuICB9O1xufVxuXG5cbi8qKlxuICogU2hvcnRlbnMgYSBsaW5lIGJhc2VkIG9uIHNwYWNpbmcgYW5kIGh5cGhlbnMuXG4gKiBSZXR1cm5zIHRoZSBzaG9ydGVuZWQgcmVzdWx0IG9uIHN1Y2Nlc3MuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBsaW5lXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1heExlbmd0aCB0aGUgbWF4aW11bSBjaGFyYWN0ZXJzIG9mIHRoZSBzdHJpbmdcbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHNob3J0ZW5lZCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gc2VtYW50aWNTaG9ydGVuKGxpbmUsIG1heExlbmd0aCkge1xuICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KC8oXFxzfC0pL2cpLFxuICAgICAgcGFydCxcbiAgICAgIHNob3J0ZW5lZFBhcnRzID0gW10sXG4gICAgICBsZW5ndGggPSAwO1xuXG4gIC8vIHRyeSB0byBzaG9ydGVuIHZpYSBzcGFjZXMgKyBoeXBoZW5zXG4gIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgd2hpbGUgKChwYXJ0ID0gcGFydHMuc2hpZnQoKSkpIHtcbiAgICAgIGlmIChwYXJ0Lmxlbmd0aCArIGxlbmd0aCA8IG1heExlbmd0aCkge1xuICAgICAgICBzaG9ydGVuZWRQYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICBsZW5ndGggKz0gcGFydC5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIHJlbW92ZSBwcmV2aW91cyBwYXJ0LCB0b28gaWYgaHlwaGVuIGRvZXMgbm90IGZpdCBhbnltb3JlXG4gICAgICAgIGlmIChwYXJ0ID09PSAnLScpIHtcbiAgICAgICAgICBzaG9ydGVuZWRQYXJ0cy5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzaG9ydGVuZWRQYXJ0cy5qb2luKCcnKTtcbn1cblxuXG5mdW5jdGlvbiBzaG9ydGVuTGluZShsaW5lLCB3aWR0aCwgbWF4V2lkdGgpIHtcbiAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KGxpbmUubGVuZ3RoICogKG1heFdpZHRoIC8gd2lkdGgpLCAxKTtcblxuICAvLyB0cnkgdG8gc2hvcnRlbiBzZW1hbnRpY2FsbHkgKGkuZS4gYmFzZWQgb24gc3BhY2VzIGFuZCBoeXBoZW5zKVxuICB2YXIgc2hvcnRlbmVkTGluZSA9IHNlbWFudGljU2hvcnRlbihsaW5lLCBsZW5ndGgpO1xuXG4gIGlmICghc2hvcnRlbmVkTGluZSkge1xuXG4gICAgLy8gZm9yY2Ugc2hvcnRlbiBieSBjdXR0aW5nIHRoZSBsb25nIHdvcmRcbiAgICBzaG9ydGVuZWRMaW5lID0gbGluZS5zbGljZSgwLCBNYXRoLm1heChNYXRoLnJvdW5kKGxlbmd0aCAtIDEpLCAxKSk7XG4gIH1cblxuICByZXR1cm4gc2hvcnRlbmVkTGluZTtcbn1cblxuXG5mdW5jdGlvbiBnZXRIZWxwZXJTdmcoKSB7XG4gIHZhciBoZWxwZXJTdmcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaGVscGVyLXN2ZycpO1xuXG4gIGlmICghaGVscGVyU3ZnKSB7XG4gICAgaGVscGVyU3ZnID0gc3ZnQ3JlYXRlKCdzdmcnKTtcblxuICAgIHN2Z0F0dHIoaGVscGVyU3ZnLCB7XG4gICAgICBpZDogJ2hlbHBlci1zdmcnLFxuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgICBzdHlsZTogJ3Zpc2liaWxpdHk6IGhpZGRlbjsgcG9zaXRpb246IGZpeGVkJ1xuICAgIH0pO1xuXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChoZWxwZXJTdmcpO1xuICB9XG5cbiAgcmV0dXJuIGhlbHBlclN2Zztcbn1cblxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbGFiZWwgdXRpbGl0eVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAqIEBwYXJhbSB7RGltZW5zaW9uc30gY29uZmlnLnNpemVcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcucGFkZGluZ1xuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZy5zdHlsZVxuICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5hbGlnblxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBUZXh0KGNvbmZpZykge1xuXG4gIHRoaXMuX2NvbmZpZyA9IGFzc2lnbih7fSwge1xuICAgIHNpemU6IERFRkFVTFRfTEFCRUxfU0laRSxcbiAgICBwYWRkaW5nOiBERUZBVUxUX0JPWF9QQURESU5HLFxuICAgIHN0eWxlOiB7fSxcbiAgICBhbGlnbjogJ2NlbnRlci10b3AnXG4gIH0sIGNvbmZpZyB8fCB7fSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbGF5b3V0ZWQgdGV4dCBhcyBhbiBTVkcgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJuIHtTVkdFbGVtZW50fVxuICovXG5UZXh0LnByb3RvdHlwZS5jcmVhdGVUZXh0ID0gZnVuY3Rpb24odGV4dCwgb3B0aW9ucykge1xuICByZXR1cm4gdGhpcy5sYXlvdXRUZXh0KHRleHQsIG9wdGlvbnMpLmVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBsYWJlbHMgbGF5b3V0ZWQgZGltZW5zaW9ucy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dCB0byBsYXlvdXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKlxuICogQHJldHVybiB7RGltZW5zaW9uc31cbiAqL1xuVGV4dC5wcm90b3R5cGUuZ2V0RGltZW5zaW9ucyA9IGZ1bmN0aW9uKHRleHQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMubGF5b3V0VGV4dCh0ZXh0LCBvcHRpb25zKS5kaW1lbnNpb25zO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgbGFiZWwgYW5kIGl0cyBib3VuZGluZyBib3guXG4gKlxuICogQG1ldGhvZCBUZXh0I2NyZWF0ZVRleHRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dCB0aGUgdGV4dCB0byByZW5kZXIgb24gdGhlIGxhYmVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuYWxpZ24gaG93IHRvIGFsaWduIGluIHRoZSBib3VuZGluZyBib3guXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbnkgb2YgeyAnY2VudGVyLW1pZGRsZScsICdjZW50ZXItdG9wJyB9LFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdHMgdG8gJ2NlbnRlci10b3AnLlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuc3R5bGUgc3R5bGUgdG8gYmUgYXBwbGllZCB0byB0aGUgdGV4dFxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmZpdEJveCBpbmRpY2F0ZXMgaWYgYm94IHdpbGwgYmUgcmVjYWxjdWxhdGVkIHRvXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpdCB0ZXh0XG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB7IGVsZW1lbnQsIGRpbWVuc2lvbnMgfVxuICovXG5UZXh0LnByb3RvdHlwZS5sYXlvdXRUZXh0ID0gZnVuY3Rpb24odGV4dCwgb3B0aW9ucykge1xuICB2YXIgYm94ID0gYXNzaWduKHt9LCB0aGlzLl9jb25maWcuc2l6ZSwgb3B0aW9ucy5ib3gpLFxuICAgICAgc3R5bGUgPSBhc3NpZ24oe30sIHRoaXMuX2NvbmZpZy5zdHlsZSwgb3B0aW9ucy5zdHlsZSksXG4gICAgICBhbGlnbiA9IHBhcnNlQWxpZ24ob3B0aW9ucy5hbGlnbiB8fCB0aGlzLl9jb25maWcuYWxpZ24pLFxuICAgICAgcGFkZGluZyA9IHBhcnNlUGFkZGluZyhvcHRpb25zLnBhZGRpbmcgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucGFkZGluZyA6IHRoaXMuX2NvbmZpZy5wYWRkaW5nKSxcbiAgICAgIGZpdEJveCA9IG9wdGlvbnMuZml0Qm94IHx8IGZhbHNlO1xuXG4gIHZhciBsaW5lSGVpZ2h0ID0gZ2V0TGluZUhlaWdodChzdHlsZSk7XG5cbiAgdmFyIGxpbmVzID0gdGV4dC5zcGxpdCgvXFxyP1xcbi9nKSxcbiAgICAgIGxheW91dGVkID0gW107XG5cbiAgdmFyIG1heFdpZHRoID0gYm94LndpZHRoIC0gcGFkZGluZy5sZWZ0IC0gcGFkZGluZy5yaWdodDtcblxuICAvLyBlbnN1cmUgY29ycmVjdCByZW5kZXJpbmcgYnkgYXR0YWNoaW5nIGhlbHBlciB0ZXh0IG5vZGUgdG8gaW52aXNpYmxlIFNWR1xuICB2YXIgaGVscGVyVGV4dCA9IHN2Z0NyZWF0ZSgndGV4dCcpO1xuICBzdmdBdHRyKGhlbHBlclRleHQsIHsgeDogMCwgeTogMCB9KTtcbiAgc3ZnQXR0cihoZWxwZXJUZXh0LCBzdHlsZSk7XG5cbiAgdmFyIGhlbHBlclN2ZyA9IGdldEhlbHBlclN2ZygpO1xuXG4gIHN2Z0FwcGVuZChoZWxwZXJTdmcsIGhlbHBlclRleHQpO1xuXG4gIHdoaWxlIChsaW5lcy5sZW5ndGgpIHtcbiAgICBsYXlvdXRlZC5wdXNoKGxheW91dE5leHQobGluZXMsIG1heFdpZHRoLCBoZWxwZXJUZXh0KSk7XG4gIH1cblxuICBpZiAoYWxpZ24udmVydGljYWwgPT09ICdtaWRkbGUnKSB7XG4gICAgcGFkZGluZy50b3AgPSBwYWRkaW5nLmJvdHRvbSA9IDA7XG4gIH1cblxuICB2YXIgdG90YWxIZWlnaHQgPSByZWR1Y2UobGF5b3V0ZWQsIGZ1bmN0aW9uKHN1bSwgbGluZSwgaWR4KSB7XG4gICAgcmV0dXJuIHN1bSArIChsaW5lSGVpZ2h0IHx8IGxpbmUuaGVpZ2h0KTtcbiAgfSwgMCkgKyBwYWRkaW5nLnRvcCArIHBhZGRpbmcuYm90dG9tO1xuXG4gIHZhciBtYXhMaW5lV2lkdGggPSByZWR1Y2UobGF5b3V0ZWQsIGZ1bmN0aW9uKHN1bSwgbGluZSwgaWR4KSB7XG4gICAgcmV0dXJuIGxpbmUud2lkdGggPiBzdW0gPyBsaW5lLndpZHRoIDogc3VtO1xuICB9LCAwKTtcblxuICAvLyB0aGUgeSBwb3NpdGlvbiBvZiB0aGUgbmV4dCBsaW5lXG4gIHZhciB5ID0gcGFkZGluZy50b3A7XG5cbiAgaWYgKGFsaWduLnZlcnRpY2FsID09PSAnbWlkZGxlJykge1xuICAgIHkgKz0gKGJveC5oZWlnaHQgLSB0b3RhbEhlaWdodCkgLyAyO1xuICB9XG5cbiAgLy8gbWFnaWMgbnVtYmVyIGluaXRpYWwgb2Zmc2V0XG4gIHkgLT0gKGxpbmVIZWlnaHQgfHwgbGF5b3V0ZWRbMF0uaGVpZ2h0KSAvIDQ7XG5cblxuICB2YXIgdGV4dEVsZW1lbnQgPSBzdmdDcmVhdGUoJ3RleHQnKTtcblxuICBzdmdBdHRyKHRleHRFbGVtZW50LCBzdHlsZSk7XG5cbiAgLy8gbGF5b3V0IGVhY2ggbGluZSB0YWtpbmcgaW50byBhY2NvdW50IHRoYXQgcGFyZW50XG4gIC8vIHNoYXBlIG1pZ2h0IHJlc2l6ZSB0byBmaXQgdGV4dCBzaXplXG4gIGZvckVhY2gobGF5b3V0ZWQsIGZ1bmN0aW9uKGxpbmUpIHtcblxuICAgIHZhciB4O1xuXG4gICAgeSArPSAobGluZUhlaWdodCB8fCBsaW5lLmhlaWdodCk7XG5cbiAgICBzd2l0Y2ggKGFsaWduLmhvcml6b250YWwpIHtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHggPSBwYWRkaW5nLmxlZnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHggPSAoKGZpdEJveCA/IG1heExpbmVXaWR0aCA6IG1heFdpZHRoKVxuICAgICAgICAtIHBhZGRpbmcucmlnaHQgLSBsaW5lLndpZHRoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcblxuICAgICAgLy8gYWthIGNlbnRlclxuICAgICAgeCA9IE1hdGgubWF4KCgoKGZpdEJveCA/IG1heExpbmVXaWR0aCA6IG1heFdpZHRoKVxuICAgICAgICAtIGxpbmUud2lkdGgpIC8gMiArIHBhZGRpbmcubGVmdCksIDApO1xuICAgIH1cblxuICAgIHZhciB0c3BhbiA9IHN2Z0NyZWF0ZSgndHNwYW4nKTtcbiAgICBzdmdBdHRyKHRzcGFuLCB7IHg6IHgsIHk6IHkgfSk7XG5cbiAgICB0c3Bhbi50ZXh0Q29udGVudCA9IGxpbmUudGV4dDtcblxuICAgIHN2Z0FwcGVuZCh0ZXh0RWxlbWVudCwgdHNwYW4pO1xuICB9KTtcblxuICBzdmdSZW1vdmUoaGVscGVyVGV4dCk7XG5cbiAgdmFyIGRpbWVuc2lvbnMgPSB7XG4gICAgd2lkdGg6IG1heExpbmVXaWR0aCxcbiAgICBoZWlnaHQ6IHRvdGFsSGVpZ2h0XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBkaW1lbnNpb25zOiBkaW1lbnNpb25zLFxuICAgIGVsZW1lbnQ6IHRleHRFbGVtZW50XG4gIH07XG59O1xuXG5cbmZ1bmN0aW9uIGdldExpbmVIZWlnaHQoc3R5bGUpIHtcbiAgaWYgKCdmb250U2l6ZScgaW4gc3R5bGUgJiYgJ2xpbmVIZWlnaHQnIGluIHN0eWxlKSB7XG4gICAgcmV0dXJuIHN0eWxlLmxpbmVIZWlnaHQgKiBwYXJzZUludChzdHlsZS5mb250U2l6ZSwgMTApO1xuICB9XG59IiwidmFyIENMQVNTX1BBVFRFUk4gPSAvXmNsYXNzIC87XG5cbmZ1bmN0aW9uIGlzQ2xhc3MoZm4pIHtcbiAgcmV0dXJuIENMQVNTX1BBVFRFUk4udGVzdChmbi50b1N0cmluZygpKTtcbn1cblxuZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG5mdW5jdGlvbiBhbm5vdGF0ZSgpIHtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgYXJncyA9IGFyZ3NbMF07XG4gIH1cblxuICB2YXIgZm4gPSBhcmdzLnBvcCgpO1xuXG4gIGZuLiRpbmplY3QgPSBhcmdzO1xuXG4gIHJldHVybiBmbjtcbn1cblxuLy8gQ3VycmVudCBsaW1pdGF0aW9uczpcbi8vIC0gY2FuJ3QgcHV0IGludG8gXCJmdW5jdGlvbiBhcmdcIiBjb21tZW50c1xuLy8gZnVuY3Rpb24gLyogKG5vIHBhcmVudGhlc2lzIGxpa2UgdGhpcykgKi8gKCl7fVxuLy8gZnVuY3Rpb24gYWJjKCAvKiB4eCAobm8gcGFyZW50aGVzaXMgbGlrZSB0aGlzKSAqLyBhLCBiKSB7fVxuLy9cbi8vIEp1c3QgcHV0IHRoZSBjb21tZW50IGJlZm9yZSBmdW5jdGlvbiBvciBpbnNpZGU6XG4vLyAvKiAoKCh0aGlzIGlzIGZpbmUpKSkgKi8gZnVuY3Rpb24oYSwgYikge31cbi8vIGZ1bmN0aW9uIGFiYyhhKSB7IC8qICgoKHRoaXMgaXMgZmluZSkpKSAqL31cbi8vXG4vLyAtIGNhbid0IHJlbGlhYmx5IGF1dG8tYW5ub3RhdGUgY29uc3RydWN0b3I7IHdlJ2xsIG1hdGNoIHRoZVxuLy8gZmlyc3QgY29uc3RydWN0b3IoLi4uKSBwYXR0ZXJuIGZvdW5kIHdoaWNoIG1heSBiZSB0aGUgb25lXG4vLyBvZiBhIG5lc3RlZCBjbGFzcywgdG9vLlxuXG52YXIgQ09OU1RSVUNUT1JfQVJHUyA9IC9jb25zdHJ1Y3RvclxccypbXihdKlxcKFxccyooW14pXSopXFwpL207XG52YXIgRk5fQVJHUyA9IC9eZnVuY3Rpb25cXHMqW14oXSpcXChcXHMqKFteKV0qKVxcKS9tO1xudmFyIEZOX0FSRyA9IC9cXC9cXCooW14qXSopXFwqXFwvL207XG5cbmZ1bmN0aW9uIHBhcnNlKGZuKSB7XG5cbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFubm90YXRlIFwiJyArIGZuICsgJ1wiLiBFeHBlY3RlZCBhIGZ1bmN0aW9uIScpO1xuICB9XG5cbiAgdmFyIG1hdGNoID0gZm4udG9TdHJpbmcoKS5tYXRjaChpc0NsYXNzKGZuKSA/IENPTlNUUlVDVE9SX0FSR1MgOiBGTl9BUkdTKTtcblxuICAvLyBtYXkgcGFyc2UgY2xhc3Mgd2l0aG91dCBjb25zdHJ1Y3RvclxuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoWzFdICYmIG1hdGNoWzFdLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICBtYXRjaCA9IGFyZy5tYXRjaChGTl9BUkcpO1xuICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdLnRyaW0oKSA6IGFyZy50cmltKCk7XG4gIH0pIHx8IFtdO1xufVxuXG5mdW5jdGlvbiBNb2R1bGUoKSB7XG4gIHZhciBwcm92aWRlcnMgPSBbXTtcblxuICB0aGlzLmZhY3RvcnkgPSBmdW5jdGlvbiAobmFtZSwgZmFjdG9yeSkge1xuICAgIHByb3ZpZGVycy5wdXNoKFtuYW1lLCAnZmFjdG9yeScsIGZhY3RvcnldKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB0aGlzLnZhbHVlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgcHJvdmlkZXJzLnB1c2goW25hbWUsICd2YWx1ZScsIHZhbHVlXSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdGhpcy50eXBlID0gZnVuY3Rpb24gKG5hbWUsIHR5cGUpIHtcbiAgICBwcm92aWRlcnMucHVzaChbbmFtZSwgJ3R5cGUnLCB0eXBlXSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdGhpcy5mb3JFYWNoID0gZnVuY3Rpb24gKGl0ZXJhdG9yKSB7XG4gICAgcHJvdmlkZXJzLmZvckVhY2goaXRlcmF0b3IpO1xuICB9O1xufVxuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXG5mdW5jdGlvbiBJbmplY3Rvcihtb2R1bGVzLCBwYXJlbnQpIHtcbiAgcGFyZW50ID0gcGFyZW50IHx8IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldChuYW1lLCBzdHJpY3QpIHtcbiAgICAgIGN1cnJlbnRseVJlc29sdmluZy5wdXNoKG5hbWUpO1xuXG4gICAgICBpZiAoc3RyaWN0ID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycm9yKCdObyBwcm92aWRlciBmb3IgXCInICsgbmFtZSArICdcIiEnKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGN1cnJlbnRseVJlc29sdmluZyA9IFtdO1xuICB2YXIgcHJvdmlkZXJzID0gdGhpcy5fcHJvdmlkZXJzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQuX3Byb3ZpZGVycyB8fCBudWxsKTtcbiAgdmFyIGluc3RhbmNlcyA9IHRoaXMuX2luc3RhbmNlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgdmFyIHNlbGYgPSBpbnN0YW5jZXMuaW5qZWN0b3IgPSB0aGlzO1xuXG4gIHZhciBlcnJvciA9IGZ1bmN0aW9uIGVycm9yKG1zZykge1xuICAgIHZhciBzdGFjayA9IGN1cnJlbnRseVJlc29sdmluZy5qb2luKCcgLT4gJyk7XG4gICAgY3VycmVudGx5UmVzb2x2aW5nLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihzdGFjayA/IG1zZyArICcgKFJlc29sdmluZzogJyArIHN0YWNrICsgJyknIDogbXNnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIGEgbmFtZWQgc2VydmljZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RyaWN0PXRydWVdIGlmIGZhbHNlLCByZXNvbHZlIG1pc3Npbmcgc2VydmljZXMgdG8gbnVsbFxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICB2YXIgZ2V0ID0gZnVuY3Rpb24gZ2V0KG5hbWUsIHN0cmljdCkge1xuICAgIGlmICghcHJvdmlkZXJzW25hbWVdICYmIG5hbWUuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgdmFyIHBhcnRzID0gbmFtZS5zcGxpdCgnLicpO1xuICAgICAgdmFyIHBpdm90ID0gZ2V0KHBhcnRzLnNoaWZ0KCkpO1xuXG4gICAgICB3aGlsZSAocGFydHMubGVuZ3RoKSB7XG4gICAgICAgIHBpdm90ID0gcGl2b3RbcGFydHMuc2hpZnQoKV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwaXZvdDtcbiAgICB9XG5cbiAgICBpZiAoaGFzUHJvcChpbnN0YW5jZXMsIG5hbWUpKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2VzW25hbWVdO1xuICAgIH1cblxuICAgIGlmIChoYXNQcm9wKHByb3ZpZGVycywgbmFtZSkpIHtcbiAgICAgIGlmIChjdXJyZW50bHlSZXNvbHZpbmcuaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgY3VycmVudGx5UmVzb2x2aW5nLnB1c2gobmFtZSk7XG4gICAgICAgIHRocm93IGVycm9yKCdDYW5ub3QgcmVzb2x2ZSBjaXJjdWxhciBkZXBlbmRlbmN5IScpO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50bHlSZXNvbHZpbmcucHVzaChuYW1lKTtcbiAgICAgIGluc3RhbmNlc1tuYW1lXSA9IHByb3ZpZGVyc1tuYW1lXVswXShwcm92aWRlcnNbbmFtZV1bMV0pO1xuICAgICAgY3VycmVudGx5UmVzb2x2aW5nLnBvcCgpO1xuXG4gICAgICByZXR1cm4gaW5zdGFuY2VzW25hbWVdO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJlbnQuZ2V0KG5hbWUsIHN0cmljdCk7XG4gIH07XG5cbiAgdmFyIGZuRGVmID0gZnVuY3Rpb24gZm5EZWYoZm4pIHtcbiAgICB2YXIgbG9jYWxzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChpc0FycmF5KGZuKSkge1xuICAgICAgICBmbiA9IGFubm90YXRlKGZuLnNsaWNlKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52b2tlIFwiJyArIGZuICsgJ1wiLiBFeHBlY3RlZCBhIGZ1bmN0aW9uIScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpbmplY3QgPSBmbi4kaW5qZWN0IHx8IHBhcnNlKGZuKTtcbiAgICB2YXIgZGVwZW5kZW5jaWVzID0gaW5qZWN0Lm1hcChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICBpZiAoaGFzUHJvcChsb2NhbHMsIGRlcCkpIHtcbiAgICAgICAgcmV0dXJuIGxvY2Fsc1tkZXBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdldChkZXApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZuOiBmbixcbiAgICAgIGRlcGVuZGVuY2llczogZGVwZW5kZW5jaWVzXG4gICAgfTtcbiAgfTtcblxuICB2YXIgaW5zdGFudGlhdGUgPSBmdW5jdGlvbiBpbnN0YW50aWF0ZShUeXBlKSB7XG4gICAgdmFyIF9mbkRlZiA9IGZuRGVmKFR5cGUpLFxuICAgICAgICBkZXBlbmRlbmNpZXMgPSBfZm5EZWYuZGVwZW5kZW5jaWVzLFxuICAgICAgICBmbiA9IF9mbkRlZi5mbjtcblxuICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KGZuLCBbbnVsbF0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShkZXBlbmRlbmNpZXMpKSkpKCk7XG4gIH07XG5cbiAgdmFyIGludm9rZSA9IGZ1bmN0aW9uIGludm9rZShmdW5jLCBjb250ZXh0LCBsb2NhbHMpIHtcbiAgICB2YXIgX2ZuRGVmMiA9IGZuRGVmKGZ1bmMsIGxvY2FscyksXG4gICAgICAgIGRlcGVuZGVuY2llcyA9IF9mbkRlZjIuZGVwZW5kZW5jaWVzLFxuICAgICAgICBmbiA9IF9mbkRlZjIuZm47XG5cbiAgICByZXR1cm4gZm4uY2FsbC5hcHBseShmbiwgW2NvbnRleHRdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoZGVwZW5kZW5jaWVzKSkpO1xuICB9O1xuXG4gIHZhciBjcmVhdGVQcml2YXRlSW5qZWN0b3JGYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlUHJpdmF0ZUluamVjdG9yRmFjdG9yeShwcml2YXRlQ2hpbGRJbmplY3Rvcikge1xuICAgIHJldHVybiBhbm5vdGF0ZShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gcHJpdmF0ZUNoaWxkSW5qZWN0b3IuZ2V0KGtleSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUNoaWxkID0gZnVuY3Rpb24gY3JlYXRlQ2hpbGQobW9kdWxlcywgZm9yY2VOZXdJbnN0YW5jZXMpIHtcbiAgICBpZiAoZm9yY2VOZXdJbnN0YW5jZXMgJiYgZm9yY2VOZXdJbnN0YW5jZXMubGVuZ3RoKSB7XG4gICAgICB2YXIgZnJvbVBhcmVudE1vZHVsZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB2YXIgbWF0Y2hlZFNjb3BlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIHZhciBwcml2YXRlSW5qZWN0b3JzQ2FjaGUgPSBbXTtcbiAgICAgIHZhciBwcml2YXRlQ2hpbGRJbmplY3RvcnMgPSBbXTtcbiAgICAgIHZhciBwcml2YXRlQ2hpbGRGYWN0b3JpZXMgPSBbXTtcblxuICAgICAgdmFyIHByb3ZpZGVyO1xuICAgICAgdmFyIGNhY2hlSWR4O1xuICAgICAgdmFyIHByaXZhdGVDaGlsZEluamVjdG9yO1xuICAgICAgdmFyIHByaXZhdGVDaGlsZEluamVjdG9yRmFjdG9yeTtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gcHJvdmlkZXJzKSB7XG4gICAgICAgIHByb3ZpZGVyID0gcHJvdmlkZXJzW25hbWVdO1xuXG4gICAgICAgIGlmIChmb3JjZU5ld0luc3RhbmNlcy5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgICAgIGlmIChwcm92aWRlclsyXSA9PT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgICAgICBjYWNoZUlkeCA9IHByaXZhdGVJbmplY3RvcnNDYWNoZS5pbmRleE9mKHByb3ZpZGVyWzNdKTtcbiAgICAgICAgICAgIGlmIChjYWNoZUlkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgcHJpdmF0ZUNoaWxkSW5qZWN0b3IgPSBwcm92aWRlclszXS5jcmVhdGVDaGlsZChbXSwgZm9yY2VOZXdJbnN0YW5jZXMpO1xuICAgICAgICAgICAgICBwcml2YXRlQ2hpbGRJbmplY3RvckZhY3RvcnkgPSBjcmVhdGVQcml2YXRlSW5qZWN0b3JGYWN0b3J5KHByaXZhdGVDaGlsZEluamVjdG9yKTtcbiAgICAgICAgICAgICAgcHJpdmF0ZUluamVjdG9yc0NhY2hlLnB1c2gocHJvdmlkZXJbM10pO1xuICAgICAgICAgICAgICBwcml2YXRlQ2hpbGRJbmplY3RvcnMucHVzaChwcml2YXRlQ2hpbGRJbmplY3Rvcik7XG4gICAgICAgICAgICAgIHByaXZhdGVDaGlsZEZhY3Rvcmllcy5wdXNoKHByaXZhdGVDaGlsZEluamVjdG9yRmFjdG9yeSk7XG4gICAgICAgICAgICAgIGZyb21QYXJlbnRNb2R1bGVbbmFtZV0gPSBbcHJpdmF0ZUNoaWxkSW5qZWN0b3JGYWN0b3J5LCBuYW1lLCAncHJpdmF0ZScsIHByaXZhdGVDaGlsZEluamVjdG9yXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZyb21QYXJlbnRNb2R1bGVbbmFtZV0gPSBbcHJpdmF0ZUNoaWxkRmFjdG9yaWVzW2NhY2hlSWR4XSwgbmFtZSwgJ3ByaXZhdGUnLCBwcml2YXRlQ2hpbGRJbmplY3RvcnNbY2FjaGVJZHhdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJvbVBhcmVudE1vZHVsZVtuYW1lXSA9IFtwcm92aWRlclsyXSwgcHJvdmlkZXJbMV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXRjaGVkU2NvcGVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgocHJvdmlkZXJbMl0gPT09ICdmYWN0b3J5JyB8fCBwcm92aWRlclsyXSA9PT0gJ3R5cGUnKSAmJiBwcm92aWRlclsxXS4kc2NvcGUpIHtcbiAgICAgICAgICAvKiBqc2hpbnQgLVcwODMgKi9cbiAgICAgICAgICBmb3JjZU5ld0luc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzY29wZSkge1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVyWzFdLiRzY29wZS5pbmRleE9mKHNjb3BlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgZnJvbVBhcmVudE1vZHVsZVtuYW1lXSA9IFtwcm92aWRlclsyXSwgcHJvdmlkZXJbMV1dO1xuICAgICAgICAgICAgICBtYXRjaGVkU2NvcGVzW3Njb3BlXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yY2VOZXdJbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoc2NvcGUpIHtcbiAgICAgICAgaWYgKCFtYXRjaGVkU2NvcGVzW3Njb3BlXSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcHJvdmlkZXIgZm9yIFwiJyArIHNjb3BlICsgJ1wiLiBDYW5ub3QgdXNlIHByb3ZpZGVyIGZyb20gdGhlIHBhcmVudCEnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIG1vZHVsZXMudW5zaGlmdChmcm9tUGFyZW50TW9kdWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEluamVjdG9yKG1vZHVsZXMsIHNlbGYpO1xuICB9O1xuXG4gIHZhciBmYWN0b3J5TWFwID0ge1xuICAgIGZhY3Rvcnk6IGludm9rZSxcbiAgICB0eXBlOiBpbnN0YW50aWF0ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoX3ZhbHVlKSB7XG4gICAgICByZXR1cm4gX3ZhbHVlO1xuICAgIH1cbiAgfTtcblxuICBtb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZSkge1xuXG4gICAgZnVuY3Rpb24gYXJyYXlVbndyYXAodHlwZSwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlICE9PSAndmFsdWUnICYmIGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gYW5ub3RhdGUodmFsdWUuc2xpY2UoKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBUT0RPKHZvanRhKTogaGFuZGxlIHdyb25nIGlucHV0cyAobW9kdWxlcylcbiAgICBpZiAobW9kdWxlIGluc3RhbmNlb2YgTW9kdWxlKSB7XG4gICAgICBtb2R1bGUuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBwcm92aWRlclswXTtcbiAgICAgICAgdmFyIHR5cGUgPSBwcm92aWRlclsxXTtcbiAgICAgICAgdmFyIHZhbHVlID0gcHJvdmlkZXJbMl07XG5cbiAgICAgICAgcHJvdmlkZXJzW25hbWVdID0gW2ZhY3RvcnlNYXBbdHlwZV0sIGFycmF5VW53cmFwKHR5cGUsIHZhbHVlKSwgdHlwZV07XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCh0eXBlb2YgbW9kdWxlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihtb2R1bGUpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChtb2R1bGUuX19leHBvcnRzX18pIHtcbiAgICAgICAgdmFyIGNsb25lZE1vZHVsZSA9IE9iamVjdC5rZXlzKG1vZHVsZSkucmVkdWNlKGZ1bmN0aW9uIChtLCBrZXkpIHtcbiAgICAgICAgICBpZiAoa2V5LnN1YnN0cmluZygwLCAyKSAhPT0gJ19fJykge1xuICAgICAgICAgICAgbVtrZXldID0gbW9kdWxlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9LCBPYmplY3QuY3JlYXRlKG51bGwpKTtcblxuICAgICAgICB2YXIgcHJpdmF0ZUluamVjdG9yID0gbmV3IEluamVjdG9yKChtb2R1bGUuX19tb2R1bGVzX18gfHwgW10pLmNvbmNhdChbY2xvbmVkTW9kdWxlXSksIHNlbGYpO1xuICAgICAgICB2YXIgZ2V0RnJvbVByaXZhdGVJbmplY3RvciA9IGFubm90YXRlKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gcHJpdmF0ZUluamVjdG9yLmdldChrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgbW9kdWxlLl9fZXhwb3J0c19fLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHByb3ZpZGVyc1trZXldID0gW2dldEZyb21Qcml2YXRlSW5qZWN0b3IsIGtleSwgJ3ByaXZhdGUnLCBwcml2YXRlSW5qZWN0b3JdO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC5rZXlzKG1vZHVsZSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIGlmIChtb2R1bGVbbmFtZV1bMl0gPT09ICdwcml2YXRlJykge1xuICAgICAgICAgICAgcHJvdmlkZXJzW25hbWVdID0gbW9kdWxlW25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB0eXBlID0gbW9kdWxlW25hbWVdWzBdO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG1vZHVsZVtuYW1lXVsxXTtcblxuICAgICAgICAgIHByb3ZpZGVyc1tuYW1lXSA9IFtmYWN0b3J5TWFwW3R5cGVdLCBhcnJheVVud3JhcCh0eXBlLCB2YWx1ZSksIHR5cGVdO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIHB1YmxpYyBBUElcbiAgdGhpcy5nZXQgPSBnZXQ7XG4gIHRoaXMuaW52b2tlID0gaW52b2tlO1xuICB0aGlzLmluc3RhbnRpYXRlID0gaW5zdGFudGlhdGU7XG4gIHRoaXMuY3JlYXRlQ2hpbGQgPSBjcmVhdGVDaGlsZDtcbn1cblxuLy8gaGVscGVycyAvLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBoYXNQcm9wKG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxuZXhwb3J0IHsgYW5ub3RhdGUsIE1vZHVsZSwgSW5qZWN0b3IgfTtcbiIsImZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcblx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xufVxuXG52YXIgaGF0XzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG52YXIgaGF0ID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0cywgYmFzZSkge1xuICAgIGlmICghYmFzZSkgYmFzZSA9IDE2O1xuICAgIGlmIChiaXRzID09PSB1bmRlZmluZWQpIGJpdHMgPSAxMjg7XG4gICAgaWYgKGJpdHMgPD0gMCkgcmV0dXJuICcwJztcbiAgICBcbiAgICB2YXIgZGlnaXRzID0gTWF0aC5sb2coTWF0aC5wb3coMiwgYml0cykpIC8gTWF0aC5sb2coYmFzZSk7XG4gICAgZm9yICh2YXIgaSA9IDI7IGRpZ2l0cyA9PT0gSW5maW5pdHk7IGkgKj0gMikge1xuICAgICAgICBkaWdpdHMgPSBNYXRoLmxvZyhNYXRoLnBvdygyLCBiaXRzIC8gaSkpIC8gTWF0aC5sb2coYmFzZSkgKiBpO1xuICAgIH1cbiAgICBcbiAgICB2YXIgcmVtID0gZGlnaXRzIC0gTWF0aC5mbG9vcihkaWdpdHMpO1xuICAgIFxuICAgIHZhciByZXMgPSAnJztcbiAgICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGguZmxvb3IoZGlnaXRzKTsgaSsrKSB7XG4gICAgICAgIHZhciB4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYmFzZSkudG9TdHJpbmcoYmFzZSk7XG4gICAgICAgIHJlcyA9IHggKyByZXM7XG4gICAgfVxuICAgIFxuICAgIGlmIChyZW0pIHtcbiAgICAgICAgdmFyIGIgPSBNYXRoLnBvdyhiYXNlLCByZW0pO1xuICAgICAgICB2YXIgeCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGIpLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgICByZXMgPSB4ICsgcmVzO1xuICAgIH1cbiAgICBcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQocmVzLCBiYXNlKTtcbiAgICBpZiAocGFyc2VkICE9PSBJbmZpbml0eSAmJiBwYXJzZWQgPj0gTWF0aC5wb3coMiwgYml0cykpIHtcbiAgICAgICAgcmV0dXJuIGhhdChiaXRzLCBiYXNlKVxuICAgIH1cbiAgICBlbHNlIHJldHVybiByZXM7XG59O1xuXG5oYXQucmFjayA9IGZ1bmN0aW9uIChiaXRzLCBiYXNlLCBleHBhbmRCeSkge1xuICAgIHZhciBmbiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBpdGVycyA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChpdGVycyArKyA+IDEwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cGFuZEJ5KSBiaXRzICs9IGV4cGFuZEJ5O1xuICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCd0b28gbWFueSBJRCBjb2xsaXNpb25zLCB1c2UgbW9yZSBiaXRzJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGlkID0gaGF0KGJpdHMsIGJhc2UpO1xuICAgICAgICB9IHdoaWxlIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChoYXRzLCBpZCkpO1xuICAgICAgICBcbiAgICAgICAgaGF0c1tpZF0gPSBkYXRhO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfTtcbiAgICB2YXIgaGF0cyA9IGZuLmhhdHMgPSB7fTtcbiAgICBcbiAgICBmbi5nZXQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIGZuLmhhdHNbaWRdO1xuICAgIH07XG4gICAgXG4gICAgZm4uc2V0ID0gZnVuY3Rpb24gKGlkLCB2YWx1ZSkge1xuICAgICAgICBmbi5oYXRzW2lkXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gZm47XG4gICAgfTtcbiAgICBcbiAgICBmbi5iaXRzID0gYml0cyB8fCAxMjg7XG4gICAgZm4uYmFzZSA9IGJhc2UgfHwgMTY7XG4gICAgcmV0dXJuIGZuO1xufTtcbn0pO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpZCBnZW5lcmF0b3IgLyBjYWNoZSBpbnN0YW5jZS5cbiAqXG4gKiBZb3UgbWF5IG9wdGlvbmFsbHkgcHJvdmlkZSBhIHNlZWQgdGhhdCBpcyB1c2VkIGludGVybmFsbHkuXG4gKlxuICogQHBhcmFtIHtTZWVkfSBzZWVkXG4gKi9cblxuZnVuY3Rpb24gSWRzKHNlZWQpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIElkcykpIHtcbiAgICByZXR1cm4gbmV3IElkcyhzZWVkKTtcbiAgfVxuXG4gIHNlZWQgPSBzZWVkIHx8IFsxMjgsIDM2LCAxXTtcbiAgdGhpcy5fc2VlZCA9IHNlZWQubGVuZ3RoID8gaGF0XzEucmFjayhzZWVkWzBdLCBzZWVkWzFdLCBzZWVkWzJdKSA6IHNlZWQ7XG59XG4vKipcbiAqIEdlbmVyYXRlIGEgbmV4dCBpZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2VsZW1lbnRdIGVsZW1lbnQgdG8gYmluZCB0aGUgaWQgdG9cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGlkXG4gKi9cblxuSWRzLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHRoaXMuX3NlZWQoZWxlbWVudCB8fCB0cnVlKTtcbn07XG4vKipcbiAqIEdlbmVyYXRlIGEgbmV4dCBpZCB3aXRoIGEgZ2l2ZW4gcHJlZml4LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZWxlbWVudF0gZWxlbWVudCB0byBiaW5kIHRoZSBpZCB0b1xuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gaWRcbiAqL1xuXG5cbklkcy5wcm90b3R5cGUubmV4dFByZWZpeGVkID0gZnVuY3Rpb24gKHByZWZpeCwgZWxlbWVudCkge1xuICB2YXIgaWQ7XG5cbiAgZG8ge1xuICAgIGlkID0gcHJlZml4ICsgdGhpcy5uZXh0KHRydWUpO1xuICB9IHdoaWxlICh0aGlzLmFzc2lnbmVkKGlkKSk7IC8vIGNsYWltIHtwcmVmaXh9e3JhbmRvbX1cblxuXG4gIHRoaXMuY2xhaW0oaWQsIGVsZW1lbnQpOyAvLyByZXR1cm5cblxuICByZXR1cm4gaWQ7XG59O1xuLyoqXG4gKiBNYW51YWxseSBjbGFpbSBhbiBleGlzdGluZyBpZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZWxlbWVudF0gZWxlbWVudCB0aGUgaWQgaXMgY2xhaW1lZCBieVxuICovXG5cblxuSWRzLnByb3RvdHlwZS5jbGFpbSA9IGZ1bmN0aW9uIChpZCwgZWxlbWVudCkge1xuICB0aGlzLl9zZWVkLnNldChpZCwgZWxlbWVudCB8fCB0cnVlKTtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gaWQgaGFzIGFscmVhZHkgYmVlbiBhc3NpZ25lZC5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGlkXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cblxuSWRzLnByb3RvdHlwZS5hc3NpZ25lZCA9IGZ1bmN0aW9uIChpZCkge1xuICByZXR1cm4gdGhpcy5fc2VlZC5nZXQoaWQpIHx8IGZhbHNlO1xufTtcbi8qKlxuICogVW5jbGFpbSBhbiBpZC5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGlkIHRoZSBpZCB0byB1bmNsYWltXG4gKi9cblxuXG5JZHMucHJvdG90eXBlLnVuY2xhaW0gPSBmdW5jdGlvbiAoaWQpIHtcbiAgZGVsZXRlIHRoaXMuX3NlZWQuaGF0c1tpZF07XG59O1xuLyoqXG4gKiBDbGVhciBhbGwgY2xhaW1lZCBpZHMuXG4gKi9cblxuXG5JZHMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGF0cyA9IHRoaXMuX3NlZWQuaGF0cyxcbiAgICAgIGlkO1xuXG4gIGZvciAoaWQgaW4gaGF0cykge1xuICAgIHRoaXMudW5jbGFpbShpZCk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IElkcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogRmxhdHRlbiBhcnJheSwgb25lIGxldmVsIGRlZXAuXG4gKlxuICogQHBhcmFtIHtBcnJheTw/Pn0gYXJyXG4gKlxuICogQHJldHVybiB7QXJyYXk8Pz59XG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcnIpO1xufVxuXG52YXIgbmF0aXZlVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIG5hdGl2ZUhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKG9iaikge1xuICByZXR1cm4gb2JqID09PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc0RlZmluZWQob2JqKSB7XG4gIHJldHVybiBvYmogIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzTmlsKG9iaikge1xuICByZXR1cm4gb2JqID09IG51bGw7XG59XG5mdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICByZXR1cm4gbmF0aXZlVG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIHJldHVybiBuYXRpdmVUb1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuZnVuY3Rpb24gaXNOdW1iZXIob2JqKSB7XG4gIHJldHVybiBuYXRpdmVUb1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE51bWJlcl0nO1xufVxuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgdmFyIHRhZyA9IG5hdGl2ZVRvU3RyaW5nLmNhbGwob2JqKTtcbiAgcmV0dXJuIHRhZyA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJyB8fCB0YWcgPT09ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyB8fCB0YWcgPT09ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScgfHwgdGFnID09PSAnW29iamVjdCBBc3luY0dlbmVyYXRvckZ1bmN0aW9uXScgfHwgdGFnID09PSAnW29iamVjdCBQcm94eV0nO1xufVxuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XG4gIHJldHVybiBuYXRpdmVUb1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufVxuLyoqXG4gKiBFbnN1cmUgY29sbGVjdGlvbiBpcyBhbiBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKi9cblxuZnVuY3Rpb24gZW5zdXJlQXJyYXkob2JqKSB7XG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ211c3Qgc3VwcGx5IGFycmF5Jyk7XG59XG4vKipcbiAqIFJldHVybiB0cnVlLCBpZiB0YXJnZXQgb3ducyBhIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIGtleS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBoYXModGFyZ2V0LCBrZXkpIHtcbiAgcmV0dXJuIG5hdGl2ZUhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpO1xufVxuXG4vKipcbiAqIEZpbmQgZWxlbWVudCBpbiBjb2xsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fE9iamVjdH0gY29sbGVjdGlvblxuICogQHBhcmFtICB7RnVuY3Rpb258T2JqZWN0fSBtYXRjaGVyXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIGZpbmQoY29sbGVjdGlvbiwgbWF0Y2hlcikge1xuICBtYXRjaGVyID0gdG9NYXRjaGVyKG1hdGNoZXIpO1xuICB2YXIgbWF0Y2g7XG4gIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24gKHZhbCwga2V5KSB7XG4gICAgaWYgKG1hdGNoZXIodmFsLCBrZXkpKSB7XG4gICAgICBtYXRjaCA9IHZhbDtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbWF0Y2g7XG59XG4vKipcbiAqIEZpbmQgZWxlbWVudCBpbmRleCBpbiBjb2xsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fE9iamVjdH0gY29sbGVjdGlvblxuICogQHBhcmFtICB7RnVuY3Rpb259IG1hdGNoZXJcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gZmluZEluZGV4KGNvbGxlY3Rpb24sIG1hdGNoZXIpIHtcbiAgbWF0Y2hlciA9IHRvTWF0Y2hlcihtYXRjaGVyKTtcbiAgdmFyIGlkeCA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyAtMSA6IHVuZGVmaW5lZDtcbiAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbiAodmFsLCBrZXkpIHtcbiAgICBpZiAobWF0Y2hlcih2YWwsIGtleSkpIHtcbiAgICAgIGlkeCA9IGtleTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaWR4O1xufVxuLyoqXG4gKiBGaW5kIGVsZW1lbnQgaW4gY29sbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb25cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBtYXRjaGVyXG4gKlxuICogQHJldHVybiB7QXJyYXl9IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uLCBtYXRjaGVyKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbiAodmFsLCBrZXkpIHtcbiAgICBpZiAobWF0Y2hlcih2YWwsIGtleSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGNvbGxlY3Rpb247IHJldHVybmluZyBzb21ldGhpbmdcbiAqIChub24tdW5kZWZpbmVkKSB3aWxsIHN0b3AgaXRlcmF0aW9uLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fE9iamVjdH0gY29sbGVjdGlvblxuICogQHBhcmFtICB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSByZXR1cm4gcmVzdWx0IHRoYXQgc3RvcHBlZCB0aGUgaXRlcmF0aW9uXG4gKi9cblxuZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRvcikge1xuICB2YXIgdmFsLCByZXN1bHQ7XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGNvbGxlY3Rpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvbnZlcnRLZXkgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gdG9OdW0gOiBpZGVudGl0eTtcblxuICBmb3IgKHZhciBrZXkgaW4gY29sbGVjdGlvbikge1xuICAgIGlmIChoYXMoY29sbGVjdGlvbiwga2V5KSkge1xuICAgICAgdmFsID0gY29sbGVjdGlvbltrZXldO1xuICAgICAgcmVzdWx0ID0gaXRlcmF0b3IodmFsLCBjb252ZXJ0S2V5KGtleSkpO1xuXG4gICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBSZXR1cm4gY29sbGVjdGlvbiB3aXRob3V0IGVsZW1lbnQuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGFyclxuICogQHBhcmFtICB7RnVuY3Rpb259IG1hdGNoZXJcbiAqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5mdW5jdGlvbiB3aXRob3V0KGFyciwgbWF0Y2hlcikge1xuICBpZiAoaXNVbmRlZmluZWQoYXJyKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGVuc3VyZUFycmF5KGFycik7XG4gIG1hdGNoZXIgPSB0b01hdGNoZXIobWF0Y2hlcik7XG4gIHJldHVybiBhcnIuZmlsdGVyKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgcmV0dXJuICFtYXRjaGVyKGVsLCBpZHgpO1xuICB9KTtcbn1cbi8qKlxuICogUmVkdWNlIGNvbGxlY3Rpb24sIHJldHVybmluZyBhIHNpbmdsZSByZXN1bHQuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fEFycmF5fSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gaXRlcmF0b3JcbiAqIEBwYXJhbSAge0FueX0gcmVzdWx0XG4gKlxuICogQHJldHVybiB7QW55fSByZXN1bHQgcmV0dXJuZWQgZnJvbSBsYXN0IGl0ZXJhdG9yXG4gKi9cblxuZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdG9yLCByZXN1bHQpIHtcbiAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbiAodmFsdWUsIGlkeCkge1xuICAgIHJlc3VsdCA9IGl0ZXJhdG9yKHJlc3VsdCwgdmFsdWUsIGlkeCk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiBldmVyeSBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uXG4gKiBtYXRjaGVzIHRoZSBjcml0ZXJpYS5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R8QXJyYXl9IGNvbGxlY3Rpb25cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBtYXRjaGVyXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBldmVyeShjb2xsZWN0aW9uLCBtYXRjaGVyKSB7XG4gIHJldHVybiAhIXJlZHVjZShjb2xsZWN0aW9uLCBmdW5jdGlvbiAobWF0Y2hlcywgdmFsLCBrZXkpIHtcbiAgICByZXR1cm4gbWF0Y2hlcyAmJiBtYXRjaGVyKHZhbCwga2V5KTtcbiAgfSwgdHJ1ZSk7XG59XG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHNvbWUgZWxlbWVudHMgaW4gdGhlIGNvbGxlY3Rpb25cbiAqIG1hdGNoIHRoZSBjcml0ZXJpYS5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R8QXJyYXl9IGNvbGxlY3Rpb25cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBtYXRjaGVyXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBzb21lKGNvbGxlY3Rpb24sIG1hdGNoZXIpIHtcbiAgcmV0dXJuICEhZmluZChjb2xsZWN0aW9uLCBtYXRjaGVyKTtcbn1cbi8qKlxuICogVHJhbnNmb3JtIGEgY29sbGVjdGlvbiBpbnRvIGFub3RoZXIgY29sbGVjdGlvblxuICogYnkgcGlwaW5nIGVhY2ggbWVtYmVyIHRocm91Z2ggdGhlIGdpdmVuIGZuLlxuICpcbiAqIEBwYXJhbSAge09iamVjdHxBcnJheX0gICBjb2xsZWN0aW9uXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gdHJhbnNmb3JtZWQgY29sbGVjdGlvblxuICovXG5cbmZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBmbikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24gKHZhbCwga2V5KSB7XG4gICAgcmVzdWx0LnB1c2goZm4odmFsLCBrZXkpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEdldCB0aGUgY29sbGVjdGlvbnMga2V5cy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R8QXJyYXl9IGNvbGxlY3Rpb25cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5mdW5jdGlvbiBrZXlzKGNvbGxlY3Rpb24pIHtcbiAgcmV0dXJuIGNvbGxlY3Rpb24gJiYgT2JqZWN0LmtleXMoY29sbGVjdGlvbikgfHwgW107XG59XG4vKipcbiAqIFNob3J0aGFuZCBmb3IgYGtleXMobykubGVuZ3RoYC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R8QXJyYXl9IGNvbGxlY3Rpb25cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblxuZnVuY3Rpb24gc2l6ZShjb2xsZWN0aW9uKSB7XG4gIHJldHVybiBrZXlzKGNvbGxlY3Rpb24pLmxlbmd0aDtcbn1cbi8qKlxuICogR2V0IHRoZSB2YWx1ZXMgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fEFycmF5fSBjb2xsZWN0aW9uXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZnVuY3Rpb24gdmFsdWVzKGNvbGxlY3Rpb24pIHtcbiAgcmV0dXJuIG1hcChjb2xsZWN0aW9uLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfSk7XG59XG4vKipcbiAqIEdyb3VwIGNvbGxlY3Rpb24gbWVtYmVycyBieSBhdHRyaWJ1dGUuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fEFycmF5fSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZXh0cmFjdG9yXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBtYXAgd2l0aCB7IGF0dHJWYWx1ZSA9PiBbIGEsIGIsIGMgXSB9XG4gKi9cblxuZnVuY3Rpb24gZ3JvdXBCeShjb2xsZWN0aW9uLCBleHRyYWN0b3IpIHtcbiAgdmFyIGdyb3VwZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBleHRyYWN0b3IgPSB0b0V4dHJhY3RvcihleHRyYWN0b3IpO1xuICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uICh2YWwpIHtcbiAgICB2YXIgZGlzY3JpbWluYXRvciA9IGV4dHJhY3Rvcih2YWwpIHx8ICdfJztcbiAgICB2YXIgZ3JvdXAgPSBncm91cGVkW2Rpc2NyaW1pbmF0b3JdO1xuXG4gICAgaWYgKCFncm91cCkge1xuICAgICAgZ3JvdXAgPSBncm91cGVkW2Rpc2NyaW1pbmF0b3JdID0gW107XG4gICAgfVxuXG4gICAgZ3JvdXAucHVzaCh2YWwpO1xuICB9KTtcbiAgcmV0dXJuIGdyb3VwZWQ7XG59XG5mdW5jdGlvbiB1bmlxdWVCeShleHRyYWN0b3IpIHtcbiAgZXh0cmFjdG9yID0gdG9FeHRyYWN0b3IoZXh0cmFjdG9yKTtcbiAgdmFyIGdyb3VwZWQgPSB7fTtcblxuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgY29sbGVjdGlvbnMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGNvbGxlY3Rpb25zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGZvckVhY2goY29sbGVjdGlvbnMsIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuIGdyb3VwQnkoYywgZXh0cmFjdG9yLCBncm91cGVkKTtcbiAgfSk7XG4gIHZhciByZXN1bHQgPSBtYXAoZ3JvdXBlZCwgZnVuY3Rpb24gKHZhbCwga2V5KSB7XG4gICAgcmV0dXJuIHZhbFswXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgdW5pb25CeSA9IHVuaXF1ZUJ5O1xuLyoqXG4gKiBTb3J0IGNvbGxlY3Rpb24gYnkgY3JpdGVyaWEuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fEFycmF5fSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0gIHtTdHJpbmd8RnVuY3Rpb259IGV4dHJhY3RvclxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIHNvcnRCeShjb2xsZWN0aW9uLCBleHRyYWN0b3IpIHtcbiAgZXh0cmFjdG9yID0gdG9FeHRyYWN0b3IoZXh0cmFjdG9yKTtcbiAgdmFyIHNvcnRlZCA9IFtdO1xuICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgdmFyIGRpc2MgPSBleHRyYWN0b3IodmFsdWUsIGtleSk7XG4gICAgdmFyIGVudHJ5ID0ge1xuICAgICAgZDogZGlzYyxcbiAgICAgIHY6IHZhbHVlXG4gICAgfTtcblxuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IHNvcnRlZC5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICB2YXIgZCA9IHNvcnRlZFtpZHhdLmQ7XG5cbiAgICAgIGlmIChkaXNjIDwgZCkge1xuICAgICAgICBzb3J0ZWQuc3BsaWNlKGlkeCwgMCwgZW50cnkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSAvLyBub3QgaW5zZXJ0ZWQsIGFwcGVuZCAoISlcblxuXG4gICAgc29ydGVkLnB1c2goZW50cnkpO1xuICB9KTtcbiAgcmV0dXJuIG1hcChzb3J0ZWQsIGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIGUudjtcbiAgfSk7XG59XG4vKipcbiAqIENyZWF0ZSBhbiBvYmplY3QgcGF0dGVybiBtYXRjaGVyLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogY29uc3QgbWF0Y2hlciA9IG1hdGNoUGF0dGVybih7IGlkOiAxIH0pO1xuICpcbiAqIHZhciBlbGVtZW50ID0gZmluZChlbGVtZW50cywgbWF0Y2hlcik7XG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBwYXR0ZXJuXG4gKlxuICogQHJldHVybiB7RnVuY3Rpb259IG1hdGNoZXJGblxuICovXG5cbmZ1bmN0aW9uIG1hdGNoUGF0dGVybihwYXR0ZXJuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZWwpIHtcbiAgICByZXR1cm4gZXZlcnkocGF0dGVybiwgZnVuY3Rpb24gKHZhbCwga2V5KSB7XG4gICAgICByZXR1cm4gZWxba2V5XSA9PT0gdmFsO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0b0V4dHJhY3RvcihleHRyYWN0b3IpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oZXh0cmFjdG9yKSA/IGV4dHJhY3RvciA6IGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIGVbZXh0cmFjdG9yXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdG9NYXRjaGVyKG1hdGNoZXIpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24obWF0Y2hlcikgPyBtYXRjaGVyIDogZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gZSA9PT0gbWF0Y2hlcjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaWRlbnRpdHkoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59XG5cbmZ1bmN0aW9uIHRvTnVtKGFyZykge1xuICByZXR1cm4gTnVtYmVyKGFyZyk7XG59XG5cbi8qKlxuICogRGVib3VuY2UgZm4sIGNhbGxpbmcgaXQgb25seSBvbmNlIGlmXG4gKiB0aGUgZ2l2ZW4gdGltZSBlbGFwc2VkIGJldHdlZW4gY2FsbHMuXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWVvdXRcbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gZGVib3VuY2VkIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZuLCB0aW1lb3V0KSB7XG4gIHZhciB0aW1lcjtcbiAgdmFyIGxhc3RBcmdzO1xuICB2YXIgbGFzdFRoaXM7XG4gIHZhciBsYXN0Tm93O1xuXG4gIGZ1bmN0aW9uIGZpcmUoKSB7XG4gICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgdmFyIHNjaGVkdWxlZERpZmYgPSBsYXN0Tm93ICsgdGltZW91dCAtIG5vdztcblxuICAgIGlmIChzY2hlZHVsZWREaWZmID4gMCkge1xuICAgICAgcmV0dXJuIHNjaGVkdWxlKHNjaGVkdWxlZERpZmYpO1xuICAgIH1cblxuICAgIGZuLmFwcGx5KGxhc3RUaGlzLCBsYXN0QXJncyk7XG4gICAgdGltZXIgPSBsYXN0Tm93ID0gbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlKHRpbWVvdXQpIHtcbiAgICB0aW1lciA9IHNldFRpbWVvdXQoZmlyZSwgdGltZW91dCk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGxhc3ROb3cgPSBEYXRlLm5vdygpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGxhc3RBcmdzID0gYXJncztcbiAgICBsYXN0VGhpcyA9IHRoaXM7IC8vIGVuc3VyZSBhbiBleGVjdXRpb24gaXMgc2NoZWR1bGVkXG5cbiAgICBpZiAoIXRpbWVyKSB7XG4gICAgICBzY2hlZHVsZSh0aW1lb3V0KTtcbiAgICB9XG4gIH07XG59XG4vKipcbiAqIFRocm90dGxlIGZuLCBjYWxsaW5nIGF0IG1vc3Qgb25jZVxuICogaW4gdGhlIGdpdmVuIGludGVydmFsLlxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtICB7TnVtYmVyfSBpbnRlcnZhbFxuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiB0aHJvdHRsZShmbiwgaW50ZXJ2YWwpIHtcbiAgdmFyIHRocm90dGxpbmcgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhyb3R0bGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZuLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgICB0aHJvdHRsaW5nID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm90dGxpbmcgPSBmYWxzZTtcbiAgICB9LCBpbnRlcnZhbCk7XG4gIH07XG59XG4vKipcbiAqIEJpbmQgZnVuY3Rpb24gYWdhaW5zdCB0YXJnZXQgPHRoaXM+LlxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtICB7T2JqZWN0fSAgIHRhcmdldFxuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBib3VuZCBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIGJpbmQoZm4sIHRhcmdldCkge1xuICByZXR1cm4gZm4uYmluZCh0YXJnZXQpO1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIENvbnZlbmllbmNlIHdyYXBwZXIgZm9yIGBPYmplY3QuYXNzaWduYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0gey4uLk9iamVjdH0gb3RoZXJzXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgdGFyZ2V0XG4gKi9cblxuZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgb3RoZXJzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBvdGhlcnNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHZvaWQgMCwgW3RhcmdldF0uY29uY2F0KG90aGVycykpO1xufVxuLyoqXG4gKiBQaWNrIGdpdmVuIHByb3BlcnRpZXMgZnJvbSB0aGUgdGFyZ2V0IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wZXJ0aWVzXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB0YXJnZXRcbiAqL1xuXG5mdW5jdGlvbiBwaWNrKHRhcmdldCwgcHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIHZhciBvYmogPSBPYmplY3QodGFyZ2V0KTtcbiAgZm9yRWFjaChwcm9wZXJ0aWVzLCBmdW5jdGlvbiAocHJvcCkge1xuICAgIGlmIChwcm9wIGluIG9iaikge1xuICAgICAgcmVzdWx0W3Byb3BdID0gdGFyZ2V0W3Byb3BdO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFBpY2sgYWxsIHRhcmdldCBwcm9wZXJ0aWVzLCBleGNsdWRpbmcgdGhlIGdpdmVuIG9uZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHtBcnJheX0gcHJvcGVydGllc1xuICpcbiAqIEByZXR1cm4ge09iamVjdH0gdGFyZ2V0XG4gKi9cblxuZnVuY3Rpb24gb21pdCh0YXJnZXQsIHByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICB2YXIgb2JqID0gT2JqZWN0KHRhcmdldCk7XG4gIGZvckVhY2gob2JqLCBmdW5jdGlvbiAocHJvcCwga2V5KSB7XG4gICAgaWYgKHByb3BlcnRpZXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBwcm9wO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IG1lcmdlIGAuLi5zb3VyY2VzYCBpbnRvIGdpdmVuIHRhcmdldC5cbiAqXG4gKiBEb2VzIHN1cHBvcnQgbWVyZ2luZyBvYmplY3RzOyBkb2VzIG5vdCBzdXBwb3J0IG1lcmdpbmcgYXJyYXlzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgdGFyZ2V0XG4gKi9cblxuZnVuY3Rpb24gbWVyZ2UodGFyZ2V0KSB7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgc291cmNlcyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgc291cmNlc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuXG4gIGlmICghc291cmNlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgZm9yRWFjaChzb3VyY2VzLCBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgLy8gc2tpcCBub24tb2JqIHNvdXJjZXMsIGkuZS4gbnVsbFxuICAgIGlmICghc291cmNlIHx8ICFpc09iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yRWFjaChzb3VyY2UsIGZ1bmN0aW9uIChzb3VyY2VWYWwsIGtleSkge1xuICAgICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGFyZ2V0VmFsID0gdGFyZ2V0W2tleV07XG5cbiAgICAgIGlmIChpc09iamVjdChzb3VyY2VWYWwpKSB7XG4gICAgICAgIGlmICghaXNPYmplY3QodGFyZ2V0VmFsKSkge1xuICAgICAgICAgIC8vIG92ZXJyaWRlIHRhcmdldFtrZXldIHdpdGggb2JqZWN0XG4gICAgICAgICAgdGFyZ2V0VmFsID0ge307XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXRba2V5XSA9IG1lcmdlKHRhcmdldFZhbCwgc291cmNlVmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlVmFsO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZXhwb3J0IHsgZmxhdHRlbiwgZmluZCwgZmluZEluZGV4LCBmaWx0ZXIsIGZvckVhY2gsIHdpdGhvdXQsIHJlZHVjZSwgZXZlcnksIHNvbWUsIG1hcCwga2V5cywgc2l6ZSwgdmFsdWVzLCBncm91cEJ5LCB1bmlxdWVCeSwgdW5pb25CeSwgc29ydEJ5LCBtYXRjaFBhdHRlcm4sIGRlYm91bmNlLCB0aHJvdHRsZSwgYmluZCwgaXNVbmRlZmluZWQsIGlzRGVmaW5lZCwgaXNOaWwsIGlzQXJyYXksIGlzT2JqZWN0LCBpc051bWJlciwgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGVuc3VyZUFycmF5LCBoYXMsIGFzc2lnbiwgcGljaywgb21pdCwgbWVyZ2UgfTtcbiIsIi8qKlxuICogU2V0IGF0dHJpYnV0ZSBgbmFtZWAgdG8gYHZhbGAsIG9yIGdldCBhdHRyIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IFt2YWxdXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBhdHRyKGVsLCBuYW1lLCB2YWwpIHtcbiAgLy8gZ2V0XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcbiAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICB9XG5cbiAgLy8gcmVtb3ZlXG4gIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZWwucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9XG5cbiAgLy8gc2V0XG4gIGVsLnNldEF0dHJpYnV0ZShuYW1lLCB2YWwpO1xuXG4gIHJldHVybiBlbDtcbn1cblxudmFyIGluZGV4T2YgPSBbXS5pbmRleE9mO1xuXG52YXIgaW5kZXhvZiA9IGZ1bmN0aW9uKGFyciwgb2JqKXtcbiAgaWYgKGluZGV4T2YpIHJldHVybiBhcnIuaW5kZXhPZihvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcblxuLyoqXG4gKiBUYWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9jb21wb25lbnQvY2xhc3Nlc1xuICpcbiAqIFdpdGhvdXQgdGhlIGNvbXBvbmVudCBiaXRzLlxuICovXG5cbi8qKlxuICogV2hpdGVzcGFjZSByZWdleHAuXG4gKi9cblxudmFyIHJlID0gL1xccysvO1xuXG4vKipcbiAqIHRvU3RyaW5nIHJlZmVyZW5jZS5cbiAqL1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIFdyYXAgYGVsYCBpbiBhIGBDbGFzc0xpc3RgLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY2xhc3NlcyhlbCkge1xuICByZXR1cm4gbmV3IENsYXNzTGlzdChlbCk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBDbGFzc0xpc3QgZm9yIGBlbGAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gQ2xhc3NMaXN0KGVsKSB7XG4gIGlmICghZWwgfHwgIWVsLm5vZGVUeXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBIERPTSBlbGVtZW50IHJlZmVyZW5jZSBpcyByZXF1aXJlZCcpO1xuICB9XG4gIHRoaXMuZWwgPSBlbDtcbiAgdGhpcy5saXN0ID0gZWwuY2xhc3NMaXN0O1xufVxuXG4vKipcbiAqIEFkZCBjbGFzcyBgbmFtZWAgaWYgbm90IGFscmVhZHkgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5DbGFzc0xpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIC8vIGNsYXNzTGlzdFxuICBpZiAodGhpcy5saXN0KSB7XG4gICAgdGhpcy5saXN0LmFkZChuYW1lKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGZhbGxiYWNrXG4gIHZhciBhcnIgPSB0aGlzLmFycmF5KCk7XG4gIHZhciBpID0gaW5kZXhvZihhcnIsIG5hbWUpO1xuICBpZiAoIX5pKSBhcnIucHVzaChuYW1lKTtcbiAgdGhpcy5lbC5jbGFzc05hbWUgPSBhcnIuam9pbignICcpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzIGBuYW1lYCB3aGVuIHByZXNlbnQsIG9yXG4gKiBwYXNzIGEgcmVndWxhciBleHByZXNzaW9uIHRvIHJlbW92ZVxuICogYW55IHdoaWNoIG1hdGNoLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gbmFtZVxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5DbGFzc0xpc3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmICgnW29iamVjdCBSZWdFeHBdJyA9PSB0b1N0cmluZy5jYWxsKG5hbWUpKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlTWF0Y2hpbmcobmFtZSk7XG4gIH1cblxuICAvLyBjbGFzc0xpc3RcbiAgaWYgKHRoaXMubGlzdCkge1xuICAgIHRoaXMubGlzdC5yZW1vdmUobmFtZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBmYWxsYmFja1xuICB2YXIgYXJyID0gdGhpcy5hcnJheSgpO1xuICB2YXIgaSA9IGluZGV4b2YoYXJyLCBuYW1lKTtcbiAgaWYgKH5pKSBhcnIuc3BsaWNlKGksIDEpO1xuICB0aGlzLmVsLmNsYXNzTmFtZSA9IGFyci5qb2luKCcgJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGNsYXNzZXMgbWF0Y2hpbmcgYHJlYC5cbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNsYXNzTGlzdC5wcm90b3R5cGUucmVtb3ZlTWF0Y2hpbmcgPSBmdW5jdGlvbiAocmUpIHtcbiAgdmFyIGFyciA9IHRoaXMuYXJyYXkoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocmUudGVzdChhcnJbaV0pKSB7XG4gICAgICB0aGlzLnJlbW92ZShhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVG9nZ2xlIGNsYXNzIGBuYW1lYCwgY2FuIGZvcmNlIHN0YXRlIHZpYSBgZm9yY2VgLlxuICpcbiAqIEZvciBicm93c2VycyB0aGF0IHN1cHBvcnQgY2xhc3NMaXN0LCBidXQgZG8gbm90IHN1cHBvcnQgYGZvcmNlYCB5ZXQsXG4gKiB0aGUgbWlzdGFrZSB3aWxsIGJlIGRldGVjdGVkIGFuZCBjb3JyZWN0ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2VcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ2xhc3NMaXN0LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAobmFtZSwgZm9yY2UpIHtcbiAgLy8gY2xhc3NMaXN0XG4gIGlmICh0aGlzLmxpc3QpIHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBmb3JjZSkge1xuICAgICAgaWYgKGZvcmNlICE9PSB0aGlzLmxpc3QudG9nZ2xlKG5hbWUsIGZvcmNlKSkge1xuICAgICAgICB0aGlzLmxpc3QudG9nZ2xlKG5hbWUpOyAvLyB0b2dnbGUgYWdhaW4gdG8gY29ycmVjdFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxpc3QudG9nZ2xlKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGZhbGxiYWNrXG4gIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGZvcmNlKSB7XG4gICAgaWYgKCFmb3JjZSkge1xuICAgICAgdGhpcy5yZW1vdmUobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkKG5hbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5oYXMobmFtZSkpIHtcbiAgICAgIHRoaXMucmVtb3ZlKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZChuYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IG9mIGNsYXNzZXMuXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNsYXNzTGlzdC5wcm90b3R5cGUuYXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjbGFzc05hbWUgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJztcbiAgdmFyIHN0ciA9IGNsYXNzTmFtZS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG4gIHZhciBhcnIgPSBzdHIuc3BsaXQocmUpO1xuICBpZiAoJycgPT09IGFyclswXSkgYXJyLnNoaWZ0KCk7XG4gIHJldHVybiBhcnI7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGNsYXNzIGBuYW1lYCBpcyBwcmVzZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtDbGFzc0xpc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNsYXNzTGlzdC5wcm90b3R5cGUuaGFzID0gQ2xhc3NMaXN0LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB0aGlzLmxpc3QgPyB0aGlzLmxpc3QuY29udGFpbnMobmFtZSkgOiAhIX5pbmRleG9mKHRoaXMuYXJyYXkoKSwgbmFtZSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgY2hpbGRyZW4gZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gY2xlYXIoZWwpIHtcblxuICB2YXIgYztcblxuICB3aGlsZSAoZWwuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICBjID0gZWwuY2hpbGROb2Rlc1swXTtcbiAgICBlbC5yZW1vdmVDaGlsZChjKTtcbiAgfVxuXG4gIHJldHVybiBlbDtcbn1cblxudmFyIHByb3RvID0gdHlwZW9mIEVsZW1lbnQgIT09ICd1bmRlZmluZWQnID8gRWxlbWVudC5wcm90b3R5cGUgOiB7fTtcbnZhciB2ZW5kb3IgPSBwcm90by5tYXRjaGVzXG4gIHx8IHByb3RvLm1hdGNoZXNTZWxlY3RvclxuICB8fCBwcm90by53ZWJraXRNYXRjaGVzU2VsZWN0b3JcbiAgfHwgcHJvdG8ubW96TWF0Y2hlc1NlbGVjdG9yXG4gIHx8IHByb3RvLm1zTWF0Y2hlc1NlbGVjdG9yXG4gIHx8IHByb3RvLm9NYXRjaGVzU2VsZWN0b3I7XG5cbnZhciBtYXRjaGVzU2VsZWN0b3IgPSBtYXRjaDtcblxuLyoqXG4gKiBNYXRjaCBgZWxgIHRvIGBzZWxlY3RvcmAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBtYXRjaChlbCwgc2VsZWN0b3IpIHtcbiAgaWYgKCFlbCB8fCBlbC5ub2RlVHlwZSAhPT0gMSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodmVuZG9yKSByZXR1cm4gdmVuZG9yLmNhbGwoZWwsIHNlbGVjdG9yKTtcbiAgdmFyIG5vZGVzID0gZWwucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChub2Rlc1tpXSA9PSBlbCkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENsb3Nlc3RcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY2hlY2tZb3VyU2VsZiAob3B0aW9uYWwpXG4gKi9cbmZ1bmN0aW9uIGNsb3Nlc3QgKGVsZW1lbnQsIHNlbGVjdG9yLCBjaGVja1lvdXJTZWxmKSB7XG4gIHZhciBjdXJyZW50RWxlbSA9IGNoZWNrWW91clNlbGYgPyBlbGVtZW50IDogZWxlbWVudC5wYXJlbnROb2RlO1xuXG4gIHdoaWxlIChjdXJyZW50RWxlbSAmJiBjdXJyZW50RWxlbS5ub2RlVHlwZSAhPT0gZG9jdW1lbnQuRE9DVU1FTlRfTk9ERSAmJiBjdXJyZW50RWxlbS5ub2RlVHlwZSAhPT0gZG9jdW1lbnQuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuXG4gICAgaWYgKG1hdGNoZXNTZWxlY3RvcihjdXJyZW50RWxlbSwgc2VsZWN0b3IpKSB7XG4gICAgICByZXR1cm4gY3VycmVudEVsZW07XG4gICAgfVxuXG4gICAgY3VycmVudEVsZW0gPSBjdXJyZW50RWxlbS5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXNTZWxlY3RvcihjdXJyZW50RWxlbSwgc2VsZWN0b3IpID8gY3VycmVudEVsZW0gOiBudWxsO1xufVxuXG4vKipcclxuICogRWxlbWVudCBwcm90b3R5cGUuXHJcbiAqL1xyXG5cclxudmFyIHByb3RvJDEgPSBFbGVtZW50LnByb3RvdHlwZTtcclxuXHJcbi8qKlxyXG4gKiBWZW5kb3IgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxudmFyIHZlbmRvciQxID0gcHJvdG8kMS5tYXRjaGVzU2VsZWN0b3JcclxuICB8fCBwcm90byQxLndlYmtpdE1hdGNoZXNTZWxlY3RvclxyXG4gIHx8IHByb3RvJDEubW96TWF0Y2hlc1NlbGVjdG9yXHJcbiAgfHwgcHJvdG8kMS5tc01hdGNoZXNTZWxlY3RvclxyXG4gIHx8IHByb3RvJDEub01hdGNoZXNTZWxlY3RvcjtcclxuXHJcbi8qKlxyXG4gKiBFeHBvc2UgYG1hdGNoKClgLlxyXG4gKi9cclxuXHJcbnZhciBtYXRjaGVzU2VsZWN0b3IkMSA9IG1hdGNoJDE7XHJcblxyXG4vKipcclxuICogTWF0Y2ggYGVsYCB0byBgc2VsZWN0b3JgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1hdGNoJDEoZWwsIHNlbGVjdG9yKSB7XHJcbiAgaWYgKHZlbmRvciQxKSByZXR1cm4gdmVuZG9yJDEuY2FsbChlbCwgc2VsZWN0b3IpO1xyXG4gIHZhciBub2RlcyA9IGVsLnBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7ICsraSkge1xyXG4gICAgaWYgKG5vZGVzW2ldID09IGVsKSByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XG5cbnZhciBjbG9zZXN0JDEgPSBmdW5jdGlvbiAoZWxlbWVudCwgc2VsZWN0b3IsIGNoZWNrWW9TZWxmKSB7XHJcbiAgdmFyIHBhcmVudCA9IGNoZWNrWW9TZWxmID8gZWxlbWVudCA6IGVsZW1lbnQucGFyZW50Tm9kZTtcclxuXHJcbiAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQgIT09IGRvY3VtZW50KSB7XHJcbiAgICBpZiAobWF0Y2hlc1NlbGVjdG9yJDEocGFyZW50LCBzZWxlY3RvcikpIHJldHVybiBwYXJlbnQ7XHJcbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcclxuICB9XHJcbn07XG5cbnZhciBiaW5kID0gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAnYXR0YWNoRXZlbnQnLFxuICAgIHVuYmluZCA9IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyID8gJ3JlbW92ZUV2ZW50TGlzdGVuZXInIDogJ2RldGFjaEV2ZW50JyxcbiAgICBwcmVmaXggPSBiaW5kICE9PSAnYWRkRXZlbnRMaXN0ZW5lcicgPyAnb24nIDogJyc7XG5cbi8qKlxuICogQmluZCBgZWxgIGV2ZW50IGB0eXBlYCB0byBgZm5gLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudmFyIGJpbmRfMSA9IGZ1bmN0aW9uKGVsLCB0eXBlLCBmbiwgY2FwdHVyZSl7XG4gIGVsW2JpbmRdKHByZWZpeCArIHR5cGUsIGZuLCBjYXB0dXJlIHx8IGZhbHNlKTtcbiAgcmV0dXJuIGZuO1xufTtcblxuLyoqXG4gKiBVbmJpbmQgYGVsYCBldmVudCBgdHlwZWAncyBjYWxsYmFjayBgZm5gLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudmFyIHVuYmluZF8xID0gZnVuY3Rpb24oZWwsIHR5cGUsIGZuLCBjYXB0dXJlKXtcbiAgZWxbdW5iaW5kXShwcmVmaXggKyB0eXBlLCBmbiwgY2FwdHVyZSB8fCBmYWxzZSk7XG4gIHJldHVybiBmbjtcbn07XG5cbnZhciBjb21wb25lbnRFdmVudCA9IHtcblx0YmluZDogYmluZF8xLFxuXHR1bmJpbmQ6IHVuYmluZF8xXG59O1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuXG5cbi8qKlxuICogRGVsZWdhdGUgZXZlbnQgYHR5cGVgIHRvIGBzZWxlY3RvcmBcbiAqIGFuZCBpbnZva2UgYGZuKGUpYC4gQSBjYWxsYmFjayBmdW5jdGlvblxuICogaXMgcmV0dXJuZWQgd2hpY2ggbWF5IGJlIHBhc3NlZCB0byBgLnVuYmluZCgpYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLy8gU29tZSBldmVudHMgZG9uJ3QgYnViYmxlLCBzbyB3ZSB3YW50IHRvIGJpbmQgdG8gdGhlIGNhcHR1cmUgcGhhc2UgaW5zdGVhZFxuLy8gd2hlbiBkZWxlZ2F0aW5nLlxudmFyIGZvcmNlQ2FwdHVyZUV2ZW50cyA9IFsnZm9jdXMnLCAnYmx1ciddO1xuXG52YXIgYmluZCQxID0gZnVuY3Rpb24oZWwsIHNlbGVjdG9yLCB0eXBlLCBmbiwgY2FwdHVyZSl7XG4gIGlmIChmb3JjZUNhcHR1cmVFdmVudHMuaW5kZXhPZih0eXBlKSAhPT0gLTEpIGNhcHR1cmUgPSB0cnVlO1xuXG4gIHJldHVybiBjb21wb25lbnRFdmVudC5iaW5kKGVsLCB0eXBlLCBmdW5jdGlvbihlKXtcbiAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuICAgIGUuZGVsZWdhdGVUYXJnZXQgPSBjbG9zZXN0JDEodGFyZ2V0LCBzZWxlY3RvciwgdHJ1ZSwgZWwpO1xuICAgIGlmIChlLmRlbGVnYXRlVGFyZ2V0KSBmbi5jYWxsKGVsLCBlKTtcbiAgfSwgY2FwdHVyZSk7XG59O1xuXG4vKipcbiAqIFVuYmluZCBldmVudCBgdHlwZWAncyBjYWxsYmFjayBgZm5gLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnZhciB1bmJpbmQkMSA9IGZ1bmN0aW9uKGVsLCB0eXBlLCBmbiwgY2FwdHVyZSl7XG4gIGlmIChmb3JjZUNhcHR1cmVFdmVudHMuaW5kZXhPZih0eXBlKSAhPT0gLTEpIGNhcHR1cmUgPSB0cnVlO1xuXG4gIGNvbXBvbmVudEV2ZW50LnVuYmluZChlbCwgdHlwZSwgZm4sIGNhcHR1cmUpO1xufTtcblxudmFyIGRlbGVnYXRlRXZlbnRzID0ge1xuXHRiaW5kOiBiaW5kJDEsXG5cdHVuYmluZDogdW5iaW5kJDFcbn07XG5cbi8qKlxuICogRXhwb3NlIGBwYXJzZWAuXG4gKi9cblxudmFyIGRvbWlmeSA9IHBhcnNlO1xuXG4vKipcbiAqIFRlc3RzIGZvciBicm93c2VyIHN1cHBvcnQuXG4gKi9cblxudmFyIGlubmVySFRNTEJ1ZyA9IGZhbHNlO1xudmFyIGJ1Z1Rlc3REaXY7XG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICBidWdUZXN0RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIC8vIFNldHVwXG4gIGJ1Z1Rlc3REaXYuaW5uZXJIVE1MID0gJyAgPGxpbmsvPjx0YWJsZT48L3RhYmxlPjxhIGhyZWY9XCIvYVwiPmE8L2E+PGlucHV0IHR5cGU9XCJjaGVja2JveFwiLz4nO1xuICAvLyBNYWtlIHN1cmUgdGhhdCBsaW5rIGVsZW1lbnRzIGdldCBzZXJpYWxpemVkIGNvcnJlY3RseSBieSBpbm5lckhUTUxcbiAgLy8gVGhpcyByZXF1aXJlcyBhIHdyYXBwZXIgZWxlbWVudCBpbiBJRVxuICBpbm5lckhUTUxCdWcgPSAhYnVnVGVzdERpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbGluaycpLmxlbmd0aDtcbiAgYnVnVGVzdERpdiA9IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBXcmFwIG1hcCBmcm9tIGpxdWVyeS5cbiAqL1xuXG52YXIgbWFwID0ge1xuICBsZWdlbmQ6IFsxLCAnPGZpZWxkc2V0PicsICc8L2ZpZWxkc2V0PiddLFxuICB0cjogWzIsICc8dGFibGU+PHRib2R5PicsICc8L3Rib2R5PjwvdGFibGU+J10sXG4gIGNvbDogWzIsICc8dGFibGU+PHRib2R5PjwvdGJvZHk+PGNvbGdyb3VwPicsICc8L2NvbGdyb3VwPjwvdGFibGU+J10sXG4gIC8vIGZvciBzY3JpcHQvbGluay9zdHlsZSB0YWdzIHRvIHdvcmsgaW4gSUU2LTgsIHlvdSBoYXZlIHRvIHdyYXBcbiAgLy8gaW4gYSBkaXYgd2l0aCBhIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlciBpbiBmcm9udCwgaGEhXG4gIF9kZWZhdWx0OiBpbm5lckhUTUxCdWcgPyBbMSwgJ1g8ZGl2PicsICc8L2Rpdj4nXSA6IFswLCAnJywgJyddXG59O1xuXG5tYXAudGQgPVxubWFwLnRoID0gWzMsICc8dGFibGU+PHRib2R5Pjx0cj4nLCAnPC90cj48L3Rib2R5PjwvdGFibGU+J107XG5cbm1hcC5vcHRpb24gPVxubWFwLm9wdGdyb3VwID0gWzEsICc8c2VsZWN0IG11bHRpcGxlPVwibXVsdGlwbGVcIj4nLCAnPC9zZWxlY3Q+J107XG5cbm1hcC50aGVhZCA9XG5tYXAudGJvZHkgPVxubWFwLmNvbGdyb3VwID1cbm1hcC5jYXB0aW9uID1cbm1hcC50Zm9vdCA9IFsxLCAnPHRhYmxlPicsICc8L3RhYmxlPiddO1xuXG5tYXAucG9seWxpbmUgPVxubWFwLmVsbGlwc2UgPVxubWFwLnBvbHlnb24gPVxubWFwLmNpcmNsZSA9XG5tYXAudGV4dCA9XG5tYXAubGluZSA9XG5tYXAucGF0aCA9XG5tYXAucmVjdCA9XG5tYXAuZyA9IFsxLCAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmVyc2lvbj1cIjEuMVwiPicsJzwvc3ZnPiddO1xuXG4vKipcbiAqIFBhcnNlIGBodG1sYCBhbmQgcmV0dXJuIGEgRE9NIE5vZGUgaW5zdGFuY2UsIHdoaWNoIGNvdWxkIGJlIGEgVGV4dE5vZGUsXG4gKiBIVE1MIERPTSBOb2RlIG9mIHNvbWUga2luZCAoPGRpdj4gZm9yIGV4YW1wbGUpLCBvciBhIERvY3VtZW50RnJhZ21lbnRcbiAqIGluc3RhbmNlLCBkZXBlbmRpbmcgb24gdGhlIGNvbnRlbnRzIG9mIHRoZSBgaHRtbGAgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sIC0gSFRNTCBzdHJpbmcgdG8gXCJkb21pZnlcIlxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jIC0gVGhlIGBkb2N1bWVudGAgaW5zdGFuY2UgdG8gY3JlYXRlIHRoZSBOb2RlIGZvclxuICogQHJldHVybiB7RE9NTm9kZX0gdGhlIFRleHROb2RlLCBET00gTm9kZSwgb3IgRG9jdW1lbnRGcmFnbWVudCBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2UoaHRtbCwgZG9jKSB7XG4gIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgaHRtbCkgdGhyb3cgbmV3IFR5cGVFcnJvcignU3RyaW5nIGV4cGVjdGVkJyk7XG5cbiAgLy8gZGVmYXVsdCB0byB0aGUgZ2xvYmFsIGBkb2N1bWVudGAgb2JqZWN0XG4gIGlmICghZG9jKSBkb2MgPSBkb2N1bWVudDtcblxuICAvLyB0YWcgbmFtZVxuICB2YXIgbSA9IC88KFtcXHc6XSspLy5leGVjKGh0bWwpO1xuICBpZiAoIW0pIHJldHVybiBkb2MuY3JlYXRlVGV4dE5vZGUoaHRtbCk7XG5cbiAgaHRtbCA9IGh0bWwucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpOyAvLyBSZW1vdmUgbGVhZGluZy90cmFpbGluZyB3aGl0ZXNwYWNlXG5cbiAgdmFyIHRhZyA9IG1bMV07XG5cbiAgLy8gYm9keSBzdXBwb3J0XG4gIGlmICh0YWcgPT0gJ2JvZHknKSB7XG4gICAgdmFyIGVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2h0bWwnKTtcbiAgICBlbC5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiBlbC5yZW1vdmVDaGlsZChlbC5sYXN0Q2hpbGQpO1xuICB9XG5cbiAgLy8gd3JhcCBtYXBcbiAgdmFyIHdyYXAgPSBtYXBbdGFnXSB8fCBtYXAuX2RlZmF1bHQ7XG4gIHZhciBkZXB0aCA9IHdyYXBbMF07XG4gIHZhciBwcmVmaXggPSB3cmFwWzFdO1xuICB2YXIgc3VmZml4ID0gd3JhcFsyXTtcbiAgdmFyIGVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBlbC5pbm5lckhUTUwgPSBwcmVmaXggKyBodG1sICsgc3VmZml4O1xuICB3aGlsZSAoZGVwdGgtLSkgZWwgPSBlbC5sYXN0Q2hpbGQ7XG5cbiAgLy8gb25lIGVsZW1lbnRcbiAgaWYgKGVsLmZpcnN0Q2hpbGQgPT0gZWwubGFzdENoaWxkKSB7XG4gICAgcmV0dXJuIGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgLy8gc2V2ZXJhbCBlbGVtZW50c1xuICB2YXIgZnJhZ21lbnQgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICB3aGlsZSAoZWwuZmlyc3RDaGlsZCkge1xuICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpKTtcbiAgfVxuXG4gIHJldHVybiBmcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gcXVlcnkoc2VsZWN0b3IsIGVsKSB7XG4gIGVsID0gZWwgfHwgZG9jdW1lbnQ7XG5cbiAgcmV0dXJuIGVsLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xufVxuXG5mdW5jdGlvbiBhbGwoc2VsZWN0b3IsIGVsKSB7XG4gIGVsID0gZWwgfHwgZG9jdW1lbnQ7XG5cbiAgcmV0dXJuIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoZWwpIHtcbiAgZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbn1cblxuZXhwb3J0IHsgYXR0ciwgY2xhc3NlcywgY2xlYXIsIGNsb3Nlc3QsIGRlbGVnYXRlRXZlbnRzIGFzIGRlbGVnYXRlLCBkb21pZnksIGNvbXBvbmVudEV2ZW50IGFzIGV2ZW50LCBtYXRjaGVzU2VsZWN0b3IgYXMgbWF0Y2hlcywgcXVlcnksIGFsbCBhcyBxdWVyeUFsbCwgcmVtb3ZlIH07XG4iLCJpbXBvcnQgeyBmb3JFYWNoLCBhc3NpZ24sIGZpbmQsIGZpbHRlciwgaXNTdHJpbmcsIG1hcCB9IGZyb20gJ21pbi1kYXNoJztcbmltcG9ydCB7IFBhcnNlciB9IGZyb20gJ3NheGVuJztcbmltcG9ydCB7IGNvZXJjZVR5cGUsIHBhcnNlTmFtZU5TLCBpc1NpbXBsZVR5cGUsIE1vZGRsZSB9IGZyb20gJ21vZGRsZSc7XG5cbmZ1bmN0aW9uIGhhc0xvd2VyQ2FzZUFsaWFzKHBrZykge1xuICByZXR1cm4gcGtnLnhtbCAmJiBwa2cueG1sLnRhZ0FsaWFzID09PSAnbG93ZXJDYXNlJztcbn1cblxudmFyIERFRkFVTFRfTlNfTUFQID0ge1xuICAneHNpJzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hLWluc3RhbmNlJ1xufTtcblxudmFyIFhTSV9UWVBFID0gJ3hzaTp0eXBlJztcblxuZnVuY3Rpb24gc2VyaWFsaXplRm9ybWF0KGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQueG1sICYmIGVsZW1lbnQueG1sLnNlcmlhbGl6ZTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplQXNUeXBlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHNlcmlhbGl6ZUZvcm1hdChlbGVtZW50KSA9PT0gWFNJX1RZUEU7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUFzUHJvcGVydHkoZWxlbWVudCkge1xuICByZXR1cm4gc2VyaWFsaXplRm9ybWF0KGVsZW1lbnQpID09PSAncHJvcGVydHknO1xufVxuXG5mdW5jdGlvbiBjYXBpdGFsaXplKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufVxuXG5mdW5jdGlvbiBhbGlhc1RvTmFtZShhbGlhc05zLCBwa2cpIHtcblxuICBpZiAoIWhhc0xvd2VyQ2FzZUFsaWFzKHBrZykpIHtcbiAgICByZXR1cm4gYWxpYXNOcy5uYW1lO1xuICB9XG5cbiAgcmV0dXJuIGFsaWFzTnMucHJlZml4ICsgJzonICsgY2FwaXRhbGl6ZShhbGlhc05zLmxvY2FsTmFtZSk7XG59XG5cbmZ1bmN0aW9uIHByZWZpeGVkVG9OYW1lKG5hbWVOcywgcGtnKSB7XG5cbiAgdmFyIG5hbWUgPSBuYW1lTnMubmFtZSxcbiAgICAgIGxvY2FsTmFtZSA9IG5hbWVOcy5sb2NhbE5hbWU7XG5cbiAgdmFyIHR5cGVQcmVmaXggPSBwa2cueG1sICYmIHBrZy54bWwudHlwZVByZWZpeDtcblxuICBpZiAodHlwZVByZWZpeCAmJiBsb2NhbE5hbWUuaW5kZXhPZih0eXBlUHJlZml4KSA9PT0gMCkge1xuICAgIHJldHVybiBuYW1lTnMucHJlZml4ICsgJzonICsgbG9jYWxOYW1lLnNsaWNlKHR5cGVQcmVmaXgubGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVYc2lUeXBlTmFtZShuYW1lLCBtb2RlbCkge1xuXG4gIHZhciBuYW1lTnMgPSBwYXJzZU5hbWVOUyhuYW1lKTtcbiAgdmFyIHBrZyA9IG1vZGVsLmdldFBhY2thZ2UobmFtZU5zLnByZWZpeCk7XG5cbiAgcmV0dXJuIHByZWZpeGVkVG9OYW1lKG5hbWVOcywgcGtnKTtcbn1cblxuZnVuY3Rpb24gZXJyb3IobWVzc2FnZSkge1xuICByZXR1cm4gbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbW9kZGxlIGRlc2NyaXB0b3IgZm9yIGEgZ2l2ZW4gaW5zdGFuY2Ugb3IgdHlwZS5cbiAqXG4gKiBAcGFyYW0gIHtNb2RkbGVFbGVtZW50fEZ1bmN0aW9ufSBlbGVtZW50XG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgbW9kZGxlIGRlc2NyaXB0b3JcbiAqL1xuZnVuY3Rpb24gZ2V0TW9kZGxlRGVzY3JpcHRvcihlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LiRkZXNjcmlwdG9yO1xufVxuXG5mdW5jdGlvbiBkZWZlcihmbikge1xuICBzZXRUaW1lb3V0KGZuLCAwKTtcbn1cblxuLyoqXG4gKiBBIHBhcnNlIGNvbnRleHQuXG4gKlxuICogQGNsYXNzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7RWxlbWVudEhhbmRsZXJ9IG9wdGlvbnMucm9vdEhhbmRsZXIgdGhlIHJvb3QgaGFuZGxlciBmb3IgcGFyc2luZyBhIGRvY3VtZW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxheD1mYWxzZV0gd2hldGhlciBvciBub3QgdG8gaWdub3JlIGludmFsaWQgZWxlbWVudHNcbiAqL1xuZnVuY3Rpb24gQ29udGV4dChvcHRpb25zKSB7XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB7RWxlbWVudEhhbmRsZXJ9IHJvb3RIYW5kbGVyXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGxheFxuICAgKi9cblxuICBhc3NpZ24odGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5lbGVtZW50c0J5SWQgPSB7fTtcbiAgdGhpcy5yZWZlcmVuY2VzID0gW107XG4gIHRoaXMud2FybmluZ3MgPSBbXTtcblxuICAvKipcbiAgICogQWRkIGFuIHVucmVzb2x2ZWQgcmVmZXJlbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVmZXJlbmNlXG4gICAqL1xuICB0aGlzLmFkZFJlZmVyZW5jZSA9IGZ1bmN0aW9uKHJlZmVyZW5jZSkge1xuICAgIHRoaXMucmVmZXJlbmNlcy5wdXNoKHJlZmVyZW5jZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIHByb2Nlc3NlZCBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge01vZGRsZUVsZW1lbnR9IGVsZW1lbnRcbiAgICovXG4gIHRoaXMuYWRkRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgdGhyb3cgZXJyb3IoJ2V4cGVjdGVkIGVsZW1lbnQnKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudHNCeUlkID0gdGhpcy5lbGVtZW50c0J5SWQ7XG5cbiAgICB2YXIgZGVzY3JpcHRvciA9IGdldE1vZGRsZURlc2NyaXB0b3IoZWxlbWVudCk7XG5cbiAgICB2YXIgaWRQcm9wZXJ0eSA9IGRlc2NyaXB0b3IuaWRQcm9wZXJ0eSxcbiAgICAgICAgaWQ7XG5cbiAgICBpZiAoaWRQcm9wZXJ0eSkge1xuICAgICAgaWQgPSBlbGVtZW50LmdldChpZFByb3BlcnR5Lm5hbWUpO1xuXG4gICAgICBpZiAoaWQpIHtcbiAgICAgICAgLy8gZm9yIFFOYW1lIHZhbGlkYXRpb24gYXMgcGVyIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy14bWwvI05ULU5hbWVDaGFyXG4gICAgICAgIGlmICghL14oW2Etel1bXFx3LS5dKjopP1thLXpfXVtcXHctLl0qJC9pLnRlc3QoaWQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbGxlZ2FsIElEIDwnICsgaWQgKyAnPicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsZW1lbnRzQnlJZFtpZF0pIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcignZHVwbGljYXRlIElEIDwnICsgaWQgKyAnPicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudHNCeUlkW2lkXSA9IGVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYW4gaW1wb3J0IHdhcm5pbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB3YXJuaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB3YXJuaW5nLm1lc3NhZ2VcbiAgICogQHBhcmFtIHtFcnJvcn0gW3dhcm5pbmcuZXJyb3JdXG4gICAqL1xuICB0aGlzLmFkZFdhcm5pbmcgPSBmdW5jdGlvbih3YXJuaW5nKSB7XG4gICAgdGhpcy53YXJuaW5ncy5wdXNoKHdhcm5pbmcpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBCYXNlSGFuZGxlcigpIHt9XG5cbkJhc2VIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVFbmQgPSBmdW5jdGlvbigpIHt9O1xuQmFzZUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZVRleHQgPSBmdW5jdGlvbigpIHt9O1xuQmFzZUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZU5vZGUgPSBmdW5jdGlvbigpIHt9O1xuXG5cbi8qKlxuICogQSBzaW1wbGUgcGFzcyB0aHJvdWdoIGhhbmRsZXIgdGhhdCBkb2VzIG5vdGhpbmcgZXhjZXB0IGZvclxuICogaWdub3JpbmcgYWxsIGlucHV0IGl0IHJlY2VpdmVzLlxuICpcbiAqIFRoaXMgaXMgdXNlZCB0byBpZ25vcmUgdW5rbm93biBlbGVtZW50cyBhbmRcbiAqIGF0dHJpYnV0ZXMuXG4gKi9cbmZ1bmN0aW9uIE5vb3BIYW5kbGVyKCkgeyB9XG5cbk5vb3BIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZUhhbmRsZXIucHJvdG90eXBlKTtcblxuTm9vcEhhbmRsZXIucHJvdG90eXBlLmhhbmRsZU5vZGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBCb2R5SGFuZGxlcigpIHt9XG5cbkJvZHlIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZUhhbmRsZXIucHJvdG90eXBlKTtcblxuQm9keUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZVRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHRoaXMuYm9keSA9ICh0aGlzLmJvZHkgfHwgJycpICsgdGV4dDtcbn07XG5cbmZ1bmN0aW9uIFJlZmVyZW5jZUhhbmRsZXIocHJvcGVydHksIGNvbnRleHQpIHtcbiAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xufVxuXG5SZWZlcmVuY2VIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQm9keUhhbmRsZXIucHJvdG90eXBlKTtcblxuUmVmZXJlbmNlSGFuZGxlci5wcm90b3R5cGUuaGFuZGxlTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcblxuICBpZiAodGhpcy5lbGVtZW50KSB7XG4gICAgdGhyb3cgZXJyb3IoJ2V4cGVjdGVkIG5vIHN1YiBub2RlcycpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZWxlbWVudCA9IHRoaXMuY3JlYXRlUmVmZXJlbmNlKG5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZWZlcmVuY2VIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVFbmQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbGVtZW50LmlkID0gdGhpcy5ib2R5O1xufTtcblxuUmVmZXJlbmNlSGFuZGxlci5wcm90b3R5cGUuY3JlYXRlUmVmZXJlbmNlID0gZnVuY3Rpb24obm9kZSkge1xuICByZXR1cm4ge1xuICAgIHByb3BlcnR5OiB0aGlzLnByb3BlcnR5Lm5zLm5hbWUsXG4gICAgaWQ6ICcnXG4gIH07XG59O1xuXG5mdW5jdGlvbiBWYWx1ZUhhbmRsZXIocHJvcGVydHlEZXNjLCBlbGVtZW50KSB7XG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIHRoaXMucHJvcGVydHlEZXNjID0gcHJvcGVydHlEZXNjO1xufVxuXG5WYWx1ZUhhbmRsZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCb2R5SGFuZGxlci5wcm90b3R5cGUpO1xuXG5WYWx1ZUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZUVuZCA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciB2YWx1ZSA9IHRoaXMuYm9keSB8fCAnJyxcbiAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICBwcm9wZXJ0eURlc2MgPSB0aGlzLnByb3BlcnR5RGVzYztcblxuICB2YWx1ZSA9IGNvZXJjZVR5cGUocHJvcGVydHlEZXNjLnR5cGUsIHZhbHVlKTtcblxuICBpZiAocHJvcGVydHlEZXNjLmlzTWFueSkge1xuICAgIGVsZW1lbnQuZ2V0KHByb3BlcnR5RGVzYy5uYW1lKS5wdXNoKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50LnNldChwcm9wZXJ0eURlc2MubmFtZSwgdmFsdWUpO1xuICB9XG59O1xuXG5cbmZ1bmN0aW9uIEJhc2VFbGVtZW50SGFuZGxlcigpIHt9XG5cbkJhc2VFbGVtZW50SGFuZGxlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJvZHlIYW5kbGVyLnByb3RvdHlwZSk7XG5cbkJhc2VFbGVtZW50SGFuZGxlci5wcm90b3R5cGUuaGFuZGxlTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdmFyIHBhcnNlciA9IHRoaXMsXG4gICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXG4gIGlmICghZWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQgPSB0aGlzLmNyZWF0ZUVsZW1lbnQobm9kZSk7XG5cbiAgICB0aGlzLmNvbnRleHQuYWRkRWxlbWVudChlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICBwYXJzZXIgPSB0aGlzLmhhbmRsZUNoaWxkKG5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlcjtcbn07XG5cbi8qKlxuICogQGNsYXNzIFJlYWRlci5FbGVtZW50SGFuZGxlclxuICpcbiAqL1xuZnVuY3Rpb24gRWxlbWVudEhhbmRsZXIobW9kZWwsIHR5cGVOYW1lLCBjb250ZXh0KSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgdGhpcy50eXBlID0gbW9kZWwuZ2V0VHlwZSh0eXBlTmFtZSk7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbkVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZUVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZSk7XG5cbkVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5hZGRSZWZlcmVuY2UgPSBmdW5jdGlvbihyZWZlcmVuY2UpIHtcbiAgdGhpcy5jb250ZXh0LmFkZFJlZmVyZW5jZShyZWZlcmVuY2UpO1xufTtcblxuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmhhbmRsZVRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XG5cbiAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICBkZXNjcmlwdG9yID0gZ2V0TW9kZGxlRGVzY3JpcHRvcihlbGVtZW50KSxcbiAgICAgIGJvZHlQcm9wZXJ0eSA9IGRlc2NyaXB0b3IuYm9keVByb3BlcnR5O1xuXG4gIGlmICghYm9keVByb3BlcnR5KSB7XG4gICAgdGhyb3cgZXJyb3IoJ3VuZXhwZWN0ZWQgYm9keSB0ZXh0IDwnICsgdGV4dCArICc+Jyk7XG4gIH1cblxuICBCb2R5SGFuZGxlci5wcm90b3R5cGUuaGFuZGxlVGV4dC5jYWxsKHRoaXMsIHRleHQpO1xufTtcblxuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmhhbmRsZUVuZCA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciB2YWx1ZSA9IHRoaXMuYm9keSxcbiAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICBkZXNjcmlwdG9yID0gZ2V0TW9kZGxlRGVzY3JpcHRvcihlbGVtZW50KSxcbiAgICAgIGJvZHlQcm9wZXJ0eSA9IGRlc2NyaXB0b3IuYm9keVByb3BlcnR5O1xuXG4gIGlmIChib2R5UHJvcGVydHkgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gY29lcmNlVHlwZShib2R5UHJvcGVydHkudHlwZSwgdmFsdWUpO1xuICAgIGVsZW1lbnQuc2V0KGJvZHlQcm9wZXJ0eS5uYW1lLCB2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoZSBtb2RlbCBmcm9tIHRoZSBnaXZlbiBub2RlLlxuICpcbiAqIEBwYXJhbSAge0VsZW1lbnR9IG5vZGUgdGhlIHhtbCBub2RlXG4gKi9cbkVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB2YXIgYXR0cmlidXRlcyA9IG5vZGUuYXR0cmlidXRlcyxcbiAgICAgIFR5cGUgPSB0aGlzLnR5cGUsXG4gICAgICBkZXNjcmlwdG9yID0gZ2V0TW9kZGxlRGVzY3JpcHRvcihUeXBlKSxcbiAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQsXG4gICAgICBpbnN0YW5jZSA9IG5ldyBUeXBlKHt9KSxcbiAgICAgIG1vZGVsID0gdGhpcy5tb2RlbCxcbiAgICAgIHByb3BOYW1lTnM7XG5cbiAgZm9yRWFjaChhdHRyaWJ1dGVzLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuXG4gICAgdmFyIHByb3AgPSBkZXNjcmlwdG9yLnByb3BlcnRpZXNCeU5hbWVbbmFtZV0sXG4gICAgICAgIHZhbHVlcztcblxuICAgIGlmIChwcm9wICYmIHByb3AuaXNSZWZlcmVuY2UpIHtcblxuICAgICAgaWYgKCFwcm9wLmlzTWFueSkge1xuICAgICAgICBjb250ZXh0LmFkZFJlZmVyZW5jZSh7XG4gICAgICAgICAgZWxlbWVudDogaW5zdGFuY2UsXG4gICAgICAgICAgcHJvcGVydHk6IHByb3AubnMubmFtZSxcbiAgICAgICAgICBpZDogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJRFJFRlM6IHBhcnNlIHJlZmVyZW5jZXMgYXMgd2hpdGVzcGFjZS1zZXBhcmF0ZWQgbGlzdFxuICAgICAgICB2YWx1ZXMgPSB2YWx1ZS5zcGxpdCgnICcpO1xuXG4gICAgICAgIGZvckVhY2godmFsdWVzLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgY29udGV4dC5hZGRSZWZlcmVuY2Uoe1xuICAgICAgICAgICAgZWxlbWVudDogaW5zdGFuY2UsXG4gICAgICAgICAgICBwcm9wZXJ0eTogcHJvcC5ucy5uYW1lLFxuICAgICAgICAgICAgaWQ6IHZcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgdmFsdWUgPSBjb2VyY2VUeXBlKHByb3AudHlwZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlXG4gICAgICBpZiAobmFtZSAhPT0gJ3htbG5zJykge1xuICAgICAgICBwcm9wTmFtZU5zID0gcGFyc2VOYW1lTlMobmFtZSwgZGVzY3JpcHRvci5ucy5wcmVmaXgpO1xuXG4gICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgYXR0cmlidXRlIGlzIGRlZmluZWQgaW4gYSB3ZWxsLWtub3duIG5hbWVzcGFjZVxuICAgICAgICAvLyBpZiB0aGF0IGlzIHRoZSBjYXNlIHdlIGVtaXQgYSB3YXJuaW5nIHRvIGluZGljYXRlIHBvdGVudGlhbCBtaXN1c2VcbiAgICAgICAgaWYgKG1vZGVsLmdldFBhY2thZ2UocHJvcE5hbWVOcy5wcmVmaXgpKSB7XG5cbiAgICAgICAgICBjb250ZXh0LmFkZFdhcm5pbmcoe1xuICAgICAgICAgICAgbWVzc2FnZTogJ3Vua25vd24gYXR0cmlidXRlIDwnICsgbmFtZSArICc+JyxcbiAgICAgICAgICAgIGVsZW1lbnQ6IGluc3RhbmNlLFxuICAgICAgICAgICAgcHJvcGVydHk6IG5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbnN0YW5jZS5zZXQobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufTtcblxuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmdldFByb3BlcnR5Rm9yTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcblxuICB2YXIgbmFtZSA9IG5vZGUubmFtZTtcbiAgdmFyIG5hbWVOcyA9IHBhcnNlTmFtZU5TKG5hbWUpO1xuXG4gIHZhciB0eXBlID0gdGhpcy50eXBlLFxuICAgICAgbW9kZWwgPSB0aGlzLm1vZGVsLFxuICAgICAgZGVzY3JpcHRvciA9IGdldE1vZGRsZURlc2NyaXB0b3IodHlwZSk7XG5cbiAgdmFyIHByb3BlcnR5TmFtZSA9IG5hbWVOcy5uYW1lLFxuICAgICAgcHJvcGVydHkgPSBkZXNjcmlwdG9yLnByb3BlcnRpZXNCeU5hbWVbcHJvcGVydHlOYW1lXSxcbiAgICAgIGVsZW1lbnRUeXBlTmFtZSxcbiAgICAgIGVsZW1lbnRUeXBlO1xuXG4gIC8vIHNlYXJjaCBmb3IgcHJvcGVydGllcyBieSBuYW1lIGZpcnN0XG5cbiAgaWYgKHByb3BlcnR5KSB7XG5cbiAgICBpZiAoc2VyaWFsaXplQXNUeXBlKHByb3BlcnR5KSkge1xuICAgICAgZWxlbWVudFR5cGVOYW1lID0gbm9kZS5hdHRyaWJ1dGVzW1hTSV9UWVBFXTtcblxuICAgICAgLy8geHNpIHR5cGUgaXMgb3B0aW9uYWwsIGlmIGl0IGRvZXMgbm90IGV4aXN0cyB0aGVcbiAgICAgIC8vIGRlZmF1bHQgdHlwZSBpcyBhc3N1bWVkXG4gICAgICBpZiAoZWxlbWVudFR5cGVOYW1lKSB7XG5cbiAgICAgICAgLy8gdGFrZSBwb3NzaWJsZSB0eXBlIHByZWZpeGVzIGZyb20gWE1MXG4gICAgICAgIC8vIGludG8gYWNjb3VudCwgaS5lLjogeHNpOnR5cGU9XCJ0e0FjdHVhbFR5cGV9XCJcbiAgICAgICAgZWxlbWVudFR5cGVOYW1lID0gbm9ybWFsaXplWHNpVHlwZU5hbWUoZWxlbWVudFR5cGVOYW1lLCBtb2RlbCk7XG5cbiAgICAgICAgZWxlbWVudFR5cGUgPSBtb2RlbC5nZXRUeXBlKGVsZW1lbnRUeXBlTmFtZSk7XG5cbiAgICAgICAgcmV0dXJuIGFzc2lnbih7fSwgcHJvcGVydHksIHtcbiAgICAgICAgICBlZmZlY3RpdmVUeXBlOiBnZXRNb2RkbGVEZXNjcmlwdG9yKGVsZW1lbnRUeXBlKS5uYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNlYXJjaCBmb3IgcHJvcGVydGllcyBieSBuYW1lIGZpcnN0XG4gICAgcmV0dXJuIHByb3BlcnR5O1xuICB9XG5cbiAgdmFyIHBrZyA9IG1vZGVsLmdldFBhY2thZ2UobmFtZU5zLnByZWZpeCk7XG5cbiAgaWYgKHBrZykge1xuICAgIGVsZW1lbnRUeXBlTmFtZSA9IGFsaWFzVG9OYW1lKG5hbWVOcywgcGtnKTtcbiAgICBlbGVtZW50VHlwZSA9IG1vZGVsLmdldFR5cGUoZWxlbWVudFR5cGVOYW1lKTtcblxuICAgIC8vIHNlYXJjaCBmb3IgY29sbGVjdGlvbiBtZW1iZXJzIGxhdGVyXG4gICAgcHJvcGVydHkgPSBmaW5kKGRlc2NyaXB0b3IucHJvcGVydGllcywgZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuICFwLmlzVmlydHVhbCAmJiAhcC5pc1JlZmVyZW5jZSAmJiAhcC5pc0F0dHJpYnV0ZSAmJiBlbGVtZW50VHlwZS5oYXNUeXBlKHAudHlwZSk7XG4gICAgfSk7XG5cbiAgICBpZiAocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiBhc3NpZ24oe30sIHByb3BlcnR5LCB7XG4gICAgICAgIGVmZmVjdGl2ZVR5cGU6IGdldE1vZGRsZURlc2NyaXB0b3IoZWxlbWVudFR5cGUpLm5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBwYXJzZSB1bmtub3duIGVsZW1lbnQgKG1heWJlIGV4dGVuc2lvbilcbiAgICBwcm9wZXJ0eSA9IGZpbmQoZGVzY3JpcHRvci5wcm9wZXJ0aWVzLCBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gIXAuaXNSZWZlcmVuY2UgJiYgIXAuaXNBdHRyaWJ1dGUgJiYgcC50eXBlID09PSAnRWxlbWVudCc7XG4gICAgfSk7XG5cbiAgICBpZiAocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBlcnJvcigndW5yZWNvZ25pemVkIGVsZW1lbnQgPCcgKyBuYW1lTnMubmFtZSArICc+Jyk7XG59O1xuXG5FbGVtZW50SGFuZGxlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICdFbGVtZW50RGVzY3JpcHRvclsnICsgZ2V0TW9kZGxlRGVzY3JpcHRvcih0aGlzLnR5cGUpLm5hbWUgKyAnXSc7XG59O1xuXG5FbGVtZW50SGFuZGxlci5wcm90b3R5cGUudmFsdWVIYW5kbGVyID0gZnVuY3Rpb24ocHJvcGVydHlEZXNjLCBlbGVtZW50KSB7XG4gIHJldHVybiBuZXcgVmFsdWVIYW5kbGVyKHByb3BlcnR5RGVzYywgZWxlbWVudCk7XG59O1xuXG5FbGVtZW50SGFuZGxlci5wcm90b3R5cGUucmVmZXJlbmNlSGFuZGxlciA9IGZ1bmN0aW9uKHByb3BlcnR5RGVzYykge1xuICByZXR1cm4gbmV3IFJlZmVyZW5jZUhhbmRsZXIocHJvcGVydHlEZXNjLCB0aGlzLmNvbnRleHQpO1xufTtcblxuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmhhbmRsZXIgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0eXBlID09PSAnRWxlbWVudCcpIHtcbiAgICByZXR1cm4gbmV3IEdlbmVyaWNFbGVtZW50SGFuZGxlcih0aGlzLm1vZGVsLCB0eXBlLCB0aGlzLmNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgRWxlbWVudEhhbmRsZXIodGhpcy5tb2RlbCwgdHlwZSwgdGhpcy5jb250ZXh0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGUgdGhlIGNoaWxkIGVsZW1lbnQgcGFyc2luZ1xuICpcbiAqIEBwYXJhbSAge0VsZW1lbnR9IG5vZGUgdGhlIHhtbCBub2RlXG4gKi9cbkVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVDaGlsZCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdmFyIHByb3BlcnR5RGVzYywgdHlwZSwgZWxlbWVudCwgY2hpbGRIYW5kbGVyO1xuXG4gIHByb3BlcnR5RGVzYyA9IHRoaXMuZ2V0UHJvcGVydHlGb3JOb2RlKG5vZGUpO1xuICBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXG4gIHR5cGUgPSBwcm9wZXJ0eURlc2MuZWZmZWN0aXZlVHlwZSB8fCBwcm9wZXJ0eURlc2MudHlwZTtcblxuICBpZiAoaXNTaW1wbGVUeXBlKHR5cGUpKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVIYW5kbGVyKHByb3BlcnR5RGVzYywgZWxlbWVudCk7XG4gIH1cblxuICBpZiAocHJvcGVydHlEZXNjLmlzUmVmZXJlbmNlKSB7XG4gICAgY2hpbGRIYW5kbGVyID0gdGhpcy5yZWZlcmVuY2VIYW5kbGVyKHByb3BlcnR5RGVzYykuaGFuZGxlTm9kZShub2RlKTtcbiAgfSBlbHNlIHtcbiAgICBjaGlsZEhhbmRsZXIgPSB0aGlzLmhhbmRsZXIodHlwZSkuaGFuZGxlTm9kZShub2RlKTtcbiAgfVxuXG4gIHZhciBuZXdFbGVtZW50ID0gY2hpbGRIYW5kbGVyLmVsZW1lbnQ7XG5cbiAgLy8gY2hpbGQgaGFuZGxlcyBtYXkgZGVjaWRlIHRvIHNraXAgZWxlbWVudHNcbiAgLy8gYnkgbm90IHJldHVybmluZyBhbnl0aGluZ1xuICBpZiAobmV3RWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICBpZiAocHJvcGVydHlEZXNjLmlzTWFueSkge1xuICAgICAgZWxlbWVudC5nZXQocHJvcGVydHlEZXNjLm5hbWUpLnB1c2gobmV3RWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuc2V0KHByb3BlcnR5RGVzYy5uYW1lLCBuZXdFbGVtZW50KTtcbiAgICB9XG5cbiAgICBpZiAocHJvcGVydHlEZXNjLmlzUmVmZXJlbmNlKSB7XG4gICAgICBhc3NpZ24obmV3RWxlbWVudCwge1xuICAgICAgICBlbGVtZW50OiBlbGVtZW50XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5jb250ZXh0LmFkZFJlZmVyZW5jZShuZXdFbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXN0YWJsaXNoIGNoaWxkIC0+IHBhcmVudCByZWxhdGlvbnNoaXBcbiAgICAgIG5ld0VsZW1lbnQuJHBhcmVudCA9IGVsZW1lbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNoaWxkSGFuZGxlcjtcbn07XG5cbi8qKlxuICogQW4gZWxlbWVudCBoYW5kbGVyIHRoYXQgcGVyZm9ybXMgc3BlY2lhbCB2YWxpZGF0aW9uXG4gKiB0byBlbnN1cmUgdGhlIG5vZGUgaXQgZ2V0cyBpbml0aWFsaXplZCB3aXRoIG1hdGNoZXNcbiAqIHRoZSBoYW5kbGVycyB0eXBlIChuYW1lc3BhY2Ugd2lzZSkuXG4gKlxuICogQHBhcmFtIHtNb2RkbGV9IG1vZGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZU5hbWVcbiAqIEBwYXJhbSB7Q29udGV4dH0gY29udGV4dFxuICovXG5mdW5jdGlvbiBSb290RWxlbWVudEhhbmRsZXIobW9kZWwsIHR5cGVOYW1lLCBjb250ZXh0KSB7XG4gIEVsZW1lbnRIYW5kbGVyLmNhbGwodGhpcywgbW9kZWwsIHR5cGVOYW1lLCBjb250ZXh0KTtcbn1cblxuUm9vdEVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRWxlbWVudEhhbmRsZXIucHJvdG90eXBlKTtcblxuUm9vdEVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuXG4gIHZhciBuYW1lID0gbm9kZS5uYW1lLFxuICAgICAgbmFtZU5zID0gcGFyc2VOYW1lTlMobmFtZSksXG4gICAgICBtb2RlbCA9IHRoaXMubW9kZWwsXG4gICAgICB0eXBlID0gdGhpcy50eXBlLFxuICAgICAgcGtnID0gbW9kZWwuZ2V0UGFja2FnZShuYW1lTnMucHJlZml4KSxcbiAgICAgIHR5cGVOYW1lID0gcGtnICYmIGFsaWFzVG9OYW1lKG5hbWVOcywgcGtnKSB8fCBuYW1lO1xuXG4gIC8vIHZlcmlmeSB0aGUgY29ycmVjdCBuYW1lc3BhY2UgaWYgd2UgcGFyc2VcbiAgLy8gdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGhhbmRsZXIgdHJlZVxuICAvL1xuICAvLyB0aGlzIGVuc3VyZXMgd2UgZG9uJ3QgbWlzdGFrZW5seSBpbXBvcnQgd3JvbmcgbmFtZXNwYWNlIGVsZW1lbnRzXG4gIGlmICghdHlwZS5oYXNUeXBlKHR5cGVOYW1lKSkge1xuICAgIHRocm93IGVycm9yKCd1bmV4cGVjdGVkIGVsZW1lbnQgPCcgKyBub2RlLm9yaWdpbmFsTmFtZSArICc+Jyk7XG4gIH1cblxuICByZXR1cm4gRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQuY2FsbCh0aGlzLCBub2RlKTtcbn07XG5cblxuZnVuY3Rpb24gR2VuZXJpY0VsZW1lbnRIYW5kbGVyKG1vZGVsLCB0eXBlTmFtZSwgY29udGV4dCkge1xuICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbkdlbmVyaWNFbGVtZW50SGFuZGxlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2VFbGVtZW50SGFuZGxlci5wcm90b3R5cGUpO1xuXG5HZW5lcmljRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG5cbiAgdmFyIG5hbWUgPSBub2RlLm5hbWUsXG4gICAgICBucyA9IHBhcnNlTmFtZU5TKG5hbWUpLFxuICAgICAgcHJlZml4ID0gbnMucHJlZml4LFxuICAgICAgdXJpID0gbm9kZS5uc1twcmVmaXggKyAnJHVyaSddLFxuICAgICAgYXR0cmlidXRlcyA9IG5vZGUuYXR0cmlidXRlcztcblxuICByZXR1cm4gdGhpcy5tb2RlbC5jcmVhdGVBbnkobmFtZSwgdXJpLCBhdHRyaWJ1dGVzKTtcbn07XG5cbkdlbmVyaWNFbGVtZW50SGFuZGxlci5wcm90b3R5cGUuaGFuZGxlQ2hpbGQgPSBmdW5jdGlvbihub2RlKSB7XG5cbiAgdmFyIGhhbmRsZXIgPSBuZXcgR2VuZXJpY0VsZW1lbnRIYW5kbGVyKHRoaXMubW9kZWwsICdFbGVtZW50JywgdGhpcy5jb250ZXh0KS5oYW5kbGVOb2RlKG5vZGUpLFxuICAgICAgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblxuICB2YXIgbmV3RWxlbWVudCA9IGhhbmRsZXIuZWxlbWVudCxcbiAgICAgIGNoaWxkcmVuO1xuXG4gIGlmIChuZXdFbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjaGlsZHJlbiA9IGVsZW1lbnQuJGNoaWxkcmVuID0gZWxlbWVudC4kY2hpbGRyZW4gfHwgW107XG4gICAgY2hpbGRyZW4ucHVzaChuZXdFbGVtZW50KTtcblxuICAgIC8vIGVzdGFibGlzaCBjaGlsZCAtPiBwYXJlbnQgcmVsYXRpb25zaGlwXG4gICAgbmV3RWxlbWVudC4kcGFyZW50ID0gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiBoYW5kbGVyO1xufTtcblxuR2VuZXJpY0VsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVFbmQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuYm9keSkge1xuICAgIHRoaXMuZWxlbWVudC4kYm9keSA9IHRoaXMuYm9keTtcbiAgfVxufTtcblxuLyoqXG4gKiBBIHJlYWRlciBmb3IgYSBtZXRhLW1vZGVsXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7TW9kZWx9IG9wdGlvbnMubW9kZWwgdXNlZCB0byByZWFkIHhtbCBmaWxlc1xuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmxheCB3aGV0aGVyIHRvIG1ha2UgcGFyc2UgZXJyb3JzIHdhcm5pbmdzXG4gKi9cbmZ1bmN0aW9uIFJlYWRlcihvcHRpb25zKSB7XG5cbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBNb2RkbGUpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgbW9kZWw6IG9wdGlvbnNcbiAgICB9O1xuICB9XG5cbiAgYXNzaWduKHRoaXMsIHsgbGF4OiBmYWxzZSB9LCBvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBYTUwgaW50byBhIG1vZGRsZSBkb2N1bWVudCB0cmVlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB4bWxcbiAqIEBwYXJhbSB7RWxlbWVudEhhbmRsZXJ8T2JqZWN0fSBvcHRpb25zIG9yIHJvb3RIYW5kbGVyXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZG9uZVxuICovXG5SZWFkZXIucHJvdG90eXBlLmZyb21YTUwgPSBmdW5jdGlvbih4bWwsIG9wdGlvbnMsIGRvbmUpIHtcblxuICB2YXIgcm9vdEhhbmRsZXIgPSBvcHRpb25zLnJvb3RIYW5kbGVyO1xuXG4gIGlmIChvcHRpb25zIGluc3RhbmNlb2YgRWxlbWVudEhhbmRsZXIpIHtcbiAgICAvLyByb290IGhhbmRsZXIgcGFzc2VkIHZpYSAoeG1sLCB7IHJvb3RIYW5kbGVyOiBFbGVtZW50SGFuZGxlciB9LCAuLi4pXG4gICAgcm9vdEhhbmRsZXIgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyByb290SGFuZGxlciBwYXNzZWQgdmlhICh4bWwsICdzb21lU3RyaW5nJywgLi4uKVxuICAgICAgcm9vdEhhbmRsZXIgPSB0aGlzLmhhbmRsZXIob3B0aW9ucyk7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygcm9vdEhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyByb290SGFuZGxlciBwYXNzZWQgdmlhICh4bWwsIHsgcm9vdEhhbmRsZXI6ICdzb21lU3RyaW5nJyB9LCAuLi4pXG4gICAgICByb290SGFuZGxlciA9IHRoaXMuaGFuZGxlcihyb290SGFuZGxlcik7XG4gICAgfVxuICB9XG5cbiAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbCxcbiAgICAgIGxheCA9IHRoaXMubGF4O1xuXG4gIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQoYXNzaWduKHt9LCBvcHRpb25zLCB7IHJvb3RIYW5kbGVyOiByb290SGFuZGxlciB9KSksXG4gICAgICBwYXJzZXIgPSBuZXcgUGFyc2VyKHsgcHJveHk6IHRydWUgfSksXG4gICAgICBzdGFjayA9IGNyZWF0ZVN0YWNrKCk7XG5cbiAgcm9vdEhhbmRsZXIuY29udGV4dCA9IGNvbnRleHQ7XG5cbiAgLy8gcHVzaCByb290IGhhbmRsZXJcbiAgc3RhY2sucHVzaChyb290SGFuZGxlcik7XG5cblxuICAvKipcbiAgICogSGFuZGxlIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gIHtFcnJvcn0gZXJyXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBnZXRDb250ZXh0XG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IGxheFxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGhhbmRsZWRcbiAgICovXG4gIGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVyciwgZ2V0Q29udGV4dCwgbGF4KSB7XG5cbiAgICB2YXIgY3R4ID0gZ2V0Q29udGV4dCgpO1xuXG4gICAgdmFyIGxpbmUgPSBjdHgubGluZSxcbiAgICAgICAgY29sdW1uID0gY3R4LmNvbHVtbixcbiAgICAgICAgZGF0YSA9IGN0eC5kYXRhO1xuXG4gICAgLy8gd2UgcmVjZWl2ZSB0aGUgZnVsbCBjb250ZXh0IGRhdGEgaGVyZSxcbiAgICAvLyBmb3IgZWxlbWVudHMgdHJpbSBkb3duIHRoZSBpbmZvcm1hdGlvblxuICAgIC8vIHRvIHRoZSB0YWcgbmFtZSwgb25seVxuICAgIGlmIChkYXRhLmNoYXJBdCgwKSA9PT0gJzwnICYmIGRhdGEuaW5kZXhPZignICcpICE9PSAtMSkge1xuICAgICAgZGF0YSA9IGRhdGEuc2xpY2UoMCwgZGF0YS5pbmRleE9mKCcgJykpICsgJz4nO1xuICAgIH1cblxuICAgIHZhciBtZXNzYWdlID1cbiAgICAgICd1bnBhcnNhYmxlIGNvbnRlbnQgJyArIChkYXRhID8gZGF0YSArICcgJyA6ICcnKSArICdkZXRlY3RlZFxcblxcdCcgK1xuICAgICAgICAnbGluZTogJyArIGxpbmUgKyAnXFxuXFx0JyArXG4gICAgICAgICdjb2x1bW46ICcgKyBjb2x1bW4gKyAnXFxuXFx0JyArXG4gICAgICAgICduZXN0ZWQgZXJyb3I6ICcgKyBlcnIubWVzc2FnZTtcblxuICAgIGlmIChsYXgpIHtcbiAgICAgIGNvbnRleHQuYWRkV2FybmluZyh7XG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgIGVycm9yOiBlcnJcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlV2FybmluZyhlcnIsIGdldENvbnRleHQpIHtcbiAgICAvLyBqdXN0IGxpa2UgaGFuZGxpbmcgZXJyb3JzIGluIDxsYXg9dHJ1ZT4gbW9kZVxuICAgIHJldHVybiBoYW5kbGVFcnJvcihlcnIsIGdldENvbnRleHQsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmUgY29sbGVjdGVkIHJlZmVyZW5jZXMgb24gcGFyc2UgZW5kLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVzb2x2ZVJlZmVyZW5jZXMoKSB7XG5cbiAgICB2YXIgZWxlbWVudHNCeUlkID0gY29udGV4dC5lbGVtZW50c0J5SWQ7XG4gICAgdmFyIHJlZmVyZW5jZXMgPSBjb250ZXh0LnJlZmVyZW5jZXM7XG5cbiAgICB2YXIgaSwgcjtcblxuICAgIGZvciAoaSA9IDA7IChyID0gcmVmZXJlbmNlc1tpXSk7IGkrKykge1xuICAgICAgdmFyIGVsZW1lbnQgPSByLmVsZW1lbnQ7XG4gICAgICB2YXIgcmVmZXJlbmNlID0gZWxlbWVudHNCeUlkW3IuaWRdO1xuICAgICAgdmFyIHByb3BlcnR5ID0gZ2V0TW9kZGxlRGVzY3JpcHRvcihlbGVtZW50KS5wcm9wZXJ0aWVzQnlOYW1lW3IucHJvcGVydHldO1xuXG4gICAgICBpZiAoIXJlZmVyZW5jZSkge1xuICAgICAgICBjb250ZXh0LmFkZFdhcm5pbmcoe1xuICAgICAgICAgIG1lc3NhZ2U6ICd1bnJlc29sdmVkIHJlZmVyZW5jZSA8JyArIHIuaWQgKyAnPicsXG4gICAgICAgICAgZWxlbWVudDogci5lbGVtZW50LFxuICAgICAgICAgIHByb3BlcnR5OiByLnByb3BlcnR5LFxuICAgICAgICAgIHZhbHVlOiByLmlkXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcGVydHkuaXNNYW55KSB7XG4gICAgICAgIHZhciBjb2xsZWN0aW9uID0gZWxlbWVudC5nZXQocHJvcGVydHkubmFtZSksXG4gICAgICAgICAgICBpZHggPSBjb2xsZWN0aW9uLmluZGV4T2Yocik7XG5cbiAgICAgICAgLy8gd2UgcmVwbGFjZSBhbiBleGlzdGluZyBwbGFjZSBob2xkZXIgKGlkeCAhPSAtMSkgb3JcbiAgICAgICAgLy8gYXBwZW5kIHRvIHRoZSBjb2xsZWN0aW9uIGluc3RlYWRcbiAgICAgICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgICBpZHggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVmZXJlbmNlKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHVucmVzb2x2YWJsZSByZWZlcmVuY2VcbiAgICAgICAgICBjb2xsZWN0aW9uLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGFkZCBvciB1cGRhdGUgcmVmZXJlbmNlIGluIGNvbGxlY3Rpb25cbiAgICAgICAgICBjb2xsZWN0aW9uW2lkeF0gPSByZWZlcmVuY2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2V0KHByb3BlcnR5Lm5hbWUsIHJlZmVyZW5jZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ2xvc2UoKSB7XG4gICAgc3RhY2sucG9wKCkuaGFuZGxlRW5kKCk7XG4gIH1cblxuICB2YXIgUFJFQU1CTEVfU1RBUlRfUEFUVEVSTiA9IC9ePFxcP3htbCAvaTtcblxuICB2YXIgRU5DT0RJTkdfUEFUVEVSTiA9IC8gZW5jb2Rpbmc9XCIoW15cIl0rKVwiL2k7XG5cbiAgdmFyIFVURl84X1BBVFRFUk4gPSAvXnV0Zi04JC9pO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZVF1ZXN0aW9uKHF1ZXN0aW9uKSB7XG5cbiAgICBpZiAoIVBSRUFNQkxFX1NUQVJUX1BBVFRFUk4udGVzdChxdWVzdGlvbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2ggPSBFTkNPRElOR19QQVRURVJOLmV4ZWMocXVlc3Rpb24pO1xuICAgIHZhciBlbmNvZGluZyA9IG1hdGNoICYmIG1hdGNoWzFdO1xuXG4gICAgaWYgKCFlbmNvZGluZyB8fCBVVEZfOF9QQVRURVJOLnRlc3QoZW5jb2RpbmcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29udGV4dC5hZGRXYXJuaW5nKHtcbiAgICAgIG1lc3NhZ2U6XG4gICAgICAgICd1bnN1cHBvcnRlZCBkb2N1bWVudCBlbmNvZGluZyA8JyArIGVuY29kaW5nICsgJz4sICcgK1xuICAgICAgICAnZmFsbGluZyBiYWNrIHRvIFVURi04J1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlT3Blbihub2RlLCBnZXRDb250ZXh0KSB7XG4gICAgdmFyIGhhbmRsZXIgPSBzdGFjay5wZWVrKCk7XG5cbiAgICB0cnkge1xuICAgICAgc3RhY2sucHVzaChoYW5kbGVyLmhhbmRsZU5vZGUobm9kZSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuXG4gICAgICBpZiAoaGFuZGxlRXJyb3IoZXJyLCBnZXRDb250ZXh0LCBsYXgpKSB7XG4gICAgICAgIHN0YWNrLnB1c2gobmV3IE5vb3BIYW5kbGVyKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUNEYXRhKHRleHQsIGdldENvbnRleHQpIHtcblxuICAgIHRyeSB7XG4gICAgICBzdGFjay5wZWVrKCkuaGFuZGxlVGV4dCh0ZXh0KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGhhbmRsZVdhcm5pbmcoZXJyLCBnZXRDb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVUZXh0KHRleHQsIGdldENvbnRleHQpIHtcbiAgICAvLyBzdHJpcCB3aGl0ZXNwYWNlIG9ubHkgbm9kZXMsIGkuZS4gYmVmb3JlXG4gICAgLy8gPCFDREFUQVsgLi4uIF0+IHNlY3Rpb25zIGFuZCBpbiBiZXR3ZWVuIHRhZ3NcbiAgICB0ZXh0ID0gdGV4dC50cmltKCk7XG5cbiAgICBpZiAoIXRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBoYW5kbGVDRGF0YSh0ZXh0LCBnZXRDb250ZXh0KTtcbiAgfVxuXG4gIHZhciB1cmlNYXAgPSBtb2RlbC5nZXRQYWNrYWdlcygpLnJlZHVjZShmdW5jdGlvbih1cmlNYXAsIHApIHtcbiAgICB1cmlNYXBbcC51cmldID0gcC5wcmVmaXg7XG5cbiAgICByZXR1cm4gdXJpTWFwO1xuICB9LCB7fSk7XG5cbiAgcGFyc2VyXG4gICAgLm5zKHVyaU1hcClcbiAgICAub24oJ29wZW5UYWcnLCBmdW5jdGlvbihvYmosIGRlY29kZVN0ciwgc2VsZkNsb3NpbmcsIGdldENvbnRleHQpIHtcblxuICAgICAgLy8gZ3JhY2VmdWxseSBoYW5kbGUgdW5wYXJzYWJsZSBhdHRyaWJ1dGVzIChhdHRycz1mYWxzZSlcbiAgICAgIHZhciBhdHRycyA9IG9iai5hdHRycyB8fCB7fTtcblxuICAgICAgdmFyIGRlY29kZWRBdHRycyA9IE9iamVjdC5rZXlzKGF0dHJzKS5yZWR1Y2UoZnVuY3Rpb24oZCwga2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGRlY29kZVN0cihhdHRyc1trZXldKTtcblxuICAgICAgICBkW2tleV0gPSB2YWx1ZTtcblxuICAgICAgICByZXR1cm4gZDtcbiAgICAgIH0sIHt9KTtcblxuICAgICAgdmFyIG5vZGUgPSB7XG4gICAgICAgIG5hbWU6IG9iai5uYW1lLFxuICAgICAgICBvcmlnaW5hbE5hbWU6IG9iai5vcmlnaW5hbE5hbWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IGRlY29kZWRBdHRycyxcbiAgICAgICAgbnM6IG9iai5uc1xuICAgICAgfTtcblxuICAgICAgaGFuZGxlT3Blbihub2RlLCBnZXRDb250ZXh0KTtcbiAgICB9KVxuICAgIC5vbigncXVlc3Rpb24nLCBoYW5kbGVRdWVzdGlvbilcbiAgICAub24oJ2Nsb3NlVGFnJywgaGFuZGxlQ2xvc2UpXG4gICAgLm9uKCdjZGF0YScsIGhhbmRsZUNEYXRhKVxuICAgIC5vbigndGV4dCcsIGZ1bmN0aW9uKHRleHQsIGRlY29kZUVudGl0aWVzLCBnZXRDb250ZXh0KSB7XG4gICAgICBoYW5kbGVUZXh0KGRlY29kZUVudGl0aWVzKHRleHQpLCBnZXRDb250ZXh0KTtcbiAgICB9KVxuICAgIC5vbignZXJyb3InLCBoYW5kbGVFcnJvcilcbiAgICAub24oJ3dhcm4nLCBoYW5kbGVXYXJuaW5nKTtcblxuICAvLyBkZWZlcnJlZCBwYXJzZSBYTUwgdG8gbWFrZSBsb2FkaW5nIHJlYWxseSBhc2NuY2hyb25vdXNcbiAgLy8gdGhpcyBlbnN1cmVzIHRoZSBleGVjdXRpb24gZW52aXJvbm1lbnQgKG5vZGUgb3IgYnJvd3NlcilcbiAgLy8gaXMga2VwdCByZXNwb25zaXZlIGFuZCB0aGF0IGNlcnRhaW4gb3B0aW1pemF0aW9uIHN0cmF0ZWdpZXNcbiAgLy8gY2FuIGtpY2sgaW5cbiAgZGVmZXIoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGVycjtcblxuICAgIHRyeSB7XG4gICAgICBwYXJzZXIucGFyc2UoeG1sKTtcblxuICAgICAgcmVzb2x2ZVJlZmVyZW5jZXMoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnIgPSBlO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0gcm9vdEhhbmRsZXIuZWxlbWVudDtcblxuICAgIC8vIGhhbmRsZSB0aGUgc2l0dWF0aW9uIHRoYXQgd2UgY291bGQgbm90IGV4dHJhY3RcbiAgICAvLyB0aGUgZGVzaXJlZCByb290IGVsZW1lbnQgZnJvbSB0aGUgZG9jdW1lbnRcbiAgICBpZiAoIWVyciAmJiAhZWxlbWVudCkge1xuICAgICAgZXJyID0gZXJyb3IoJ2ZhaWxlZCB0byBwYXJzZSBkb2N1bWVudCBhcyA8JyArIHJvb3RIYW5kbGVyLnR5cGUuJGRlc2NyaXB0b3IubmFtZSArICc+Jyk7XG4gICAgfVxuXG4gICAgZG9uZShlcnIsIGVyciA/IHVuZGVmaW5lZCA6IGVsZW1lbnQsIGNvbnRleHQpO1xuICB9KTtcbn07XG5cblJlYWRlci5wcm90b3R5cGUuaGFuZGxlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBSb290RWxlbWVudEhhbmRsZXIodGhpcy5tb2RlbCwgbmFtZSk7XG59O1xuXG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gY3JlYXRlU3RhY2soKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdGFjaywgJ3BlZWsnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXNbdGhpcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBzdGFjaztcbn1cblxudmFyIFhNTF9QUkVBTUJMRSA9ICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiPz5cXG4nO1xuXG52YXIgRVNDQVBFX0FUVFJfQ0hBUlMgPSAvPHw+fCd8XCJ8JnxcXG5cXHJ8XFxuL2c7XG52YXIgRVNDQVBFX0NIQVJTID0gLzx8PnwmL2c7XG5cblxuZnVuY3Rpb24gTmFtZXNwYWNlcyhwYXJlbnQpIHtcblxuICB2YXIgcHJlZml4TWFwID0ge307XG4gIHZhciB1cmlNYXAgPSB7fTtcbiAgdmFyIHVzZWQgPSB7fTtcblxuICB2YXIgd2VsbGtub3duID0gW107XG4gIHZhciBjdXN0b20gPSBbXTtcblxuICAvLyBBUElcblxuICB0aGlzLmJ5VXJpID0gZnVuY3Rpb24odXJpKSB7XG4gICAgcmV0dXJuIHVyaU1hcFt1cmldIHx8IChcbiAgICAgIHBhcmVudCAmJiBwYXJlbnQuYnlVcmkodXJpKVxuICAgICk7XG4gIH07XG5cbiAgdGhpcy5hZGQgPSBmdW5jdGlvbihucywgaXNXZWxsa25vd24pIHtcblxuICAgIHVyaU1hcFtucy51cmldID0gbnM7XG5cbiAgICBpZiAoaXNXZWxsa25vd24pIHtcbiAgICAgIHdlbGxrbm93bi5wdXNoKG5zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VzdG9tLnB1c2gobnMpO1xuICAgIH1cblxuICAgIHRoaXMubWFwUHJlZml4KG5zLnByZWZpeCwgbnMudXJpKTtcbiAgfTtcblxuICB0aGlzLnVyaUJ5UHJlZml4ID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgcmV0dXJuIHByZWZpeE1hcFtwcmVmaXggfHwgJ3htbG5zJ107XG4gIH07XG5cbiAgdGhpcy5tYXBQcmVmaXggPSBmdW5jdGlvbihwcmVmaXgsIHVyaSkge1xuICAgIHByZWZpeE1hcFtwcmVmaXggfHwgJ3htbG5zJ10gPSB1cmk7XG4gIH07XG5cbiAgdGhpcy5sb2dVc2VkID0gZnVuY3Rpb24obnMpIHtcbiAgICB2YXIgdXJpID0gbnMudXJpO1xuXG4gICAgdXNlZFt1cmldID0gdGhpcy5ieVVyaSh1cmkpO1xuICB9O1xuXG4gIHRoaXMuZ2V0VXNlZCA9IGZ1bmN0aW9uKG5zKSB7XG5cbiAgICBmdW5jdGlvbiBpc1VzZWQobnMpIHtcbiAgICAgIHJldHVybiB1c2VkW25zLnVyaV07XG4gICAgfVxuXG4gICAgdmFyIGFsbE5zID0gW10uY29uY2F0KHdlbGxrbm93biwgY3VzdG9tKTtcblxuICAgIHJldHVybiBhbGxOcy5maWx0ZXIoaXNVc2VkKTtcbiAgfTtcblxufVxuXG5mdW5jdGlvbiBsb3dlcihzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbn1cblxuZnVuY3Rpb24gbmFtZVRvQWxpYXMobmFtZSwgcGtnKSB7XG4gIGlmIChoYXNMb3dlckNhc2VBbGlhcyhwa2cpKSB7XG4gICAgcmV0dXJuIGxvd2VyKG5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gbnNOYW1lKG5zKSB7XG4gIGlmIChpc1N0cmluZyhucykpIHtcbiAgICByZXR1cm4gbnM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChucy5wcmVmaXggPyBucy5wcmVmaXggKyAnOicgOiAnJykgKyBucy5sb2NhbE5hbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TnNBdHRycyhuYW1lc3BhY2VzKSB7XG5cbiAgcmV0dXJuIG1hcChuYW1lc3BhY2VzLmdldFVzZWQoKSwgZnVuY3Rpb24obnMpIHtcbiAgICB2YXIgbmFtZSA9ICd4bWxucycgKyAobnMucHJlZml4ID8gJzonICsgbnMucHJlZml4IDogJycpO1xuICAgIHJldHVybiB7IG5hbWU6IG5hbWUsIHZhbHVlOiBucy51cmkgfTtcbiAgfSk7XG5cbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudE5zKG5zLCBkZXNjcmlwdG9yKSB7XG4gIGlmIChkZXNjcmlwdG9yLmlzR2VuZXJpYykge1xuICAgIHJldHVybiBhc3NpZ24oeyBsb2NhbE5hbWU6IGRlc2NyaXB0b3IubnMubG9jYWxOYW1lIH0sIG5zKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXNzaWduKHsgbG9jYWxOYW1lOiBuYW1lVG9BbGlhcyhkZXNjcmlwdG9yLm5zLmxvY2FsTmFtZSwgZGVzY3JpcHRvci4kcGtnKSB9LCBucyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UHJvcGVydHlOcyhucywgZGVzY3JpcHRvcikge1xuICByZXR1cm4gYXNzaWduKHsgbG9jYWxOYW1lOiBkZXNjcmlwdG9yLm5zLmxvY2FsTmFtZSB9LCBucyk7XG59XG5cbmZ1bmN0aW9uIGdldFNlcmlhbGl6YWJsZVByb3BlcnRpZXMoZWxlbWVudCkge1xuICB2YXIgZGVzY3JpcHRvciA9IGVsZW1lbnQuJGRlc2NyaXB0b3I7XG5cbiAgcmV0dXJuIGZpbHRlcihkZXNjcmlwdG9yLnByb3BlcnRpZXMsIGZ1bmN0aW9uKHApIHtcbiAgICB2YXIgbmFtZSA9IHAubmFtZTtcblxuICAgIGlmIChwLmlzVmlydHVhbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGRvIG5vdCBzZXJpYWxpemUgZGVmYXVsdHNcbiAgICBpZiAoIWVsZW1lbnQuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBlbGVtZW50W25hbWVdO1xuXG4gICAgLy8gZG8gbm90IHNlcmlhbGl6ZSBkZWZhdWx0IGVxdWFsc1xuICAgIGlmICh2YWx1ZSA9PT0gcC5kZWZhdWx0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gZG8gbm90IHNlcmlhbGl6ZSBudWxsIHByb3BlcnRpZXNcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcC5pc01hbnkgPyB2YWx1ZS5sZW5ndGggOiB0cnVlO1xuICB9KTtcbn1cblxudmFyIEVTQ0FQRV9BVFRSX01BUCA9IHtcbiAgJ1xcbic6ICcjMTAnLFxuICAnXFxuXFxyJzogJyMxMCcsXG4gICdcIic6ICcjMzQnLFxuICAnXFwnJzogJyMzOScsXG4gICc8JzogJyM2MCcsXG4gICc+JzogJyM2MicsXG4gICcmJzogJyMzOCdcbn07XG5cbnZhciBFU0NBUEVfTUFQID0ge1xuICAnPCc6ICdsdCcsXG4gICc+JzogJ2d0JyxcbiAgJyYnOiAnYW1wJ1xufTtcblxuZnVuY3Rpb24gZXNjYXBlKHN0ciwgY2hhclBhdHRlcm4sIHJlcGxhY2VNYXApIHtcblxuICAvLyBlbnN1cmUgd2UgYXJlIGhhbmRsaW5nIHN0cmluZ3MgaGVyZVxuICBzdHIgPSBpc1N0cmluZyhzdHIpID8gc3RyIDogJycgKyBzdHI7XG5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNoYXJQYXR0ZXJuLCBmdW5jdGlvbihzKSB7XG4gICAgcmV0dXJuICcmJyArIHJlcGxhY2VNYXBbc10gKyAnOyc7XG4gIH0pO1xufVxuXG4vKipcbiAqIEVzY2FwZSBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gbm90IGNvbnRhaW4gYW55IGJhZCB2YWx1ZXMgKGxpbmUgYnJlYWtzLCAnXCInLCAuLi4pXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIGVzY2FwZVxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgZXNjYXBlZCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZXNjYXBlQXR0cihzdHIpIHtcbiAgcmV0dXJuIGVzY2FwZShzdHIsIEVTQ0FQRV9BVFRSX0NIQVJTLCBFU0NBUEVfQVRUUl9NQVApO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVCb2R5KHN0cikge1xuICByZXR1cm4gZXNjYXBlKHN0ciwgRVNDQVBFX0NIQVJTLCBFU0NBUEVfTUFQKTtcbn1cblxuZnVuY3Rpb24gZmlsdGVyQXR0cmlidXRlcyhwcm9wcykge1xuICByZXR1cm4gZmlsdGVyKHByb3BzLCBmdW5jdGlvbihwKSB7IHJldHVybiBwLmlzQXR0cjsgfSk7XG59XG5cbmZ1bmN0aW9uIGZpbHRlckNvbnRhaW5lZChwcm9wcykge1xuICByZXR1cm4gZmlsdGVyKHByb3BzLCBmdW5jdGlvbihwKSB7IHJldHVybiAhcC5pc0F0dHI7IH0pO1xufVxuXG5cbmZ1bmN0aW9uIFJlZmVyZW5jZVNlcmlhbGl6ZXIodGFnTmFtZSkge1xuICB0aGlzLnRhZ05hbWUgPSB0YWdOYW1lO1xufVxuXG5SZWZlcmVuY2VTZXJpYWxpemVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZWZlcmVuY2VTZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemVUbyA9IGZ1bmN0aW9uKHdyaXRlcikge1xuICB3cml0ZXJcbiAgICAuYXBwZW5kSW5kZW50KClcbiAgICAuYXBwZW5kKCc8JyArIHRoaXMudGFnTmFtZSArICc+JyArIHRoaXMuZWxlbWVudC5pZCArICc8LycgKyB0aGlzLnRhZ05hbWUgKyAnPicpXG4gICAgLmFwcGVuZE5ld0xpbmUoKTtcbn07XG5cbmZ1bmN0aW9uIEJvZHlTZXJpYWxpemVyKCkge31cblxuQm9keVNlcmlhbGl6ZXIucHJvdG90eXBlLnNlcmlhbGl6ZVZhbHVlID1cbkJvZHlTZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemVUbyA9IGZ1bmN0aW9uKHdyaXRlcikge1xuICB3cml0ZXIuYXBwZW5kKFxuICAgIHRoaXMuZXNjYXBlXG4gICAgICA/IGVzY2FwZUJvZHkodGhpcy52YWx1ZSlcbiAgICAgIDogdGhpcy52YWx1ZVxuICApO1xufTtcblxuQm9keVNlcmlhbGl6ZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24ocHJvcCwgdmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuXG4gIGlmIChwcm9wLnR5cGUgPT09ICdTdHJpbmcnICYmIHZhbHVlLnNlYXJjaChFU0NBUEVfQ0hBUlMpICE9PSAtMSkge1xuICAgIHRoaXMuZXNjYXBlID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gVmFsdWVTZXJpYWxpemVyKHRhZ05hbWUpIHtcbiAgdGhpcy50YWdOYW1lID0gdGFnTmFtZTtcbn1cblxuaW5oZXJpdHMoVmFsdWVTZXJpYWxpemVyLCBCb2R5U2VyaWFsaXplcik7XG5cblZhbHVlU2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplVG8gPSBmdW5jdGlvbih3cml0ZXIpIHtcblxuICB3cml0ZXJcbiAgICAuYXBwZW5kSW5kZW50KClcbiAgICAuYXBwZW5kKCc8JyArIHRoaXMudGFnTmFtZSArICc+Jyk7XG5cbiAgdGhpcy5zZXJpYWxpemVWYWx1ZSh3cml0ZXIpO1xuXG4gIHdyaXRlclxuICAgIC5hcHBlbmQoJzwvJyArIHRoaXMudGFnTmFtZSArICc+JylcbiAgICAuYXBwZW5kTmV3TGluZSgpO1xufTtcblxuZnVuY3Rpb24gRWxlbWVudFNlcmlhbGl6ZXIocGFyZW50LCBwcm9wZXJ0eURlc2NyaXB0b3IpIHtcbiAgdGhpcy5ib2R5ID0gW107XG4gIHRoaXMuYXR0cnMgPSBbXTtcblxuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5wcm9wZXJ0eURlc2NyaXB0b3IgPSBwcm9wZXJ0eURlc2NyaXB0b3I7XG59XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcblxuICB2YXIgZWxlbWVudERlc2NyaXB0b3IgPSBlbGVtZW50LiRkZXNjcmlwdG9yLFxuICAgICAgcHJvcGVydHlEZXNjcmlwdG9yID0gdGhpcy5wcm9wZXJ0eURlc2NyaXB0b3I7XG5cbiAgdmFyIG90aGVyQXR0cnMsXG4gICAgICBwcm9wZXJ0aWVzO1xuXG4gIHZhciBpc0dlbmVyaWMgPSBlbGVtZW50RGVzY3JpcHRvci5pc0dlbmVyaWM7XG5cbiAgaWYgKGlzR2VuZXJpYykge1xuICAgIG90aGVyQXR0cnMgPSB0aGlzLnBhcnNlR2VuZXJpYyhlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICBvdGhlckF0dHJzID0gdGhpcy5wYXJzZU5zQXR0cmlidXRlcyhlbGVtZW50KTtcbiAgfVxuXG4gIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IpIHtcbiAgICB0aGlzLm5zID0gdGhpcy5uc1Byb3BlcnR5VGFnTmFtZShwcm9wZXJ0eURlc2NyaXB0b3IpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubnMgPSB0aGlzLm5zVGFnTmFtZShlbGVtZW50RGVzY3JpcHRvcik7XG4gIH1cblxuICAvLyBjb21wdXRlIHRhZyBuYW1lXG4gIHRoaXMudGFnTmFtZSA9IHRoaXMuYWRkVGFnTmFtZSh0aGlzLm5zKTtcblxuICBpZiAoIWlzR2VuZXJpYykge1xuICAgIHByb3BlcnRpZXMgPSBnZXRTZXJpYWxpemFibGVQcm9wZXJ0aWVzKGVsZW1lbnQpO1xuXG4gICAgdGhpcy5wYXJzZUF0dHJpYnV0ZXMoZmlsdGVyQXR0cmlidXRlcyhwcm9wZXJ0aWVzKSk7XG4gICAgdGhpcy5wYXJzZUNvbnRhaW5tZW50cyhmaWx0ZXJDb250YWluZWQocHJvcGVydGllcykpO1xuICB9XG5cbiAgdGhpcy5wYXJzZUdlbmVyaWNBdHRyaWJ1dGVzKGVsZW1lbnQsIG90aGVyQXR0cnMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLm5zVGFnTmFtZSA9IGZ1bmN0aW9uKGRlc2NyaXB0b3IpIHtcbiAgdmFyIGVmZmVjdGl2ZU5zID0gdGhpcy5sb2dOYW1lc3BhY2VVc2VkKGRlc2NyaXB0b3IubnMpO1xuICByZXR1cm4gZ2V0RWxlbWVudE5zKGVmZmVjdGl2ZU5zLCBkZXNjcmlwdG9yKTtcbn07XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5uc1Byb3BlcnR5VGFnTmFtZSA9IGZ1bmN0aW9uKGRlc2NyaXB0b3IpIHtcbiAgdmFyIGVmZmVjdGl2ZU5zID0gdGhpcy5sb2dOYW1lc3BhY2VVc2VkKGRlc2NyaXB0b3IubnMpO1xuICByZXR1cm4gZ2V0UHJvcGVydHlOcyhlZmZlY3RpdmVOcywgZGVzY3JpcHRvcik7XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUuaXNMb2NhbE5zID0gZnVuY3Rpb24obnMpIHtcbiAgcmV0dXJuIG5zLnVyaSA9PT0gdGhpcy5ucy51cmk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYWN0dWFsIG5zIGF0dHJpYnV0ZSBuYW1lIGZvciB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudFxuICogQHBhcmFtIHtCb29sZWFufSBbZWxlbWVudC5pbmhlcml0ZWQ9ZmFsc2VdXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBuc05hbWVcbiAqL1xuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLm5zQXR0cmlidXRlTmFtZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICB2YXIgbnM7XG5cbiAgaWYgKGlzU3RyaW5nKGVsZW1lbnQpKSB7XG4gICAgbnMgPSBwYXJzZU5hbWVOUyhlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICBucyA9IGVsZW1lbnQubnM7XG4gIH1cblxuICAvLyByZXR1cm4ganVzdCBsb2NhbCBuYW1lIGZvciBpbmhlcml0ZWQgYXR0cmlidXRlc1xuICBpZiAoZWxlbWVudC5pbmhlcml0ZWQpIHtcbiAgICByZXR1cm4geyBsb2NhbE5hbWU6IG5zLmxvY2FsTmFtZSB9O1xuICB9XG5cbiAgLy8gcGFyc2UgKyBsb2cgZWZmZWN0aXZlIG5zXG4gIHZhciBlZmZlY3RpdmVOcyA9IHRoaXMubG9nTmFtZXNwYWNlVXNlZChucyk7XG5cbiAgLy8gTE9HIEFDVFVBTCBuYW1lc3BhY2UgdXNlXG4gIHRoaXMuZ2V0TmFtZXNwYWNlcygpLmxvZ1VzZWQoZWZmZWN0aXZlTnMpO1xuXG4gIC8vIHN0cmlwIHByZWZpeCBpZiBzYW1lIG5hbWVzcGFjZSBsaWtlIHBhcmVudFxuICBpZiAodGhpcy5pc0xvY2FsTnMoZWZmZWN0aXZlTnMpKSB7XG4gICAgcmV0dXJuIHsgbG9jYWxOYW1lOiBucy5sb2NhbE5hbWUgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXNzaWduKHsgbG9jYWxOYW1lOiBucy5sb2NhbE5hbWUgfSwgZWZmZWN0aXZlTnMpO1xuICB9XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUucGFyc2VHZW5lcmljID0gZnVuY3Rpb24oZWxlbWVudCkge1xuXG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIGJvZHkgPSB0aGlzLmJvZHk7XG5cbiAgdmFyIGF0dHJpYnV0ZXMgPSBbXTtcblxuICBmb3JFYWNoKGVsZW1lbnQsIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG5cbiAgICB2YXIgbm9uTnNBdHRyO1xuXG4gICAgaWYgKGtleSA9PT0gJyRib2R5Jykge1xuICAgICAgYm9keS5wdXNoKG5ldyBCb2R5U2VyaWFsaXplcigpLmJ1aWxkKHsgdHlwZTogJ1N0cmluZycgfSwgdmFsKSk7XG4gICAgfSBlbHNlXG4gICAgaWYgKGtleSA9PT0gJyRjaGlsZHJlbicpIHtcbiAgICAgIGZvckVhY2godmFsLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICBib2R5LnB1c2gobmV3IEVsZW1lbnRTZXJpYWxpemVyKHNlbGYpLmJ1aWxkKGNoaWxkKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2VcbiAgICBpZiAoa2V5LmluZGV4T2YoJyQnKSAhPT0gMCkge1xuICAgICAgbm9uTnNBdHRyID0gc2VsZi5wYXJzZU5zQXR0cmlidXRlKGVsZW1lbnQsIGtleSwgdmFsKTtcblxuICAgICAgaWYgKG5vbk5zQXR0cikge1xuICAgICAgICBhdHRyaWJ1dGVzLnB1c2goeyBuYW1lOiBrZXksIHZhbHVlOiB2YWwgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gYXR0cmlidXRlcztcbn07XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5wYXJzZU5zQXR0cmlidXRlID0gZnVuY3Rpb24oZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIG1vZGVsID0gZWxlbWVudC4kbW9kZWw7XG5cbiAgdmFyIG5hbWVOcyA9IHBhcnNlTmFtZU5TKG5hbWUpO1xuXG4gIHZhciBucztcblxuICAvLyBwYXJzZSB4bWxuczpmb289XCJodHRwOi8vZm9vLmJhclwiXG4gIGlmIChuYW1lTnMucHJlZml4ID09PSAneG1sbnMnKSB7XG4gICAgbnMgPSB7IHByZWZpeDogbmFtZU5zLmxvY2FsTmFtZSwgdXJpOiB2YWx1ZSB9O1xuICB9XG5cbiAgLy8gcGFyc2UgeG1sbnM9XCJodHRwOi8vZm9vLmJhclwiXG4gIGlmICghbmFtZU5zLnByZWZpeCAmJiBuYW1lTnMubG9jYWxOYW1lID09PSAneG1sbnMnKSB7XG4gICAgbnMgPSB7IHVyaTogdmFsdWUgfTtcbiAgfVxuXG4gIGlmICghbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH07XG4gIH1cblxuICBpZiAobW9kZWwgJiYgbW9kZWwuZ2V0UGFja2FnZSh2YWx1ZSkpIHtcbiAgICAvLyByZWdpc3RlciB3ZWxsIGtub3duIG5hbWVzcGFjZVxuICAgIHRoaXMubG9nTmFtZXNwYWNlKG5zLCB0cnVlLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBsb2cgY3VzdG9tIG5hbWVzcGFjZSBkaXJlY3RseSBhcyB1c2VkXG4gICAgdmFyIGFjdHVhbE5zID0gdGhpcy5sb2dOYW1lc3BhY2VVc2VkKG5zLCB0cnVlKTtcblxuICAgIHRoaXMuZ2V0TmFtZXNwYWNlcygpLmxvZ1VzZWQoYWN0dWFsTnMpO1xuICB9XG59O1xuXG5cbi8qKlxuICogUGFyc2UgbmFtZXNwYWNlcyBhbmQgcmV0dXJuIGEgbGlzdCBvZiBsZWZ0IG92ZXIgZ2VuZXJpYyBhdHRyaWJ1dGVzXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtBcnJheTxPYmplY3Q+fVxuICovXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUucGFyc2VOc0F0dHJpYnV0ZXMgPSBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIGdlbmVyaWNBdHRycyA9IGVsZW1lbnQuJGF0dHJzO1xuXG4gIHZhciBhdHRyaWJ1dGVzID0gW107XG5cbiAgLy8gcGFyc2UgbmFtZXNwYWNlIGF0dHJpYnV0ZXMgZmlyc3RcbiAgLy8gYW5kIGxvZyB0aGVtLiBwdXNoIG5vbiBuYW1lc3BhY2UgYXR0cmlidXRlcyB0byBhIGxpc3RcbiAgLy8gYW5kIHByb2Nlc3MgdGhlbSBsYXRlclxuICBmb3JFYWNoKGdlbmVyaWNBdHRycywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcblxuICAgIHZhciBub25Oc0F0dHIgPSBzZWxmLnBhcnNlTnNBdHRyaWJ1dGUoZWxlbWVudCwgbmFtZSwgdmFsdWUpO1xuXG4gICAgaWYgKG5vbk5zQXR0cikge1xuICAgICAgYXR0cmlidXRlcy5wdXNoKG5vbk5zQXR0cik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gYXR0cmlidXRlcztcbn07XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5wYXJzZUdlbmVyaWNBdHRyaWJ1dGVzID0gZnVuY3Rpb24oZWxlbWVudCwgYXR0cmlidXRlcykge1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmb3JFYWNoKGF0dHJpYnV0ZXMsIGZ1bmN0aW9uKGF0dHIpIHtcblxuICAgIC8vIGRvIG5vdCBzZXJpYWxpemUgeHNpOnR5cGUgYXR0cmlidXRlXG4gICAgLy8gaXQgaXMgc2V0IG1hbnVhbGx5IGJhc2VkIG9uIHRoZSBhY3R1YWwgaW1wbGVtZW50YXRpb24gdHlwZVxuICAgIGlmIChhdHRyLm5hbWUgPT09IFhTSV9UWVBFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHNlbGYuYWRkQXR0cmlidXRlKHNlbGYubnNBdHRyaWJ1dGVOYW1lKGF0dHIubmFtZSksIGF0dHIudmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ21pc3NpbmcgbmFtZXNwYWNlIGluZm9ybWF0aW9uIGZvciAnLFxuICAgICAgICBhdHRyLm5hbWUsICc9JywgYXR0ci52YWx1ZSwgJ29uJywgZWxlbWVudCxcbiAgICAgICAgZSk7XG4gICAgfVxuICB9KTtcbn07XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5wYXJzZUNvbnRhaW5tZW50cyA9IGZ1bmN0aW9uKHByb3BlcnRpZXMpIHtcblxuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICBib2R5ID0gdGhpcy5ib2R5LFxuICAgICAgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblxuICBmb3JFYWNoKHByb3BlcnRpZXMsIGZ1bmN0aW9uKHApIHtcbiAgICB2YXIgdmFsdWUgPSBlbGVtZW50LmdldChwLm5hbWUpLFxuICAgICAgICBpc1JlZmVyZW5jZSA9IHAuaXNSZWZlcmVuY2UsXG4gICAgICAgIGlzTWFueSA9IHAuaXNNYW55O1xuXG4gICAgaWYgKCFpc01hbnkpIHtcbiAgICAgIHZhbHVlID0gWyB2YWx1ZSBdO1xuICAgIH1cblxuICAgIGlmIChwLmlzQm9keSkge1xuICAgICAgYm9keS5wdXNoKG5ldyBCb2R5U2VyaWFsaXplcigpLmJ1aWxkKHAsIHZhbHVlWzBdKSk7XG4gICAgfSBlbHNlXG4gICAgaWYgKGlzU2ltcGxlVHlwZShwLnR5cGUpKSB7XG4gICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbih2KSB7XG4gICAgICAgIGJvZHkucHVzaChuZXcgVmFsdWVTZXJpYWxpemVyKHNlbGYuYWRkVGFnTmFtZShzZWxmLm5zUHJvcGVydHlUYWdOYW1lKHApKSkuYnVpbGQocCwgdikpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlXG4gICAgaWYgKGlzUmVmZXJlbmNlKSB7XG4gICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbih2KSB7XG4gICAgICAgIGJvZHkucHVzaChuZXcgUmVmZXJlbmNlU2VyaWFsaXplcihzZWxmLmFkZFRhZ05hbWUoc2VsZi5uc1Byb3BlcnR5VGFnTmFtZShwKSkpLmJ1aWxkKHYpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhbGxvdyBzZXJpYWxpemF0aW9uIHZpYSB0eXBlXG4gICAgICAvLyByYXRoZXIgdGhhbiBlbGVtZW50IG5hbWVcbiAgICAgIHZhciBhc1R5cGUgPSBzZXJpYWxpemVBc1R5cGUocCksXG4gICAgICAgICAgYXNQcm9wZXJ0eSA9IHNlcmlhbGl6ZUFzUHJvcGVydHkocCk7XG5cbiAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgdmFyIHNlcmlhbGl6ZXI7XG5cbiAgICAgICAgaWYgKGFzVHlwZSkge1xuICAgICAgICAgIHNlcmlhbGl6ZXIgPSBuZXcgVHlwZVNlcmlhbGl6ZXIoc2VsZiwgcCk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICBpZiAoYXNQcm9wZXJ0eSkge1xuICAgICAgICAgIHNlcmlhbGl6ZXIgPSBuZXcgRWxlbWVudFNlcmlhbGl6ZXIoc2VsZiwgcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VyaWFsaXplciA9IG5ldyBFbGVtZW50U2VyaWFsaXplcihzZWxmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJvZHkucHVzaChzZXJpYWxpemVyLmJ1aWxkKHYpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUuZ2V0TmFtZXNwYWNlcyA9IGZ1bmN0aW9uKGxvY2FsKSB7XG5cbiAgdmFyIG5hbWVzcGFjZXMgPSB0aGlzLm5hbWVzcGFjZXMsXG4gICAgICBwYXJlbnQgPSB0aGlzLnBhcmVudCxcbiAgICAgIHBhcmVudE5hbWVzcGFjZXM7XG5cbiAgaWYgKCFuYW1lc3BhY2VzKSB7XG4gICAgcGFyZW50TmFtZXNwYWNlcyA9IHBhcmVudCAmJiBwYXJlbnQuZ2V0TmFtZXNwYWNlcygpO1xuXG4gICAgaWYgKGxvY2FsIHx8ICFwYXJlbnROYW1lc3BhY2VzKSB7XG4gICAgICB0aGlzLm5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzID0gbmV3IE5hbWVzcGFjZXMocGFyZW50TmFtZXNwYWNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWVzcGFjZXMgPSBwYXJlbnROYW1lc3BhY2VzO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lc3BhY2VzO1xufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLmxvZ05hbWVzcGFjZSA9IGZ1bmN0aW9uKG5zLCB3ZWxsa25vd24sIGxvY2FsKSB7XG4gIHZhciBuYW1lc3BhY2VzID0gdGhpcy5nZXROYW1lc3BhY2VzKGxvY2FsKTtcblxuICB2YXIgbnNVcmkgPSBucy51cmksXG4gICAgICBuc1ByZWZpeCA9IG5zLnByZWZpeDtcblxuICB2YXIgZXhpc3RpbmcgPSBuYW1lc3BhY2VzLmJ5VXJpKG5zVXJpKTtcblxuICBpZiAoIWV4aXN0aW5nKSB7XG4gICAgbmFtZXNwYWNlcy5hZGQobnMsIHdlbGxrbm93bik7XG4gIH1cblxuICBuYW1lc3BhY2VzLm1hcFByZWZpeChuc1ByZWZpeCwgbnNVcmkpO1xuXG4gIHJldHVybiBucztcbn07XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5sb2dOYW1lc3BhY2VVc2VkID0gZnVuY3Rpb24obnMsIGxvY2FsKSB7XG4gIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgbW9kZWwgPSBlbGVtZW50LiRtb2RlbCxcbiAgICAgIG5hbWVzcGFjZXMgPSB0aGlzLmdldE5hbWVzcGFjZXMobG9jYWwpO1xuXG4gIC8vIG5zIG1heSBiZVxuICAvL1xuICAvLyAgICogcHJlZml4IG9ubHlcbiAgLy8gICAqIHByZWZpeDp1cmlcbiAgLy8gICAqIGxvY2FsTmFtZSBvbmx5XG5cbiAgdmFyIHByZWZpeCA9IG5zLnByZWZpeCxcbiAgICAgIHVyaSA9IG5zLnVyaSxcbiAgICAgIG5ld1ByZWZpeCwgaWR4LFxuICAgICAgd2VsbGtub3duVXJpO1xuXG4gIC8vIGhhbmRsZSBhbm9ueW1vdXMgbmFtZXNwYWNlcyAoZWxlbWVudEZvcm09dW5xdWFsaWZpZWQpLCBjZi4gIzIzXG4gIGlmICghcHJlZml4ICYmICF1cmkpIHtcbiAgICByZXR1cm4geyBsb2NhbE5hbWU6IG5zLmxvY2FsTmFtZSB9O1xuICB9XG5cbiAgd2VsbGtub3duVXJpID0gREVGQVVMVF9OU19NQVBbcHJlZml4XSB8fCBtb2RlbCAmJiAobW9kZWwuZ2V0UGFja2FnZShwcmVmaXgpIHx8IHt9KS51cmk7XG5cbiAgdXJpID0gdXJpIHx8IHdlbGxrbm93blVyaSB8fCBuYW1lc3BhY2VzLnVyaUJ5UHJlZml4KHByZWZpeCk7XG5cbiAgaWYgKCF1cmkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIG5hbWVzcGFjZSB1cmkgZ2l2ZW4gZm9yIHByZWZpeCA8JyArIHByZWZpeCArICc+Jyk7XG4gIH1cblxuICBucyA9IG5hbWVzcGFjZXMuYnlVcmkodXJpKTtcblxuICBpZiAoIW5zKSB7XG4gICAgbmV3UHJlZml4ID0gcHJlZml4O1xuICAgIGlkeCA9IDE7XG5cbiAgICAvLyBmaW5kIGEgcHJlZml4IHRoYXQgaXMgbm90IG1hcHBlZCB5ZXRcbiAgICB3aGlsZSAobmFtZXNwYWNlcy51cmlCeVByZWZpeChuZXdQcmVmaXgpKSB7XG4gICAgICBuZXdQcmVmaXggPSBwcmVmaXggKyAnXycgKyBpZHgrKztcbiAgICB9XG5cbiAgICBucyA9IHRoaXMubG9nTmFtZXNwYWNlKHsgcHJlZml4OiBuZXdQcmVmaXgsIHVyaTogdXJpIH0sIHdlbGxrbm93blVyaSA9PT0gdXJpKTtcbiAgfVxuXG4gIGlmIChwcmVmaXgpIHtcbiAgICBuYW1lc3BhY2VzLm1hcFByZWZpeChwcmVmaXgsIHVyaSk7XG4gIH1cblxuICByZXR1cm4gbnM7XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUucGFyc2VBdHRyaWJ1dGVzID0gZnVuY3Rpb24ocHJvcGVydGllcykge1xuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXG4gIGZvckVhY2gocHJvcGVydGllcywgZnVuY3Rpb24ocCkge1xuXG4gICAgdmFyIHZhbHVlID0gZWxlbWVudC5nZXQocC5uYW1lKTtcblxuICAgIGlmIChwLmlzUmVmZXJlbmNlKSB7XG5cbiAgICAgIGlmICghcC5pc01hbnkpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5pZDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB2YWx1ZXMucHVzaCh2LmlkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElEUkVGUyBpcyBhIHdoaXRlc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2YgcmVmZXJlbmNlcy5cbiAgICAgICAgdmFsdWUgPSB2YWx1ZXMuam9pbignICcpO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgc2VsZi5hZGRBdHRyaWJ1dGUoc2VsZi5uc0F0dHJpYnV0ZU5hbWUocCksIHZhbHVlKTtcbiAgfSk7XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUuYWRkVGFnTmFtZSA9IGZ1bmN0aW9uKG5zVGFnTmFtZSkge1xuICB2YXIgYWN0dWFsTnMgPSB0aGlzLmxvZ05hbWVzcGFjZVVzZWQobnNUYWdOYW1lKTtcblxuICB0aGlzLmdldE5hbWVzcGFjZXMoKS5sb2dVc2VkKGFjdHVhbE5zKTtcblxuICByZXR1cm4gbnNOYW1lKG5zVGFnTmFtZSk7XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUuYWRkQXR0cmlidXRlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGF0dHJzID0gdGhpcy5hdHRycztcblxuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFsdWUgPSBlc2NhcGVBdHRyKHZhbHVlKTtcbiAgfVxuXG4gIGF0dHJzLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplQXR0cmlidXRlcyA9IGZ1bmN0aW9uKHdyaXRlcikge1xuICB2YXIgYXR0cnMgPSB0aGlzLmF0dHJzLFxuICAgICAgbmFtZXNwYWNlcyA9IHRoaXMubmFtZXNwYWNlcztcblxuICBpZiAobmFtZXNwYWNlcykge1xuICAgIGF0dHJzID0gZ2V0TnNBdHRycyhuYW1lc3BhY2VzKS5jb25jYXQoYXR0cnMpO1xuICB9XG5cbiAgZm9yRWFjaChhdHRycywgZnVuY3Rpb24oYSkge1xuICAgIHdyaXRlclxuICAgICAgLmFwcGVuZCgnICcpXG4gICAgICAuYXBwZW5kKG5zTmFtZShhLm5hbWUpKS5hcHBlbmQoJz1cIicpLmFwcGVuZChhLnZhbHVlKS5hcHBlbmQoJ1wiJyk7XG4gIH0pO1xufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLnNlcmlhbGl6ZVRvID0gZnVuY3Rpb24od3JpdGVyKSB7XG4gIHZhciBmaXJzdEJvZHkgPSB0aGlzLmJvZHlbMF0sXG4gICAgICBpbmRlbnQgPSBmaXJzdEJvZHkgJiYgZmlyc3RCb2R5LmNvbnN0cnVjdG9yICE9PSBCb2R5U2VyaWFsaXplcjtcblxuICB3cml0ZXJcbiAgICAuYXBwZW5kSW5kZW50KClcbiAgICAuYXBwZW5kKCc8JyArIHRoaXMudGFnTmFtZSk7XG5cbiAgdGhpcy5zZXJpYWxpemVBdHRyaWJ1dGVzKHdyaXRlcik7XG5cbiAgd3JpdGVyLmFwcGVuZChmaXJzdEJvZHkgPyAnPicgOiAnIC8+Jyk7XG5cbiAgaWYgKGZpcnN0Qm9keSkge1xuXG4gICAgaWYgKGluZGVudCkge1xuICAgICAgd3JpdGVyXG4gICAgICAgIC5hcHBlbmROZXdMaW5lKClcbiAgICAgICAgLmluZGVudCgpO1xuICAgIH1cblxuICAgIGZvckVhY2godGhpcy5ib2R5LCBmdW5jdGlvbihiKSB7XG4gICAgICBiLnNlcmlhbGl6ZVRvKHdyaXRlcik7XG4gICAgfSk7XG5cbiAgICBpZiAoaW5kZW50KSB7XG4gICAgICB3cml0ZXJcbiAgICAgICAgLnVuaW5kZW50KClcbiAgICAgICAgLmFwcGVuZEluZGVudCgpO1xuICAgIH1cblxuICAgIHdyaXRlci5hcHBlbmQoJzwvJyArIHRoaXMudGFnTmFtZSArICc+Jyk7XG4gIH1cblxuICB3cml0ZXIuYXBwZW5kTmV3TGluZSgpO1xufTtcblxuLyoqXG4gKiBBIHNlcmlhbGl6ZXIgZm9yIHR5cGVzIHRoYXQgaGFuZGxlcyBzZXJpYWxpemF0aW9uIG9mIGRhdGEgdHlwZXNcbiAqL1xuZnVuY3Rpb24gVHlwZVNlcmlhbGl6ZXIocGFyZW50LCBwcm9wZXJ0eURlc2NyaXB0b3IpIHtcbiAgRWxlbWVudFNlcmlhbGl6ZXIuY2FsbCh0aGlzLCBwYXJlbnQsIHByb3BlcnR5RGVzY3JpcHRvcik7XG59XG5cbmluaGVyaXRzKFR5cGVTZXJpYWxpemVyLCBFbGVtZW50U2VyaWFsaXplcik7XG5cblR5cGVTZXJpYWxpemVyLnByb3RvdHlwZS5wYXJzZU5zQXR0cmlidXRlcyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICAvLyBleHRyYWN0ZWQgYXR0cmlidXRlc1xuICB2YXIgYXR0cmlidXRlcyA9IEVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5wYXJzZU5zQXR0cmlidXRlcy5jYWxsKHRoaXMsIGVsZW1lbnQpO1xuXG4gIHZhciBkZXNjcmlwdG9yID0gZWxlbWVudC4kZGVzY3JpcHRvcjtcblxuICAvLyBvbmx5IHNlcmlhbGl6ZSB4c2k6dHlwZSBpZiBuZWNlc3NhcnlcbiAgaWYgKGRlc2NyaXB0b3IubmFtZSA9PT0gdGhpcy5wcm9wZXJ0eURlc2NyaXB0b3IudHlwZSkge1xuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICB9XG5cbiAgdmFyIHR5cGVOcyA9IHRoaXMudHlwZU5zID0gdGhpcy5uc1RhZ05hbWUoZGVzY3JpcHRvcik7XG4gIHRoaXMuZ2V0TmFtZXNwYWNlcygpLmxvZ1VzZWQodGhpcy50eXBlTnMpO1xuXG4gIC8vIGFkZCB4c2k6dHlwZSBhdHRyaWJ1dGUgdG8gcmVwcmVzZW50IHRoZSBlbGVtZW50c1xuICAvLyBhY3R1YWwgdHlwZVxuXG4gIHZhciBwa2cgPSBlbGVtZW50LiRtb2RlbC5nZXRQYWNrYWdlKHR5cGVOcy51cmkpLFxuICAgICAgdHlwZVByZWZpeCA9IChwa2cueG1sICYmIHBrZy54bWwudHlwZVByZWZpeCkgfHwgJyc7XG5cbiAgdGhpcy5hZGRBdHRyaWJ1dGUoXG4gICAgdGhpcy5uc0F0dHJpYnV0ZU5hbWUoWFNJX1RZUEUpLFxuICAgICh0eXBlTnMucHJlZml4ID8gdHlwZU5zLnByZWZpeCArICc6JyA6ICcnKSArIHR5cGVQcmVmaXggKyBkZXNjcmlwdG9yLm5zLmxvY2FsTmFtZVxuICApO1xuXG4gIHJldHVybiBhdHRyaWJ1dGVzO1xufTtcblxuVHlwZVNlcmlhbGl6ZXIucHJvdG90eXBlLmlzTG9jYWxOcyA9IGZ1bmN0aW9uKG5zKSB7XG4gIHJldHVybiBucy51cmkgPT09ICh0aGlzLnR5cGVOcyB8fCB0aGlzLm5zKS51cmk7XG59O1xuXG5mdW5jdGlvbiBTYXZpbmdXcml0ZXIoKSB7XG4gIHRoaXMudmFsdWUgPSAnJztcblxuICB0aGlzLndyaXRlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgdGhpcy52YWx1ZSArPSBzdHI7XG4gIH07XG59XG5cbmZ1bmN0aW9uIEZvcm1hdGluZ1dyaXRlcihvdXQsIGZvcm1hdCkge1xuXG4gIHZhciBpbmRlbnQgPSBbJyddO1xuXG4gIHRoaXMuYXBwZW5kID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgb3V0LndyaXRlKHN0cik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB0aGlzLmFwcGVuZE5ld0xpbmUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICBvdXQud3JpdGUoJ1xcbicpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHRoaXMuYXBwZW5kSW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgb3V0LndyaXRlKGluZGVudC5qb2luKCcgICcpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB0aGlzLmluZGVudCA9IGZ1bmN0aW9uKCkge1xuICAgIGluZGVudC5wdXNoKCcnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB0aGlzLnVuaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgaW5kZW50LnBvcCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG4vKipcbiAqIEEgd3JpdGVyIGZvciBtZXRhLW1vZGVsIGJhY2tlZCBkb2N1bWVudCB0cmVlc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG91dHB1dCBvcHRpb25zIHRvIHBhc3MgaW50byB0aGUgd3JpdGVyXG4gKi9cbmZ1bmN0aW9uIFdyaXRlcihvcHRpb25zKSB7XG5cbiAgb3B0aW9ucyA9IGFzc2lnbih7IGZvcm1hdDogZmFsc2UsIHByZWFtYmxlOiB0cnVlIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIGZ1bmN0aW9uIHRvWE1MKHRyZWUsIHdyaXRlcikge1xuICAgIHZhciBpbnRlcm5hbFdyaXRlciA9IHdyaXRlciB8fCBuZXcgU2F2aW5nV3JpdGVyKCk7XG4gICAgdmFyIGZvcm1hdGluZ1dyaXRlciA9IG5ldyBGb3JtYXRpbmdXcml0ZXIoaW50ZXJuYWxXcml0ZXIsIG9wdGlvbnMuZm9ybWF0KTtcblxuICAgIGlmIChvcHRpb25zLnByZWFtYmxlKSB7XG4gICAgICBmb3JtYXRpbmdXcml0ZXIuYXBwZW5kKFhNTF9QUkVBTUJMRSk7XG4gICAgfVxuXG4gICAgbmV3IEVsZW1lbnRTZXJpYWxpemVyKCkuYnVpbGQodHJlZSkuc2VyaWFsaXplVG8oZm9ybWF0aW5nV3JpdGVyKTtcblxuICAgIGlmICghd3JpdGVyKSB7XG4gICAgICByZXR1cm4gaW50ZXJuYWxXcml0ZXIudmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b1hNTDogdG9YTUxcbiAgfTtcbn1cblxuZXhwb3J0IHsgUmVhZGVyLCBXcml0ZXIgfTtcbiIsImltcG9ydCB7IGZvckVhY2gsIGJpbmQsIHBpY2ssIGFzc2lnbiwgaXNTdHJpbmcsIGlzT2JqZWN0IH0gZnJvbSAnbWluLWRhc2gnO1xuXG4vKipcbiAqIE1vZGRsZSBiYXNlIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIEJhc2UoKSB7IH1cblxuQmFzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy4kbW9kZWwucHJvcGVydGllcy5nZXQodGhpcywgbmFtZSk7XG59O1xuXG5CYXNlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB0aGlzLiRtb2RlbC5wcm9wZXJ0aWVzLnNldCh0aGlzLCBuYW1lLCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEEgbW9kZWwgZWxlbWVudCBmYWN0b3J5LlxuICpcbiAqIEBwYXJhbSB7TW9kZGxlfSBtb2RlbFxuICogQHBhcmFtIHtQcm9wZXJ0aWVzfSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIEZhY3RvcnkobW9kZWwsIHByb3BlcnRpZXMpIHtcbiAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xufVxuXG5cbkZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZVR5cGUgPSBmdW5jdGlvbihkZXNjcmlwdG9yKSB7XG5cbiAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcblxuICB2YXIgcHJvcHMgPSB0aGlzLnByb3BlcnRpZXMsXG4gICAgICBwcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2UucHJvdG90eXBlKTtcblxuICAvLyBpbml0aWFsaXplIGRlZmF1bHQgdmFsdWVzXG4gIGZvckVhY2goZGVzY3JpcHRvci5wcm9wZXJ0aWVzLCBmdW5jdGlvbihwKSB7XG4gICAgaWYgKCFwLmlzTWFueSAmJiBwLmRlZmF1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcHJvdG90eXBlW3AubmFtZV0gPSBwLmRlZmF1bHQ7XG4gICAgfVxuICB9KTtcblxuICBwcm9wcy5kZWZpbmVNb2RlbChwcm90b3R5cGUsIG1vZGVsKTtcbiAgcHJvcHMuZGVmaW5lRGVzY3JpcHRvcihwcm90b3R5cGUsIGRlc2NyaXB0b3IpO1xuXG4gIHZhciBuYW1lID0gZGVzY3JpcHRvci5ucy5uYW1lO1xuXG4gIC8qKlxuICAgKiBUaGUgbmV3IHR5cGUgY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIE1vZGRsZUVsZW1lbnQoYXR0cnMpIHtcbiAgICBwcm9wcy5kZWZpbmUodGhpcywgJyR0eXBlJywgeyB2YWx1ZTogbmFtZSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbiAgICBwcm9wcy5kZWZpbmUodGhpcywgJyRhdHRycycsIHsgdmFsdWU6IHt9IH0pO1xuICAgIHByb3BzLmRlZmluZSh0aGlzLCAnJHBhcmVudCcsIHsgd3JpdGFibGU6IHRydWUgfSk7XG5cbiAgICBmb3JFYWNoKGF0dHJzLCBiaW5kKGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgICB0aGlzLnNldChrZXksIHZhbCk7XG4gICAgfSwgdGhpcykpO1xuICB9XG5cbiAgTW9kZGxlRWxlbWVudC5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG5cbiAgTW9kZGxlRWxlbWVudC5oYXNUeXBlID0gcHJvdG90eXBlLiRpbnN0YW5jZU9mID0gdGhpcy5tb2RlbC5oYXNUeXBlO1xuXG4gIC8vIHN0YXRpYyBsaW5rc1xuICBwcm9wcy5kZWZpbmVNb2RlbChNb2RkbGVFbGVtZW50LCBtb2RlbCk7XG4gIHByb3BzLmRlZmluZURlc2NyaXB0b3IoTW9kZGxlRWxlbWVudCwgZGVzY3JpcHRvcik7XG5cbiAgcmV0dXJuIE1vZGRsZUVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIEJ1aWx0LWluIG1vZGRsZSB0eXBlc1xuICovXG52YXIgQlVJTFRJTlMgPSB7XG4gIFN0cmluZzogdHJ1ZSxcbiAgQm9vbGVhbjogdHJ1ZSxcbiAgSW50ZWdlcjogdHJ1ZSxcbiAgUmVhbDogdHJ1ZSxcbiAgRWxlbWVudDogdHJ1ZVxufTtcblxuLyoqXG4gKiBDb252ZXJ0ZXJzIGZvciBidWlsdCBpbiB0eXBlcyBmcm9tIHN0cmluZyByZXByZXNlbnRhdGlvbnNcbiAqL1xudmFyIFRZUEVfQ09OVkVSVEVSUyA9IHtcbiAgU3RyaW5nOiBmdW5jdGlvbihzKSB7IHJldHVybiBzOyB9LFxuICBCb29sZWFuOiBmdW5jdGlvbihzKSB7IHJldHVybiBzID09PSAndHJ1ZSc7IH0sXG4gIEludGVnZXI6IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHBhcnNlSW50KHMsIDEwKTsgfSxcbiAgUmVhbDogZnVuY3Rpb24ocykgeyByZXR1cm4gcGFyc2VGbG9hdChzLCAxMCk7IH1cbn07XG5cbi8qKlxuICogQ29udmVydCBhIHR5cGUgdG8gaXRzIHJlYWwgcmVwcmVzZW50YXRpb25cbiAqL1xuZnVuY3Rpb24gY29lcmNlVHlwZSh0eXBlLCB2YWx1ZSkge1xuXG4gIHZhciBjb252ZXJ0ZXIgPSBUWVBFX0NPTlZFUlRFUlNbdHlwZV07XG5cbiAgaWYgKGNvbnZlcnRlcikge1xuICAgIHJldHVybiBjb252ZXJ0ZXIodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIHRoZSBnaXZlbiB0eXBlIGlzIGJ1aWx0LWluXG4gKi9cbmZ1bmN0aW9uIGlzQnVpbHRJbih0eXBlKSB7XG4gIHJldHVybiAhIUJVSUxUSU5TW3R5cGVdO1xufVxuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIHRoZSBnaXZlbiB0eXBlIGlzIHNpbXBsZVxuICovXG5mdW5jdGlvbiBpc1NpbXBsZSh0eXBlKSB7XG4gIHJldHVybiAhIVRZUEVfQ09OVkVSVEVSU1t0eXBlXTtcbn1cblxuLyoqXG4gKiBQYXJzZXMgYSBuYW1lc3BhY2VkIGF0dHJpYnV0ZSBuYW1lIG9mIHRoZSBmb3JtIChuczopbG9jYWxOYW1lIHRvIGFuIG9iamVjdCxcbiAqIGdpdmVuIGEgZGVmYXVsdCBwcmVmaXggdG8gYXNzdW1lIGluIGNhc2Ugbm8gZXhwbGljaXQgbmFtZXNwYWNlIGlzIGdpdmVuLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gW2RlZmF1bHRQcmVmaXhdIHRoZSBkZWZhdWx0IHByZWZpeCB0byB0YWtlLCBpZiBub25lIGlzIHByZXNlbnQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgcGFyc2VkIG5hbWVcbiAqL1xuZnVuY3Rpb24gcGFyc2VOYW1lKG5hbWUsIGRlZmF1bHRQcmVmaXgpIHtcbiAgdmFyIHBhcnRzID0gbmFtZS5zcGxpdCgvOi8pLFxuICAgICAgbG9jYWxOYW1lLCBwcmVmaXg7XG5cbiAgLy8gbm8gcHJlZml4IChpLmUuIG9ubHkgbG9jYWwgbmFtZSlcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGxvY2FsTmFtZSA9IG5hbWU7XG4gICAgcHJlZml4ID0gZGVmYXVsdFByZWZpeDtcbiAgfSBlbHNlXG4gIC8vIHByZWZpeCArIGxvY2FsIG5hbWVcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgIGxvY2FsTmFtZSA9IHBhcnRzWzFdO1xuICAgIHByZWZpeCA9IHBhcnRzWzBdO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgPHByZWZpeDpsb2NhbE5hbWU+IG9yIDxsb2NhbE5hbWU+LCBnb3QgJyArIG5hbWUpO1xuICB9XG5cbiAgbmFtZSA9IChwcmVmaXggPyBwcmVmaXggKyAnOicgOiAnJykgKyBsb2NhbE5hbWU7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIHByZWZpeDogcHJlZml4LFxuICAgIGxvY2FsTmFtZTogbG9jYWxOYW1lXG4gIH07XG59XG5cbi8qKlxuICogQSB1dGlsaXR5IHRvIGJ1aWxkIGVsZW1lbnQgZGVzY3JpcHRvcnMuXG4gKi9cbmZ1bmN0aW9uIERlc2NyaXB0b3JCdWlsZGVyKG5hbWVOcykge1xuICB0aGlzLm5zID0gbmFtZU5zO1xuICB0aGlzLm5hbWUgPSBuYW1lTnMubmFtZTtcbiAgdGhpcy5hbGxUeXBlcyA9IFtdO1xuICB0aGlzLmFsbFR5cGVzQnlOYW1lID0ge307XG4gIHRoaXMucHJvcGVydGllcyA9IFtdO1xuICB0aGlzLnByb3BlcnRpZXNCeU5hbWUgPSB7fTtcbn1cblxuXG5EZXNjcmlwdG9yQnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHBpY2sodGhpcywgW1xuICAgICducycsXG4gICAgJ25hbWUnLFxuICAgICdhbGxUeXBlcycsXG4gICAgJ2FsbFR5cGVzQnlOYW1lJyxcbiAgICAncHJvcGVydGllcycsXG4gICAgJ3Byb3BlcnRpZXNCeU5hbWUnLFxuICAgICdib2R5UHJvcGVydHknLFxuICAgICdpZFByb3BlcnR5J1xuICBdKTtcbn07XG5cbi8qKlxuICogQWRkIHByb3BlcnR5IGF0IGdpdmVuIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwXG4gKiBAcGFyYW0ge051bWJlcn0gW2lkeF1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ZhbGlkYXRlPXRydWVdXG4gKi9cbkRlc2NyaXB0b3JCdWlsZGVyLnByb3RvdHlwZS5hZGRQcm9wZXJ0eSA9IGZ1bmN0aW9uKHAsIGlkeCwgdmFsaWRhdGUpIHtcblxuICBpZiAodHlwZW9mIGlkeCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdmFsaWRhdGUgPSBpZHg7XG4gICAgaWR4ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdGhpcy5hZGROYW1lZFByb3BlcnR5KHAsIHZhbGlkYXRlICE9PSBmYWxzZSk7XG5cbiAgdmFyIHByb3BlcnRpZXMgPSB0aGlzLnByb3BlcnRpZXM7XG5cbiAgaWYgKGlkeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHJvcGVydGllcy5zcGxpY2UoaWR4LCAwLCBwKTtcbiAgfSBlbHNlIHtcbiAgICBwcm9wZXJ0aWVzLnB1c2gocCk7XG4gIH1cbn07XG5cblxuRGVzY3JpcHRvckJ1aWxkZXIucHJvdG90eXBlLnJlcGxhY2VQcm9wZXJ0eSA9IGZ1bmN0aW9uKG9sZFByb3BlcnR5LCBuZXdQcm9wZXJ0eSwgcmVwbGFjZSkge1xuICB2YXIgb2xkTmFtZU5zID0gb2xkUHJvcGVydHkubnM7XG5cbiAgdmFyIHByb3BzID0gdGhpcy5wcm9wZXJ0aWVzLFxuICAgICAgcHJvcGVydGllc0J5TmFtZSA9IHRoaXMucHJvcGVydGllc0J5TmFtZSxcbiAgICAgIHJlbmFtZSA9IG9sZFByb3BlcnR5Lm5hbWUgIT09IG5ld1Byb3BlcnR5Lm5hbWU7XG5cbiAgaWYgKG9sZFByb3BlcnR5LmlzSWQpIHtcbiAgICBpZiAoIW5ld1Byb3BlcnR5LmlzSWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3Byb3BlcnR5IDwnICsgbmV3UHJvcGVydHkubnMubmFtZSArICc+IG11c3QgYmUgaWQgcHJvcGVydHkgJyArXG4gICAgICAgICd0byByZWZpbmUgPCcgKyBvbGRQcm9wZXJ0eS5ucy5uYW1lICsgJz4nKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldElkUHJvcGVydHkobmV3UHJvcGVydHksIGZhbHNlKTtcbiAgfVxuXG4gIGlmIChvbGRQcm9wZXJ0eS5pc0JvZHkpIHtcblxuICAgIGlmICghbmV3UHJvcGVydHkuaXNCb2R5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdwcm9wZXJ0eSA8JyArIG5ld1Byb3BlcnR5Lm5zLm5hbWUgKyAnPiBtdXN0IGJlIGJvZHkgcHJvcGVydHkgJyArXG4gICAgICAgICd0byByZWZpbmUgPCcgKyBvbGRQcm9wZXJ0eS5ucy5uYW1lICsgJz4nKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBDaGVjayBjb21wYXRpYmlsaXR5XG4gICAgdGhpcy5zZXRCb2R5UHJvcGVydHkobmV3UHJvcGVydHksIGZhbHNlKTtcbiAgfVxuXG4gIC8vIHZhbGlkYXRlIGV4aXN0ZW5jZSBhbmQgZ2V0IGxvY2F0aW9uIG9mIG9sZCBwcm9wZXJ0eVxuICB2YXIgaWR4ID0gcHJvcHMuaW5kZXhPZihvbGRQcm9wZXJ0eSk7XG4gIGlmIChpZHggPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9wZXJ0eSA8JyArIG9sZE5hbWVOcy5uYW1lICsgJz4gbm90IGZvdW5kIGluIHByb3BlcnR5IGxpc3QnKTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBvbGQgcHJvcGVydHlcbiAgcHJvcHMuc3BsaWNlKGlkeCwgMSk7XG5cbiAgLy8gcmVwbGFjaW5nIHRoZSBuYW1lZCBwcm9wZXJ0eSBpcyBpbnRlbnRpb25hbFxuICAvL1xuICAvLyAgKiB2YWxpZGF0ZSBvbmx5IGlmIHRoaXMgaXMgYSBcInJlbmFtZVwiIG9wZXJhdGlvblxuICAvLyAgKiBhZGQgYXQgc3BlY2lmaWMgaW5kZXggdW5sZXNzIHdlIFwicmVwbGFjZVwiXG4gIC8vXG4gIHRoaXMuYWRkUHJvcGVydHkobmV3UHJvcGVydHksIHJlcGxhY2UgPyB1bmRlZmluZWQgOiBpZHgsIHJlbmFtZSk7XG5cbiAgLy8gbWFrZSBuZXcgcHJvcGVydHkgYXZhaWxhYmxlIHVuZGVyIG9sZCBuYW1lXG4gIHByb3BlcnRpZXNCeU5hbWVbb2xkTmFtZU5zLm5hbWVdID0gcHJvcGVydGllc0J5TmFtZVtvbGROYW1lTnMubG9jYWxOYW1lXSA9IG5ld1Byb3BlcnR5O1xufTtcblxuXG5EZXNjcmlwdG9yQnVpbGRlci5wcm90b3R5cGUucmVkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uKHAsIHRhcmdldFByb3BlcnR5TmFtZSwgcmVwbGFjZSkge1xuXG4gIHZhciBuc1ByZWZpeCA9IHAubnMucHJlZml4O1xuICB2YXIgcGFydHMgPSB0YXJnZXRQcm9wZXJ0eU5hbWUuc3BsaXQoJyMnKTtcblxuICB2YXIgbmFtZSA9IHBhcnNlTmFtZShwYXJ0c1swXSwgbnNQcmVmaXgpO1xuICB2YXIgYXR0ck5hbWUgPSBwYXJzZU5hbWUocGFydHNbMV0sIG5hbWUucHJlZml4KS5uYW1lO1xuXG4gIHZhciByZWRlZmluZWRQcm9wZXJ0eSA9IHRoaXMucHJvcGVydGllc0J5TmFtZVthdHRyTmFtZV07XG4gIGlmICghcmVkZWZpbmVkUHJvcGVydHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlZmluZWQgcHJvcGVydHkgPCcgKyBhdHRyTmFtZSArICc+IG5vdCBmb3VuZCcpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVwbGFjZVByb3BlcnR5KHJlZGVmaW5lZFByb3BlcnR5LCBwLCByZXBsYWNlKTtcbiAgfVxuXG4gIGRlbGV0ZSBwLnJlZGVmaW5lcztcbn07XG5cbkRlc2NyaXB0b3JCdWlsZGVyLnByb3RvdHlwZS5hZGROYW1lZFByb3BlcnR5ID0gZnVuY3Rpb24ocCwgdmFsaWRhdGUpIHtcbiAgdmFyIG5zID0gcC5ucyxcbiAgICAgIHByb3BzQnlOYW1lID0gdGhpcy5wcm9wZXJ0aWVzQnlOYW1lO1xuXG4gIGlmICh2YWxpZGF0ZSkge1xuICAgIHRoaXMuYXNzZXJ0Tm90RGVmaW5lZChwLCBucy5uYW1lKTtcbiAgICB0aGlzLmFzc2VydE5vdERlZmluZWQocCwgbnMubG9jYWxOYW1lKTtcbiAgfVxuXG4gIHByb3BzQnlOYW1lW25zLm5hbWVdID0gcHJvcHNCeU5hbWVbbnMubG9jYWxOYW1lXSA9IHA7XG59O1xuXG5EZXNjcmlwdG9yQnVpbGRlci5wcm90b3R5cGUucmVtb3ZlTmFtZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIG5zID0gcC5ucyxcbiAgICAgIHByb3BzQnlOYW1lID0gdGhpcy5wcm9wZXJ0aWVzQnlOYW1lO1xuXG4gIGRlbGV0ZSBwcm9wc0J5TmFtZVtucy5uYW1lXTtcbiAgZGVsZXRlIHByb3BzQnlOYW1lW25zLmxvY2FsTmFtZV07XG59O1xuXG5EZXNjcmlwdG9yQnVpbGRlci5wcm90b3R5cGUuc2V0Qm9keVByb3BlcnR5ID0gZnVuY3Rpb24ocCwgdmFsaWRhdGUpIHtcblxuICBpZiAodmFsaWRhdGUgJiYgdGhpcy5ib2R5UHJvcGVydHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnYm9keSBwcm9wZXJ0eSBkZWZpbmVkIG11bHRpcGxlIHRpbWVzICcgK1xuICAgICAgJyg8JyArIHRoaXMuYm9keVByb3BlcnR5Lm5zLm5hbWUgKyAnPiwgPCcgKyBwLm5zLm5hbWUgKyAnPiknKTtcbiAgfVxuXG4gIHRoaXMuYm9keVByb3BlcnR5ID0gcDtcbn07XG5cbkRlc2NyaXB0b3JCdWlsZGVyLnByb3RvdHlwZS5zZXRJZFByb3BlcnR5ID0gZnVuY3Rpb24ocCwgdmFsaWRhdGUpIHtcblxuICBpZiAodmFsaWRhdGUgJiYgdGhpcy5pZFByb3BlcnR5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2lkIHByb3BlcnR5IGRlZmluZWQgbXVsdGlwbGUgdGltZXMgJyArXG4gICAgICAnKDwnICsgdGhpcy5pZFByb3BlcnR5Lm5zLm5hbWUgKyAnPiwgPCcgKyBwLm5zLm5hbWUgKyAnPiknKTtcbiAgfVxuXG4gIHRoaXMuaWRQcm9wZXJ0eSA9IHA7XG59O1xuXG5EZXNjcmlwdG9yQnVpbGRlci5wcm90b3R5cGUuYXNzZXJ0Tm90RGVmaW5lZCA9IGZ1bmN0aW9uKHAsIG5hbWUpIHtcbiAgdmFyIHByb3BlcnR5TmFtZSA9IHAubmFtZSxcbiAgICAgIGRlZmluZWRQcm9wZXJ0eSA9IHRoaXMucHJvcGVydGllc0J5TmFtZVtwcm9wZXJ0eU5hbWVdO1xuXG4gIGlmIChkZWZpbmVkUHJvcGVydHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAncHJvcGVydHkgPCcgKyBwcm9wZXJ0eU5hbWUgKyAnPiBhbHJlYWR5IGRlZmluZWQ7ICcgK1xuICAgICAgJ292ZXJyaWRlIG9mIDwnICsgZGVmaW5lZFByb3BlcnR5LmRlZmluZWRCeS5ucy5uYW1lICsgJyMnICsgZGVmaW5lZFByb3BlcnR5Lm5zLm5hbWUgKyAnPiBieSAnICtcbiAgICAgICc8JyArIHAuZGVmaW5lZEJ5Lm5zLm5hbWUgKyAnIycgKyBwLm5zLm5hbWUgKyAnPiBub3QgYWxsb3dlZCB3aXRob3V0IHJlZGVmaW5lcycpO1xuICB9XG59O1xuXG5EZXNjcmlwdG9yQnVpbGRlci5wcm90b3R5cGUuaGFzUHJvcGVydHkgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLnByb3BlcnRpZXNCeU5hbWVbbmFtZV07XG59O1xuXG5EZXNjcmlwdG9yQnVpbGRlci5wcm90b3R5cGUuYWRkVHJhaXQgPSBmdW5jdGlvbih0LCBpbmhlcml0ZWQpIHtcblxuICB2YXIgdHlwZXNCeU5hbWUgPSB0aGlzLmFsbFR5cGVzQnlOYW1lLFxuICAgICAgdHlwZXMgPSB0aGlzLmFsbFR5cGVzO1xuXG4gIHZhciB0eXBlTmFtZSA9IHQubmFtZTtcblxuICBpZiAodHlwZU5hbWUgaW4gdHlwZXNCeU5hbWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3JFYWNoKHQucHJvcGVydGllcywgYmluZChmdW5jdGlvbihwKSB7XG5cbiAgICAvLyBjbG9uZSBwcm9wZXJ0eSB0byBhbGxvdyBleHRlbnNpb25zXG4gICAgcCA9IGFzc2lnbih7fSwgcCwge1xuICAgICAgbmFtZTogcC5ucy5sb2NhbE5hbWUsXG4gICAgICBpbmhlcml0ZWQ6IGluaGVyaXRlZFxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHAsICdkZWZpbmVkQnknLCB7XG4gICAgICB2YWx1ZTogdFxuICAgIH0pO1xuXG4gICAgdmFyIHJlcGxhY2VzID0gcC5yZXBsYWNlcyxcbiAgICAgICAgcmVkZWZpbmVzID0gcC5yZWRlZmluZXM7XG5cbiAgICAvLyBhZGQgcmVwbGFjZS9yZWRlZmluZSBzdXBwb3J0XG4gICAgaWYgKHJlcGxhY2VzIHx8IHJlZGVmaW5lcykge1xuICAgICAgdGhpcy5yZWRlZmluZVByb3BlcnR5KHAsIHJlcGxhY2VzIHx8IHJlZGVmaW5lcywgcmVwbGFjZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocC5pc0JvZHkpIHtcbiAgICAgICAgdGhpcy5zZXRCb2R5UHJvcGVydHkocCk7XG4gICAgICB9XG4gICAgICBpZiAocC5pc0lkKSB7XG4gICAgICAgIHRoaXMuc2V0SWRQcm9wZXJ0eShwKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkUHJvcGVydHkocCk7XG4gICAgfVxuICB9LCB0aGlzKSk7XG5cbiAgdHlwZXMucHVzaCh0KTtcbiAgdHlwZXNCeU5hbWVbdHlwZU5hbWVdID0gdDtcbn07XG5cbi8qKlxuICogQSByZWdpc3RyeSBvZiBNb2RkbGUgcGFja2FnZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxQYWNrYWdlPn0gcGFja2FnZXNcbiAqIEBwYXJhbSB7UHJvcGVydGllc30gcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBSZWdpc3RyeShwYWNrYWdlcywgcHJvcGVydGllcykge1xuICB0aGlzLnBhY2thZ2VNYXAgPSB7fTtcbiAgdGhpcy50eXBlTWFwID0ge307XG5cbiAgdGhpcy5wYWNrYWdlcyA9IFtdO1xuXG4gIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG5cbiAgZm9yRWFjaChwYWNrYWdlcywgYmluZCh0aGlzLnJlZ2lzdGVyUGFja2FnZSwgdGhpcykpO1xufVxuXG5cblJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRQYWNrYWdlID0gZnVuY3Rpb24odXJpT3JQcmVmaXgpIHtcbiAgcmV0dXJuIHRoaXMucGFja2FnZU1hcFt1cmlPclByZWZpeF07XG59O1xuXG5SZWdpc3RyeS5wcm90b3R5cGUuZ2V0UGFja2FnZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucGFja2FnZXM7XG59O1xuXG5cblJlZ2lzdHJ5LnByb3RvdHlwZS5yZWdpc3RlclBhY2thZ2UgPSBmdW5jdGlvbihwa2cpIHtcblxuICAvLyBjb3B5IHBhY2thZ2VcbiAgcGtnID0gYXNzaWduKHt9LCBwa2cpO1xuXG4gIHZhciBwa2dNYXAgPSB0aGlzLnBhY2thZ2VNYXA7XG5cbiAgZW5zdXJlQXZhaWxhYmxlKHBrZ01hcCwgcGtnLCAncHJlZml4Jyk7XG4gIGVuc3VyZUF2YWlsYWJsZShwa2dNYXAsIHBrZywgJ3VyaScpO1xuXG4gIC8vIHJlZ2lzdGVyIHR5cGVzXG4gIGZvckVhY2gocGtnLnR5cGVzLCBiaW5kKGZ1bmN0aW9uKGRlc2NyaXB0b3IpIHtcbiAgICB0aGlzLnJlZ2lzdGVyVHlwZShkZXNjcmlwdG9yLCBwa2cpO1xuICB9LCB0aGlzKSk7XG5cbiAgcGtnTWFwW3BrZy51cmldID0gcGtnTWFwW3BrZy5wcmVmaXhdID0gcGtnO1xuICB0aGlzLnBhY2thZ2VzLnB1c2gocGtnKTtcbn07XG5cblxuLyoqXG4gKiBSZWdpc3RlciBhIHR5cGUgZnJvbSBhIHNwZWNpZmljIHBhY2thZ2Ugd2l0aCB1c1xuICovXG5SZWdpc3RyeS5wcm90b3R5cGUucmVnaXN0ZXJUeXBlID0gZnVuY3Rpb24odHlwZSwgcGtnKSB7XG5cbiAgdHlwZSA9IGFzc2lnbih7fSwgdHlwZSwge1xuICAgIHN1cGVyQ2xhc3M6ICh0eXBlLnN1cGVyQ2xhc3MgfHwgW10pLnNsaWNlKCksXG4gICAgZXh0ZW5kczogKHR5cGUuZXh0ZW5kcyB8fCBbXSkuc2xpY2UoKSxcbiAgICBwcm9wZXJ0aWVzOiAodHlwZS5wcm9wZXJ0aWVzIHx8IFtdKS5zbGljZSgpLFxuICAgIG1ldGE6IGFzc2lnbigodHlwZS5tZXRhIHx8IHt9KSlcbiAgfSk7XG5cbiAgdmFyIG5zID0gcGFyc2VOYW1lKHR5cGUubmFtZSwgcGtnLnByZWZpeCksXG4gICAgICBuYW1lID0gbnMubmFtZSxcbiAgICAgIHByb3BlcnRpZXNCeU5hbWUgPSB7fTtcblxuICAvLyBwYXJzZSBwcm9wZXJ0aWVzXG4gIGZvckVhY2godHlwZS5wcm9wZXJ0aWVzLCBiaW5kKGZ1bmN0aW9uKHApIHtcblxuICAgIC8vIG5hbWVzcGFjZSBwcm9wZXJ0eSBuYW1lc1xuICAgIHZhciBwcm9wZXJ0eU5zID0gcGFyc2VOYW1lKHAubmFtZSwgbnMucHJlZml4KSxcbiAgICAgICAgcHJvcGVydHlOYW1lID0gcHJvcGVydHlOcy5uYW1lO1xuXG4gICAgLy8gbmFtZXNwYWNlIHByb3BlcnR5IHR5cGVzXG4gICAgaWYgKCFpc0J1aWx0SW4ocC50eXBlKSkge1xuICAgICAgcC50eXBlID0gcGFyc2VOYW1lKHAudHlwZSwgcHJvcGVydHlOcy5wcmVmaXgpLm5hbWU7XG4gICAgfVxuXG4gICAgYXNzaWduKHAsIHtcbiAgICAgIG5zOiBwcm9wZXJ0eU5zLFxuICAgICAgbmFtZTogcHJvcGVydHlOYW1lXG4gICAgfSk7XG5cbiAgICBwcm9wZXJ0aWVzQnlOYW1lW3Byb3BlcnR5TmFtZV0gPSBwO1xuICB9LCB0aGlzKSk7XG5cbiAgLy8gdXBkYXRlIG5zICsgbmFtZVxuICBhc3NpZ24odHlwZSwge1xuICAgIG5zOiBucyxcbiAgICBuYW1lOiBuYW1lLFxuICAgIHByb3BlcnRpZXNCeU5hbWU6IHByb3BlcnRpZXNCeU5hbWVcbiAgfSk7XG5cbiAgZm9yRWFjaCh0eXBlLmV4dGVuZHMsIGJpbmQoZnVuY3Rpb24oZXh0ZW5kc05hbWUpIHtcbiAgICB2YXIgZXh0ZW5kZWQgPSB0aGlzLnR5cGVNYXBbZXh0ZW5kc05hbWVdO1xuXG4gICAgZXh0ZW5kZWQudHJhaXRzID0gZXh0ZW5kZWQudHJhaXRzIHx8IFtdO1xuICAgIGV4dGVuZGVkLnRyYWl0cy5wdXNoKG5hbWUpO1xuICB9LCB0aGlzKSk7XG5cbiAgLy8gbGluayB0byBwYWNrYWdlXG4gIHRoaXMuZGVmaW5lUGFja2FnZSh0eXBlLCBwa2cpO1xuXG4gIC8vIHJlZ2lzdGVyXG4gIHRoaXMudHlwZU1hcFtuYW1lXSA9IHR5cGU7XG59O1xuXG5cbi8qKlxuICogVHJhdmVyc2UgdGhlIHR5cGUgaGllcmFyY2h5IGZyb20gYm90dG9tIHRvIHRvcCxcbiAqIGNhbGxpbmcgaXRlcmF0b3Igd2l0aCAodHlwZSwgaW5oZXJpdGVkKSBmb3IgYWxsIGVsZW1lbnRzIGluXG4gKiB0aGUgaW5oZXJpdGFuY2UgY2hhaW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG5zTmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0b3JcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3RyYWl0PWZhbHNlXVxuICovXG5SZWdpc3RyeS5wcm90b3R5cGUubWFwVHlwZXMgPSBmdW5jdGlvbihuc05hbWUsIGl0ZXJhdG9yLCB0cmFpdCkge1xuXG4gIHZhciB0eXBlID0gaXNCdWlsdEluKG5zTmFtZS5uYW1lKSA/IHsgbmFtZTogbnNOYW1lLm5hbWUgfSA6IHRoaXMudHlwZU1hcFtuc05hbWUubmFtZV07XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8qKlxuICAgKiBUcmF2ZXJzZSB0aGUgc2VsZWN0ZWQgdHJhaXQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbHNcbiAgICovXG4gIGZ1bmN0aW9uIHRyYXZlcnNlVHJhaXQoY2xzKSB7XG4gICAgcmV0dXJuIHRyYXZlcnNlU3VwZXIoY2xzLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmF2ZXJzZSB0aGUgc2VsZWN0ZWQgc3VwZXIgdHlwZSBvciB0cmFpdFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY2xzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3RyYWl0PWZhbHNlXVxuICAgKi9cbiAgZnVuY3Rpb24gdHJhdmVyc2VTdXBlcihjbHMsIHRyYWl0KSB7XG4gICAgdmFyIHBhcmVudE5zID0gcGFyc2VOYW1lKGNscywgaXNCdWlsdEluKGNscykgPyAnJyA6IG5zTmFtZS5wcmVmaXgpO1xuICAgIHNlbGYubWFwVHlwZXMocGFyZW50TnMsIGl0ZXJhdG9yLCB0cmFpdCk7XG4gIH1cblxuICBpZiAoIXR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gdHlwZSA8JyArIG5zTmFtZS5uYW1lICsgJz4nKTtcbiAgfVxuXG4gIGZvckVhY2godHlwZS5zdXBlckNsYXNzLCB0cmFpdCA/IHRyYXZlcnNlVHJhaXQgOiB0cmF2ZXJzZVN1cGVyKTtcblxuICAvLyBjYWxsIGl0ZXJhdG9yIHdpdGggKHR5cGUsIGluaGVyaXRlZD0hdHJhaXQpXG4gIGl0ZXJhdG9yKHR5cGUsICF0cmFpdCk7XG5cbiAgZm9yRWFjaCh0eXBlLnRyYWl0cywgdHJhdmVyc2VUcmFpdCk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZWZmZWN0aXZlIGRlc2NyaXB0b3IgZm9yIGEgdHlwZS5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGUgdGhlIG5hbWVzcGFjZWQgbmFtZSAobnM6bG9jYWxOYW1lKSBvZiB0aGUgdHlwZVxuICpcbiAqIEByZXR1cm4ge0Rlc2NyaXB0b3J9IHRoZSByZXN1bHRpbmcgZWZmZWN0aXZlIGRlc2NyaXB0b3JcbiAqL1xuUmVnaXN0cnkucHJvdG90eXBlLmdldEVmZmVjdGl2ZURlc2NyaXB0b3IgPSBmdW5jdGlvbihuYW1lKSB7XG5cbiAgdmFyIG5zTmFtZSA9IHBhcnNlTmFtZShuYW1lKTtcblxuICB2YXIgYnVpbGRlciA9IG5ldyBEZXNjcmlwdG9yQnVpbGRlcihuc05hbWUpO1xuXG4gIHRoaXMubWFwVHlwZXMobnNOYW1lLCBmdW5jdGlvbih0eXBlLCBpbmhlcml0ZWQpIHtcbiAgICBidWlsZGVyLmFkZFRyYWl0KHR5cGUsIGluaGVyaXRlZCk7XG4gIH0pO1xuXG4gIHZhciBkZXNjcmlwdG9yID0gYnVpbGRlci5idWlsZCgpO1xuXG4gIC8vIGRlZmluZSBwYWNrYWdlIGxpbmtcbiAgdGhpcy5kZWZpbmVQYWNrYWdlKGRlc2NyaXB0b3IsIGRlc2NyaXB0b3IuYWxsVHlwZXNbZGVzY3JpcHRvci5hbGxUeXBlcy5sZW5ndGggLSAxXS4kcGtnKTtcblxuICByZXR1cm4gZGVzY3JpcHRvcjtcbn07XG5cblxuUmVnaXN0cnkucHJvdG90eXBlLmRlZmluZVBhY2thZ2UgPSBmdW5jdGlvbih0YXJnZXQsIHBrZykge1xuICB0aGlzLnByb3BlcnRpZXMuZGVmaW5lKHRhcmdldCwgJyRwa2cnLCB7IHZhbHVlOiBwa2cgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vIGhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBlbnN1cmVBdmFpbGFibGUocGFja2FnZU1hcCwgcGtnLCBpZGVudGlmaWVyS2V5KSB7XG5cbiAgdmFyIHZhbHVlID0gcGtnW2lkZW50aWZpZXJLZXldO1xuXG4gIGlmICh2YWx1ZSBpbiBwYWNrYWdlTWFwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwYWNrYWdlIHdpdGggJyArIGlkZW50aWZpZXJLZXkgKyAnIDwnICsgdmFsdWUgKyAnPiBhbHJlYWR5IGRlZmluZWQnKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgdXRpbGl0eSB0aGF0IGdldHMgYW5kIHNldHMgcHJvcGVydGllcyBvZiBtb2RlbCBlbGVtZW50cy5cbiAqXG4gKiBAcGFyYW0ge01vZGVsfSBtb2RlbFxuICovXG5mdW5jdGlvbiBQcm9wZXJ0aWVzKG1vZGVsKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbn1cblxuXG4vKipcbiAqIFNldHMgYSBuYW1lZCBwcm9wZXJ0eSBvbiB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gKiBJZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCB0aGUgcHJvcGVydHkgZ2V0cyBkZWxldGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqL1xuUHJvcGVydGllcy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24odGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xuXG4gIHZhciBwcm9wZXJ0eSA9IHRoaXMubW9kZWwuZ2V0UHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgbmFtZSk7XG5cbiAgdmFyIHByb3BlcnR5TmFtZSA9IHByb3BlcnR5ICYmIHByb3BlcnR5Lm5hbWU7XG5cbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgIC8vIHVuc2V0IHRoZSBwcm9wZXJ0eSwgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyB1bmRlZmluZWQ7XG4gICAgLy8gZGVsZXRlIGZyb20gJGF0dHJzIChmb3IgZXh0ZW5zaW9ucykgb3IgdGhlIHRhcmdldCBpdHNlbGZcbiAgICBpZiAocHJvcGVydHkpIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcGVydHlOYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHRhcmdldC4kYXR0cnNbbmFtZV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIHNldCB0aGUgcHJvcGVydHksIGRlZmluaW5nIHdlbGwgZGVmaW5lZCBwcm9wZXJ0aWVzIG9uIHRoZSBmbHlcbiAgICAvLyBvciBzaW1wbHkgdXBkYXRpbmcgdGhlbSBpbiB0YXJnZXQuJGF0dHJzIChmb3IgZXh0ZW5zaW9ucylcbiAgICBpZiAocHJvcGVydHkpIHtcbiAgICAgIGlmIChwcm9wZXJ0eU5hbWUgaW4gdGFyZ2V0KSB7XG4gICAgICAgIHRhcmdldFtwcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldC4kYXR0cnNbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbmFtZWQgcHJvcGVydHkgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtICB7U3RyaW5nfSBuYW1lXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5Qcm9wZXJ0aWVzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbih0YXJnZXQsIG5hbWUpIHtcblxuICB2YXIgcHJvcGVydHkgPSB0aGlzLm1vZGVsLmdldFByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIG5hbWUpO1xuXG4gIGlmICghcHJvcGVydHkpIHtcbiAgICByZXR1cm4gdGFyZ2V0LiRhdHRyc1tuYW1lXTtcbiAgfVxuXG4gIHZhciBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eS5uYW1lO1xuXG4gIC8vIGNoZWNrIGlmIGFjY2VzcyB0byBjb2xsZWN0aW9uIHByb3BlcnR5IGFuZCBsYXppbHkgaW5pdGlhbGl6ZSBpdFxuICBpZiAoIXRhcmdldFtwcm9wZXJ0eU5hbWVdICYmIHByb3BlcnR5LmlzTWFueSkge1xuICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIFtdKTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXRbcHJvcGVydHlOYW1lXTtcbn07XG5cblxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eSBvbiB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtICB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuUHJvcGVydGllcy5wcm90b3R5cGUuZGVmaW5lID0gZnVuY3Rpb24odGFyZ2V0LCBuYW1lLCBvcHRpb25zKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIG9wdGlvbnMpO1xufTtcblxuXG4vKipcbiAqIERlZmluZSB0aGUgZGVzY3JpcHRvciBmb3IgYW4gZWxlbWVudFxuICovXG5Qcm9wZXJ0aWVzLnByb3RvdHlwZS5kZWZpbmVEZXNjcmlwdG9yID0gZnVuY3Rpb24odGFyZ2V0LCBkZXNjcmlwdG9yKSB7XG4gIHRoaXMuZGVmaW5lKHRhcmdldCwgJyRkZXNjcmlwdG9yJywgeyB2YWx1ZTogZGVzY3JpcHRvciB9KTtcbn07XG5cbi8qKlxuICogRGVmaW5lIHRoZSBtb2RlbCBmb3IgYW4gZWxlbWVudFxuICovXG5Qcm9wZXJ0aWVzLnByb3RvdHlwZS5kZWZpbmVNb2RlbCA9IGZ1bmN0aW9uKHRhcmdldCwgbW9kZWwpIHtcbiAgdGhpcy5kZWZpbmUodGFyZ2V0LCAnJG1vZGVsJywgeyB2YWx1ZTogbW9kZWwgfSk7XG59O1xuXG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5Lm5hbWUsIHtcbiAgICBlbnVtZXJhYmxlOiAhcHJvcGVydHkuaXNSZWZlcmVuY2UsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLy8vLyBNb2RkbGUgaW1wbGVtZW50YXRpb24gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEBjbGFzcyBNb2RkbGVcbiAqXG4gKiBBIG1vZGVsIHRoYXQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGVsZW1lbnRzIG9mIGEgc3BlY2lmaWMgdHlwZS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBNb2RkbGUgPSByZXF1aXJlKCdtb2RkbGUnKTtcbiAqXG4gKiB2YXIgcGtnID0ge1xuICogICBuYW1lOiAnbXlwYWNrYWdlJyxcbiAqICAgcHJlZml4OiAnbXknLFxuICogICB0eXBlczogW1xuICogICAgIHsgbmFtZTogJ1Jvb3QnIH1cbiAqICAgXVxuICogfTtcbiAqXG4gKiB2YXIgbW9kZGxlID0gbmV3IE1vZGRsZShbcGtnXSk7XG4gKlxuICogQHBhcmFtIHtBcnJheTxQYWNrYWdlPn0gcGFja2FnZXMgdGhlIHBhY2thZ2VzIHRvIGNvbnRhaW5cbiAqL1xuZnVuY3Rpb24gTW9kZGxlKHBhY2thZ2VzKSB7XG5cbiAgdGhpcy5wcm9wZXJ0aWVzID0gbmV3IFByb3BlcnRpZXModGhpcyk7XG5cbiAgdGhpcy5mYWN0b3J5ID0gbmV3IEZhY3RvcnkodGhpcywgdGhpcy5wcm9wZXJ0aWVzKTtcbiAgdGhpcy5yZWdpc3RyeSA9IG5ldyBSZWdpc3RyeShwYWNrYWdlcywgdGhpcy5wcm9wZXJ0aWVzKTtcblxuICB0aGlzLnR5cGVDYWNoZSA9IHt9O1xufVxuXG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoZSBzcGVjaWZpZWQgdHlwZS5cbiAqXG4gKiBAbWV0aG9kIE1vZGRsZSNjcmVhdGVcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBmb28gPSBtb2RkbGUuY3JlYXRlKCdteTpGb28nKTtcbiAqIHZhciBiYXIgPSBtb2RkbGUuY3JlYXRlKCdteTpCYXInLCB7IGlkOiAnQkFSXzEnIH0pO1xuICpcbiAqIEBwYXJhbSAge1N0cmluZ3xPYmplY3R9IGRlc2NyaXB0b3IgdGhlIHR5cGUgZGVzY3JpcHRvciBvciBuYW1lIGtub3cgdG8gdGhlIG1vZGVsXG4gKiBAcGFyYW0gIHtPYmplY3R9IGF0dHJzICAgYSBudW1iZXIgb2YgYXR0cmlidXRlcyB0byBpbml0aWFsaXplIHRoZSBtb2RlbCBpbnN0YW5jZSB3aXRoXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgbW9kZWwgaW5zdGFuY2VcbiAqL1xuTW9kZGxlLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbihkZXNjcmlwdG9yLCBhdHRycykge1xuICB2YXIgVHlwZSA9IHRoaXMuZ2V0VHlwZShkZXNjcmlwdG9yKTtcblxuICBpZiAoIVR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gdHlwZSA8JyArIGRlc2NyaXB0b3IgKyAnPicpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBUeXBlKGF0dHJzKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0eXBlIHJlcHJlc2VudGluZyBhIGdpdmVuIGRlc2NyaXB0b3JcbiAqXG4gKiBAbWV0aG9kIE1vZGRsZSNnZXRUeXBlXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgRm9vID0gbW9kZGxlLmdldFR5cGUoJ215OkZvbycpO1xuICogdmFyIGZvbyA9IG5ldyBGb28oeyAnaWQnIDogJ0ZPT18xJyB9KTtcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd8T2JqZWN0fSBkZXNjcmlwdG9yIHRoZSB0eXBlIGRlc2NyaXB0b3Igb3IgbmFtZSBrbm93IHRvIHRoZSBtb2RlbFxuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgIHRoZSB0eXBlIHJlcHJlc2VudGluZyB0aGUgZGVzY3JpcHRvclxuICovXG5Nb2RkbGUucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbihkZXNjcmlwdG9yKSB7XG5cbiAgdmFyIGNhY2hlID0gdGhpcy50eXBlQ2FjaGU7XG5cbiAgdmFyIG5hbWUgPSBpc1N0cmluZyhkZXNjcmlwdG9yKSA/IGRlc2NyaXB0b3IgOiBkZXNjcmlwdG9yLm5zLm5hbWU7XG5cbiAgdmFyIHR5cGUgPSBjYWNoZVtuYW1lXTtcblxuICBpZiAoIXR5cGUpIHtcbiAgICBkZXNjcmlwdG9yID0gdGhpcy5yZWdpc3RyeS5nZXRFZmZlY3RpdmVEZXNjcmlwdG9yKG5hbWUpO1xuICAgIHR5cGUgPSBjYWNoZVtuYW1lXSA9IHRoaXMuZmFjdG9yeS5jcmVhdGVUeXBlKGRlc2NyaXB0b3IpO1xuICB9XG5cbiAgcmV0dXJuIHR5cGU7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhbnktZWxlbWVudCB0eXBlIHRvIGJlIHVzZWQgd2l0aGluIG1vZGVsIGluc3RhbmNlcy5cbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBjdXN0b20gZWxlbWVudHMgdGhhdCBsaWUgb3V0c2lkZSB0aGUgbWV0YS1tb2RlbC5cbiAqIFRoZSBjcmVhdGVkIGVsZW1lbnQgY29udGFpbnMgYWxsIHRoZSBtZXRhLWRhdGEgcmVxdWlyZWQgdG8gc2VyaWFsaXplIGl0XG4gKiBhcyBwYXJ0IG9mIG1ldGEtbW9kZWwgZWxlbWVudHMuXG4gKlxuICogQG1ldGhvZCBNb2RkbGUjY3JlYXRlQW55XG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgZm9vID0gbW9kZGxlLmNyZWF0ZUFueSgndmVuZG9yOkZvbycsICdodHRwOi8vdmVuZG9yJywge1xuICogICB2YWx1ZTogJ2JhcidcbiAqIH0pO1xuICpcbiAqIHZhciBjb250YWluZXIgPSBtb2RkbGUuY3JlYXRlKCdteTpDb250YWluZXInLCAnaHR0cDovL215Jywge1xuICogICBhbnk6IFsgZm9vIF1cbiAqIH0pO1xuICpcbiAqIC8vIGdvIGFoZWFkIGFuZCBzZXJpYWxpemUgdGhlIHN0dWZmXG4gKlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSAgdGhlIG5hbWUgb2YgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSAge1N0cmluZ30gbnNVcmkgdGhlIG5hbWVzcGFjZSB1cmkgb2YgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSAge09iamVjdH0gW3Byb3BlcnRpZXNdIGEgbWFwIG9mIHByb3BlcnRpZXMgdG8gaW5pdGlhbGl6ZSB0aGUgaW5zdGFuY2Ugd2l0aFxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgYW55IHR5cGUgaW5zdGFuY2VcbiAqL1xuTW9kZGxlLnByb3RvdHlwZS5jcmVhdGVBbnkgPSBmdW5jdGlvbihuYW1lLCBuc1VyaSwgcHJvcGVydGllcykge1xuXG4gIHZhciBuYW1lTnMgPSBwYXJzZU5hbWUobmFtZSk7XG5cbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgJHR5cGU6IG5hbWUsXG4gICAgJGluc3RhbmNlT2Y6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHJldHVybiB0eXBlID09PSB0aGlzLiR0eXBlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZGVzY3JpcHRvciA9IHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIGlzR2VuZXJpYzogdHJ1ZSxcbiAgICBuczoge1xuICAgICAgcHJlZml4OiBuYW1lTnMucHJlZml4LFxuICAgICAgbG9jYWxOYW1lOiBuYW1lTnMubG9jYWxOYW1lLFxuICAgICAgdXJpOiBuc1VyaVxuICAgIH1cbiAgfTtcblxuICB0aGlzLnByb3BlcnRpZXMuZGVmaW5lRGVzY3JpcHRvcihlbGVtZW50LCBkZXNjcmlwdG9yKTtcbiAgdGhpcy5wcm9wZXJ0aWVzLmRlZmluZU1vZGVsKGVsZW1lbnQsIHRoaXMpO1xuICB0aGlzLnByb3BlcnRpZXMuZGVmaW5lKGVsZW1lbnQsICckcGFyZW50JywgeyBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUgfSk7XG5cbiAgZm9yRWFjaChwcm9wZXJ0aWVzLCBmdW5jdGlvbihhLCBrZXkpIHtcbiAgICBpZiAoaXNPYmplY3QoYSkgJiYgYS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbGVtZW50W2EubmFtZV0gPSBhLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50W2tleV0gPSBhO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSByZWdpc3RlcmVkIHBhY2thZ2UgYnkgdXJpIG9yIHByZWZpeFxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIHBhY2thZ2VcbiAqL1xuTW9kZGxlLnByb3RvdHlwZS5nZXRQYWNrYWdlID0gZnVuY3Rpb24odXJpT3JQcmVmaXgpIHtcbiAgcmV0dXJuIHRoaXMucmVnaXN0cnkuZ2V0UGFja2FnZSh1cmlPclByZWZpeCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzbmFwc2hvdCBvZiBhbGwga25vd24gcGFja2FnZXNcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBwYWNrYWdlXG4gKi9cbk1vZGRsZS5wcm90b3R5cGUuZ2V0UGFja2FnZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucmVnaXN0cnkuZ2V0UGFja2FnZXMoKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGVzY3JpcHRvciBmb3IgYW4gZWxlbWVudFxuICovXG5Nb2RkbGUucHJvdG90eXBlLmdldEVsZW1lbnREZXNjcmlwdG9yID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC4kZGVzY3JpcHRvcjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBkZXNjcmlwdG9yIG9yIGluc3RhbmNlXG4gKiByZXByZXNlbnRzIHRoZSBnaXZlbiB0eXBlLlxuICpcbiAqIE1heSBiZSBhcHBsaWVkIHRvIHRoaXMsIGlmIGVsZW1lbnQgaXMgb21pdHRlZC5cbiAqL1xuTW9kZGxlLnByb3RvdHlwZS5oYXNUeXBlID0gZnVuY3Rpb24oZWxlbWVudCwgdHlwZSkge1xuICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdHlwZSA9IGVsZW1lbnQ7XG4gICAgZWxlbWVudCA9IHRoaXM7XG4gIH1cblxuICB2YXIgZGVzY3JpcHRvciA9IGVsZW1lbnQuJG1vZGVsLmdldEVsZW1lbnREZXNjcmlwdG9yKGVsZW1lbnQpO1xuXG4gIHJldHVybiAodHlwZSBpbiBkZXNjcmlwdG9yLmFsbFR5cGVzQnlOYW1lKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGVzY3JpcHRvciBvZiBhbiBlbGVtZW50cyBuYW1lZCBwcm9wZXJ0eVxuICovXG5Nb2RkbGUucHJvdG90eXBlLmdldFByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uKGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gIHJldHVybiB0aGlzLmdldEVsZW1lbnREZXNjcmlwdG9yKGVsZW1lbnQpLnByb3BlcnRpZXNCeU5hbWVbcHJvcGVydHldO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbWFwcGVkIHR5cGUncyBkZXNjcmlwdG9yXG4gKi9cbk1vZGRsZS5wcm90b3R5cGUuZ2V0VHlwZURlc2NyaXB0b3IgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHJldHVybiB0aGlzLnJlZ2lzdHJ5LnR5cGVNYXBbdHlwZV07XG59O1xuXG5leHBvcnQgeyBNb2RkbGUsIGNvZXJjZVR5cGUsIGlzQnVpbHRJbiBhcyBpc0J1aWx0SW5UeXBlLCBpc1NpbXBsZSBhcyBpc1NpbXBsZVR5cGUsIHBhcnNlTmFtZSBhcyBwYXJzZU5hbWVOUyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9yZWZzJyk7XG5cbm1vZHVsZS5leHBvcnRzLkNvbGxlY3Rpb24gPSByZXF1aXJlKCcuL2xpYi9jb2xsZWN0aW9uJyk7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEFuIGVtcHR5IGNvbGxlY3Rpb24gc3R1Yi4gVXNlIHtAbGluayBSZWZzQ29sbGVjdGlvbi5leHRlbmR9IHRvIGV4dGVuZCBhXG4gKiBjb2xsZWN0aW9uIHdpdGggcmVmIHNlbWFudGljcy5cbiAqXG4gKiBAY2xhc3MgUmVmc0NvbGxlY3Rpb25cbiAqL1xuXG4vKipcbiAqIEV4dGVuZHMgYSBjb2xsZWN0aW9uIHdpdGgge0BsaW5rIFJlZnN9IGF3YXJlIG1ldGhvZHNcbiAqXG4gKiBAbWVtYmVyb2YgUmVmc0NvbGxlY3Rpb25cbiAqIEBzdGF0aWNcbiAqXG4gKiBAcGFyYW0gIHtBcnJheTxPYmplY3Q+fSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0gIHtSZWZzfSByZWZzIGluc3RhbmNlXG4gKiBAcGFyYW0gIHtPYmplY3R9IHByb3BlcnR5IHJlcHJlc2VudGVkIGJ5IHRoZSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0gIHtPYmplY3R9IHRhcmdldCBvYmplY3QgdGhlIGNvbGxlY3Rpb24gaXMgYXR0YWNoZWQgdG9cbiAqXG4gKiBAcmV0dXJuIHtSZWZzQ29sbGVjdGlvbjxPYmplY3Q+fSB0aGUgZXh0ZW5kZWQgYXJyYXlcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKGNvbGxlY3Rpb24sIHJlZnMsIHByb3BlcnR5LCB0YXJnZXQpIHtcblxuICB2YXIgaW52ZXJzZVByb3BlcnR5ID0gcHJvcGVydHkuaW52ZXJzZTtcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gZWxlbWVudCBmcm9tIHRoZSBhcnJheSBhbmQgcmV0dXJucyBpdC5cbiAgICpcbiAgICogQG1ldGhvZCBSZWZzQ29sbGVjdGlvbiNyZW1vdmVcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gcmVtb3ZlXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29sbGVjdGlvbiwgJ3JlbW92ZScsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgdmFyIGlkeCA9IHRoaXMuaW5kZXhPZihlbGVtZW50KTtcbiAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuc3BsaWNlKGlkeCwgMSk7XG5cbiAgICAgICAgLy8gdW5zZXQgaW52ZXJzZVxuICAgICAgICByZWZzLnVuc2V0KGVsZW1lbnQsIGludmVyc2VQcm9wZXJ0eSwgdGFyZ2V0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb2xsZWN0aW9uIGNvbnRhaW5zIHRoZSBnaXZlbiBlbGVtZW50XG4gICAqXG4gICAqIEBtZXRob2QgUmVmc0NvbGxlY3Rpb24jY29udGFpbnNcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gY2hlY2sgZm9yXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29sbGVjdGlvbiwgJ2NvbnRhaW5zJywge1xuICAgIHZhbHVlOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleE9mKGVsZW1lbnQpICE9PSAtMTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGVsZW1lbnQgdG8gdGhlIGFycmF5LCB1bmxlc3MgaXQgZXhpc3RzIGFscmVhZHkgKHNldCBzZW1hbnRpY3MpLlxuICAgKlxuICAgKiBAbWV0aG9kIFJlZnNDb2xsZWN0aW9uI2FkZFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCB0aGUgZWxlbWVudCB0byBhZGRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbmFsIGluZGV4IHRvIGFkZCBlbGVtZW50IHRvXG4gICAqICAgICAgICAgICAgICAgICAocG9zc2libHkgbW92aW5nIG90aGVyIGVsZW1lbnRzIGFyb3VuZClcbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb2xsZWN0aW9uLCAnYWRkJywge1xuICAgIHZhbHVlOiBmdW5jdGlvbihlbGVtZW50LCBpZHgpIHtcblxuICAgICAgdmFyIGN1cnJlbnRJZHggPSB0aGlzLmluZGV4T2YoZWxlbWVudCk7XG5cbiAgICAgIGlmICh0eXBlb2YgaWR4ID09PSAndW5kZWZpbmVkJykge1xuXG4gICAgICAgIGlmIChjdXJyZW50SWR4ICE9PSAtMSkge1xuICAgICAgICAgIC8vIGVsZW1lbnQgYWxyZWFkeSBpbiBjb2xsZWN0aW9uICghKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0byBlbmQgb2YgYXJyYXksIGFzIG5vIGlkeCBpcyBzcGVjaWZpZWRcbiAgICAgICAgaWR4ID0gdGhpcy5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZSBhbHJlYWR5IGluIGNvbGxlY3Rpb25cbiAgICAgIGlmIChjdXJyZW50SWR4ICE9PSAtMSkge1xuXG4gICAgICAgIC8vIHJlbW92ZSBlbGVtZW50IGZyb20gY3VycmVudElkeFxuICAgICAgICB0aGlzLnNwbGljZShjdXJyZW50SWR4LCAxKTtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIGVsZW1lbnQgYXQgaWR4XG4gICAgICB0aGlzLnNwbGljZShpZHgsIDAsIGVsZW1lbnQpO1xuXG4gICAgICBpZiAoY3VycmVudElkeCA9PT0gLTEpIHtcbiAgICAgICAgLy8gc2V0IGludmVyc2UsIHVubGVzcyBlbGVtZW50IHdhc1xuICAgICAgICAvLyBpbiBjb2xsZWN0aW9uIGFscmVhZHlcbiAgICAgICAgcmVmcy5zZXQoZWxlbWVudCwgaW52ZXJzZVByb3BlcnR5LCB0YXJnZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gYSBzaW1wbGUgbWFya2VyLCBpZGVudGlmeWluZyB0aGlzIGVsZW1lbnRcbiAgLy8gYXMgYmVpbmcgYSByZWZzIGNvbGxlY3Rpb25cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbGxlY3Rpb24sICdfX3JlZnNfY29sbGVjdGlvbicsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICByZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuXG5mdW5jdGlvbiBpc0V4dGVuZGVkKGNvbGxlY3Rpb24pIHtcbiAgcmV0dXJuIGNvbGxlY3Rpb24uX19yZWZzX2NvbGxlY3Rpb24gPT09IHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzLmV4dGVuZCA9IGV4dGVuZDtcblxubW9kdWxlLmV4cG9ydHMuaXNFeHRlbmRlZCA9IGlzRXh0ZW5kZWQ7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vY29sbGVjdGlvbicpO1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShlLCBwcm9wZXJ0eSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHByb3BlcnR5Lm5hbWUgfHwgcHJvcGVydHkpO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVDb2xsZWN0aW9uUHJvcGVydHkocmVmLCBwcm9wZXJ0eSwgdGFyZ2V0KSB7XG5cbiAgdmFyIGNvbGxlY3Rpb24gPSBDb2xsZWN0aW9uLmV4dGVuZCh0YXJnZXRbcHJvcGVydHkubmFtZV0gfHwgW10sIHJlZiwgcHJvcGVydHksIHRhcmdldCk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkubmFtZSwge1xuICAgIGVudW1lcmFibGU6IHByb3BlcnR5LmVudW1lcmFibGUsXG4gICAgdmFsdWU6IGNvbGxlY3Rpb25cbiAgfSk7XG5cbiAgaWYgKGNvbGxlY3Rpb24ubGVuZ3RoKSB7XG5cbiAgICBjb2xsZWN0aW9uLmZvckVhY2goZnVuY3Rpb24obykge1xuICAgICAgcmVmLnNldChvLCBwcm9wZXJ0eS5pbnZlcnNlLCB0YXJnZXQpO1xuICAgIH0pO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkocmVmLCBwcm9wZXJ0eSwgdGFyZ2V0KSB7XG5cbiAgdmFyIGludmVyc2VQcm9wZXJ0eSA9IHByb3BlcnR5LmludmVyc2U7XG5cbiAgdmFyIF92YWx1ZSA9IHRhcmdldFtwcm9wZXJ0eS5uYW1lXTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eS5uYW1lLCB7XG4gICAgY29uZmlndXJhYmxlOiBwcm9wZXJ0eS5jb25maWd1cmFibGUsXG4gICAgZW51bWVyYWJsZTogcHJvcGVydHkuZW51bWVyYWJsZSxcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX3ZhbHVlO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cbiAgICAgIC8vIHJldHVybiBpZiB3ZSBhbHJlYWR5IHBlcmZvcm1lZCBhbGwgY2hhbmdlc1xuICAgICAgaWYgKHZhbHVlID09PSBfdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2xkID0gX3ZhbHVlO1xuXG4gICAgICAvLyB0ZW1wb3Jhcnkgc2V0IG51bGxcbiAgICAgIF92YWx1ZSA9IG51bGw7XG5cbiAgICAgIGlmIChvbGQpIHtcbiAgICAgICAgcmVmLnVuc2V0KG9sZCwgaW52ZXJzZVByb3BlcnR5LCB0YXJnZXQpO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICBfdmFsdWUgPSB2YWx1ZTtcblxuICAgICAgLy8gc2V0IGludmVyc2UgdmFsdWVcbiAgICAgIHJlZi5zZXQoX3ZhbHVlLCBpbnZlcnNlUHJvcGVydHksIHRhcmdldCk7XG4gICAgfVxuICB9KTtcblxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcmVmZXJlbmNlcyBvYmplY3QgZGVmaW5pbmcgdHdvIGludmVyc2x5IHJlbGF0ZWRcbiAqIGF0dHJpYnV0ZSBkZXNjcmlwdG9ycyBhIGFuZCBiLlxuICpcbiAqIDxwPlxuICogICBXaGVuIGJvdW5kIHRvIGFuIG9iamVjdCB1c2luZyB7QGxpbmsgUmVmcyNiaW5kfSB0aGUgcmVmZXJlbmNlc1xuICogICBnZXQgYWN0aXZhdGVkIGFuZCBlbnN1cmUgdGhhdCBhZGQgYW5kIHJlbW92ZSBvcGVyYXRpb25zIGFyZSBhcHBsaWVkXG4gKiAgIHJldmVyc2VseSwgdG9vLlxuICogPC9wPlxuICpcbiAqIDxwPlxuICogICBGb3IgYXR0cmlidXRlcyByZXByZXNlbnRlZCBhcyBjb2xsZWN0aW9ucyB7QGxpbmsgUmVmc30gcHJvdmlkZXMgdGhlXG4gKiAgIHtAbGluayBSZWZzQ29sbGVjdGlvbiNhZGR9LCB7QGxpbmsgUmVmc0NvbGxlY3Rpb24jcmVtb3ZlfSBhbmQge0BsaW5rIFJlZnNDb2xsZWN0aW9uI2NvbnRhaW5zfSBleHRlbnNpb25zXG4gKiAgIHRoYXQgbXVzdCBiZSB1c2VkIHRvIHByb3Blcmx5IGhvb2sgaW50byB0aGUgaW52ZXJzZSBjaGFuZ2UgbWVjaGFuaXNtLlxuICogPC9wPlxuICpcbiAqIEBjbGFzcyBSZWZzXG4gKlxuICogQGNsYXNzZGVzYyBBIGJpLWRpcmVjdGlvbmFsIHJlZmVyZW5jZSBiZXR3ZWVuIHR3byBhdHRyaWJ1dGVzLlxuICpcbiAqIEBwYXJhbSB7UmVmcy5BdHRyaWJ1dGVEZXNjcmlwdG9yfSBhIHByb3BlcnR5IGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7UmVmcy5BdHRyaWJ1dGVEZXNjcmlwdG9yfSBiIHByb3BlcnR5IGRlc2NyaXB0b3JcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciByZWZzID0gUmVmcyh7IG5hbWU6ICd3aGVlbHMnLCBjb2xsZWN0aW9uOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlIH0sIHsgbmFtZTogJ2NhcicgfSk7XG4gKlxuICogdmFyIGNhciA9IHsgbmFtZTogJ3RveW90YScgfTtcbiAqIHZhciB3aGVlbHMgPSBbeyBwb3M6ICdmcm9udC1sZWZ0JyB9LCB7IHBvczogJ2Zyb250LXJpZ2h0JyB9XTtcbiAqXG4gKiByZWZzLmJpbmQoY2FyLCAnd2hlZWxzJyk7XG4gKlxuICogY2FyLndoZWVscyAvLyBbXVxuICogY2FyLndoZWVscy5hZGQod2hlZWxzWzBdKTtcbiAqIGNhci53aGVlbHMuYWRkKHdoZWVsc1sxXSk7XG4gKlxuICogY2FyLndoZWVscyAvLyBbeyBwb3M6ICdmcm9udC1sZWZ0JyB9LCB7IHBvczogJ2Zyb250LXJpZ2h0JyB9XVxuICpcbiAqIHdoZWVsc1swXS5jYXIgLy8geyBuYW1lOiAndG95b3RhJyB9O1xuICogY2FyLndoZWVscy5yZW1vdmUod2hlZWxzWzBdKTtcbiAqXG4gKiB3aGVlbHNbMF0uY2FyIC8vIHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBSZWZzKGEsIGIpIHtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVmcykpIHtcbiAgICByZXR1cm4gbmV3IFJlZnMoYSwgYik7XG4gIH1cblxuICAvLyBsaW5rXG4gIGEuaW52ZXJzZSA9IGI7XG4gIGIuaW52ZXJzZSA9IGE7XG5cbiAgdGhpcy5wcm9wcyA9IHt9O1xuICB0aGlzLnByb3BzW2EubmFtZV0gPSBhO1xuICB0aGlzLnByb3BzW2IubmFtZV0gPSBiO1xufVxuXG4vKipcbiAqIEJpbmRzIG9uZSBzaWRlIG9mIGEgYmktZGlyZWN0aW9uYWwgcmVmZXJlbmNlIHRvIGFcbiAqIHRhcmdldCBvYmplY3QuXG4gKlxuICogQG1lbWJlck9mIFJlZnNcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtICB7U3RyaW5nfSBwcm9wZXJ0eVxuICovXG5SZWZzLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24odGFyZ2V0LCBwcm9wZXJ0eSkge1xuICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnc3RyaW5nJykge1xuICAgIGlmICghdGhpcy5wcm9wc1twcm9wZXJ0eV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gcHJvcGVydHkgPCcgKyBwcm9wZXJ0eSArICc+IGluIHJlZicpO1xuICAgIH1cbiAgICBwcm9wZXJ0eSA9IHRoaXMucHJvcHNbcHJvcGVydHldO1xuICB9XG5cbiAgaWYgKHByb3BlcnR5LmNvbGxlY3Rpb24pIHtcbiAgICBkZWZpbmVDb2xsZWN0aW9uUHJvcGVydHkodGhpcywgcHJvcGVydHksIHRhcmdldCk7XG4gIH0gZWxzZSB7XG4gICAgZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcGVydHksIHRhcmdldCk7XG4gIH1cbn07XG5cblJlZnMucHJvdG90eXBlLmVuc3VyZVJlZnNDb2xsZWN0aW9uID0gZnVuY3Rpb24odGFyZ2V0LCBwcm9wZXJ0eSkge1xuXG4gIHZhciBjb2xsZWN0aW9uID0gdGFyZ2V0W3Byb3BlcnR5Lm5hbWVdO1xuXG4gIGlmICghQ29sbGVjdGlvbi5pc0V4dGVuZGVkKGNvbGxlY3Rpb24pKSB7XG4gICAgZGVmaW5lQ29sbGVjdGlvblByb3BlcnR5KHRoaXMsIHByb3BlcnR5LCB0YXJnZXQpO1xuICB9XG5cbiAgcmV0dXJuIGNvbGxlY3Rpb247XG59O1xuXG5SZWZzLnByb3RvdHlwZS5lbnN1cmVCb3VuZCA9IGZ1bmN0aW9uKHRhcmdldCwgcHJvcGVydHkpIHtcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5KSkge1xuICAgIHRoaXMuYmluZCh0YXJnZXQsIHByb3BlcnR5KTtcbiAgfVxufTtcblxuUmVmcy5wcm90b3R5cGUudW5zZXQgPSBmdW5jdGlvbih0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuXG4gIGlmICh0YXJnZXQpIHtcbiAgICB0aGlzLmVuc3VyZUJvdW5kKHRhcmdldCwgcHJvcGVydHkpO1xuXG4gICAgaWYgKHByb3BlcnR5LmNvbGxlY3Rpb24pIHtcbiAgICAgIHRoaXMuZW5zdXJlUmVmc0NvbGxlY3Rpb24odGFyZ2V0LCBwcm9wZXJ0eSkucmVtb3ZlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0W3Byb3BlcnR5Lm5hbWVdID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufTtcblxuUmVmcy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24odGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcblxuICBpZiAodGFyZ2V0KSB7XG4gICAgdGhpcy5lbnN1cmVCb3VuZCh0YXJnZXQsIHByb3BlcnR5KTtcblxuICAgIGlmIChwcm9wZXJ0eS5jb2xsZWN0aW9uKSB7XG4gICAgICB0aGlzLmVuc3VyZVJlZnNDb2xsZWN0aW9uKHRhcmdldCwgcHJvcGVydHkpLmFkZCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldFtwcm9wZXJ0eS5uYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWZzO1xuXG5cbi8qKlxuICogQW4gYXR0cmlidXRlIGRlc2NyaXB0b3IgdG8gYmUgdXNlZCBzcGVjaWZ5IGFuIGF0dHJpYnV0ZSBpbiBhIHtAbGluayBSZWZzfSBpbnN0YW5jZVxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlZnMuQXR0cmlidXRlRGVzY3JpcHRvclxuICogQHByb3BlcnR5IHtTdHJpbmd9IG5hbWVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NvbGxlY3Rpb249ZmFsc2VdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtlbnVtZXJhYmxlPWZhbHNlXVxuICovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyBzb3VyY2UgY29kZSBhZGFwdGVkIGZyb20gU25hcC5zdmcgKGxpY2Vuc2VkIEFwYWNoZS0yLjApLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Fkb2JlLXdlYnBsYXRmb3JtL1NuYXAuc3ZnL2Jsb2IvbWFzdGVyL3NyYy9wYXRoLmpzXG4gKi9cblxuLyogZXNsaW50IG5vLWZhbGx0aHJvdWdoOiBcIm9mZlwiICovXG5cbnZhciBwMnMgPSAvLD8oW2Etel0pLD8vZ2ksXG4gICAgdG9GbG9hdCA9IHBhcnNlRmxvYXQsXG4gICAgbWF0aCA9IE1hdGgsXG4gICAgUEkgPSBtYXRoLlBJLFxuICAgIG1taW4gPSBtYXRoLm1pbixcbiAgICBtbWF4ID0gbWF0aC5tYXgsXG4gICAgcG93ID0gbWF0aC5wb3csXG4gICAgYWJzID0gbWF0aC5hYnMsXG4gICAgcGF0aENvbW1hbmQgPSAvKFthLXpdKVtcXHMsXSooKC0/XFxkKlxcLj9cXGQqKD86ZVstK10/XFxkKyk/W1xcc10qLD9bXFxzXSopKykvaWcsXG4gICAgcGF0aFZhbHVlcyA9IC8oLT9cXGQqXFwuP1xcZCooPzplWy0rXT9cXFxcZCspPylbXFxzXSosP1tcXHNdKi9pZztcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8gaW5zdGFuY2VvZiBBcnJheTsgfTtcblxuZnVuY3Rpb24gaGFzUHJvcGVydHkob2JqLCBwcm9wZXJ0eSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcGVydHkpO1xufVxuXG5mdW5jdGlvbiBjbG9uZShvYmopIHtcblxuICBpZiAodHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nIHx8IE9iamVjdChvYmopICE9PSBvYmopIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlcyA9IG5ldyBvYmouY29uc3RydWN0b3I7XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXNQcm9wZXJ0eShvYmosIGtleSkpIHtcbiAgICAgIHJlc1trZXldID0gY2xvbmUob2JqW2tleV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHJlcHVzaChhcnJheSwgaXRlbSkge1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBhcnJheS5sZW5ndGg7IGkgPCBpaTsgaSsrKSBpZiAoYXJyYXlbaV0gPT09IGl0ZW0pIHtcbiAgICByZXR1cm4gYXJyYXkucHVzaChhcnJheS5zcGxpY2UoaSwgMSlbMF0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhY2hlcihmKSB7XG5cbiAgZnVuY3Rpb24gbmV3ZigpIHtcblxuICAgIHZhciBhcmcgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApLFxuICAgICAgICBhcmdzID0gYXJnLmpvaW4oJ1xcdTI0MDAnKSxcbiAgICAgICAgY2FjaGUgPSBuZXdmLmNhY2hlID0gbmV3Zi5jYWNoZSB8fCB7fSxcbiAgICAgICAgY291bnQgPSBuZXdmLmNvdW50ID0gbmV3Zi5jb3VudCB8fCBbXTtcblxuICAgIGlmIChoYXNQcm9wZXJ0eShjYWNoZSwgYXJncykpIHtcbiAgICAgIHJlcHVzaChjb3VudCwgYXJncyk7XG4gICAgICByZXR1cm4gY2FjaGVbYXJnc107XG4gICAgfVxuXG4gICAgY291bnQubGVuZ3RoID49IDFlMyAmJiBkZWxldGUgY2FjaGVbY291bnQuc2hpZnQoKV07XG4gICAgY291bnQucHVzaChhcmdzKTtcbiAgICBjYWNoZVthcmdzXSA9IGYuYXBwbHkoMCwgYXJnKTtcblxuICAgIHJldHVybiBjYWNoZVthcmdzXTtcbiAgfVxuICByZXR1cm4gbmV3Zjtcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXRoU3RyaW5nKHBhdGhTdHJpbmcpIHtcblxuICBpZiAoIXBhdGhTdHJpbmcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBwdGggPSBwYXRocyhwYXRoU3RyaW5nKTtcblxuICBpZiAocHRoLmFycikge1xuICAgIHJldHVybiBjbG9uZShwdGguYXJyKTtcbiAgfVxuXG4gIHZhciBwYXJhbUNvdW50cyA9IHsgYTogNywgYzogNiwgaDogMSwgbDogMiwgbTogMiwgcTogNCwgczogNCwgdDogMiwgdjogMSwgejogMCB9LFxuICAgICAgZGF0YSA9IFtdO1xuXG4gIGlmIChpc0FycmF5KHBhdGhTdHJpbmcpICYmIGlzQXJyYXkocGF0aFN0cmluZ1swXSkpIHsgLy8gcm91Z2ggYXNzdW1wdGlvblxuICAgIGRhdGEgPSBjbG9uZShwYXRoU3RyaW5nKTtcbiAgfVxuXG4gIGlmICghZGF0YS5sZW5ndGgpIHtcblxuICAgIFN0cmluZyhwYXRoU3RyaW5nKS5yZXBsYWNlKHBhdGhDb21tYW5kLCBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICB2YXIgcGFyYW1zID0gW10sXG4gICAgICAgICAgbmFtZSA9IGIudG9Mb3dlckNhc2UoKTtcblxuICAgICAgYy5yZXBsYWNlKHBhdGhWYWx1ZXMsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgYiAmJiBwYXJhbXMucHVzaCgrYik7XG4gICAgICB9KTtcblxuICAgICAgaWYgKG5hbWUgPT0gJ20nICYmIHBhcmFtcy5sZW5ndGggPiAyKSB7XG4gICAgICAgIGRhdGEucHVzaChbYl0uY29uY2F0KHBhcmFtcy5zcGxpY2UoMCwgMikpKTtcbiAgICAgICAgbmFtZSA9ICdsJztcbiAgICAgICAgYiA9IGIgPT0gJ20nID8gJ2wnIDogJ0wnO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAocGFyYW1zLmxlbmd0aCA+PSBwYXJhbUNvdW50c1tuYW1lXSkge1xuICAgICAgICBkYXRhLnB1c2goW2JdLmNvbmNhdChwYXJhbXMuc3BsaWNlKDAsIHBhcmFtQ291bnRzW25hbWVdKSkpO1xuICAgICAgICBpZiAoIXBhcmFtQ291bnRzW25hbWVdKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGRhdGEudG9TdHJpbmcgPSBwYXRocy50b1N0cmluZztcbiAgcHRoLmFyciA9IGNsb25lKGRhdGEpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBwYXRocyhwcykge1xuICB2YXIgcCA9IHBhdGhzLnBzID0gcGF0aHMucHMgfHwge307XG5cbiAgaWYgKHBbcHNdKSB7XG4gICAgcFtwc10uc2xlZXAgPSAxMDA7XG4gIH0gZWxzZSB7XG4gICAgcFtwc10gPSB7XG4gICAgICBzbGVlcDogMTAwXG4gICAgfTtcbiAgfVxuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHApIHtcbiAgICAgIGlmIChoYXNQcm9wZXJ0eShwLCBrZXkpICYmIGtleSAhPSBwcykge1xuICAgICAgICBwW2tleV0uc2xlZXAtLTtcbiAgICAgICAgIXBba2V5XS5zbGVlcCAmJiBkZWxldGUgcFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBbcHNdO1xufVxuXG5mdW5jdGlvbiByZWN0QkJveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB5ID0geC55O1xuICAgIHdpZHRoID0geC53aWR0aDtcbiAgICBoZWlnaHQgPSB4LmhlaWdodDtcbiAgICB4ID0geC54O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHgyOiB4ICsgd2lkdGgsXG4gICAgeTI6IHkgKyBoZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGF0aFRvU3RyaW5nKCkge1xuICByZXR1cm4gdGhpcy5qb2luKCcsJykucmVwbGFjZShwMnMsICckMScpO1xufVxuXG5mdW5jdGlvbiBwYXRoQ2xvbmUocGF0aEFycmF5KSB7XG4gIHZhciByZXMgPSBjbG9uZShwYXRoQXJyYXkpO1xuICByZXMudG9TdHJpbmcgPSBwYXRoVG9TdHJpbmc7XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGZpbmREb3RzQXRTZWdtZW50KHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5LCB0KSB7XG4gIHZhciB0MSA9IDEgLSB0LFxuICAgICAgdDEzID0gcG93KHQxLCAzKSxcbiAgICAgIHQxMiA9IHBvdyh0MSwgMiksXG4gICAgICB0MiA9IHQgKiB0LFxuICAgICAgdDMgPSB0MiAqIHQsXG4gICAgICB4ID0gdDEzICogcDF4ICsgdDEyICogMyAqIHQgKiBjMXggKyB0MSAqIDMgKiB0ICogdCAqIGMyeCArIHQzICogcDJ4LFxuICAgICAgeSA9IHQxMyAqIHAxeSArIHQxMiAqIDMgKiB0ICogYzF5ICsgdDEgKiAzICogdCAqIHQgKiBjMnkgKyB0MyAqIHAyeTtcblxuICByZXR1cm4ge1xuICAgIHg6IGZpeEVycm9yKHgpLFxuICAgIHk6IGZpeEVycm9yKHkpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGJlemllckJCb3gocG9pbnRzKSB7XG5cbiAgdmFyIGJib3ggPSBjdXJ2ZUJCb3guYXBwbHkobnVsbCwgcG9pbnRzKTtcblxuICByZXR1cm4gcmVjdEJCb3goXG4gICAgYmJveC54MCxcbiAgICBiYm94LnkwLFxuICAgIGJib3gueDEgLSBiYm94LngwLFxuICAgIGJib3gueTEgLSBiYm94LnkwXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzUG9pbnRJbnNpZGVCQm94KGJib3gsIHgsIHkpIHtcbiAgcmV0dXJuIHggPj0gYmJveC54ICYmXG4gICAgeCA8PSBiYm94LnggKyBiYm94LndpZHRoICYmXG4gICAgeSA+PSBiYm94LnkgJiZcbiAgICB5IDw9IGJib3gueSArIGJib3guaGVpZ2h0O1xufVxuXG5mdW5jdGlvbiBpc0JCb3hJbnRlcnNlY3QoYmJveDEsIGJib3gyKSB7XG4gIGJib3gxID0gcmVjdEJCb3goYmJveDEpO1xuICBiYm94MiA9IHJlY3RCQm94KGJib3gyKTtcbiAgcmV0dXJuIGlzUG9pbnRJbnNpZGVCQm94KGJib3gyLCBiYm94MS54LCBiYm94MS55KVxuICAgIHx8IGlzUG9pbnRJbnNpZGVCQm94KGJib3gyLCBiYm94MS54MiwgYmJveDEueSlcbiAgICB8fCBpc1BvaW50SW5zaWRlQkJveChiYm94MiwgYmJveDEueCwgYmJveDEueTIpXG4gICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDIsIGJib3gxLngyLCBiYm94MS55MilcbiAgICB8fCBpc1BvaW50SW5zaWRlQkJveChiYm94MSwgYmJveDIueCwgYmJveDIueSlcbiAgICB8fCBpc1BvaW50SW5zaWRlQkJveChiYm94MSwgYmJveDIueDIsIGJib3gyLnkpXG4gICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDEsIGJib3gyLngsIGJib3gyLnkyKVxuICAgIHx8IGlzUG9pbnRJbnNpZGVCQm94KGJib3gxLCBiYm94Mi54MiwgYmJveDIueTIpXG4gICAgfHwgKGJib3gxLnggPCBiYm94Mi54MiAmJiBiYm94MS54ID4gYmJveDIueFxuICAgICAgICB8fCBiYm94Mi54IDwgYmJveDEueDIgJiYgYmJveDIueCA+IGJib3gxLngpXG4gICAgJiYgKGJib3gxLnkgPCBiYm94Mi55MiAmJiBiYm94MS55ID4gYmJveDIueVxuICAgICAgICB8fCBiYm94Mi55IDwgYmJveDEueTIgJiYgYmJveDIueSA+IGJib3gxLnkpO1xufVxuXG5mdW5jdGlvbiBiYXNlMyh0LCBwMSwgcDIsIHAzLCBwNCkge1xuICB2YXIgdDEgPSAtMyAqIHAxICsgOSAqIHAyIC0gOSAqIHAzICsgMyAqIHA0LFxuICAgICAgdDIgPSB0ICogdDEgKyA2ICogcDEgLSAxMiAqIHAyICsgNiAqIHAzO1xuICByZXR1cm4gdCAqIHQyIC0gMyAqIHAxICsgMyAqIHAyO1xufVxuXG5mdW5jdGlvbiBiZXpsZW4oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCB6KSB7XG5cbiAgaWYgKHogPT0gbnVsbCkge1xuICAgIHogPSAxO1xuICB9XG5cbiAgeiA9IHogPiAxID8gMSA6IHogPCAwID8gMCA6IHo7XG5cbiAgdmFyIHoyID0geiAvIDIsXG4gICAgICBuID0gMTIsXG4gICAgICBUdmFsdWVzID0gWy0uMTI1MiwuMTI1MiwtLjM2NzgsLjM2NzgsLS41ODczLC41ODczLC0uNzY5OSwuNzY5OSwtLjkwNDEsLjkwNDEsLS45ODE2LC45ODE2XSxcbiAgICAgIEN2YWx1ZXMgPSBbMC4yNDkxLDAuMjQ5MSwwLjIzMzUsMC4yMzM1LDAuMjAzMiwwLjIwMzIsMC4xNjAxLDAuMTYwMSwwLjEwNjksMC4xMDY5LDAuMDQ3MiwwLjA0NzJdLFxuICAgICAgc3VtID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIHZhciBjdCA9IHoyICogVHZhbHVlc1tpXSArIHoyLFxuICAgICAgICB4YmFzZSA9IGJhc2UzKGN0LCB4MSwgeDIsIHgzLCB4NCksXG4gICAgICAgIHliYXNlID0gYmFzZTMoY3QsIHkxLCB5MiwgeTMsIHk0KSxcbiAgICAgICAgY29tYiA9IHhiYXNlICogeGJhc2UgKyB5YmFzZSAqIHliYXNlO1xuXG4gICAgc3VtICs9IEN2YWx1ZXNbaV0gKiBtYXRoLnNxcnQoY29tYik7XG4gIH1cblxuICByZXR1cm4gejIgKiBzdW07XG59XG5cblxuZnVuY3Rpb24gaW50ZXJzZWN0TGluZXMoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0KSB7XG5cbiAgaWYgKFxuICAgIG1tYXgoeDEsIHgyKSA8IG1taW4oeDMsIHg0KSB8fFxuICAgICAgbW1pbih4MSwgeDIpID4gbW1heCh4MywgeDQpIHx8XG4gICAgICBtbWF4KHkxLCB5MikgPCBtbWluKHkzLCB5NCkgfHxcbiAgICAgIG1taW4oeTEsIHkyKSA+IG1tYXgoeTMsIHk0KVxuICApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbnggPSAoeDEgKiB5MiAtIHkxICogeDIpICogKHgzIC0geDQpIC0gKHgxIC0geDIpICogKHgzICogeTQgLSB5MyAqIHg0KSxcbiAgICAgIG55ID0gKHgxICogeTIgLSB5MSAqIHgyKSAqICh5MyAtIHk0KSAtICh5MSAtIHkyKSAqICh4MyAqIHk0IC0geTMgKiB4NCksXG4gICAgICBkZW5vbWluYXRvciA9ICh4MSAtIHgyKSAqICh5MyAtIHk0KSAtICh5MSAtIHkyKSAqICh4MyAtIHg0KTtcblxuICBpZiAoIWRlbm9taW5hdG9yKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHB4ID0gZml4RXJyb3IobnggLyBkZW5vbWluYXRvciksXG4gICAgICBweSA9IGZpeEVycm9yKG55IC8gZGVub21pbmF0b3IpLFxuICAgICAgcHgyID0gK3B4LnRvRml4ZWQoMiksXG4gICAgICBweTIgPSArcHkudG9GaXhlZCgyKTtcblxuICBpZiAoXG4gICAgcHgyIDwgK21taW4oeDEsIHgyKS50b0ZpeGVkKDIpIHx8XG4gICAgICBweDIgPiArbW1heCh4MSwgeDIpLnRvRml4ZWQoMikgfHxcbiAgICAgIHB4MiA8ICttbWluKHgzLCB4NCkudG9GaXhlZCgyKSB8fFxuICAgICAgcHgyID4gK21tYXgoeDMsIHg0KS50b0ZpeGVkKDIpIHx8XG4gICAgICBweTIgPCArbW1pbih5MSwgeTIpLnRvRml4ZWQoMikgfHxcbiAgICAgIHB5MiA+ICttbWF4KHkxLCB5MikudG9GaXhlZCgyKSB8fFxuICAgICAgcHkyIDwgK21taW4oeTMsIHk0KS50b0ZpeGVkKDIpIHx8XG4gICAgICBweTIgPiArbW1heCh5MywgeTQpLnRvRml4ZWQoMilcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIHsgeDogcHgsIHk6IHB5IH07XG59XG5cbmZ1bmN0aW9uIGZpeEVycm9yKG51bWJlcikge1xuICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIgKiAxMDAwMDAwMDAwMDApIC8gMTAwMDAwMDAwMDAwO1xufVxuXG5mdW5jdGlvbiBmaW5kQmV6aWVySW50ZXJzZWN0aW9ucyhiZXoxLCBiZXoyLCBqdXN0Q291bnQpIHtcbiAgdmFyIGJib3gxID0gYmV6aWVyQkJveChiZXoxKSxcbiAgICAgIGJib3gyID0gYmV6aWVyQkJveChiZXoyKTtcblxuICBpZiAoIWlzQkJveEludGVyc2VjdChiYm94MSwgYmJveDIpKSB7XG4gICAgcmV0dXJuIGp1c3RDb3VudCA/IDAgOiBbXTtcbiAgfVxuXG4gIC8vIEFzIGFuIG9wdGltaXphdGlvbiwgbGluZXMgd2lsbCBoYXZlIG9ubHkgMSBzZWdtZW50XG5cbiAgdmFyIGwxID0gYmV6bGVuLmFwcGx5KDAsIGJlejEpLFxuICAgICAgbDIgPSBiZXpsZW4uYXBwbHkoMCwgYmV6MiksXG4gICAgICBuMSA9IGlzTGluZShiZXoxKSA/IDEgOiB+fihsMSAvIDUpIHx8IDEsXG4gICAgICBuMiA9IGlzTGluZShiZXoyKSA/IDEgOiB+fihsMiAvIDUpIHx8IDEsXG4gICAgICBkb3RzMSA9IFtdLFxuICAgICAgZG90czIgPSBbXSxcbiAgICAgIHh5ID0ge30sXG4gICAgICByZXMgPSBqdXN0Q291bnQgPyAwIDogW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuMSArIDE7IGkrKykge1xuICAgIHZhciBwID0gZmluZERvdHNBdFNlZ21lbnQuYXBwbHkoMCwgYmV6MS5jb25jYXQoaSAvIG4xKSk7XG4gICAgZG90czEucHVzaCh7IHg6IHAueCwgeTogcC55LCB0OiBpIC8gbjEgfSk7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgbjIgKyAxOyBpKyspIHtcbiAgICBwID0gZmluZERvdHNBdFNlZ21lbnQuYXBwbHkoMCwgYmV6Mi5jb25jYXQoaSAvIG4yKSk7XG4gICAgZG90czIucHVzaCh7IHg6IHAueCwgeTogcC55LCB0OiBpIC8gbjIgfSk7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgbjE7IGkrKykge1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBuMjsgaisrKSB7XG4gICAgICB2YXIgZGkgPSBkb3RzMVtpXSxcbiAgICAgICAgICBkaTEgPSBkb3RzMVtpICsgMV0sXG4gICAgICAgICAgZGogPSBkb3RzMltqXSxcbiAgICAgICAgICBkajEgPSBkb3RzMltqICsgMV0sXG4gICAgICAgICAgY2kgPSBhYnMoZGkxLnggLSBkaS54KSA8IC4wMSA/ICd5JyA6ICd4JyxcbiAgICAgICAgICBjaiA9IGFicyhkajEueCAtIGRqLngpIDwgLjAxID8gJ3knIDogJ3gnLFxuICAgICAgICAgIGlzID0gaW50ZXJzZWN0TGluZXMoZGkueCwgZGkueSwgZGkxLngsIGRpMS55LCBkai54LCBkai55LCBkajEueCwgZGoxLnkpLFxuICAgICAgICAgIGtleTtcblxuICAgICAgaWYgKGlzKSB7XG4gICAgICAgIGtleSA9IGlzLngudG9GaXhlZCg5KSArICcjJyArIGlzLnkudG9GaXhlZCg5KTtcblxuICAgICAgICBpZiAoeHlba2V5XSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgeHlba2V5XSA9IHRydWU7XG5cbiAgICAgICAgdmFyIHQxID0gZGkudCArIGFicygoaXNbY2ldIC0gZGlbY2ldKSAvIChkaTFbY2ldIC0gZGlbY2ldKSkgKiAoZGkxLnQgLSBkaS50KSxcbiAgICAgICAgICAgIHQyID0gZGoudCArIGFicygoaXNbY2pdIC0gZGpbY2pdKSAvIChkajFbY2pdIC0gZGpbY2pdKSkgKiAoZGoxLnQgLSBkai50KTtcblxuICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxICYmIHQyID49IDAgJiYgdDIgPD0gMSkge1xuXG4gICAgICAgICAgaWYgKGp1c3RDb3VudCkge1xuICAgICAgICAgICAgcmVzKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKHtcbiAgICAgICAgICAgICAgeDogaXMueCxcbiAgICAgICAgICAgICAgeTogaXMueSxcbiAgICAgICAgICAgICAgdDE6IHQxLFxuICAgICAgICAgICAgICB0MjogdDJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59XG5cblxuLyoqXG4gKiBGaW5kIG9yIGNvdW50cyB0aGUgaW50ZXJzZWN0aW9ucyBiZXR3ZWVuIHR3byBTVkcgcGF0aHMuXG4gKlxuICogUmV0dXJucyBhIG51bWJlciBpbiBjb3VudGluZyBtb2RlIGFuZCBhIGxpc3Qgb2YgaW50ZXJzZWN0aW9ucyBvdGhlcndpc2UuXG4gKlxuICogQSBzaW5nbGUgaW50ZXJzZWN0aW9uIGVudHJ5IGNvbnRhaW5zIHRoZSBpbnRlcnNlY3Rpb24gY29vcmRpbmF0ZXMgKHgsIHkpXG4gKiBhcyB3ZWxsIGFzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIHRoZSBpbnRlcnNlY3Rpbmcgc2VnbWVudHNcbiAqIG9uIGVhY2ggcGF0aCAoc2VnbWVudDEsIHNlZ21lbnQyKSBhbmQgdGhlIHJlbGF0aXZlIGxvY2F0aW9uIG9mIHRoZVxuICogaW50ZXJzZWN0aW9uIG9uIHRoZXNlIHNlZ21lbnRzICh0MSwgdDIpLlxuICpcbiAqIFRoZSBwYXRoIG1heSBiZSBhbiBTVkcgcGF0aCBzdHJpbmcgb3IgYSBsaXN0IG9mIHBhdGggY29tcG9uZW50c1xuICogc3VjaCBhcyBgWyBbICdNJywgMCwgMTAgXSwgWyAnTCcsIDIwLCAwIF0gXWAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgaW50ZXJzZWN0aW9ucyA9IGZpbmRQYXRoSW50ZXJzZWN0aW9ucyhcbiAqICAgJ00wLDBMMTAwLDEwMCcsXG4gKiAgIFsgWyAnTScsIDAsIDEwMCBdLCBbICdMJywgMTAwLCAwIF0gXVxuICogKTtcbiAqXG4gKiAvLyBpbnRlcnNlY3Rpb25zID0gW1xuICogLy8gICB7IHg6IDUwLCB5OiA1MCwgc2VnbWVudDE6IDEsIHNlZ21lbnQyOiAxLCB0MTogMC41LCB0MjogMC41IH1cbiAqIC8vIF1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheTxQYXRoRGVmPn0gcGF0aDFcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5PFBhdGhEZWY+fSBwYXRoMlxuICogQHBhcmFtIHtCb29sZWFufSBbanVzdENvdW50PWZhbHNlXVxuICpcbiAqIEByZXR1cm4ge0FycmF5PEludGVyc2VjdGlvbj58TnVtYmVyfVxuICovXG5mdW5jdGlvbiBmaW5kUGF0aEludGVyc2VjdGlvbnMocGF0aDEsIHBhdGgyLCBqdXN0Q291bnQpIHtcbiAgcGF0aDEgPSBwYXRoVG9DdXJ2ZShwYXRoMSk7XG4gIHBhdGgyID0gcGF0aFRvQ3VydmUocGF0aDIpO1xuXG4gIHZhciB4MSwgeTEsIHgyLCB5MiwgeDFtLCB5MW0sIHgybSwgeTJtLCBiZXoxLCBiZXoyLFxuICAgICAgcmVzID0ganVzdENvdW50ID8gMCA6IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IHBhdGgxLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICB2YXIgcGkgPSBwYXRoMVtpXTtcblxuICAgIGlmIChwaVswXSA9PSAnTScpIHtcbiAgICAgIHgxID0geDFtID0gcGlbMV07XG4gICAgICB5MSA9IHkxbSA9IHBpWzJdO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIGlmIChwaVswXSA9PSAnQycpIHtcbiAgICAgICAgYmV6MSA9IFt4MSwgeTFdLmNvbmNhdChwaS5zbGljZSgxKSk7XG4gICAgICAgIHgxID0gYmV6MVs2XTtcbiAgICAgICAgeTEgPSBiZXoxWzddO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmV6MSA9IFt4MSwgeTEsIHgxLCB5MSwgeDFtLCB5MW0sIHgxbSwgeTFtXTtcbiAgICAgICAgeDEgPSB4MW07XG4gICAgICAgIHkxID0geTFtO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgamogPSBwYXRoMi5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgIHZhciBwaiA9IHBhdGgyW2pdO1xuXG4gICAgICAgIGlmIChwalswXSA9PSAnTScpIHtcbiAgICAgICAgICB4MiA9IHgybSA9IHBqWzFdO1xuICAgICAgICAgIHkyID0geTJtID0gcGpbMl07XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBpZiAocGpbMF0gPT0gJ0MnKSB7XG4gICAgICAgICAgICBiZXoyID0gW3gyLCB5Ml0uY29uY2F0KHBqLnNsaWNlKDEpKTtcbiAgICAgICAgICAgIHgyID0gYmV6Mls2XTtcbiAgICAgICAgICAgIHkyID0gYmV6Mls3XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmV6MiA9IFt4MiwgeTIsIHgyLCB5MiwgeDJtLCB5Mm0sIHgybSwgeTJtXTtcbiAgICAgICAgICAgIHgyID0geDJtO1xuICAgICAgICAgICAgeTIgPSB5Mm07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGludHIgPSBmaW5kQmV6aWVySW50ZXJzZWN0aW9ucyhiZXoxLCBiZXoyLCBqdXN0Q291bnQpO1xuXG4gICAgICAgICAgaWYgKGp1c3RDb3VudCkge1xuICAgICAgICAgICAgcmVzICs9IGludHI7XG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDAsIGtrID0gaW50ci5sZW5ndGg7IGsgPCBrazsgaysrKSB7XG4gICAgICAgICAgICAgIGludHJba10uc2VnbWVudDEgPSBpO1xuICAgICAgICAgICAgICBpbnRyW2tdLnNlZ21lbnQyID0gajtcbiAgICAgICAgICAgICAgaW50cltrXS5iZXoxID0gYmV6MTtcbiAgICAgICAgICAgICAgaW50cltrXS5iZXoyID0gYmV6MjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChpbnRyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuXG5cbmZ1bmN0aW9uIHBhdGhUb0Fic29sdXRlKHBhdGhBcnJheSkge1xuICB2YXIgcHRoID0gcGF0aHMocGF0aEFycmF5KTtcblxuICBpZiAocHRoLmFicykge1xuICAgIHJldHVybiBwYXRoQ2xvbmUocHRoLmFicyk7XG4gIH1cblxuICBpZiAoIWlzQXJyYXkocGF0aEFycmF5KSB8fCAhaXNBcnJheShwYXRoQXJyYXkgJiYgcGF0aEFycmF5WzBdKSkgeyAvLyByb3VnaCBhc3N1bXB0aW9uXG4gICAgcGF0aEFycmF5ID0gcGFyc2VQYXRoU3RyaW5nKHBhdGhBcnJheSk7XG4gIH1cblxuICBpZiAoIXBhdGhBcnJheSB8fCAhcGF0aEFycmF5Lmxlbmd0aCkge1xuICAgIHJldHVybiBbWydNJywgMCwgMF1dO1xuICB9XG5cbiAgdmFyIHJlcyA9IFtdLFxuICAgICAgeCA9IDAsXG4gICAgICB5ID0gMCxcbiAgICAgIG14ID0gMCxcbiAgICAgIG15ID0gMCxcbiAgICAgIHN0YXJ0ID0gMCxcbiAgICAgIHBhMDtcblxuICBpZiAocGF0aEFycmF5WzBdWzBdID09ICdNJykge1xuICAgIHggPSArcGF0aEFycmF5WzBdWzFdO1xuICAgIHkgPSArcGF0aEFycmF5WzBdWzJdO1xuICAgIG14ID0geDtcbiAgICBteSA9IHk7XG4gICAgc3RhcnQrKztcbiAgICByZXNbMF0gPSBbJ00nLCB4LCB5XTtcbiAgfVxuXG4gIGZvciAodmFyIHIsIHBhLCBpID0gc3RhcnQsIGlpID0gcGF0aEFycmF5Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICByZXMucHVzaChyID0gW10pO1xuICAgIHBhID0gcGF0aEFycmF5W2ldO1xuICAgIHBhMCA9IHBhWzBdO1xuXG4gICAgaWYgKHBhMCAhPSBwYTAudG9VcHBlckNhc2UoKSkge1xuICAgICAgclswXSA9IHBhMC50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICBzd2l0Y2ggKHJbMF0pIHtcbiAgICAgIGNhc2UgJ0EnOlxuICAgICAgICByWzFdID0gcGFbMV07XG4gICAgICAgIHJbMl0gPSBwYVsyXTtcbiAgICAgICAgclszXSA9IHBhWzNdO1xuICAgICAgICByWzRdID0gcGFbNF07XG4gICAgICAgIHJbNV0gPSBwYVs1XTtcbiAgICAgICAgcls2XSA9ICtwYVs2XSArIHg7XG4gICAgICAgIHJbN10gPSArcGFbN10gKyB5O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1YnOlxuICAgICAgICByWzFdID0gK3BhWzFdICsgeTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdIJzpcbiAgICAgICAgclsxXSA9ICtwYVsxXSArIHg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTSc6XG4gICAgICAgIG14ID0gK3BhWzFdICsgeDtcbiAgICAgICAgbXkgPSArcGFbMl0gKyB5O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZm9yICh2YXIgaiA9IDEsIGpqID0gcGEubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgIHJbal0gPSArcGFbal0gKyAoKGogJSAyKSA/IHggOiB5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBrID0gMCwga2sgPSBwYS5sZW5ndGg7IGsgPCBrazsgaysrKSB7XG4gICAgICAgIHJba10gPSBwYVtrXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcGEwID0gcGEwLnRvVXBwZXJDYXNlKCk7XG5cbiAgICBzd2l0Y2ggKHJbMF0pIHtcbiAgICBjYXNlICdaJzpcbiAgICAgIHggPSArbXg7XG4gICAgICB5ID0gK215O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnSCc6XG4gICAgICB4ID0gclsxXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1YnOlxuICAgICAgeSA9IHJbMV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdNJzpcbiAgICAgIG14ID0gcltyLmxlbmd0aCAtIDJdO1xuICAgICAgbXkgPSByW3IubGVuZ3RoIC0gMV07XG4gICAgZGVmYXVsdDpcbiAgICAgIHggPSByW3IubGVuZ3RoIC0gMl07XG4gICAgICB5ID0gcltyLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgfVxuXG4gIHJlcy50b1N0cmluZyA9IHBhdGhUb1N0cmluZztcbiAgcHRoLmFicyA9IHBhdGhDbG9uZShyZXMpO1xuXG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGlzTGluZShiZXopIHtcbiAgcmV0dXJuIChcbiAgICBiZXpbMF0gPT09IGJlelsyXSAmJlxuICAgIGJlelsxXSA9PT0gYmV6WzNdICYmXG4gICAgYmV6WzRdID09PSBiZXpbNl0gJiZcbiAgICBiZXpbNV0gPT09IGJlels3XVxuICApO1xufVxuXG5mdW5jdGlvbiBsaW5lVG9DdXJ2ZSh4MSwgeTEsIHgyLCB5Mikge1xuICByZXR1cm4gW1xuICAgIHgxLCB5MSwgeDIsXG4gICAgeTIsIHgyLCB5MlxuICBdO1xufVxuXG5mdW5jdGlvbiBxdWJpY1RvQ3VydmUoeDEsIHkxLCBheCwgYXksIHgyLCB5Mikge1xuICB2YXIgXzEzID0gMSAvIDMsXG4gICAgICBfMjMgPSAyIC8gMztcblxuICByZXR1cm4gW1xuICAgIF8xMyAqIHgxICsgXzIzICogYXgsXG4gICAgXzEzICogeTEgKyBfMjMgKiBheSxcbiAgICBfMTMgKiB4MiArIF8yMyAqIGF4LFxuICAgIF8xMyAqIHkyICsgXzIzICogYXksXG4gICAgeDIsXG4gICAgeTJcbiAgXTtcbn1cblxuZnVuY3Rpb24gYXJjVG9DdXJ2ZSh4MSwgeTEsIHJ4LCByeSwgYW5nbGUsIGxhcmdlX2FyY19mbGFnLCBzd2VlcF9mbGFnLCB4MiwgeTIsIHJlY3Vyc2l2ZSkge1xuXG4gIC8vIGZvciBtb3JlIGluZm9ybWF0aW9uIG9mIHdoZXJlIHRoaXMgbWF0aCBjYW1lIGZyb20gdmlzaXQ6XG4gIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ltcGxub3RlLmh0bWwjQXJjSW1wbGVtZW50YXRpb25Ob3Rlc1xuICB2YXIgXzEyMCA9IFBJICogMTIwIC8gMTgwLFxuICAgICAgcmFkID0gUEkgLyAxODAgKiAoK2FuZ2xlIHx8IDApLFxuICAgICAgcmVzID0gW10sXG4gICAgICB4eSxcbiAgICAgIHJvdGF0ZSA9IGNhY2hlcihmdW5jdGlvbih4LCB5LCByYWQpIHtcbiAgICAgICAgdmFyIFggPSB4ICogbWF0aC5jb3MocmFkKSAtIHkgKiBtYXRoLnNpbihyYWQpLFxuICAgICAgICAgICAgWSA9IHggKiBtYXRoLnNpbihyYWQpICsgeSAqIG1hdGguY29zKHJhZCk7XG5cbiAgICAgICAgcmV0dXJuIHsgeDogWCwgeTogWSB9O1xuICAgICAgfSk7XG5cbiAgaWYgKCFyZWN1cnNpdmUpIHtcbiAgICB4eSA9IHJvdGF0ZSh4MSwgeTEsIC1yYWQpO1xuICAgIHgxID0geHkueDtcbiAgICB5MSA9IHh5Lnk7XG4gICAgeHkgPSByb3RhdGUoeDIsIHkyLCAtcmFkKTtcbiAgICB4MiA9IHh5Lng7XG4gICAgeTIgPSB4eS55O1xuXG4gICAgdmFyIHggPSAoeDEgLSB4MikgLyAyLFxuICAgICAgICB5ID0gKHkxIC0geTIpIC8gMjtcblxuICAgIHZhciBoID0gKHggKiB4KSAvIChyeCAqIHJ4KSArICh5ICogeSkgLyAocnkgKiByeSk7XG5cbiAgICBpZiAoaCA+IDEpIHtcbiAgICAgIGggPSBtYXRoLnNxcnQoaCk7XG4gICAgICByeCA9IGggKiByeDtcbiAgICAgIHJ5ID0gaCAqIHJ5O1xuICAgIH1cblxuICAgIHZhciByeDIgPSByeCAqIHJ4LFxuICAgICAgICByeTIgPSByeSAqIHJ5LFxuICAgICAgICBrID0gKGxhcmdlX2FyY19mbGFnID09IHN3ZWVwX2ZsYWcgPyAtMSA6IDEpICpcbiAgICAgICAgICAgIG1hdGguc3FydChhYnMoKHJ4MiAqIHJ5MiAtIHJ4MiAqIHkgKiB5IC0gcnkyICogeCAqIHgpIC8gKHJ4MiAqIHkgKiB5ICsgcnkyICogeCAqIHgpKSksXG4gICAgICAgIGN4ID0gayAqIHJ4ICogeSAvIHJ5ICsgKHgxICsgeDIpIC8gMixcbiAgICAgICAgY3kgPSBrICogLXJ5ICogeCAvIHJ4ICsgKHkxICsgeTIpIC8gMixcbiAgICAgICAgZjEgPSBtYXRoLmFzaW4oKCh5MSAtIGN5KSAvIHJ5KS50b0ZpeGVkKDkpKSxcbiAgICAgICAgZjIgPSBtYXRoLmFzaW4oKCh5MiAtIGN5KSAvIHJ5KS50b0ZpeGVkKDkpKTtcblxuICAgIGYxID0geDEgPCBjeCA/IFBJIC0gZjEgOiBmMTtcbiAgICBmMiA9IHgyIDwgY3ggPyBQSSAtIGYyIDogZjI7XG4gICAgZjEgPCAwICYmIChmMSA9IFBJICogMiArIGYxKTtcbiAgICBmMiA8IDAgJiYgKGYyID0gUEkgKiAyICsgZjIpO1xuXG4gICAgaWYgKHN3ZWVwX2ZsYWcgJiYgZjEgPiBmMikge1xuICAgICAgZjEgPSBmMSAtIFBJICogMjtcbiAgICB9XG4gICAgaWYgKCFzd2VlcF9mbGFnICYmIGYyID4gZjEpIHtcbiAgICAgIGYyID0gZjIgLSBQSSAqIDI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGYxID0gcmVjdXJzaXZlWzBdO1xuICAgIGYyID0gcmVjdXJzaXZlWzFdO1xuICAgIGN4ID0gcmVjdXJzaXZlWzJdO1xuICAgIGN5ID0gcmVjdXJzaXZlWzNdO1xuICB9XG5cbiAgdmFyIGRmID0gZjIgLSBmMTtcblxuICBpZiAoYWJzKGRmKSA+IF8xMjApIHtcbiAgICB2YXIgZjJvbGQgPSBmMixcbiAgICAgICAgeDJvbGQgPSB4MixcbiAgICAgICAgeTJvbGQgPSB5MjtcblxuICAgIGYyID0gZjEgKyBfMTIwICogKHN3ZWVwX2ZsYWcgJiYgZjIgPiBmMSA/IDEgOiAtMSk7XG4gICAgeDIgPSBjeCArIHJ4ICogbWF0aC5jb3MoZjIpO1xuICAgIHkyID0gY3kgKyByeSAqIG1hdGguc2luKGYyKTtcbiAgICByZXMgPSBhcmNUb0N1cnZlKHgyLCB5MiwgcngsIHJ5LCBhbmdsZSwgMCwgc3dlZXBfZmxhZywgeDJvbGQsIHkyb2xkLCBbZjIsIGYyb2xkLCBjeCwgY3ldKTtcbiAgfVxuXG4gIGRmID0gZjIgLSBmMTtcblxuICB2YXIgYzEgPSBtYXRoLmNvcyhmMSksXG4gICAgICBzMSA9IG1hdGguc2luKGYxKSxcbiAgICAgIGMyID0gbWF0aC5jb3MoZjIpLFxuICAgICAgczIgPSBtYXRoLnNpbihmMiksXG4gICAgICB0ID0gbWF0aC50YW4oZGYgLyA0KSxcbiAgICAgIGh4ID0gNCAvIDMgKiByeCAqIHQsXG4gICAgICBoeSA9IDQgLyAzICogcnkgKiB0LFxuICAgICAgbTEgPSBbeDEsIHkxXSxcbiAgICAgIG0yID0gW3gxICsgaHggKiBzMSwgeTEgLSBoeSAqIGMxXSxcbiAgICAgIG0zID0gW3gyICsgaHggKiBzMiwgeTIgLSBoeSAqIGMyXSxcbiAgICAgIG00ID0gW3gyLCB5Ml07XG5cbiAgbTJbMF0gPSAyICogbTFbMF0gLSBtMlswXTtcbiAgbTJbMV0gPSAyICogbTFbMV0gLSBtMlsxXTtcblxuICBpZiAocmVjdXJzaXZlKSB7XG4gICAgcmV0dXJuIFttMiwgbTMsIG00XS5jb25jYXQocmVzKTtcbiAgfSBlbHNlIHtcbiAgICByZXMgPSBbbTIsIG0zLCBtNF0uY29uY2F0KHJlcykuam9pbigpLnNwbGl0KCcsJyk7XG4gICAgdmFyIG5ld3JlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcmVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIG5ld3Jlc1tpXSA9IGkgJSAyID8gcm90YXRlKHJlc1tpIC0gMV0sIHJlc1tpXSwgcmFkKS55IDogcm90YXRlKHJlc1tpXSwgcmVzW2kgKyAxXSwgcmFkKS54O1xuICAgIH1cblxuICAgIHJldHVybiBuZXdyZXM7XG4gIH1cbn1cblxuLy8gUmV0dXJucyBib3VuZGluZyBib3ggb2YgY3ViaWMgYmV6aWVyIGN1cnZlLlxuLy8gU291cmNlOiBodHRwOi8vYmxvZy5oYWNrZXJzLWNhZmUubmV0LzIwMDkvMDYvaG93LXRvLWNhbGN1bGF0ZS1iZXppZXItY3VydmVzLWJvdW5kaW5nLmh0bWxcbi8vIE9yaWdpbmFsIHZlcnNpb246IE5JU0hJTyBIaXJva2F6dVxuLy8gTW9kaWZpY2F0aW9uczogaHR0cHM6Ly9naXRodWIuY29tL3RpbW8yMjM0NVxuZnVuY3Rpb24gY3VydmVCQm94KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICB2YXIgdHZhbHVlcyA9IFtdLFxuICAgICAgYm91bmRzID0gW1tdLCBbXV0sXG4gICAgICBhLCBiLCBjLCB0LCB0MSwgdDIsIGIyYWMsIHNxcnRiMmFjO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgKytpKSB7XG5cbiAgICBpZiAoaSA9PSAwKSB7XG4gICAgICBiID0gNiAqIHgwIC0gMTIgKiB4MSArIDYgKiB4MjtcbiAgICAgIGEgPSAtMyAqIHgwICsgOSAqIHgxIC0gOSAqIHgyICsgMyAqIHgzO1xuICAgICAgYyA9IDMgKiB4MSAtIDMgKiB4MDtcbiAgICB9IGVsc2Uge1xuICAgICAgYiA9IDYgKiB5MCAtIDEyICogeTEgKyA2ICogeTI7XG4gICAgICBhID0gLTMgKiB5MCArIDkgKiB5MSAtIDkgKiB5MiArIDMgKiB5MztcbiAgICAgIGMgPSAzICogeTEgLSAzICogeTA7XG4gICAgfVxuXG4gICAgaWYgKGFicyhhKSA8IDFlLTEyKSB7XG5cbiAgICAgIGlmIChhYnMoYikgPCAxZS0xMikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdCA9IC1jIC8gYjtcblxuICAgICAgaWYgKDAgPCB0ICYmIHQgPCAxKSB7XG4gICAgICAgIHR2YWx1ZXMucHVzaCh0KTtcbiAgICAgIH1cblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgYjJhYyA9IGIgKiBiIC0gNCAqIGMgKiBhO1xuICAgIHNxcnRiMmFjID0gbWF0aC5zcXJ0KGIyYWMpO1xuXG4gICAgaWYgKGIyYWMgPCAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0MSA9ICgtYiArIHNxcnRiMmFjKSAvICgyICogYSk7XG5cbiAgICBpZiAoMCA8IHQxICYmIHQxIDwgMSkge1xuICAgICAgdHZhbHVlcy5wdXNoKHQxKTtcbiAgICB9XG5cbiAgICB0MiA9ICgtYiAtIHNxcnRiMmFjKSAvICgyICogYSk7XG5cbiAgICBpZiAoMCA8IHQyICYmIHQyIDwgMSkge1xuICAgICAgdHZhbHVlcy5wdXNoKHQyKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaiA9IHR2YWx1ZXMubGVuZ3RoLFxuICAgICAgamxlbiA9IGosXG4gICAgICBtdDtcblxuICB3aGlsZSAoai0tKSB7XG4gICAgdCA9IHR2YWx1ZXNbal07XG4gICAgbXQgPSAxIC0gdDtcbiAgICBib3VuZHNbMF1bal0gPSAobXQgKiBtdCAqIG10ICogeDApICsgKDMgKiBtdCAqIG10ICogdCAqIHgxKSArICgzICogbXQgKiB0ICogdCAqIHgyKSArICh0ICogdCAqIHQgKiB4Myk7XG4gICAgYm91bmRzWzFdW2pdID0gKG10ICogbXQgKiBtdCAqIHkwKSArICgzICogbXQgKiBtdCAqIHQgKiB5MSkgKyAoMyAqIG10ICogdCAqIHQgKiB5MikgKyAodCAqIHQgKiB0ICogeTMpO1xuICB9XG5cbiAgYm91bmRzWzBdW2psZW5dID0geDA7XG4gIGJvdW5kc1sxXVtqbGVuXSA9IHkwO1xuICBib3VuZHNbMF1bamxlbiArIDFdID0geDM7XG4gIGJvdW5kc1sxXVtqbGVuICsgMV0gPSB5MztcbiAgYm91bmRzWzBdLmxlbmd0aCA9IGJvdW5kc1sxXS5sZW5ndGggPSBqbGVuICsgMjtcblxuICByZXR1cm4ge1xuICAgIHgwOiBtbWluLmFwcGx5KDAsIGJvdW5kc1swXSksXG4gICAgeTA6IG1taW4uYXBwbHkoMCwgYm91bmRzWzFdKSxcbiAgICB4MTogbW1heC5hcHBseSgwLCBib3VuZHNbMF0pLFxuICAgIHkxOiBtbWF4LmFwcGx5KDAsIGJvdW5kc1sxXSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGF0aFRvQ3VydmUocGF0aCkge1xuXG4gIHZhciBwdGggPSBwYXRocyhwYXRoKTtcblxuICAvLyByZXR1cm4gY2FjaGVkIGN1cnZlLCBpZiBleGlzdGluZ1xuICBpZiAocHRoLmN1cnZlKSB7XG4gICAgcmV0dXJuIHBhdGhDbG9uZShwdGguY3VydmUpO1xuICB9XG5cbiAgdmFyIGN1cnZlZFBhdGggPSBwYXRoVG9BYnNvbHV0ZShwYXRoKSxcbiAgICAgIGF0dHJzID0geyB4OiAwLCB5OiAwLCBieDogMCwgYnk6IDAsIFg6IDAsIFk6IDAsIHF4OiBudWxsLCBxeTogbnVsbCB9LFxuICAgICAgcHJvY2Vzc1BhdGggPSBmdW5jdGlvbihwYXRoLCBkLCBwYXRoQ29tbWFuZCkge1xuICAgICAgICB2YXIgbngsIG55O1xuXG4gICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgIHJldHVybiBbJ0MnLCBkLngsIGQueSwgZC54LCBkLnksIGQueCwgZC55XTtcbiAgICAgICAgfVxuXG4gICAgICAgICEocGF0aFswXSBpbiB7IFQ6IDEsIFE6IDEgfSkgJiYgKGQucXggPSBkLnF5ID0gbnVsbCk7XG5cbiAgICAgICAgc3dpdGNoIChwYXRoWzBdKSB7XG4gICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgIGQuWCA9IHBhdGhbMV07XG4gICAgICAgICAgZC5ZID0gcGF0aFsyXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgcGF0aCA9IFsnQyddLmNvbmNhdChhcmNUb0N1cnZlLmFwcGx5KDAsIFtkLngsIGQueV0uY29uY2F0KHBhdGguc2xpY2UoMSkpKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgIGlmIChwYXRoQ29tbWFuZCA9PSAnQycgfHwgcGF0aENvbW1hbmQgPT0gJ1MnKSB7XG4gICAgICAgICAgICAvLyBJbiAnUycgY2FzZSB3ZSBoYXZlIHRvIHRha2UgaW50byBhY2NvdW50LCBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCBpcyBDL1MuXG4gICAgICAgICAgICBueCA9IGQueCAqIDIgLSBkLmJ4O1xuICAgICAgICAgICAgLy8gQW5kIHJlZmxlY3QgdGhlIHByZXZpb3VzXG4gICAgICAgICAgICBueSA9IGQueSAqIDIgLSBkLmJ5O1xuICAgICAgICAgICAgLy8gY29tbWFuZCdzIGNvbnRyb2wgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9pbnQuXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gb3Igc29tZSBlbHNlIG9yIG5vdGhpbmdcbiAgICAgICAgICAgIG54ID0gZC54O1xuICAgICAgICAgICAgbnkgPSBkLnk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhdGggPSBbJ0MnLCBueCwgbnldLmNvbmNhdChwYXRoLnNsaWNlKDEpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgaWYgKHBhdGhDb21tYW5kID09ICdRJyB8fCBwYXRoQ29tbWFuZCA9PSAnVCcpIHtcbiAgICAgICAgICAgIC8vIEluICdUJyBjYXNlIHdlIGhhdmUgdG8gdGFrZSBpbnRvIGFjY291bnQsIGlmIHRoZSBwcmV2aW91cyBjb21tYW5kIGlzIFEvVC5cbiAgICAgICAgICAgIGQucXggPSBkLnggKiAyIC0gZC5xeDtcbiAgICAgICAgICAgIC8vIEFuZCBtYWtlIGEgcmVmbGVjdGlvbiBzaW1pbGFyXG4gICAgICAgICAgICBkLnF5ID0gZC55ICogMiAtIGQucXk7XG4gICAgICAgICAgICAvLyB0byBjYXNlICdTJy5cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBvciBzb21ldGhpbmcgZWxzZSBvciBub3RoaW5nXG4gICAgICAgICAgICBkLnF4ID0gZC54O1xuICAgICAgICAgICAgZC5xeSA9IGQueTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0aCA9IFsnQyddLmNvbmNhdChxdWJpY1RvQ3VydmUoZC54LCBkLnksIGQucXgsIGQucXksIHBhdGhbMV0sIHBhdGhbMl0pKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgZC5xeCA9IHBhdGhbMV07XG4gICAgICAgICAgZC5xeSA9IHBhdGhbMl07XG4gICAgICAgICAgcGF0aCA9IFsnQyddLmNvbmNhdChxdWJpY1RvQ3VydmUoZC54LCBkLnksIHBhdGhbMV0sIHBhdGhbMl0sIHBhdGhbM10sIHBhdGhbNF0pKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgcGF0aCA9IFsnQyddLmNvbmNhdChsaW5lVG9DdXJ2ZShkLngsIGQueSwgcGF0aFsxXSwgcGF0aFsyXSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICBwYXRoID0gWydDJ10uY29uY2F0KGxpbmVUb0N1cnZlKGQueCwgZC55LCBwYXRoWzFdLCBkLnkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgcGF0aCA9IFsnQyddLmNvbmNhdChsaW5lVG9DdXJ2ZShkLngsIGQueSwgZC54LCBwYXRoWzFdKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgIHBhdGggPSBbJ0MnXS5jb25jYXQobGluZVRvQ3VydmUoZC54LCBkLnksIGQuWCwgZC5ZKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH0sXG5cbiAgICAgIGZpeEFyYyA9IGZ1bmN0aW9uKHBwLCBpKSB7XG5cbiAgICAgICAgaWYgKHBwW2ldLmxlbmd0aCA+IDcpIHtcbiAgICAgICAgICBwcFtpXS5zaGlmdCgpO1xuICAgICAgICAgIHZhciBwaSA9IHBwW2ldO1xuXG4gICAgICAgICAgd2hpbGUgKHBpLmxlbmd0aCkge1xuICAgICAgICAgICAgcGF0aENvbW1hbmRzW2ldID0gJ0EnOyAvLyBpZiBjcmVhdGVkIG11bHRpcGxlIEM6cywgdGhlaXIgb3JpZ2luYWwgc2VnIGlzIHNhdmVkXG4gICAgICAgICAgICBwcC5zcGxpY2UoaSsrLCAwLCBbJ0MnXS5jb25jYXQocGkuc3BsaWNlKDAsIDYpKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHAuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGlpID0gY3VydmVkUGF0aC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHBhdGhDb21tYW5kcyA9IFtdLCAvLyBwYXRoIGNvbW1hbmRzIG9mIG9yaWdpbmFsIHBhdGggcFxuICAgICAgcGZpcnN0ID0gJycsIC8vIHRlbXBvcmFyeSBob2xkZXIgZm9yIG9yaWdpbmFsIHBhdGggY29tbWFuZFxuICAgICAgcGF0aENvbW1hbmQgPSAnJzsgLy8gaG9sZGVyIGZvciBwcmV2aW91cyBwYXRoIGNvbW1hbmQgb2Ygb3JpZ2luYWwgcGF0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGN1cnZlZFBhdGgubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIGN1cnZlZFBhdGhbaV0gJiYgKHBmaXJzdCA9IGN1cnZlZFBhdGhbaV1bMF0pOyAvLyBzYXZlIGN1cnJlbnQgcGF0aCBjb21tYW5kXG5cbiAgICBpZiAocGZpcnN0ICE9ICdDJykgLy8gQyBpcyBub3Qgc2F2ZWQgeWV0LCBiZWNhdXNlIGl0IG1heSBiZSByZXN1bHQgb2YgY29udmVyc2lvblxuICAgIHtcbiAgICAgIHBhdGhDb21tYW5kc1tpXSA9IHBmaXJzdDsgLy8gU2F2ZSBjdXJyZW50IHBhdGggY29tbWFuZFxuICAgICAgaSAmJiAocGF0aENvbW1hbmQgPSBwYXRoQ29tbWFuZHNbaSAtIDFdKTsgLy8gR2V0IHByZXZpb3VzIHBhdGggY29tbWFuZCBwYXRoQ29tbWFuZFxuICAgIH1cbiAgICBjdXJ2ZWRQYXRoW2ldID0gcHJvY2Vzc1BhdGgoY3VydmVkUGF0aFtpXSwgYXR0cnMsIHBhdGhDb21tYW5kKTsgLy8gUHJldmlvdXMgcGF0aCBjb21tYW5kIGlzIGlucHV0dGVkIHRvIHByb2Nlc3NQYXRoXG5cbiAgICBpZiAocGF0aENvbW1hbmRzW2ldICE9ICdBJyAmJiBwZmlyc3QgPT0gJ0MnKSBwYXRoQ29tbWFuZHNbaV0gPSAnQyc7IC8vIEEgaXMgdGhlIG9ubHkgY29tbWFuZFxuICAgIC8vIHdoaWNoIG1heSBwcm9kdWNlIG11bHRpcGxlIEM6c1xuICAgIC8vIHNvIHdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgQyBpcyBhbHNvIEMgaW4gb3JpZ2luYWwgcGF0aFxuXG4gICAgZml4QXJjKGN1cnZlZFBhdGgsIGkpOyAvLyBmaXhBcmMgYWRkcyBhbHNvIHRoZSByaWdodCBhbW91bnQgb2YgQTpzIHRvIHBhdGhDb21tYW5kc1xuXG4gICAgdmFyIHNlZyA9IGN1cnZlZFBhdGhbaV0sXG4gICAgICAgIHNlZ2xlbiA9IHNlZy5sZW5ndGg7XG5cbiAgICBhdHRycy54ID0gc2VnW3NlZ2xlbiAtIDJdO1xuICAgIGF0dHJzLnkgPSBzZWdbc2VnbGVuIC0gMV07XG4gICAgYXR0cnMuYnggPSB0b0Zsb2F0KHNlZ1tzZWdsZW4gLSA0XSkgfHwgYXR0cnMueDtcbiAgICBhdHRycy5ieSA9IHRvRmxvYXQoc2VnW3NlZ2xlbiAtIDNdKSB8fCBhdHRycy55O1xuICB9XG5cbiAgLy8gY2FjaGUgY3VydmVcbiAgcHRoLmN1cnZlID0gcGF0aENsb25lKGN1cnZlZFBhdGgpO1xuXG4gIHJldHVybiBjdXJ2ZWRQYXRoO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRQYXRoSW50ZXJzZWN0aW9ucztcbiIsInZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgRU5USVRZX1BBVFRFUk4gPSAvJiMoXFxkKyk7fCYjeChbMC05YS1mXSspO3wmKFxcdyspOy9pZztcblxudmFyIEVOVElUWV9NQVBQSU5HID0ge1xuICAnYW1wJzogJyYnLFxuICAnYXBvcyc6ICdcXCcnLFxuICAnZ3QnOiAnPicsXG4gICdsdCc6ICc8JyxcbiAgJ3F1b3QnOiAnXCInXG59O1xuXG4vLyBtYXAgVVBQRVJDQVNFIHZhcmlhbnRzIG9mIHN1cHBvcnRlZCBzcGVjaWFsIGNoYXJzXG5PYmplY3Qua2V5cyhFTlRJVFlfTUFQUElORykuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gIEVOVElUWV9NQVBQSU5HW2sudG9VcHBlckNhc2UoKV0gPSBFTlRJVFlfTUFQUElOR1trXTtcbn0pO1xuXG5cbmZ1bmN0aW9uIHJlcGxhY2VFbnRpdGllcyhfLCBkLCB4LCB6KSB7XG5cbiAgLy8gcmVzZXJ2ZWQgbmFtZXMsIGkuZS4gJm5ic3A7XG4gIGlmICh6KSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoRU5USVRZX01BUFBJTkcsIHopKSB7XG4gICAgICByZXR1cm4gRU5USVRZX01BUFBJTkdbel07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZhbGwgYmFjayB0byBvcmlnaW5hbCB2YWx1ZVxuICAgICAgcmV0dXJuICcmJyArIHogKyAnOyc7XG4gICAgfVxuICB9XG5cbiAgLy8gZGVjaW1hbCBlbmNvZGVkIGNoYXJcbiAgaWYgKGQpIHtcbiAgICByZXR1cm4gZnJvbUNoYXJDb2RlKGQpO1xuICB9XG5cbiAgLy8gaGV4IGVuY29kZWQgY2hhclxuICByZXR1cm4gZnJvbUNoYXJDb2RlKHBhcnNlSW50KHgsIDE2KSk7XG59XG5cblxuLyoqXG4gKiBBIGJhc2ljIGVudGl0eSBkZWNvZGVyIHRoYXQgY2FuIGRlY29kZSBhIG1pbmltYWxcbiAqIHN1Yi1zZXQgb2YgcmVzZXJ2ZWQgbmFtZXMgKCZhbXA7KSBhcyB3ZWxsIGFzXG4gKiBoZXggKCYjeGFhZjspIGFuZCBkZWNpbWFsICgmIzEyMzE7KSBlbmNvZGVkIGNoYXJhY3RlcnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gZGVjb2RlZCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZGVjb2RlRW50aXRpZXMocykge1xuICBpZiAocy5sZW5ndGggPiAzICYmIHMuaW5kZXhPZignJicpICE9PSAtMSkge1xuICAgIHJldHVybiBzLnJlcGxhY2UoRU5USVRZX1BBVFRFUk4sIHJlcGxhY2VFbnRpdGllcyk7XG4gIH1cblxuICByZXR1cm4gcztcbn1cblxudmFyIFhTSV9VUkkgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEtaW5zdGFuY2UnO1xudmFyIFhTSV9QUkVGSVggPSAneHNpJztcbnZhciBYU0lfVFlQRSA9ICd4c2k6dHlwZSc7XG5cbnZhciBOT05fV0hJVEVTUEFDRV9PVVRTSURFX1JPT1RfTk9ERSA9ICdub24td2hpdGVzcGFjZSBvdXRzaWRlIG9mIHJvb3Qgbm9kZSc7XG5cbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICByZXR1cm4gbmV3IEVycm9yKG1zZyk7XG59XG5cbmZ1bmN0aW9uIG1pc3NpbmdOYW1lc3BhY2VGb3JQcmVmaXgocHJlZml4KSB7XG4gIHJldHVybiAnbWlzc2luZyBuYW1lc3BhY2UgZm9yIHByZWZpeCA8JyArIHByZWZpeCArICc+Jztcbn1cblxuZnVuY3Rpb24gZ2V0dGVyKGdldEZuKSB7XG4gIHJldHVybiB7XG4gICAgJ2dldCc6IGdldEZuLFxuICAgICdlbnVtZXJhYmxlJzogdHJ1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBjbG9uZU5zTWF0cml4KG5zTWF0cml4KSB7XG4gIHZhciBjbG9uZSA9IHt9LCBrZXk7XG4gIGZvciAoa2V5IGluIG5zTWF0cml4KSB7XG4gICAgY2xvbmVba2V5XSA9IG5zTWF0cml4W2tleV07XG4gIH1cbiAgcmV0dXJuIGNsb25lO1xufVxuXG5mdW5jdGlvbiB1cmlQcmVmaXgocHJlZml4KSB7XG4gIHJldHVybiBwcmVmaXggKyAnJHVyaSc7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkTnNNYXRyaXgobnNVcmlUb1ByZWZpeCkge1xuICB2YXIgbnNNYXRyaXggPSB7fSxcbiAgICAgIHVyaSxcbiAgICAgIHByZWZpeDtcblxuICBmb3IgKHVyaSBpbiBuc1VyaVRvUHJlZml4KSB7XG4gICAgcHJlZml4ID0gbnNVcmlUb1ByZWZpeFt1cmldO1xuICAgIG5zTWF0cml4W3ByZWZpeF0gPSBwcmVmaXg7XG4gICAgbnNNYXRyaXhbdXJpUHJlZml4KHByZWZpeCldID0gdXJpO1xuICB9XG5cbiAgcmV0dXJuIG5zTWF0cml4O1xufVxuXG5mdW5jdGlvbiBub29wR2V0Q29udGV4dCgpIHtcbiAgcmV0dXJuIHsgJ2xpbmUnOiAwLCAnY29sdW1uJzogMCB9O1xufVxuXG5mdW5jdGlvbiB0aHJvd0Z1bmMoZXJyKSB7XG4gIHRocm93IGVycjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHBhcnNlciB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSAgeyFPYmplY3Q8c3RyaW5nLCA/Pj19IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gUGFyc2VyKG9wdGlvbnMpIHtcblxuICBpZiAoIXRoaXMpIHtcbiAgICByZXR1cm4gbmV3IFBhcnNlcihvcHRpb25zKTtcbiAgfVxuXG4gIHZhciBwcm94eSA9IG9wdGlvbnMgJiYgb3B0aW9uc1sncHJveHknXTtcblxuICB2YXIgb25UZXh0LFxuICAgICAgb25PcGVuVGFnLFxuICAgICAgb25DbG9zZVRhZyxcbiAgICAgIG9uQ0RBVEEsXG4gICAgICBvbkVycm9yID0gdGhyb3dGdW5jLFxuICAgICAgb25XYXJuaW5nLFxuICAgICAgb25Db21tZW50LFxuICAgICAgb25RdWVzdGlvbixcbiAgICAgIG9uQXR0ZW50aW9uO1xuXG4gIHZhciBnZXRDb250ZXh0ID0gbm9vcEdldENvbnRleHQ7XG5cbiAgLyoqXG4gICAqIERvIHdlIG5lZWQgdG8gcGFyc2UgdGhlIGN1cnJlbnQgZWxlbWVudHMgYXR0cmlidXRlcyBmb3IgbmFtZXNwYWNlcz9cbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICB2YXIgbWF5YmVOUyA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBEbyB3ZSBwcm9jZXNzIG5hbWVzcGFjZXMgYXQgYWxsP1xuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHZhciBpc05hbWVzcGFjZSA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUaGUgY2F1Z2h0IGVycm9yIHJldHVybmVkIG9uIHBhcnNlIGVuZFxuICAgKlxuICAgKiBAdHlwZSB7RXJyb3J9XG4gICAqL1xuICB2YXIgcmV0dXJuRXJyb3IgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBTaG91bGQgd2Ugc3RvcCBwYXJzaW5nP1xuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHZhciBwYXJzZVN0b3AgPSBmYWxzZTtcblxuICAvKipcbiAgICogQSBtYXAgb2YgeyB1cmk6IHByZWZpeCB9IHVzZWQgYnkgdGhlIHBhcnNlci5cbiAgICpcbiAgICogVGhpcyBtYXAgd2lsbCBlbnN1cmUgd2UgY2FuIG5vcm1hbGl6ZSBwcmVmaXhlcyBkdXJpbmcgcHJvY2Vzc2luZztcbiAgICogZm9yIGVhY2ggdXJpLCBvbmx5IG9uZSBwcmVmaXggd2lsbCBiZSBleHBvc2VkIHRvIHRoZSBoYW5kbGVycy5cbiAgICpcbiAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fX1cbiAgICovXG4gIHZhciBuc1VyaVRvUHJlZml4O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgcGFyc2UgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xFcnJvcn0gZXJyXG4gICAqL1xuICBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnIpIHtcbiAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgIGVyciA9IGVycm9yKGVycik7XG4gICAgfVxuXG4gICAgcmV0dXJuRXJyb3IgPSBlcnI7XG5cbiAgICBvbkVycm9yKGVyciwgZ2V0Q29udGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBhcnNlIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8RXJyb3J9IGVyclxuICAgKi9cbiAgZnVuY3Rpb24gaGFuZGxlV2FybmluZyhlcnIpIHtcblxuICAgIGlmICghb25XYXJuaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICBlcnIgPSBlcnJvcihlcnIpO1xuICAgIH1cblxuICAgIG9uV2FybmluZyhlcnIsIGdldENvbnRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIHBhcnNlIGxpc3RlbmVyLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgbmFtZVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICpcbiAgICogQHJldHVybiB7UGFyc2VyfVxuICAgKi9cbiAgdGhpc1snb24nXSA9IGZ1bmN0aW9uKG5hbWUsIGNiKSB7XG5cbiAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBlcnJvcigncmVxdWlyZWQgYXJncyA8bmFtZSwgY2I+Jyk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSAnb3BlblRhZyc6IG9uT3BlblRhZyA9IGNiOyBicmVhaztcbiAgICBjYXNlICd0ZXh0Jzogb25UZXh0ID0gY2I7IGJyZWFrO1xuICAgIGNhc2UgJ2Nsb3NlVGFnJzogb25DbG9zZVRhZyA9IGNiOyBicmVhaztcbiAgICBjYXNlICdlcnJvcic6IG9uRXJyb3IgPSBjYjsgYnJlYWs7XG4gICAgY2FzZSAnd2Fybic6IG9uV2FybmluZyA9IGNiOyBicmVhaztcbiAgICBjYXNlICdjZGF0YSc6IG9uQ0RBVEEgPSBjYjsgYnJlYWs7XG4gICAgY2FzZSAnYXR0ZW50aW9uJzogb25BdHRlbnRpb24gPSBjYjsgYnJlYWs7IC8vIDwhWFhYWFggenp6ej1cImVlZWVcIj5cbiAgICBjYXNlICdxdWVzdGlvbic6IG9uUXVlc3Rpb24gPSBjYjsgYnJlYWs7IC8vIDw/IC4uLi4gID8+XG4gICAgY2FzZSAnY29tbWVudCc6IG9uQ29tbWVudCA9IGNiOyBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgZXJyb3IoJ3Vuc3VwcG9ydGVkIGV2ZW50OiAnICsgbmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbmFtZXNwYWNlIHRvIHByZWZpeCBtYXBwaW5nLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBwYXJzZXIubnMoe1xuICAgKiAgICdodHRwOi8vZm9vJzogJ2ZvbycsXG4gICAqICAgJ2h0dHA6Ly9iYXInOiAnYmFyJ1xuICAgKiB9KTtcbiAgICpcbiAgICogQHBhcmFtICB7IU9iamVjdDxzdHJpbmcsIHN0cmluZz59IG5zTWFwXG4gICAqXG4gICAqIEByZXR1cm4ge1BhcnNlcn1cbiAgICovXG4gIHRoaXNbJ25zJ10gPSBmdW5jdGlvbihuc01hcCkge1xuXG4gICAgaWYgKHR5cGVvZiBuc01hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG5zTWFwID0ge307XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuc01hcCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IGVycm9yKCdyZXF1aXJlZCBhcmdzIDxuc01hcD17fT4nKTtcbiAgICB9XG5cbiAgICB2YXIgX25zVXJpVG9QcmVmaXggPSB7fSwgaztcblxuICAgIGZvciAoayBpbiBuc01hcCkge1xuICAgICAgX25zVXJpVG9QcmVmaXhba10gPSBuc01hcFtrXTtcbiAgICB9XG5cbiAgICAvLyBGT1JDRSBkZWZhdWx0IG1hcHBpbmcgZm9yIHNjaGVtYSBpbnN0YW5jZVxuICAgIF9uc1VyaVRvUHJlZml4W1hTSV9VUkldID0gWFNJX1BSRUZJWDtcblxuICAgIGlzTmFtZXNwYWNlID0gdHJ1ZTtcbiAgICBuc1VyaVRvUHJlZml4ID0gX25zVXJpVG9QcmVmaXg7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2UgeG1sIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB4bWxcbiAgICpcbiAgICogQHJldHVybiB7RXJyb3J9IHJldHVybkVycm9yLCBpZiBub3QgdGhyb3duXG4gICAqL1xuICB0aGlzWydwYXJzZSddID0gZnVuY3Rpb24oeG1sKSB7XG4gICAgaWYgKHR5cGVvZiB4bWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBlcnJvcigncmVxdWlyZWQgYXJncyA8eG1sPXN0cmluZz4nKTtcbiAgICB9XG5cbiAgICByZXR1cm5FcnJvciA9IG51bGw7XG5cbiAgICBwYXJzZSh4bWwpO1xuXG4gICAgZ2V0Q29udGV4dCA9IG5vb3BHZXRDb250ZXh0O1xuICAgIHBhcnNlU3RvcCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHJldHVybkVycm9yO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdG9wIHBhcnNpbmcuXG4gICAqL1xuICB0aGlzWydzdG9wJ10gPSBmdW5jdGlvbigpIHtcbiAgICBwYXJzZVN0b3AgPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSBzdHJpbmcsIGludm9raW5nIGNvbmZpZ3VyZWQgbGlzdGVuZXJzIG9uIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30geG1sXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZSh4bWwpIHtcbiAgICB2YXIgbnNNYXRyaXhTdGFjayA9IGlzTmFtZXNwYWNlID8gW10gOiBudWxsLFxuICAgICAgICBuc01hdHJpeCA9IGlzTmFtZXNwYWNlID8gYnVpbGROc01hdHJpeChuc1VyaVRvUHJlZml4KSA6IG51bGwsXG4gICAgICAgIF9uc01hdHJpeCxcbiAgICAgICAgbm9kZVN0YWNrID0gW10sXG4gICAgICAgIGFub255bW91c05zQ291bnQgPSAwLFxuICAgICAgICB0YWdTdGFydCA9IGZhbHNlLFxuICAgICAgICB0YWdFbmQgPSBmYWxzZSxcbiAgICAgICAgaSA9IDAsIGogPSAwLFxuICAgICAgICB4LCB5LCBxLCB3LFxuICAgICAgICB4bWxucyxcbiAgICAgICAgZWxlbWVudE5hbWUsXG4gICAgICAgIF9lbGVtZW50TmFtZSxcbiAgICAgICAgZWxlbWVudFByb3h5XG4gICAgICAgIDtcblxuICAgIHZhciBhdHRyc1N0cmluZyA9ICcnLFxuICAgICAgICBhdHRyc1N0YXJ0ID0gMCxcbiAgICAgICAgY2FjaGVkQXR0cnMgLy8gZmFsc2UgPSBwYXJzZWQgd2l0aCBlcnJvcnMsIG51bGwgPSBuZWVkcyBwYXJzaW5nXG4gICAgICAgIDtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIGF0dHJpYnV0ZXMgb24gZGVtYW5kIGFuZCByZXR1cm5zIHRoZSBwYXJzZWQgYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIFJldHVybiBzZW1hbnRpY3M6ICgxKSBgZmFsc2VgIG9uIGF0dHJpYnV0ZSBwYXJzZSBlcnJvcixcbiAgICAgKiAoMikgb2JqZWN0IGhhc2ggb24gZXh0cmFjdGVkIGF0dHJzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbnxPYmplY3R9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0QXR0cnMoKSB7XG4gICAgICBpZiAoY2FjaGVkQXR0cnMgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZEF0dHJzO1xuICAgICAgfVxuXG4gICAgICB2YXIgbnNVcmksXG4gICAgICAgICAgbnNVcmlQcmVmaXgsXG4gICAgICAgICAgbnNOYW1lLFxuICAgICAgICAgIGRlZmF1bHRBbGlhcyA9IGlzTmFtZXNwYWNlICYmIG5zTWF0cml4Wyd4bWxucyddLFxuICAgICAgICAgIGF0dHJMaXN0ID0gaXNOYW1lc3BhY2UgJiYgbWF5YmVOUyA/IFtdIDogbnVsbCxcbiAgICAgICAgICBpID0gYXR0cnNTdGFydCxcbiAgICAgICAgICBzID0gYXR0cnNTdHJpbmcsXG4gICAgICAgICAgbCA9IHMubGVuZ3RoLFxuICAgICAgICAgIGhhc05ld01hdHJpeCxcbiAgICAgICAgICBuZXdhbGlhcyxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBhbGlhcyxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGF0dHJzID0ge30sXG4gICAgICAgICAgc2VlbkF0dHJzID0ge30sXG4gICAgICAgICAgc2tpcEF0dHIsXG4gICAgICAgICAgdyxcbiAgICAgICAgICBqO1xuXG4gICAgICBwYXJzZUF0dHI6XG4gICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICBza2lwQXR0ciA9IGZhbHNlO1xuICAgICAgICB3ID0gcy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmICh3ID09PSAzMiB8fCAodyA8IDE0ICYmIHcgPiA4KSkgeyAvLyBXSElURVNQQUNFPXsgXFxmXFxuXFxyXFx0XFx2fVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2FpdCBmb3Igbm9uIHdoaXRlc3BhY2UgY2hhcmFjdGVyXG4gICAgICAgIGlmICh3IDwgNjUgfHwgdyA+IDEyMiB8fCAodyA+IDkwICYmIHcgPCA5NykpIHtcbiAgICAgICAgICBpZiAodyAhPT0gOTUgJiYgdyAhPT0gNTgpIHsgLy8gY2hhciA5NVwiX1wiIDU4XCI6XCJcbiAgICAgICAgICAgIGhhbmRsZVdhcm5pbmcoJ2lsbGVnYWwgZmlyc3QgY2hhciBhdHRyaWJ1dGUgbmFtZScpO1xuICAgICAgICAgICAgc2tpcEF0dHIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBhcnNlIGF0dHJpYnV0ZSBuYW1lXG4gICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgdyA9IHMuY2hhckNvZGVBdChqKTtcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHcgPiA5NiAmJiB3IDwgMTIzIHx8XG4gICAgICAgICAgICB3ID4gNjQgJiYgdyA8IDkxIHx8XG4gICAgICAgICAgICB3ID4gNDcgJiYgdyA8IDU5IHx8XG4gICAgICAgICAgICB3ID09PSA0NiB8fCAvLyAnLidcbiAgICAgICAgICAgIHcgPT09IDQ1IHx8IC8vICctJ1xuICAgICAgICAgICAgdyA9PT0gOTUgLy8gJ18nXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHdoaXRlc3BhY2VcbiAgICAgICAgICBpZiAodyA9PT0gMzIgfHwgKHcgPCAxNCAmJiB3ID4gOCkpIHsgLy8gV0hJVEVTUEFDRVxuICAgICAgICAgICAgaGFuZGxlV2FybmluZygnbWlzc2luZyBhdHRyaWJ1dGUgdmFsdWUnKTtcbiAgICAgICAgICAgIGkgPSBqO1xuXG4gICAgICAgICAgICBjb250aW51ZSBwYXJzZUF0dHI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZXhwZWN0ZWQgXCI9XCJcbiAgICAgICAgICBpZiAodyA9PT0gNjEpIHsgLy8gXCI9XCIgPT0gNjFcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGhhbmRsZVdhcm5pbmcoJ2lsbGVnYWwgYXR0cmlidXRlIG5hbWUgY2hhcicpO1xuICAgICAgICAgIHNraXBBdHRyID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5hbWUgPSBzLnN1YnN0cmluZyhpLCBqKTtcblxuICAgICAgICBpZiAobmFtZSA9PT0gJ3htbG5zOnhtbG5zJykge1xuICAgICAgICAgIGhhbmRsZVdhcm5pbmcoJ2lsbGVnYWwgZGVjbGFyYXRpb24gb2YgeG1sbnMnKTtcbiAgICAgICAgICBza2lwQXR0ciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB3ID0gcy5jaGFyQ29kZUF0KGogKyAxKTtcblxuICAgICAgICBpZiAodyA9PT0gMzQpIHsgLy8gJ1wiJ1xuICAgICAgICAgIGogPSBzLmluZGV4T2YoJ1wiJywgaSA9IGogKyAyKTtcblxuICAgICAgICAgIGlmIChqID09PSAtMSkge1xuICAgICAgICAgICAgaiA9IHMuaW5kZXhPZignXFwnJywgaSk7XG5cbiAgICAgICAgICAgIGlmIChqICE9PSAtMSkge1xuICAgICAgICAgICAgICBoYW5kbGVXYXJuaW5nKCdhdHRyaWJ1dGUgdmFsdWUgcXVvdGUgbWlzc21hdGNoJyk7XG4gICAgICAgICAgICAgIHNraXBBdHRyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmICh3ID09PSAzOSkgeyAvLyBcIidcIlxuICAgICAgICAgIGogPSBzLmluZGV4T2YoJ1xcJycsIGkgPSBqICsgMik7XG5cbiAgICAgICAgICBpZiAoaiA9PT0gLTEpIHtcbiAgICAgICAgICAgIGogPSBzLmluZGV4T2YoJ1wiJywgaSk7XG5cbiAgICAgICAgICAgIGlmIChqICE9PSAtMSkge1xuICAgICAgICAgICAgICBoYW5kbGVXYXJuaW5nKCdhdHRyaWJ1dGUgdmFsdWUgcXVvdGUgbWlzc21hdGNoJyk7XG4gICAgICAgICAgICAgIHNraXBBdHRyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYW5kbGVXYXJuaW5nKCdtaXNzaW5nIGF0dHJpYnV0ZSB2YWx1ZSBxdW90ZXMnKTtcbiAgICAgICAgICBza2lwQXR0ciA9IHRydWU7XG5cbiAgICAgICAgICAvLyBza2lwIHRvIG5leHQgc3BhY2VcbiAgICAgICAgICBmb3IgKGogPSBqICsgMTsgaiA8IGw7IGorKykge1xuICAgICAgICAgICAgdyA9IHMuY2hhckNvZGVBdChqICsgMSk7XG5cbiAgICAgICAgICAgIGlmICh3ID09PSAzMiB8fCAodyA8IDE0ICYmIHcgPiA4KSkgeyAvLyBXSElURVNQQUNFXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGogPT09IC0xKSB7XG4gICAgICAgICAgaGFuZGxlV2FybmluZygnbWlzc2luZyBjbG9zaW5nIHF1b3RlcycpO1xuXG4gICAgICAgICAgaiA9IGw7XG4gICAgICAgICAgc2tpcEF0dHIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFza2lwQXR0cikge1xuICAgICAgICAgIHZhbHVlID0gcy5zdWJzdHJpbmcoaSwgaik7XG4gICAgICAgIH1cblxuICAgICAgICBpID0gajtcblxuICAgICAgICAvLyBlbnN1cmUgU1BBQ0UgZm9sbG93cyBhdHRyaWJ1dGVcbiAgICAgICAgLy8gc2tpcCBpbGxlZ2FsIGNvbnRlbnQgb3RoZXJ3aXNlXG4gICAgICAgIC8vIGV4YW1wbGUgYT1cImJcImNcbiAgICAgICAgZm9yICg7IGogKyAxIDwgbDsgaisrKSB7XG4gICAgICAgICAgdyA9IHMuY2hhckNvZGVBdChqICsgMSk7XG5cbiAgICAgICAgICBpZiAodyA9PT0gMzIgfHwgKHcgPCAxNCAmJiB3ID4gOCkpIHsgLy8gV0hJVEVTUEFDRVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRklSU1QgSUxMRUdBTCBDSEFSXG4gICAgICAgICAgaWYgKGkgPT09IGopIHtcbiAgICAgICAgICAgIGhhbmRsZVdhcm5pbmcoJ2lsbGVnYWwgY2hhcmFjdGVyIGFmdGVyIGF0dHJpYnV0ZSBlbmQnKTtcbiAgICAgICAgICAgIHNraXBBdHRyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZHZhbmNlIGN1cnNvciB0byBuZXh0IGF0dHJpYnV0ZVxuICAgICAgICBpID0gaiArIDE7XG5cbiAgICAgICAgaWYgKHNraXBBdHRyKSB7XG4gICAgICAgICAgY29udGludWUgcGFyc2VBdHRyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgYXR0cmlidXRlIHJlLWRlY2xhcmF0aW9uXG4gICAgICAgIGlmIChuYW1lIGluIHNlZW5BdHRycykge1xuICAgICAgICAgIGhhbmRsZVdhcm5pbmcoJ2F0dHJpYnV0ZSA8JyArIG5hbWUgKyAnPiBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlZW5BdHRyc1tuYW1lXSA9IHRydWU7XG5cbiAgICAgICAgaWYgKCFpc05hbWVzcGFjZSkge1xuICAgICAgICAgIGF0dHJzW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cnkgdG8gZXh0cmFjdCBuYW1lc3BhY2UgaW5mb3JtYXRpb25cbiAgICAgICAgaWYgKG1heWJlTlMpIHtcbiAgICAgICAgICBuZXdhbGlhcyA9IChcbiAgICAgICAgICAgIG5hbWUgPT09ICd4bWxucydcbiAgICAgICAgICAgICAgPyAneG1sbnMnXG4gICAgICAgICAgICAgIDogKG5hbWUuY2hhckNvZGVBdCgwKSA9PT0gMTIwICYmIG5hbWUuc3Vic3RyKDAsIDYpID09PSAneG1sbnM6JylcbiAgICAgICAgICAgICAgICA/IG5hbWUuc3Vic3RyKDYpXG4gICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIGhhbmRsZSB4bWxucyg6YWxpYXMpIGFzc2lnbm1lbnRcbiAgICAgICAgICBpZiAobmV3YWxpYXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG5zVXJpID0gZGVjb2RlRW50aXRpZXModmFsdWUpO1xuICAgICAgICAgICAgbnNVcmlQcmVmaXggPSB1cmlQcmVmaXgobmV3YWxpYXMpO1xuXG4gICAgICAgICAgICBhbGlhcyA9IG5zVXJpVG9QcmVmaXhbbnNVcmldO1xuXG4gICAgICAgICAgICBpZiAoIWFsaWFzKSB7XG4gICAgICAgICAgICAgIC8vIG5vIHByZWZpeCBkZWZpbmVkIG9yIHByZWZpeCBjb2xsaXNpb25cbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChuZXdhbGlhcyA9PT0gJ3htbG5zJykgfHxcbiAgICAgICAgICAgICAgICAobnNVcmlQcmVmaXggaW4gbnNNYXRyaXggJiYgbnNNYXRyaXhbbnNVcmlQcmVmaXhdICE9PSBuc1VyaSlcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gYWxvY2F0ZSBmcmVlIG5zIHByZWZpeFxuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgIGFsaWFzID0gJ25zJyArIChhbm9ueW1vdXNOc0NvdW50KyspO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHR5cGVvZiBuc01hdHJpeFthbGlhc10gIT09ICd1bmRlZmluZWQnKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbGlhcyA9IG5ld2FsaWFzO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbnNVcmlUb1ByZWZpeFtuc1VyaV0gPSBhbGlhcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5zTWF0cml4W25ld2FsaWFzXSAhPT0gYWxpYXMpIHtcbiAgICAgICAgICAgICAgaWYgKCFoYXNOZXdNYXRyaXgpIHtcbiAgICAgICAgICAgICAgICBuc01hdHJpeCA9IGNsb25lTnNNYXRyaXgobnNNYXRyaXgpO1xuICAgICAgICAgICAgICAgIGhhc05ld01hdHJpeCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBuc01hdHJpeFtuZXdhbGlhc10gPSBhbGlhcztcbiAgICAgICAgICAgICAgaWYgKG5ld2FsaWFzID09PSAneG1sbnMnKSB7XG4gICAgICAgICAgICAgICAgbnNNYXRyaXhbdXJpUHJlZml4KGFsaWFzKV0gPSBuc1VyaTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0QWxpYXMgPSBhbGlhcztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG5zTWF0cml4W25zVXJpUHJlZml4XSA9IG5zVXJpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBleHBvc2UgeG1sbnMoOmFzZCk9XCIuLi5cIiBpbiBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBhdHRyc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gY29sbGVjdCBhdHRyaWJ1dGVzIHVudGlsIGFsbCBuYW1lc3BhY2VcbiAgICAgICAgICAvLyBkZWNsYXJhdGlvbnMgYXJlIHByb2Nlc3NlZFxuICAgICAgICAgIGF0dHJMaXN0LnB1c2gobmFtZSwgdmFsdWUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIH0gLyoqIGVuZCBpZiAobWF5YmVOcykgKi9cblxuICAgICAgICAvLyBoYW5kbGUgYXR0cmlidXRlcyBvbiBlbGVtZW50IHdpdGhvdXRcbiAgICAgICAgLy8gbmFtZXNwYWNlIGRlY2xhcmF0aW9uc1xuICAgICAgICB3ID0gbmFtZS5pbmRleE9mKCc6Jyk7XG4gICAgICAgIGlmICh3ID09PSAtMSkge1xuICAgICAgICAgIGF0dHJzW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3JtYWxpemUgbnMgYXR0cmlidXRlIG5hbWVcbiAgICAgICAgaWYgKCEobnNOYW1lID0gbnNNYXRyaXhbbmFtZS5zdWJzdHJpbmcoMCwgdyldKSkge1xuICAgICAgICAgIGhhbmRsZVdhcm5pbmcobWlzc2luZ05hbWVzcGFjZUZvclByZWZpeChuYW1lLnN1YnN0cmluZygwLCB3KSkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbmFtZSA9IGRlZmF1bHRBbGlhcyA9PT0gbnNOYW1lXG4gICAgICAgICAgPyBuYW1lLnN1YnN0cih3ICsgMSlcbiAgICAgICAgICA6IG5zTmFtZSArIG5hbWUuc3Vic3RyKHcpO1xuICAgICAgICAvLyBlbmQ6IG5vcm1hbGl6ZSBucyBhdHRyaWJ1dGUgbmFtZVxuXG4gICAgICAgIC8vIG5vcm1hbGl6ZSB4c2k6dHlwZSBucyBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgICAgaWYgKG5hbWUgPT09IFhTSV9UWVBFKSB7XG4gICAgICAgICAgdyA9IHZhbHVlLmluZGV4T2YoJzonKTtcblxuICAgICAgICAgIGlmICh3ICE9PSAtMSkge1xuICAgICAgICAgICAgbnNOYW1lID0gdmFsdWUuc3Vic3RyaW5nKDAsIHcpO1xuICAgICAgICAgICAgLy8gaGFuZGxlIGRlZmF1bHQgcHJlZml4ZXMsIGkuZS4geHM6U3RyaW5nIGdyYWNlZnVsbHlcbiAgICAgICAgICAgIG5zTmFtZSA9IG5zTWF0cml4W25zTmFtZV0gfHwgbnNOYW1lO1xuICAgICAgICAgICAgdmFsdWUgPSBuc05hbWUgKyB2YWx1ZS5zdWJzdHJpbmcodyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gZGVmYXVsdEFsaWFzICsgJzonICsgdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGVuZDogbm9ybWFsaXplIHhzaTp0eXBlIG5zIGF0dHJpYnV0ZSB2YWx1ZVxuXG4gICAgICAgIGF0dHJzW25hbWVdID0gdmFsdWU7XG4gICAgICB9XG5cblxuICAgICAgLy8gaGFuZGxlIGRlZmVycmVkLCBwb3NzaWJseSBuYW1lc3BhY2VkIGF0dHJpYnV0ZXNcbiAgICAgIGlmIChtYXliZU5TKSB7XG5cbiAgICAgICAgLy8gbm9ybWFsaXplIGNhcHR1cmVkIGF0dHJpYnV0ZXNcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGF0dHJMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXG4gICAgICAgICAgbmFtZSA9IGF0dHJMaXN0W2krK107XG4gICAgICAgICAgdmFsdWUgPSBhdHRyTGlzdFtpXTtcblxuICAgICAgICAgIHcgPSBuYW1lLmluZGV4T2YoJzonKTtcblxuICAgICAgICAgIGlmICh3ICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gbm9ybWFsaXplIG5zIGF0dHJpYnV0ZSBuYW1lXG4gICAgICAgICAgICBpZiAoIShuc05hbWUgPSBuc01hdHJpeFtuYW1lLnN1YnN0cmluZygwLCB3KV0pKSB7XG4gICAgICAgICAgICAgIGhhbmRsZVdhcm5pbmcobWlzc2luZ05hbWVzcGFjZUZvclByZWZpeChuYW1lLnN1YnN0cmluZygwLCB3KSkpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmFtZSA9IGRlZmF1bHRBbGlhcyA9PT0gbnNOYW1lXG4gICAgICAgICAgICAgID8gbmFtZS5zdWJzdHIodyArIDEpXG4gICAgICAgICAgICAgIDogbnNOYW1lICsgbmFtZS5zdWJzdHIodyk7XG4gICAgICAgICAgICAvLyBlbmQ6IG5vcm1hbGl6ZSBucyBhdHRyaWJ1dGUgbmFtZVxuXG4gICAgICAgICAgICAvLyBub3JtYWxpemUgeHNpOnR5cGUgbnMgYXR0cmlidXRlIHZhbHVlXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gWFNJX1RZUEUpIHtcbiAgICAgICAgICAgICAgdyA9IHZhbHVlLmluZGV4T2YoJzonKTtcblxuICAgICAgICAgICAgICBpZiAodyAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBuc05hbWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgdyk7XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIGRlZmF1bHQgcHJlZml4ZXMsIGkuZS4geHM6U3RyaW5nIGdyYWNlZnVsbHlcbiAgICAgICAgICAgICAgICBuc05hbWUgPSBuc01hdHJpeFtuc05hbWVdIHx8IG5zTmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5zTmFtZSArIHZhbHVlLnN1YnN0cmluZyh3KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRlZmF1bHRBbGlhcyArICc6JyArIHZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbmQ6IG5vcm1hbGl6ZSB4c2k6dHlwZSBucyBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhdHRyc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVuZDogbm9ybWFsaXplIGNhcHR1cmVkIGF0dHJpYnV0ZXNcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhY2hlZEF0dHJzID0gYXR0cnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdCB0aGUgcGFyc2UgY29udGV4dCB7IGxpbmUsIGNvbHVtbiwgcGFydCB9XG4gICAgICogZnJvbSB0aGUgY3VycmVudCBwYXJzZXIgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHBhcnNlIGNvbnRleHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRQYXJzZUNvbnRleHQoKSB7XG4gICAgICB2YXIgc3BsaXRzUmUgPSAvKFxcclxcbnxcXHJ8XFxuKS9nO1xuXG4gICAgICB2YXIgbGluZSA9IDA7XG4gICAgICB2YXIgY29sdW1uID0gMDtcbiAgICAgIHZhciBzdGFydE9mTGluZSA9IDA7XG4gICAgICB2YXIgZW5kT2ZMaW5lID0gajtcbiAgICAgIHZhciBtYXRjaDtcbiAgICAgIHZhciBkYXRhO1xuXG4gICAgICB3aGlsZSAoaSA+PSBzdGFydE9mTGluZSkge1xuXG4gICAgICAgIG1hdGNoID0gc3BsaXRzUmUuZXhlYyh4bWwpO1xuXG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuZCBvZiBsaW5lID0gKGJyZWFrIGlkeCArIGJyZWFrIGNoYXJzKVxuICAgICAgICBlbmRPZkxpbmUgPSBtYXRjaFswXS5sZW5ndGggKyBtYXRjaC5pbmRleDtcblxuICAgICAgICBpZiAoZW5kT2ZMaW5lID4gaSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWR2YW5jZSB0byBuZXh0IGxpbmVcbiAgICAgICAgbGluZSArPSAxO1xuXG4gICAgICAgIHN0YXJ0T2ZMaW5lID0gZW5kT2ZMaW5lO1xuICAgICAgfVxuXG4gICAgICAvLyBFT0YgZXJyb3JzXG4gICAgICBpZiAoaSA9PSAtMSkge1xuICAgICAgICBjb2x1bW4gPSBlbmRPZkxpbmU7XG4gICAgICAgIGRhdGEgPSB4bWwuc3Vic3RyaW5nKGopO1xuICAgICAgfSBlbHNlXG4gICAgICAvLyBzdGFydCBlcnJvcnNcbiAgICAgIGlmIChqID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGkgLSBzdGFydE9mTGluZSk7XG4gICAgICAgIGRhdGEgPSB4bWwuc3Vic3RyaW5nKGosIGkpO1xuICAgICAgfVxuICAgICAgLy8gb3RoZXIgZXJyb3JzXG4gICAgICBlbHNlIHtcbiAgICAgICAgY29sdW1uID0gaSAtIHN0YXJ0T2ZMaW5lO1xuICAgICAgICBkYXRhID0gKGogPT0gLTEgPyB4bWwuc3Vic3RyaW5nKGkpIDogeG1sLnN1YnN0cmluZyhpLCBqICsgMSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAnZGF0YSc6IGRhdGEsXG4gICAgICAgICdsaW5lJzogbGluZSxcbiAgICAgICAgJ2NvbHVtbic6IGNvbHVtblxuICAgICAgfTtcbiAgICB9XG5cbiAgICBnZXRDb250ZXh0ID0gZ2V0UGFyc2VDb250ZXh0O1xuXG5cbiAgICBpZiAocHJveHkpIHtcbiAgICAgIGVsZW1lbnRQcm94eSA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgJ25hbWUnOiBnZXR0ZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnROYW1lO1xuICAgICAgICB9KSxcbiAgICAgICAgJ29yaWdpbmFsTmFtZSc6IGdldHRlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX2VsZW1lbnROYW1lO1xuICAgICAgICB9KSxcbiAgICAgICAgJ2F0dHJzJzogZ2V0dGVyKGdldEF0dHJzKSxcbiAgICAgICAgJ25zJzogZ2V0dGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBuc01hdHJpeDtcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGFjdHVhbCBwYXJzZSBsb2dpY1xuICAgIHdoaWxlIChqICE9PSAtMSkge1xuXG4gICAgICBpZiAoeG1sLmNoYXJDb2RlQXQoaikgPT09IDYwKSB7IC8vIFwiPFwiXG4gICAgICAgIGkgPSBqO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaSA9IHhtbC5pbmRleE9mKCc8Jywgaik7XG4gICAgICB9XG5cbiAgICAgIC8vIHBhcnNlIGVuZFxuICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgIGlmIChub2RlU3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCd1bmV4cGVjdGVkIGVuZCBvZiBmaWxlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaiA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcignbWlzc2luZyBzdGFydCB0YWcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqIDwgeG1sLmxlbmd0aCkge1xuICAgICAgICAgIGlmICh4bWwuc3Vic3RyaW5nKGopLnRyaW0oKSkge1xuICAgICAgICAgICAgaGFuZGxlV2FybmluZyhOT05fV0hJVEVTUEFDRV9PVVRTSURFX1JPT1RfTk9ERSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBwYXJzZSB0ZXh0XG4gICAgICBpZiAoaiAhPT0gaSkge1xuXG4gICAgICAgIGlmIChub2RlU3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG9uVGV4dCkge1xuICAgICAgICAgICAgb25UZXh0KHhtbC5zdWJzdHJpbmcoaiwgaSksIGRlY29kZUVudGl0aWVzLCBnZXRDb250ZXh0KTtcblxuICAgICAgICAgICAgaWYgKHBhcnNlU3RvcCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh4bWwuc3Vic3RyaW5nKGosIGkpLnRyaW0oKSkge1xuICAgICAgICAgICAgaGFuZGxlV2FybmluZyhOT05fV0hJVEVTUEFDRV9PVVRTSURFX1JPT1RfTk9ERSk7XG5cbiAgICAgICAgICAgIGlmIChwYXJzZVN0b3ApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3ID0geG1sLmNoYXJDb2RlQXQoaSsxKTtcblxuICAgICAgLy8gcGFyc2UgY29tbWVudHMgKyBDREFUQVxuICAgICAgaWYgKHcgPT09IDMzKSB7IC8vIFwiIVwiXG4gICAgICAgIHcgPSB4bWwuY2hhckNvZGVBdChpKzIpO1xuICAgICAgICBpZiAodyA9PT0gOTEgJiYgeG1sLnN1YnN0cihpICsgMywgNikgPT09ICdDREFUQVsnKSB7IC8vIDkxID09IFwiW1wiXG4gICAgICAgICAgaiA9IHhtbC5pbmRleE9mKCddXT4nLCBpKTtcbiAgICAgICAgICBpZiAoaiA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcigndW5jbG9zZWQgY2RhdGEnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob25DREFUQSkge1xuICAgICAgICAgICAgb25DREFUQSh4bWwuc3Vic3RyaW5nKGkgKyA5LCBqKSwgZ2V0Q29udGV4dCk7XG4gICAgICAgICAgICBpZiAocGFyc2VTdG9wKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBqICs9IDM7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh3ID09PSA0NSAmJiB4bWwuY2hhckNvZGVBdChpICsgMykgPT09IDQ1KSB7IC8vIDQ1ID09IFwiLVwiXG4gICAgICAgICAgaiA9IHhtbC5pbmRleE9mKCctLT4nLCBpKTtcbiAgICAgICAgICBpZiAoaiA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcigndW5jbG9zZWQgY29tbWVudCcpO1xuICAgICAgICAgIH1cblxuXG4gICAgICAgICAgaWYgKG9uQ29tbWVudCkge1xuICAgICAgICAgICAgb25Db21tZW50KHhtbC5zdWJzdHJpbmcoaSArIDQsIGopLCBkZWNvZGVFbnRpdGllcywgZ2V0Q29udGV4dCk7XG4gICAgICAgICAgICBpZiAocGFyc2VTdG9wKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBqICs9IDM7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBqID0geG1sLmluZGV4T2YoJz4nLCBpICsgMSk7XG4gICAgICAgIGlmIChqID09PSAtMSkge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcigndW5jbG9zZWQgdGFnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob25BdHRlbnRpb24pIHtcbiAgICAgICAgICBvbkF0dGVudGlvbih4bWwuc3Vic3RyaW5nKGksIGogKyAxKSwgZGVjb2RlRW50aXRpZXMsIGdldENvbnRleHQpO1xuICAgICAgICAgIGlmIChwYXJzZVN0b3ApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBqICs9IDE7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodyA9PT0gNjMpIHsgLy8gXCI/XCJcbiAgICAgICAgaiA9IHhtbC5pbmRleE9mKCc/PicsIGkpO1xuICAgICAgICBpZiAoaiA9PT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoJ3VuY2xvc2VkIHF1ZXN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob25RdWVzdGlvbikge1xuICAgICAgICAgIG9uUXVlc3Rpb24oeG1sLnN1YnN0cmluZyhpLCBqICsgMiksIGdldENvbnRleHQpO1xuICAgICAgICAgIGlmIChwYXJzZVN0b3ApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBqICs9IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBqID0geG1sLmluZGV4T2YoJz4nLCBpICsgMSk7XG5cbiAgICAgIGlmIChqID09IC0xKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVFcnJvcigndW5jbG9zZWQgdGFnJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGRvbid0IHByb2Nlc3MgYXR0cmlidXRlcztcbiAgICAgIC8vIHRoZXJlIGFyZSBub25lXG4gICAgICBjYWNoZWRBdHRycyA9IHt9O1xuXG4gICAgICAvLyBpZiAoeG1sLmNoYXJDb2RlQXQoaSsxKSA9PT0gNDcpIHsgLy8gPC8uLi5cbiAgICAgIGlmICh3ID09PSA0NykgeyAvLyA8Ly4uLlxuICAgICAgICB0YWdTdGFydCA9IGZhbHNlO1xuICAgICAgICB0YWdFbmQgPSB0cnVlO1xuXG4gICAgICAgIGlmICghbm9kZVN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcignbWlzc2luZyBvcGVuIHRhZycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmVyaWZ5IG9wZW4gPC0+IGNsb3NlIHRhZyBtYXRjaFxuICAgICAgICB4ID0gZWxlbWVudE5hbWUgPSBub2RlU3RhY2sucG9wKCk7XG4gICAgICAgIHEgPSBpICsgMiArIHgubGVuZ3RoO1xuXG4gICAgICAgIGlmICh4bWwuc3Vic3RyaW5nKGkgKyAyLCBxKSAhPT0geCkge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcignY2xvc2luZyB0YWcgbWlzbWF0Y2gnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZlcmlmeSBjaGFycyBpbiBjbG9zZSB0YWdcbiAgICAgICAgZm9yICg7IHEgPCBqOyBxKyspIHtcbiAgICAgICAgICB3ID0geG1sLmNoYXJDb2RlQXQocSk7XG5cbiAgICAgICAgICBpZiAodyA9PT0gMzIgfHwgKHcgPiA4ICYmIHcgPCAxNCkpIHsgLy8gXFxmXFxuXFxyXFx0XFx2IHNwYWNlXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoJ2Nsb3NlIHRhZycpO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh4bWwuY2hhckNvZGVBdChqIC0gMSkgPT09IDQ3KSB7IC8vIC4uLi8+XG4gICAgICAgICAgeCA9IGVsZW1lbnROYW1lID0geG1sLnN1YnN0cmluZyhpICsgMSwgaiAtIDEpO1xuXG4gICAgICAgICAgdGFnU3RhcnQgPSB0cnVlO1xuICAgICAgICAgIHRhZ0VuZCA9IHRydWU7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4ID0gZWxlbWVudE5hbWUgPSB4bWwuc3Vic3RyaW5nKGkgKyAxLCBqKTtcblxuICAgICAgICAgIHRhZ1N0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgICB0YWdFbmQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKHcgPiA5NiAmJiB3IDwgMTIzIHx8IHcgPiA2NCAmJiB3IDwgOTEgfHwgdyA9PT0gOTUgfHwgdyA9PT0gNTgpKSB7IC8vIGNoYXIgOTVcIl9cIiA1OFwiOlwiXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCdpbGxlZ2FsIGZpcnN0IGNoYXIgbm9kZU5hbWUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAocSA9IDEsIHkgPSB4Lmxlbmd0aDsgcSA8IHk7IHErKykge1xuICAgICAgICAgIHcgPSB4LmNoYXJDb2RlQXQocSk7XG5cbiAgICAgICAgICBpZiAodyA+IDk2ICYmIHcgPCAxMjMgfHwgdyA+IDY0ICYmIHcgPCA5MSB8fCB3ID4gNDcgJiYgdyA8IDU5IHx8IHcgPT09IDQ1IHx8IHcgPT09IDk1IHx8IHcgPT0gNDYpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh3ID09PSAzMiB8fCAodyA8IDE0ICYmIHcgPiA4KSkgeyAvLyBcXGZcXG5cXHJcXHRcXHYgc3BhY2VcbiAgICAgICAgICAgIGVsZW1lbnROYW1lID0geC5zdWJzdHJpbmcoMCwgcSk7XG4gICAgICAgICAgICAvLyBtYXliZSB0aGVyZSBhcmUgYXR0cmlidXRlc1xuICAgICAgICAgICAgY2FjaGVkQXR0cnMgPSBudWxsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCdpbnZhbGlkIG5vZGVOYW1lJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRhZ0VuZCkge1xuICAgICAgICAgIG5vZGVTdGFjay5wdXNoKGVsZW1lbnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNOYW1lc3BhY2UpIHtcblxuICAgICAgICBfbnNNYXRyaXggPSBuc01hdHJpeDtcblxuICAgICAgICBpZiAodGFnU3RhcnQpIHtcbiAgICAgICAgICAvLyByZW1lbWJlciBvbGQgbmFtZXNwYWNlXG4gICAgICAgICAgLy8gdW5sZXNzIHdlJ3JlIHNlbGYtY2xvc2luZ1xuICAgICAgICAgIGlmICghdGFnRW5kKSB7XG4gICAgICAgICAgICBuc01hdHJpeFN0YWNrLnB1c2goX25zTWF0cml4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2FjaGVkQXR0cnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHF1aWNrIGNoZWNrLCB3aGV0aGVyIHRoZXJlIG1heSBiZSBuYW1lc3BhY2VcbiAgICAgICAgICAgIC8vIGRlY2xhcmF0aW9ucyBvbiB0aGUgbm9kZTsgaWYgdGhhdCBpcyB0aGUgY2FzZVxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBlYWdlcmx5IHBhcnNlIHRoZSBub2RlIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIGlmICgobWF5YmVOUyA9IHguaW5kZXhPZigneG1sbnMnLCBxKSAhPT0gLTEpKSB7XG4gICAgICAgICAgICAgIGF0dHJzU3RhcnQgPSBxO1xuICAgICAgICAgICAgICBhdHRyc1N0cmluZyA9IHg7XG5cbiAgICAgICAgICAgICAgZ2V0QXR0cnMoKTtcblxuICAgICAgICAgICAgICBtYXliZU5TID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX2VsZW1lbnROYW1lID0gZWxlbWVudE5hbWU7XG5cbiAgICAgICAgdyA9IGVsZW1lbnROYW1lLmluZGV4T2YoJzonKTtcbiAgICAgICAgaWYgKHcgIT09IC0xKSB7XG4gICAgICAgICAgeG1sbnMgPSBuc01hdHJpeFtlbGVtZW50TmFtZS5zdWJzdHJpbmcoMCwgdyldO1xuXG4gICAgICAgICAgLy8gcHJlZml4IGdpdmVuOyBuYW1lc3BhY2UgbXVzdCBleGlzdFxuICAgICAgICAgIGlmICgheG1sbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcignbWlzc2luZyBuYW1lc3BhY2Ugb24gPCcgKyBfZWxlbWVudE5hbWUgKyAnPicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsZW1lbnROYW1lID0gZWxlbWVudE5hbWUuc3Vic3RyKHcgKyAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4bWxucyA9IG5zTWF0cml4Wyd4bWxucyddO1xuXG4gICAgICAgICAgLy8gaWYgbm8gZGVmYXVsdCBuYW1lc3BhY2UgaXMgZGVmaW5lZCxcbiAgICAgICAgICAvLyB3ZSdsbCBpbXBvcnQgdGhlIGVsZW1lbnQgYXMgYW5vbnltb3VzLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gaXQgaXMgdXAgdG8gdXNlcnMgdG8gY29ycmVjdCB0aGF0IHRvIHRoZSBkb2N1bWVudCBkZWZpbmVkXG4gICAgICAgICAgLy8gdGFyZ2V0TmFtZXNwYWNlLCBvciB3aGF0ZXZlciB0aGVpciB1bmRlcnNhbmRpbmcgb2YgdGhlXG4gICAgICAgICAgLy8gWE1MIHNwZWMgbWFuZGF0ZXMuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGp1c3QgbmFtZXNwYWNlIHByZWZpeHMgYXMgY29uZmlndXJlZFxuICAgICAgICBpZiAoeG1sbnMpIHtcbiAgICAgICAgICBlbGVtZW50TmFtZSA9IHhtbG5zICsgJzonICsgZWxlbWVudE5hbWU7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBpZiAodGFnU3RhcnQpIHtcbiAgICAgICAgYXR0cnNTdGFydCA9IHE7XG4gICAgICAgIGF0dHJzU3RyaW5nID0geDtcblxuICAgICAgICBpZiAob25PcGVuVGFnKSB7XG4gICAgICAgICAgaWYgKHByb3h5KSB7XG4gICAgICAgICAgICBvbk9wZW5UYWcoZWxlbWVudFByb3h5LCBkZWNvZGVFbnRpdGllcywgdGFnRW5kLCBnZXRDb250ZXh0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb25PcGVuVGFnKGVsZW1lbnROYW1lLCBnZXRBdHRycywgZGVjb2RlRW50aXRpZXMsIHRhZ0VuZCwgZ2V0Q29udGV4dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhcnNlU3RvcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmICh0YWdFbmQpIHtcblxuICAgICAgICBpZiAob25DbG9zZVRhZykge1xuICAgICAgICAgIG9uQ2xvc2VUYWcocHJveHkgPyBlbGVtZW50UHJveHkgOiBlbGVtZW50TmFtZSwgZGVjb2RlRW50aXRpZXMsIHRhZ1N0YXJ0LCBnZXRDb250ZXh0KTtcblxuICAgICAgICAgIGlmIChwYXJzZVN0b3ApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXN0b3JlIG9sZCBuYW1lc3BhY2VcbiAgICAgICAgaWYgKGlzTmFtZXNwYWNlKSB7XG4gICAgICAgICAgaWYgKCF0YWdTdGFydCkge1xuICAgICAgICAgICAgbnNNYXRyaXggPSBuc01hdHJpeFN0YWNrLnBvcCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuc01hdHJpeCA9IF9uc01hdHJpeDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaiArPSAxO1xuICAgIH1cbiAgfSAvKiogZW5kIHBhcnNlICovXG5cbn1cblxuZXhwb3J0IHsgUGFyc2VyLCBkZWNvZGVFbnRpdGllcyBhcyBkZWNvZGUgfTtcbiIsImZ1bmN0aW9uIGVuc3VyZUltcG9ydGVkKGVsZW1lbnQsIHRhcmdldCkge1xuXG4gIGlmIChlbGVtZW50Lm93bmVyRG9jdW1lbnQgIT09IHRhcmdldC5vd25lckRvY3VtZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIG1heSBmYWlsIG9uIHdlYmtpdFxuICAgICAgcmV0dXJuIHRhcmdldC5vd25lckRvY3VtZW50LmltcG9ydE5vZGUoZWxlbWVudCwgdHJ1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gaWdub3JlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbi8qKlxuICogYXBwZW5kVG8gdXRpbGl0eVxuICovXG5cbi8qKlxuICogQXBwZW5kIGEgbm9kZSB0byBhIHRhcmdldCBlbGVtZW50IGFuZCByZXR1cm4gdGhlIGFwcGVuZGVkIG5vZGUuXG4gKlxuICogQHBhcmFtICB7U1ZHRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtICB7U1ZHRWxlbWVudH0gdGFyZ2V0XG4gKlxuICogQHJldHVybiB7U1ZHRWxlbWVudH0gdGhlIGFwcGVuZGVkIG5vZGVcbiAqL1xuZnVuY3Rpb24gYXBwZW5kVG8oZWxlbWVudCwgdGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXQuYXBwZW5kQ2hpbGQoZW5zdXJlSW1wb3J0ZWQoZWxlbWVudCwgdGFyZ2V0KSk7XG59XG5cbi8qKlxuICogYXBwZW5kIHV0aWxpdHlcbiAqL1xuXG4vKipcbiAqIEFwcGVuZCBhIG5vZGUgdG8gYW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSAge1NWR0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSAge1NWR0VsZW1lbnR9IG5vZGVcbiAqXG4gKiBAcmV0dXJuIHtTVkdFbGVtZW50fSB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBhcHBlbmQodGFyZ2V0LCBub2RlKSB7XG4gIGFwcGVuZFRvKG5vZGUsIHRhcmdldCk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogYXR0cmlidXRlIGFjY2Vzc29yIHV0aWxpdHlcbiAqL1xuXG52YXIgTEVOR1RIX0FUVFIgPSAyO1xuXG52YXIgQ1NTX1BST1BFUlRJRVMgPSB7XG4gICdhbGlnbm1lbnQtYmFzZWxpbmUnOiAxLFxuICAnYmFzZWxpbmUtc2hpZnQnOiAxLFxuICAnY2xpcCc6IDEsXG4gICdjbGlwLXBhdGgnOiAxLFxuICAnY2xpcC1ydWxlJzogMSxcbiAgJ2NvbG9yJzogMSxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24nOiAxLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJzogMSxcbiAgJ2NvbG9yLXByb2ZpbGUnOiAxLFxuICAnY29sb3ItcmVuZGVyaW5nJzogMSxcbiAgJ2N1cnNvcic6IDEsXG4gICdkaXJlY3Rpb24nOiAxLFxuICAnZGlzcGxheSc6IDEsXG4gICdkb21pbmFudC1iYXNlbGluZSc6IDEsXG4gICdlbmFibGUtYmFja2dyb3VuZCc6IDEsXG4gICdmaWxsJzogMSxcbiAgJ2ZpbGwtb3BhY2l0eSc6IDEsXG4gICdmaWxsLXJ1bGUnOiAxLFxuICAnZmlsdGVyJzogMSxcbiAgJ2Zsb29kLWNvbG9yJzogMSxcbiAgJ2Zsb29kLW9wYWNpdHknOiAxLFxuICAnZm9udCc6IDEsXG4gICdmb250LWZhbWlseSc6IDEsXG4gICdmb250LXNpemUnOiBMRU5HVEhfQVRUUixcbiAgJ2ZvbnQtc2l6ZS1hZGp1c3QnOiAxLFxuICAnZm9udC1zdHJldGNoJzogMSxcbiAgJ2ZvbnQtc3R5bGUnOiAxLFxuICAnZm9udC12YXJpYW50JzogMSxcbiAgJ2ZvbnQtd2VpZ2h0JzogMSxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnOiAxLFxuICAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnOiAxLFxuICAnaW1hZ2UtcmVuZGVyaW5nJzogMSxcbiAgJ2tlcm5pbmcnOiAxLFxuICAnbGV0dGVyLXNwYWNpbmcnOiAxLFxuICAnbGlnaHRpbmctY29sb3InOiAxLFxuICAnbWFya2VyJzogMSxcbiAgJ21hcmtlci1lbmQnOiAxLFxuICAnbWFya2VyLW1pZCc6IDEsXG4gICdtYXJrZXItc3RhcnQnOiAxLFxuICAnbWFzayc6IDEsXG4gICdvcGFjaXR5JzogMSxcbiAgJ292ZXJmbG93JzogMSxcbiAgJ3BvaW50ZXItZXZlbnRzJzogMSxcbiAgJ3NoYXBlLXJlbmRlcmluZyc6IDEsXG4gICdzdG9wLWNvbG9yJzogMSxcbiAgJ3N0b3Atb3BhY2l0eSc6IDEsXG4gICdzdHJva2UnOiAxLFxuICAnc3Ryb2tlLWRhc2hhcnJheSc6IDEsXG4gICdzdHJva2UtZGFzaG9mZnNldCc6IDEsXG4gICdzdHJva2UtbGluZWNhcCc6IDEsXG4gICdzdHJva2UtbGluZWpvaW4nOiAxLFxuICAnc3Ryb2tlLW1pdGVybGltaXQnOiAxLFxuICAnc3Ryb2tlLW9wYWNpdHknOiAxLFxuICAnc3Ryb2tlLXdpZHRoJzogTEVOR1RIX0FUVFIsXG4gICd0ZXh0LWFuY2hvcic6IDEsXG4gICd0ZXh0LWRlY29yYXRpb24nOiAxLFxuICAndGV4dC1yZW5kZXJpbmcnOiAxLFxuICAndW5pY29kZS1iaWRpJzogMSxcbiAgJ3Zpc2liaWxpdHknOiAxLFxuICAnd29yZC1zcGFjaW5nJzogMSxcbiAgJ3dyaXRpbmctbW9kZSc6IDFcbn07XG5cblxuZnVuY3Rpb24gZ2V0QXR0cmlidXRlKG5vZGUsIG5hbWUpIHtcbiAgaWYgKENTU19QUk9QRVJUSUVTW25hbWVdKSB7XG4gICAgcmV0dXJuIG5vZGUuc3R5bGVbbmFtZV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlTlMobnVsbCwgbmFtZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0QXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gIHZhciBoeXBoZW5hdGVkID0gbmFtZS5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHZhciB0eXBlID0gQ1NTX1BST1BFUlRJRVNbaHlwaGVuYXRlZF07XG5cbiAgaWYgKHR5cGUpIHtcbiAgICAvLyBhcHBlbmQgcGl4ZWwgdW5pdCwgdW5sZXNzIHByZXNlbnRcbiAgICBpZiAodHlwZSA9PT0gTEVOR1RIX0FUVFIgJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpICsgJ3B4JztcbiAgICB9XG5cbiAgICBub2RlLnN0eWxlW2h5cGhlbmF0ZWRdID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBuYW1lLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhub2RlLCBhdHRycykge1xuXG4gIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKGF0dHJzKSwgaSwgbmFtZTtcblxuICBmb3IgKGkgPSAwLCBuYW1lOyAobmFtZSA9IG5hbWVzW2ldKTsgaSsrKSB7XG4gICAgc2V0QXR0cmlidXRlKG5vZGUsIG5hbWUsIGF0dHJzW25hbWVdKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgb3Igc2V0cyByYXcgYXR0cmlidXRlcyBvbiBhIG5vZGUuXG4gKlxuICogQHBhcmFtICB7U1ZHRWxlbWVudH0gbm9kZVxuICogQHBhcmFtICB7T2JqZWN0fSBbYXR0cnNdXG4gKiBAcGFyYW0gIHtTdHJpbmd9IFtuYW1lXVxuICogQHBhcmFtICB7U3RyaW5nfSBbdmFsdWVdXG4gKlxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBhdHRyKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2V0QXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldEF0dHJpYnV0ZShub2RlLCBuYW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2V0QXR0cmlidXRlcyhub2RlLCBuYW1lKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcclxuICogQ2xlYXIgdXRpbGl0eVxyXG4gKi9cclxuZnVuY3Rpb24gaW5kZXgoYXJyLCBvYmopIHtcclxuICBpZiAoYXJyLmluZGV4T2YpIHtcclxuICAgIHJldHVybiBhcnIuaW5kZXhPZihvYmopO1xyXG4gIH1cclxuXHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XHJcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHtcclxuICAgICAgcmV0dXJuIGk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gLTE7XHJcbn1cclxuXHJcbnZhciByZSA9IC9cXHMrLztcclxuXHJcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XHJcblxyXG5mdW5jdGlvbiBkZWZpbmVkKG8pIHtcclxuICByZXR1cm4gdHlwZW9mIG8gIT09ICd1bmRlZmluZWQnO1xyXG59XHJcblxyXG4vKipcclxuICogV3JhcCBgZWxgIGluIGEgYENsYXNzTGlzdGAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcclxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGNsYXNzZXMoZWwpIHtcclxuICByZXR1cm4gbmV3IENsYXNzTGlzdChlbCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIENsYXNzTGlzdChlbCkge1xyXG4gIGlmICghZWwgfHwgIWVsLm5vZGVUeXBlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgRE9NIGVsZW1lbnQgcmVmZXJlbmNlIGlzIHJlcXVpcmVkJyk7XHJcbiAgfVxyXG4gIHRoaXMuZWwgPSBlbDtcclxuICB0aGlzLmxpc3QgPSBlbC5jbGFzc0xpc3Q7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBZGQgY2xhc3MgYG5hbWVgIGlmIG5vdCBhbHJlYWR5IHByZXNlbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXHJcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5DbGFzc0xpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG5hbWUpIHtcclxuXHJcbiAgLy8gY2xhc3NMaXN0XHJcbiAgaWYgKHRoaXMubGlzdCkge1xyXG4gICAgdGhpcy5saXN0LmFkZChuYW1lKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gZmFsbGJhY2tcclxuICB2YXIgYXJyID0gdGhpcy5hcnJheSgpO1xyXG4gIHZhciBpID0gaW5kZXgoYXJyLCBuYW1lKTtcclxuICBpZiAoIX5pKSB7XHJcbiAgICBhcnIucHVzaChuYW1lKTtcclxuICB9XHJcblxyXG4gIGlmIChkZWZpbmVkKHRoaXMuZWwuY2xhc3NOYW1lLmJhc2VWYWwpKSB7XHJcbiAgICB0aGlzLmVsLmNsYXNzTmFtZS5iYXNlVmFsID0gYXJyLmpvaW4oJyAnKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5lbC5jbGFzc05hbWUgPSBhcnIuam9pbignICcpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIGNsYXNzIGBuYW1lYCB3aGVuIHByZXNlbnQsIG9yXHJcbiAqIHBhc3MgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gcmVtb3ZlXHJcbiAqIGFueSB3aGljaCBtYXRjaC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBuYW1lXHJcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5DbGFzc0xpc3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKG5hbWUpIHtcclxuICBpZiAoJ1tvYmplY3QgUmVnRXhwXScgPT09IHRvU3RyaW5nLmNhbGwobmFtZSkpIHtcclxuICAgIHJldHVybiB0aGlzLnJlbW92ZU1hdGNoaW5nKG5hbWUpO1xyXG4gIH1cclxuXHJcbiAgLy8gY2xhc3NMaXN0XHJcbiAgaWYgKHRoaXMubGlzdCkge1xyXG4gICAgdGhpcy5saXN0LnJlbW92ZShuYW1lKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gZmFsbGJhY2tcclxuICB2YXIgYXJyID0gdGhpcy5hcnJheSgpO1xyXG4gIHZhciBpID0gaW5kZXgoYXJyLCBuYW1lKTtcclxuICBpZiAofmkpIHtcclxuICAgIGFyci5zcGxpY2UoaSwgMSk7XHJcbiAgfVxyXG4gIHRoaXMuZWwuY2xhc3NOYW1lLmJhc2VWYWwgPSBhcnIuam9pbignICcpO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSBhbGwgY2xhc3NlcyBtYXRjaGluZyBgcmVgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVcclxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5DbGFzc0xpc3QucHJvdG90eXBlLnJlbW92ZU1hdGNoaW5nID0gZnVuY3Rpb24ocmUpIHtcclxuICB2YXIgYXJyID0gdGhpcy5hcnJheSgpO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAocmUudGVzdChhcnJbaV0pKSB7XHJcbiAgICAgIHRoaXMucmVtb3ZlKGFycltpXSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRvZ2dsZSBjbGFzcyBgbmFtZWAsIGNhbiBmb3JjZSBzdGF0ZSB2aWEgYGZvcmNlYC5cclxuICpcclxuICogRm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBjbGFzc0xpc3QsIGJ1dCBkbyBub3Qgc3VwcG9ydCBgZm9yY2VgIHlldCxcclxuICogdGhlIG1pc3Rha2Ugd2lsbCBiZSBkZXRlY3RlZCBhbmQgY29ycmVjdGVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlXHJcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5DbGFzc0xpc3QucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uKG5hbWUsIGZvcmNlKSB7XHJcbiAgLy8gY2xhc3NMaXN0XHJcbiAgaWYgKHRoaXMubGlzdCkge1xyXG4gICAgaWYgKGRlZmluZWQoZm9yY2UpKSB7XHJcbiAgICAgIGlmIChmb3JjZSAhPT0gdGhpcy5saXN0LnRvZ2dsZShuYW1lLCBmb3JjZSkpIHtcclxuICAgICAgICB0aGlzLmxpc3QudG9nZ2xlKG5hbWUpOyAvLyB0b2dnbGUgYWdhaW4gdG8gY29ycmVjdFxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmxpc3QudG9nZ2xlKG5hbWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBmYWxsYmFja1xyXG4gIGlmIChkZWZpbmVkKGZvcmNlKSkge1xyXG4gICAgaWYgKCFmb3JjZSkge1xyXG4gICAgICB0aGlzLnJlbW92ZShuYW1lKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuYWRkKG5hbWUpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAodGhpcy5oYXMobmFtZSkpIHtcclxuICAgICAgdGhpcy5yZW1vdmUobmFtZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmFkZChuYW1lKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybiBhbiBhcnJheSBvZiBjbGFzc2VzLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5DbGFzc0xpc3QucHJvdG90eXBlLmFycmF5ID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnO1xyXG4gIHZhciBzdHIgPSBjbGFzc05hbWUucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xyXG4gIHZhciBhcnIgPSBzdHIuc3BsaXQocmUpO1xyXG4gIGlmICgnJyA9PT0gYXJyWzBdKSB7XHJcbiAgICBhcnIuc2hpZnQoKTtcclxuICB9XHJcbiAgcmV0dXJuIGFycjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBjbGFzcyBgbmFtZWAgaXMgcHJlc2VudC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkNsYXNzTGlzdC5wcm90b3R5cGUuaGFzID1cclxuQ2xhc3NMaXN0LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKG5hbWUpIHtcclxuICByZXR1cm4gKFxyXG4gICAgdGhpcy5saXN0ID9cclxuICAgICAgdGhpcy5saXN0LmNvbnRhaW5zKG5hbWUpIDpcclxuICAgICAgISEgfmluZGV4KHRoaXMuYXJyYXkoKSwgbmFtZSlcclxuICApO1xyXG59O1xuXG5mdW5jdGlvbiByZW1vdmUoZWxlbWVudCkge1xuICB2YXIgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuXG4gIGlmIChwYXJlbnQpIHtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBDbGVhciB1dGlsaXR5XG4gKi9cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBjaGlsZHJlbiBmcm9tIHRoZSBnaXZlbiBlbGVtZW50XG4gKlxuICogQHBhcmFtICB7RE9NRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7RE9NRWxlbWVudH0gdGhlIGVsZW1lbnQgKGZvciBjaGFpbmluZylcbiAqL1xuZnVuY3Rpb24gY2xlYXIoZWxlbWVudCkge1xuICB2YXIgY2hpbGQ7XG5cbiAgd2hpbGUgKChjaGlsZCA9IGVsZW1lbnQuZmlyc3RDaGlsZCkpIHtcbiAgICByZW1vdmUoY2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNsb25lKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQuY2xvbmVOb2RlKHRydWUpO1xufVxuXG52YXIgbnMgPSB7XG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJ1xufTtcblxuLyoqXG4gKiBET00gcGFyc2luZyB1dGlsaXR5XG4gKi9cblxudmFyIFNWR19TVEFSVCA9ICc8c3ZnIHhtbG5zPVwiJyArIG5zLnN2ZyArICdcIic7XG5cbmZ1bmN0aW9uIHBhcnNlKHN2Zykge1xuXG4gIHZhciB1bndyYXAgPSBmYWxzZTtcblxuICAvLyBlbnN1cmUgd2UgaW1wb3J0IGEgdmFsaWQgc3ZnIGRvY3VtZW50XG4gIGlmIChzdmcuc3Vic3RyaW5nKDAsIDQpID09PSAnPHN2ZycpIHtcbiAgICBpZiAoc3ZnLmluZGV4T2YobnMuc3ZnKSA9PT0gLTEpIHtcbiAgICAgIHN2ZyA9IFNWR19TVEFSVCArIHN2Zy5zdWJzdHJpbmcoNCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIG5hbWVzcGFjZSBzdmdcbiAgICBzdmcgPSBTVkdfU1RBUlQgKyAnPicgKyBzdmcgKyAnPC9zdmc+JztcbiAgICB1bndyYXAgPSB0cnVlO1xuICB9XG5cbiAgdmFyIHBhcnNlZCA9IHBhcnNlRG9jdW1lbnQoc3ZnKTtcblxuICBpZiAoIXVud3JhcCkge1xuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgdmFyIHBhcmVudCA9IHBhcnNlZC5maXJzdENoaWxkO1xuXG4gIHdoaWxlIChwYXJlbnQuZmlyc3RDaGlsZCkge1xuICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHBhcmVudC5maXJzdENoaWxkKTtcbiAgfVxuXG4gIHJldHVybiBmcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gcGFyc2VEb2N1bWVudChzdmcpIHtcblxuICB2YXIgcGFyc2VyO1xuXG4gIC8vIHBhcnNlXG4gIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgcGFyc2VyLmFzeW5jID0gZmFsc2U7XG5cbiAgcmV0dXJuIHBhcnNlci5wYXJzZUZyb21TdHJpbmcoc3ZnLCAndGV4dC94bWwnKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgdXRpbGl0eSBmb3IgU1ZHIGVsZW1lbnRzXG4gKi9cblxuXG4vKipcbiAqIENyZWF0ZSBhIHNwZWNpZmljIHR5cGUgZnJvbSBuYW1lIG9yIFNWRyBtYXJrdXAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdGhlIG5hbWUgb3IgbWFya3VwIG9mIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW2F0dHJzXSBhdHRyaWJ1dGVzIHRvIHNldCBvbiB0aGUgZWxlbWVudFxuICpcbiAqIEByZXR1cm5zIHtTVkdFbGVtZW50fVxuICovXG5mdW5jdGlvbiBjcmVhdGUobmFtZSwgYXR0cnMpIHtcbiAgdmFyIGVsZW1lbnQ7XG5cbiAgaWYgKG5hbWUuY2hhckF0KDApID09PSAnPCcpIHtcbiAgICBlbGVtZW50ID0gcGFyc2UobmFtZSkuZmlyc3RDaGlsZDtcbiAgICBlbGVtZW50ID0gZG9jdW1lbnQuaW1wb3J0Tm9kZShlbGVtZW50LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLnN2ZywgbmFtZSk7XG4gIH1cblxuICBpZiAoYXR0cnMpIHtcbiAgICBhdHRyKGVsZW1lbnQsIGF0dHJzKTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuXG4vKipcbiAqIEV2ZW50cyBoYW5kbGluZyB1dGlsaXR5XG4gKi9cblxuZnVuY3Rpb24gb24obm9kZSwgZXZlbnQsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xufVxuXG5mdW5jdGlvbiBvZmYobm9kZSwgZXZlbnQsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xufVxuXG4vKipcbiAqIEdlb21ldHJ5IGhlbHBlcnNcbiAqL1xuXG4vLyBmYWtlIG5vZGUgdXNlZCB0byBpbnN0YW50aWF0ZSBzdmcgZ2VvbWV0cnkgZWxlbWVudHNcbnZhciBub2RlID0gY3JlYXRlKCdzdmcnKTtcblxuZnVuY3Rpb24gZXh0ZW5kKG9iamVjdCwgcHJvcHMpIHtcbiAgdmFyIGksIGssIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcyk7XG5cbiAgZm9yIChpID0gMDsgKGsgPSBrZXlzW2ldKTsgaSsrKSB7XG4gICAgb2JqZWN0W2tdID0gcHJvcHNba107XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZVBvaW50KHgsIHkpIHtcbiAgdmFyIHBvaW50ID0gbm9kZS5jcmVhdGVTVkdQb2ludCgpO1xuXG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICBjYXNlIDA6XG4gICAgcmV0dXJuIHBvaW50O1xuICBjYXNlIDI6XG4gICAgeCA9IHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfTtcbiAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBleHRlbmQocG9pbnQsIHgpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBtYXRyaXggdmlhIGFyZ3MuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBjcmVhdGVNYXRyaXgoeyBhOiAxLCBiOiAxIH0pO1xuICogY3JlYXRlTWF0cml4KCk7XG4gKiBjcmVhdGVNYXRyaXgoMSwgMiwgMCwgMCwgMzAsIDIwKTtcbiAqXG4gKiBAcmV0dXJuIHtTVkdNYXRyaXh9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1hdHJpeChhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhciBtYXRyaXggPSBub2RlLmNyZWF0ZVNWR01hdHJpeCgpO1xuXG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICBjYXNlIDA6XG4gICAgcmV0dXJuIG1hdHJpeDtcbiAgY2FzZSAxOlxuICAgIHJldHVybiBleHRlbmQobWF0cml4LCBhKTtcbiAgY2FzZSA2OlxuICAgIHJldHVybiBleHRlbmQobWF0cml4LCB7XG4gICAgICBhOiBhLFxuICAgICAgYjogYixcbiAgICAgIGM6IGMsXG4gICAgICBkOiBkLFxuICAgICAgZTogZSxcbiAgICAgIGY6IGZcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2Zvcm0obWF0cml4KSB7XG4gIGlmIChtYXRyaXgpIHtcbiAgICByZXR1cm4gbm9kZS5jcmVhdGVTVkdUcmFuc2Zvcm1Gcm9tTWF0cml4KG1hdHJpeCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5vZGUuY3JlYXRlU1ZHVHJhbnNmb3JtKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXJpYWxpemF0aW9uIHV0aWxcbiAqL1xuXG52YXIgVEVYVF9FTlRJVElFUyA9IC8oWyY8Pl17MX0pL2c7XG52YXIgQVRUUl9FTlRJVElFUyA9IC8oW1xcblxcclwiXXsxfSkvZztcblxudmFyIEVOVElUWV9SRVBMQUNFTUVOVCA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICdcXCcnXG59O1xuXG5mdW5jdGlvbiBlc2NhcGUoc3RyLCBwYXR0ZXJuKSB7XG5cbiAgZnVuY3Rpb24gcmVwbGFjZUZuKG1hdGNoLCBlbnRpdHkpIHtcbiAgICByZXR1cm4gRU5USVRZX1JFUExBQ0VNRU5UW2VudGl0eV0gfHwgZW50aXR5O1xuICB9XG5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHBhdHRlcm4sIHJlcGxhY2VGbik7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZShub2RlLCBvdXRwdXQpIHtcblxuICB2YXIgaSwgbGVuLCBhdHRyTWFwLCBhdHRyTm9kZSwgY2hpbGROb2RlcztcblxuICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcbiAgLy8gVEVYVFxuICBjYXNlIDM6XG4gICAgLy8gcmVwbGFjZSBzcGVjaWFsIFhNTCBjaGFyYWN0ZXJzXG4gICAgb3V0cHV0LnB1c2goZXNjYXBlKG5vZGUudGV4dENvbnRlbnQsIFRFWFRfRU5USVRJRVMpKTtcbiAgICBicmVhaztcblxuICAvLyBFTEVNRU5UXG4gIGNhc2UgMTpcbiAgICBvdXRwdXQucHVzaCgnPCcsIG5vZGUudGFnTmFtZSk7XG5cbiAgICBpZiAobm9kZS5oYXNBdHRyaWJ1dGVzKCkpIHtcbiAgICAgIGF0dHJNYXAgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBhdHRyTWFwLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGF0dHJOb2RlID0gYXR0ck1hcC5pdGVtKGkpO1xuICAgICAgICBvdXRwdXQucHVzaCgnICcsIGF0dHJOb2RlLm5hbWUsICc9XCInLCBlc2NhcGUoYXR0ck5vZGUudmFsdWUsIEFUVFJfRU5USVRJRVMpLCAnXCInKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgIG91dHB1dC5wdXNoKCc+Jyk7XG4gICAgICBjaGlsZE5vZGVzID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBzZXJpYWxpemUoY2hpbGROb2Rlcy5pdGVtKGkpLCBvdXRwdXQpO1xuICAgICAgfVxuICAgICAgb3V0cHV0LnB1c2goJzwvJywgbm9kZS50YWdOYW1lLCAnPicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnLz4nKTtcbiAgICB9XG4gICAgYnJlYWs7XG5cbiAgLy8gQ09NTUVOVFxuICBjYXNlIDg6XG4gICAgb3V0cHV0LnB1c2goJzwhLS0nLCBlc2NhcGUobm9kZS5ub2RlVmFsdWUsIFRFWFRfRU5USVRJRVMpLCAnLS0+Jyk7XG4gICAgYnJlYWs7XG5cbiAgLy8gQ0RBVEFcbiAgY2FzZSA0OlxuICAgIG91dHB1dC5wdXNoKCc8IVtDREFUQVsnLCBub2RlLm5vZGVWYWx1ZSwgJ11dPicpO1xuICAgIGJyZWFrO1xuXG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gaGFuZGxlIG5vZGUgJyArIG5vZGUubm9kZVR5cGUpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBpbm5lckhUTUwgbGlrZSBmdW5jdGlvbmFsaXR5IGZvciBTVkcgZWxlbWVudHMuXG4gKiBiYXNlZCBvbiBpbm5lclNWRyAoaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9pbm5lcnN2ZylcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldChlbGVtZW50LCBzdmcpIHtcblxuICB2YXIgcGFyc2VkID0gcGFyc2Uoc3ZnKTtcblxuICAvLyBjbGVhciBlbGVtZW50IGNvbnRlbnRzXG4gIGNsZWFyKGVsZW1lbnQpO1xuXG4gIGlmICghc3ZnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFpc0ZyYWdtZW50KHBhcnNlZCkpIHtcbiAgICAvLyBleHRyYWN0IDxzdmc+IGZyb20gcGFyc2VkIGRvY3VtZW50XG4gICAgcGFyc2VkID0gcGFyc2VkLmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIHZhciBub2RlcyA9IHNsaWNlKHBhcnNlZC5jaGlsZE5vZGVzKTtcblxuICAvLyBpbXBvcnQgKyBhcHBlbmQgZWFjaCBub2RlXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBhcHBlbmRUbyhub2Rlc1tpXSwgZWxlbWVudCk7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBnZXQoZWxlbWVudCkge1xuICB2YXIgY2hpbGQgPSBlbGVtZW50LmZpcnN0Q2hpbGQsXG4gICAgICBvdXRwdXQgPSBbXTtcblxuICB3aGlsZSAoY2hpbGQpIHtcbiAgICBzZXJpYWxpemUoY2hpbGQsIG91dHB1dCk7XG4gICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIGlzRnJhZ21lbnQobm9kZSkge1xuICByZXR1cm4gbm9kZS5ub2RlTmFtZSA9PT0gJyNkb2N1bWVudC1mcmFnbWVudCc7XG59XG5cbmZ1bmN0aW9uIGlubmVyU1ZHKGVsZW1lbnQsIHN2Zykge1xuXG4gIGlmIChzdmcgIT09IHVuZGVmaW5lZCkge1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldChlbGVtZW50LCBzdmcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXJyb3IgcGFyc2luZyBTVkc6ICcgKyBlLm1lc3NhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXQoZWxlbWVudCk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzbGljZShhcnIpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycik7XG59XG5cbi8qKlxuICogU2VsZWN0aW9uIHV0aWxpdGllc1xuICovXG5cbmZ1bmN0aW9uIHNlbGVjdChub2RlLCBzZWxlY3Rvcikge1xuICByZXR1cm4gbm9kZS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0QWxsKG5vZGUsIHNlbGVjdG9yKSB7XG4gIHZhciBub2RlcyA9IG5vZGUucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG5cbiAgcmV0dXJuIFtdLm1hcC5jYWxsKG5vZGVzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0pO1xufVxuXG4vKipcbiAqIHByZXBlbmRUbyB1dGlsaXR5XG4gKi9cblxuLyoqXG4gKiBQcmVwZW5kIGEgbm9kZSB0byBhIHRhcmdldCBlbGVtZW50IGFuZCByZXR1cm4gdGhlIHByZXBlbmRlZCBub2RlLlxuICpcbiAqIEBwYXJhbSAge1NWR0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSAge1NWR0VsZW1lbnR9IHRhcmdldFxuICpcbiAqIEByZXR1cm4ge1NWR0VsZW1lbnR9IHRoZSBwcmVwZW5kZWQgbm9kZVxuICovXG5mdW5jdGlvbiBwcmVwZW5kVG8obm9kZSwgdGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXQuaW5zZXJ0QmVmb3JlKGVuc3VyZUltcG9ydGVkKG5vZGUsIHRhcmdldCksIHRhcmdldC5maXJzdENoaWxkIHx8IG51bGwpO1xufVxuXG4vKipcbiAqIHByZXBlbmQgdXRpbGl0eVxuICovXG5cbi8qKlxuICogUHJlcGVuZCBhIG5vZGUgdG8gYSB0YXJnZXQgZWxlbWVudFxuICpcbiAqIEBwYXJhbSAge1NWR0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtICB7U1ZHRWxlbWVudH0gbm9kZVxuICpcbiAqIEByZXR1cm4ge1NWR0VsZW1lbnR9IHRoZSB0YXJnZXQgZWxlbWVudFxuICovXG5mdW5jdGlvbiBwcmVwZW5kKHRhcmdldCwgbm9kZSkge1xuICBwcmVwZW5kVG8obm9kZSwgdGFyZ2V0KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBSZXBsYWNlIHV0aWxpdHlcbiAqL1xuXG5mdW5jdGlvbiByZXBsYWNlKGVsZW1lbnQsIHJlcGxhY2VtZW50KSB7XG4gIGVsZW1lbnQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZW5zdXJlSW1wb3J0ZWQocmVwbGFjZW1lbnQsIGVsZW1lbnQpLCBlbGVtZW50KTtcbiAgcmV0dXJuIHJlcGxhY2VtZW50O1xufVxuXG4vKipcbiAqIHRyYW5zZm9ybSBhY2Nlc3NvciB1dGlsaXR5XG4gKi9cblxuZnVuY3Rpb24gd3JhcE1hdHJpeCh0cmFuc2Zvcm1MaXN0LCB0cmFuc2Zvcm0pIHtcbiAgaWYgKHRyYW5zZm9ybSBpbnN0YW5jZW9mIFNWR01hdHJpeCkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1MaXN0LmNyZWF0ZVNWR1RyYW5zZm9ybUZyb21NYXRyaXgodHJhbnNmb3JtKTtcbiAgfVxuXG4gIHJldHVybiB0cmFuc2Zvcm07XG59XG5cblxuZnVuY3Rpb24gc2V0VHJhbnNmb3Jtcyh0cmFuc2Zvcm1MaXN0LCB0cmFuc2Zvcm1zKSB7XG4gIHZhciBpLCB0O1xuXG4gIHRyYW5zZm9ybUxpc3QuY2xlYXIoKTtcblxuICBmb3IgKGkgPSAwOyAodCA9IHRyYW5zZm9ybXNbaV0pOyBpKyspIHtcbiAgICB0cmFuc2Zvcm1MaXN0LmFwcGVuZEl0ZW0od3JhcE1hdHJpeCh0cmFuc2Zvcm1MaXN0LCB0KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgb3Igc2V0IHRoZSB0cmFuc2Zvcm1zIG9uIHRoZSBnaXZlbiBub2RlLlxuICpcbiAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gbm9kZVxuICogQHBhcmFtICB7U1ZHVHJhbnNmb3JtfFNWR01hdHJpeHxBcnJheTxTVkdUcmFuc2Zvcm18U1ZHTWF0cml4Pn0gW3RyYW5zZm9ybXNdXG4gKlxuICogQHJldHVybiB7U1ZHVHJhbnNmb3JtfSB0aGUgY29uc29saWRhdGVkIHRyYW5zZm9ybVxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgdHJhbnNmb3Jtcykge1xuICB2YXIgdHJhbnNmb3JtTGlzdCA9IG5vZGUudHJhbnNmb3JtLmJhc2VWYWw7XG5cbiAgaWYgKHRyYW5zZm9ybXMpIHtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1zKSkge1xuICAgICAgdHJhbnNmb3JtcyA9IFsgdHJhbnNmb3JtcyBdO1xuICAgIH1cblxuICAgIHNldFRyYW5zZm9ybXModHJhbnNmb3JtTGlzdCwgdHJhbnNmb3Jtcyk7XG4gIH1cblxuICByZXR1cm4gdHJhbnNmb3JtTGlzdC5jb25zb2xpZGF0ZSgpO1xufVxuXG5leHBvcnQgeyBhcHBlbmQsIGFwcGVuZFRvLCBhdHRyLCBjbGFzc2VzLCBjbGVhciwgY2xvbmUsIGNyZWF0ZSwgaW5uZXJTVkcsIHByZXBlbmQsIHByZXBlbmRUbywgcmVtb3ZlLCByZXBsYWNlLCB0cmFuc2Zvcm0sIG9uLCBvZmYsIGNyZWF0ZVBvaW50LCBjcmVhdGVNYXRyaXgsIGNyZWF0ZVRyYW5zZm9ybSwgc2VsZWN0LCBzZWxlY3RBbGwgfTtcbiIsImltcG9ydCBCcG1uTW9kZGxlIGZyb20gXCJicG1uLW1vZGRsZVwiO1xuaW1wb3J0IEJwbW5KUyBmcm9tIFwiYnBtbi1qc1wiO1xuaW1wb3J0IHRlc3RYbWwgZnJvbSBcIi4veG1sXCI7XG5cbnZhciB2aWV3ZXIgPSBuZXcgQnBtbkpTKHtcbiAgY29udGFpbmVyOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImJwbW5cIiksXG59KTtcblxuZG9jdW1lbnQudXBsb2FkID0gYXN5bmMgZnVuY3Rpb24gKGV2dCkge1xuICBjb25zb2xlLmxvZyhldnQsIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYnBtbi1maWxlXCIpKTtcbiAgY29uc3QgYnBtbiA9IGF3YWl0IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYnBtbi1maWxlXCIpLmZpbGVzWzBdLnRleHQoKTtcbiAgbG9hZFZpZXdlcihicG1uKTtcbn07XG5cbi8vIGZ1bmN0aW9uIGFkZE92ZXJsYXlzKCkge1xuXG4vLyB9XG5cbmZ1bmN0aW9uIGxvYWRWaWV3ZXIoYnBtblhtbCkge1xuICB2aWV3ZXIuaW1wb3J0WE1MKGJwbW5YbWwsIGFzeW5jIGZ1bmN0aW9uIChlcnIsIGRlZmluaXRpb25zKSB7XG4gICAgLy8gVHJhdmVyc2UgdGhlIFByb2Nlc3NcbiAgICBjb25zb2xlLmxvZyhlcnIsIGRlZmluaXRpb25zKTtcblxuICAgIHZhciBlbGVtZW50cyA9IHZpZXdlci5fZGVmaW5pdGlvbnMucm9vdEVsZW1lbnRzWzBdLmZsb3dFbGVtZW50cztcbiAgICBjb25zdCBzdGFydEV2ZW50ID0gZWxlbWVudHMuZmluZCgoZWwpID0+IHtcbiAgICAgIHJldHVybiBlbC4kdHlwZSA9PT0gXCJicG1uOlN0YXJ0RXZlbnRcIjtcbiAgICB9KTtcblxuICAgIGNvbnN0IGlkVG9FbGVtZW50TWFwID0ge307XG4gICAgZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgaWRUb0VsZW1lbnRNYXBbZWxlbWVudC5pZF0gPSBlbGVtZW50O1xuICAgIH0pO1xuXG4gICAgY29uc3QgcmVhZHlFbGVtZW50cyA9IFtdO1xuICAgIGxldCBjdXJyZW50O1xuICAgIHJlYWR5RWxlbWVudHMucHVzaCguLi5zdGFydEV2ZW50Lm91dGdvaW5nKTtcblxuICAgIGNvbnN0IHByb2Nlc3NWYXJpYWJsZXMgPSB7fTtcblxuICAgIHdoaWxlICgoY3VycmVudCA9IHJlYWR5RWxlbWVudHMuc2hpZnQoKSkpIHtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnRhcmdldFJlZjtcbiAgICAgIGNvbnNvbGUubG9nKGN1cnJlbnQpO1xuICAgICAgaWYgKGN1cnJlbnQuJHR5cGUgPT09IFwiYnBtbjpTY3JpcHRUYXNrXCIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGFzeW5jIGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICBhd2FpdCBldmFsKGN1cnJlbnQuc2NyaXB0KTtcbiAgICAgICAgfS5jYWxsKHByb2Nlc3NWYXJpYWJsZXMpO1xuICAgICAgICBhd2FpdCByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW50LiR0eXBlID09PSBcImJwbW46UGFyYWxsZWxHYXRld2F5XCIpIHtcbiAgICAgICAgY3VycmVudC53YWl0aW5nVG9rZW5zID0gY3VycmVudC53YWl0aW5nVG9rZW5zXG4gICAgICAgICAgPyBjdXJyZW50LndhaXRpbmdUb2tlbnMgKyAxXG4gICAgICAgICAgOiAxO1xuXG4gICAgICAgIGlmIChjdXJyZW50LmluY29taW5nLmxlbmd0aCA+IGN1cnJlbnQud2FpdGluZ1Rva2Vucykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQud2FpdGluZ1Rva2VucyAtPSBjdXJyZW50LmluY29taW5nLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnJlbnQuJHR5cGUgPT09IFwiYnBtbjpFeGNsdXNpdmVHYXRld2F5XCIpIHtcbiAgICAgICAgbGV0IGRlZmF1bHRQYXRoO1xuICAgICAgICB2YXIgcG9zc2libGVHYXRld2F5cyA9IGN1cnJlbnQub3V0Z29pbmcuZmlsdGVyKCh2YWwpID0+IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhdmFsLmNvbmRpdGlvbkV4cHJlc3Npb24gfHxcbiAgICAgICAgICAgICh2YWwuY29uZGl0aW9uRXhwcmVzc2lvbiAmJiAhdmFsLmNvbmRpdGlvbkV4cHJlc3Npb24uYm9keSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIFByb2JhYmx5IGRlZmF1bHQgcGF0aFxuICAgICAgICAgICAgZGVmYXVsdFBhdGggPSB2YWw7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZhbCh2YWwuY29uZGl0aW9uRXhwcmVzc2lvbi5ib2R5KTtcbiAgICAgICAgICB9LmNhbGwocHJvY2Vzc1ZhcmlhYmxlcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghcG9zc2libGVHYXRld2F5cy5sZW5ndGggJiYgIWRlZmF1bHRQYXRoKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIk5vIHBvc3NpYmxlIFBhdGggZm91bmQgYXQgZWxlbWVudCBcIiArIGN1cnJlbnQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlYWR5RWxlbWVudHMucHVzaChwb3NzaWJsZUdhdGV3YXlzWzBdIHx8IGRlZmF1bHRQYXRoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIERlZmF1bHQgYmVoYXZpb3VyXG5cbiAgICAgIGlmIChjdXJyZW50Lm91dGdvaW5nICYmIGN1cnJlbnQub3V0Z29pbmdbMF0udGFyZ2V0UmVmKSB7XG4gICAgICAgIHJlYWR5RWxlbWVudHMucHVzaCguLi5jdXJyZW50Lm91dGdvaW5nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgYDw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCI/PlxuPGJwbW46ZGVmaW5pdGlvbnMgeG1sbnM6YnBtbj1cImh0dHA6Ly93d3cub21nLm9yZy9zcGVjL0JQTU4vMjAxMDA1MjQvTU9ERUxcIiB4bWxuczpicG1uZGk9XCJodHRwOi8vd3d3Lm9tZy5vcmcvc3BlYy9CUE1OLzIwMTAwNTI0L0RJXCIgeG1sbnM6ZGM9XCJodHRwOi8vd3d3Lm9tZy5vcmcvc3BlYy9ERC8yMDEwMDUyNC9EQ1wiIHhtbG5zOmRpPVwiaHR0cDovL3d3dy5vbWcub3JnL3NwZWMvREQvMjAxMDA1MjQvRElcIiBpZD1cIkRlZmluaXRpb25zXzFocDZ3aWtcIiB0YXJnZXROYW1lc3BhY2U9XCJodHRwOi8vYnBtbi5pby9zY2hlbWEvYnBtblwiIGV4cG9ydGVyPVwiQ2FtdW5kYSBNb2RlbGVyXCIgZXhwb3J0ZXJWZXJzaW9uPVwiMy41LjBcIj5cbiAgPGJwbW46cHJvY2VzcyBpZD1cIlByb2Nlc3NfMDlxaDVoNFwiIGlzRXhlY3V0YWJsZT1cInRydWVcIj5cbiAgICA8YnBtbjpzdGFydEV2ZW50IGlkPVwiU3RhcnRFdmVudF8xXCI+XG4gICAgICA8YnBtbjpvdXRnb2luZz5TZXF1ZW5jZUZsb3dfMDh1b2VwMDwvYnBtbjpvdXRnb2luZz5cbiAgICA8L2JwbW46c3RhcnRFdmVudD5cbiAgICA8YnBtbjpzZXF1ZW5jZUZsb3cgaWQ9XCJTZXF1ZW5jZUZsb3dfMDh1b2VwMFwiIHNvdXJjZVJlZj1cIlN0YXJ0RXZlbnRfMVwiIHRhcmdldFJlZj1cIlRhc2tfMTh5aHI1clwiIC8+XG4gICAgPGJwbW46c2NyaXB0VGFzayBpZD1cIlRhc2tfMTh5aHI1clwiIHNjcmlwdEZvcm1hdD1cImphdmFzY3JpcHRcIj5cbiAgICAgIDxicG1uOmluY29taW5nPlNlcXVlbmNlRmxvd18wOHVvZXAwPC9icG1uOmluY29taW5nPlxuICAgICAgPGJwbW46b3V0Z29pbmc+U2VxdWVuY2VGbG93XzByNDlhZzU8L2JwbW46b3V0Z29pbmc+XG4gICAgICA8YnBtbjpzY3JpcHQ+dmFyIHggPSA0MjtcbmNvbnNvbGUubG9nKCdmb28nLCB4KTtcblxud2luZG93LmZvb0JhciA9ICdiYXonOzwvYnBtbjpzY3JpcHQ+XG4gICAgPC9icG1uOnNjcmlwdFRhc2s+XG4gICAgPGJwbW46ZW5kRXZlbnQgaWQ9XCJFbmRFdmVudF8wb3lwNGVjXCI+XG4gICAgICA8YnBtbjppbmNvbWluZz5TZXF1ZW5jZUZsb3dfMHI0OWFnNTwvYnBtbjppbmNvbWluZz5cbiAgICA8L2JwbW46ZW5kRXZlbnQ+XG4gICAgPGJwbW46c2VxdWVuY2VGbG93IGlkPVwiU2VxdWVuY2VGbG93XzByNDlhZzVcIiBzb3VyY2VSZWY9XCJUYXNrXzE4eWhyNXJcIiB0YXJnZXRSZWY9XCJFbmRFdmVudF8wb3lwNGVjXCIgLz5cbiAgPC9icG1uOnByb2Nlc3M+XG4gIDxicG1uZGk6QlBNTkRpYWdyYW0gaWQ9XCJCUE1ORGlhZ3JhbV8xXCI+XG4gICAgPGJwbW5kaTpCUE1OUGxhbmUgaWQ9XCJCUE1OUGxhbmVfMVwiIGJwbW5FbGVtZW50PVwiUHJvY2Vzc18wOXFoNWg0XCI+XG4gICAgICA8YnBtbmRpOkJQTU5TaGFwZSBpZD1cIl9CUE1OU2hhcGVfU3RhcnRFdmVudF8yXCIgYnBtbkVsZW1lbnQ9XCJTdGFydEV2ZW50XzFcIj5cbiAgICAgICAgPGRjOkJvdW5kcyB4PVwiMTc5XCIgeT1cIjk5XCIgd2lkdGg9XCIzNlwiIGhlaWdodD1cIjM2XCIgLz5cbiAgICAgIDwvYnBtbmRpOkJQTU5TaGFwZT5cbiAgICAgIDxicG1uZGk6QlBNTkVkZ2UgaWQ9XCJTZXF1ZW5jZUZsb3dfMDh1b2VwMF9kaVwiIGJwbW5FbGVtZW50PVwiU2VxdWVuY2VGbG93XzA4dW9lcDBcIj5cbiAgICAgICAgPGRpOndheXBvaW50IHg9XCIyMTVcIiB5PVwiMTE3XCIgLz5cbiAgICAgICAgPGRpOndheXBvaW50IHg9XCIyNzBcIiB5PVwiMTE3XCIgLz5cbiAgICAgIDwvYnBtbmRpOkJQTU5FZGdlPlxuICAgICAgPGJwbW5kaTpCUE1OU2hhcGUgaWQ9XCJTY3JpcHRUYXNrXzB0dm94eHJfZGlcIiBicG1uRWxlbWVudD1cIlRhc2tfMTh5aHI1clwiPlxuICAgICAgICA8ZGM6Qm91bmRzIHg9XCIyNzBcIiB5PVwiNzdcIiB3aWR0aD1cIjEwMFwiIGhlaWdodD1cIjgwXCIgLz5cbiAgICAgIDwvYnBtbmRpOkJQTU5TaGFwZT5cbiAgICAgIDxicG1uZGk6QlBNTlNoYXBlIGlkPVwiRW5kRXZlbnRfMG95cDRlY19kaVwiIGJwbW5FbGVtZW50PVwiRW5kRXZlbnRfMG95cDRlY1wiPlxuICAgICAgICA8ZGM6Qm91bmRzIHg9XCI0MzJcIiB5PVwiOTlcIiB3aWR0aD1cIjM2XCIgaGVpZ2h0PVwiMzZcIiAvPlxuICAgICAgPC9icG1uZGk6QlBNTlNoYXBlPlxuICAgICAgPGJwbW5kaTpCUE1ORWRnZSBpZD1cIlNlcXVlbmNlRmxvd18wcjQ5YWc1X2RpXCIgYnBtbkVsZW1lbnQ9XCJTZXF1ZW5jZUZsb3dfMHI0OWFnNVwiPlxuICAgICAgICA8ZGk6d2F5cG9pbnQgeD1cIjM3MFwiIHk9XCIxMTdcIiAvPlxuICAgICAgICA8ZGk6d2F5cG9pbnQgeD1cIjQzMlwiIHk9XCIxMTdcIiAvPlxuICAgICAgPC9icG1uZGk6QlBNTkVkZ2U+XG4gICAgPC9icG1uZGk6QlBNTlBsYW5lPlxuICA8L2JwbW5kaTpCUE1ORGlhZ3JhbT5cbjwvYnBtbjpkZWZpbml0aW9ucz5cblxuYCJdLCJzb3VyY2VSb290IjoiIn0=